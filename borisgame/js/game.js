function parse(val) {
  var result = undefined;
  tmp = [];
  location.search
    .substr(1)
    .split("&")
    .forEach(function (item) {
      tmp = item.split("=");
      if (tmp[0] === val) result = decodeURIComponent(tmp[1]);
    });
  return result;
}

var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.arrayIteratorImpl = function (l) {
  var w = 0;
  return function () {
    return w < l.length
      ? {
          done: !1,
          value: l[w++],
        }
      : {
          done: !0,
        };
  };
};
$jscomp.arrayIterator = function (l) {
  return {
    next: $jscomp.arrayIteratorImpl(l),
  };
};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.SIMPLE_FROUND_POLYFILL = !1;
$jscomp.ISOLATE_POLYFILLS = !1;
$jscomp.FORCE_POLYFILL_PROMISE = !1;
$jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = !1;
$jscomp.defineProperty =
  $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties
    ? Object.defineProperty
    : function (l, w, h) {
        if (l == Array.prototype || l == Object.prototype) return l;
        l[w] = h.value;
        return l;
      };
$jscomp.getGlobal = function (l) {
  l = [
    "object" == typeof globalThis && globalThis,
    l,
    "object" == typeof window && window,
    "object" == typeof self && self,
    "object" == typeof global && global,
  ];
  for (var w = 0; w < l.length; ++w) {
    var h = l[w];
    if (h && h.Math == Math) return h;
  }
  throw Error("Cannot find global object");
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.IS_SYMBOL_NATIVE =
  "function" === typeof Symbol && "symbol" === typeof Symbol("x");
$jscomp.TRUST_ES6_POLYFILLS =
  !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE;
$jscomp.polyfills = {};
$jscomp.propertyToPolyfillSymbol = {};
$jscomp.POLYFILL_PREFIX = "$jscp$";
var $jscomp$lookupPolyfilledValue = function (l, w) {
  var h = $jscomp.propertyToPolyfillSymbol[w];
  if (null == h) return l[w];
  h = l[h];
  return void 0 !== h ? h : l[w];
};
$jscomp.polyfill = function (l, w, h, t) {
  w &&
    ($jscomp.ISOLATE_POLYFILLS
      ? $jscomp.polyfillIsolated(l, w, h, t)
      : $jscomp.polyfillUnisolated(l, w, h, t));
};
$jscomp.polyfillUnisolated = function (l, w, h, t) {
  h = $jscomp.global;
  l = l.split(".");
  for (t = 0; t < l.length - 1; t++) {
    var a = l[t];
    if (!(a in h)) return;
    h = h[a];
  }
  l = l[l.length - 1];
  t = h[l];
  w = w(t);
  w != t &&
    null != w &&
    $jscomp.defineProperty(h, l, {
      configurable: !0,
      writable: !0,
      value: w,
    });
};
$jscomp.polyfillIsolated = function (l, w, h, t) {
  var a = l.split(".");
  l = 1 === a.length;
  t = a[0];
  t = !l && t in $jscomp.polyfills ? $jscomp.polyfills : $jscomp.global;
  for (var d = 0; d < a.length - 1; d++) {
    var k = a[d];
    if (!(k in t)) return;
    t = t[k];
  }
  a = a[a.length - 1];
  h = $jscomp.IS_SYMBOL_NATIVE && "es6" === h ? t[a] : null;
  w = w(h);
  null != w &&
    (l
      ? $jscomp.defineProperty($jscomp.polyfills, a, {
          configurable: !0,
          writable: !0,
          value: w,
        })
      : w !== h &&
        (void 0 === $jscomp.propertyToPolyfillSymbol[a] &&
          ((h = (1e9 * Math.random()) >>> 0),
          ($jscomp.propertyToPolyfillSymbol[a] = $jscomp.IS_SYMBOL_NATIVE
            ? $jscomp.global.Symbol(a)
            : $jscomp.POLYFILL_PREFIX + h + "$" + a)),
        $jscomp.defineProperty(t, $jscomp.propertyToPolyfillSymbol[a], {
          configurable: !0,
          writable: !0,
          value: w,
        })));
};
$jscomp.initSymbol = function () {};
$jscomp.iteratorPrototype = function (l) {
  l = {
    next: l,
  };
  l[Symbol.iterator] = function () {
    return this;
  };
  return l;
};
$jscomp.iteratorFromArray = function (l, w) {
  l instanceof String && (l += "");
  var h = 0,
    t = !1,
    a = {
      next: function () {
        if (!t && h < l.length) {
          var d = h++;
          return {
            value: w(d, l[d]),
            done: !1,
          };
        }
        t = !0;
        return {
          done: !0,
          value: void 0,
        };
      },
    };
  a[Symbol.iterator] = function () {
    return a;
  };
  return a;
};
$jscomp.polyfill(
  "Array.prototype.values",
  function (l) {
    return l
      ? l
      : function () {
          return $jscomp.iteratorFromArray(this, function (w, h) {
            return h;
          });
        };
  },
  "es8",
  "es3"
);
$jscomp.owns = function (l, w) {
  return Object.prototype.hasOwnProperty.call(l, w);
};
$jscomp.polyfill(
  "Object.values",
  function (l) {
    return l
      ? l
      : function (w) {
          var h = [],
            t;
          for (t in w) $jscomp.owns(w, t) && h.push(w[t]);
          return h;
        };
  },
  "es8",
  "es3"
);
$jscomp.polyfill(
  "Object.entries",
  function (l) {
    return l
      ? l
      : function (w) {
          var h = [],
            t;
          for (t in w) $jscomp.owns(w, t) && h.push([t, w[t]]);
          return h;
        };
  },
  "es8",
  "es3"
);
var __defProp = Object.defineProperty,
  __defNormalProp = (l, w, h) =>
    w in l
      ? __defProp(l, w, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: h,
        })
      : (l[w] = h),
  __publicField = (l, w, h) => {
    __defNormalProp(l, "symbol" !== typeof w ? w + "" : w, h);
    return h;
  };
const p = function () {
  function l(h) {
    if (!h.ep) {
      h.ep = !0;
      var t = {};
      h.integrity && (t.integrity = h.integrity);
      h.referrerpolicy && (t.referrerPolicy = h.referrerpolicy);
      t.credentials =
        "use-credentials" === h.crossorigin
          ? "include"
          : "anonymous" === h.crossorigin
          ? "omit"
          : "same-origin";
      fetch(h.href, t);
    }
  }
  const w = document.createElement("link").relList;
  if (!(w && w.supports && w.supports("modulepreload"))) {
    for (const h of document.querySelectorAll('link[rel="modulepreload"]'))
      l(h);
    new MutationObserver((h) => {
      for (const t of h)
        if ("childList" === t.type)
          for (const a of t.addedNodes)
            "LINK" === a.tagName && "modulepreload" === a.rel && l(a);
    }).observe(document, {
      childList: !0,
      subtree: !0,
    });
  }
};
p();
const _GameBranding = class {
  static SetSingleton(l) {
    _GameBranding.Singleton = l;
    _GameBranding.Singleton.init();
  }
  constructor() {
    this.topScore = 0;
  }
  init() {}
  getPremadeOverrides() {
    return {};
  }
  gameEvent(l, w) {}
  updateTime(l) {}
  static GetSingleton() {
    return this.Singleton;
  }
  getAudioOverrides() {
    return {};
  }
  getFlags() {
    return {
      disableSaveUserPrefs: 0,
      disableSaveGameData: 0,
      disableFakeMusicPreload: 0,
      cordovaListenersEnabled: 0,
      disableAutoPause: 0,
      allowPauseAlways: 0,
    };
  }
  getUntypedFlags() {
    return {};
  }
  onGetRendererTypeOverride(l) {
    return l;
  }
  hasToResetScoreEachLevel() {
    return !1;
  }
  adaptLocalStorageSetItem(l, w) {
    localStorage.setItem(l, JSON.stringify(w));
  }
  adaptLocalStorageGetItem(l) {
    return null === localStorage.getItem(l)
      ? null
      : JSON.parse(localStorage.getItem(l));
  }
  showAd(l) {
    l();
  }
  onUpdateScore(l) {
    this.topScore = l;
  }
  onUpdateLevelNumber(l) {}
  pushAPIGameLoadObj(l) {}
};
let GameBranding = _GameBranding;
__publicField(GameBranding, "Singleton");
const inlogicData = {
  hasLost: 0,
};
class BrandingInlogic extends GameBranding {
  getFlags() {
    return {
      disableSaveUserPrefs: 0,
      disableSaveGameData: 0,
      disableFakeMusicPreload: 0,
      cordovaListenersEnabled: 0,
      disableAutoPause: 0,
      allowPauseAlways: 0,
    };
  }
  getUntypedFlags() {
    return {
      snackhopAltHome: !0,
      inlogicLost: 0,
    };
  }
  gameEvent(l, w) {
    w = void 0 === w ? null : w;
    "GameplayLoop" == w.stateName &&
      "enter" == w.stateChangeType &&
      (inlogicData.hasLost = 0);
    if ("GameOver" == w.stateName && "enter" == w.stateChangeType) {
      if (1 == inlogicData.hasLost) return;
      onGameOver();
      /////////////

      const urlParams = new URLSearchParams(window.location.search);
      const chatId = urlParams.get("chatId");
      var jumping_score = PandaJumpGlobalsInstance.subsession.score;

      var telegramBotToken = "7280095625:AAFWYp43Y7T7p6V-e_bVWWtCkKEek-XOiSU";
      const requestBody = JSON.stringify({
        chat_id: chatId,
        text: `Your score is ${jumping_score}`,
      });
      fetch(`https://api.telegram.org/bot${telegramBotToken}/sendMessage`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: requestBody,
      });
      /////////////
      //alert(PandaJumpGlobalsInstance.subsession.score);
      inlogicData.hasLost = 1;
    }
    "GameplayLevel" == w.stateName &&
      "exit" == w.stateChangeType &&
      1 != inlogicData.hasLost &&
      (onGameOver(), (inlogicData.hasLost = 1));
  }
}
var IsArray = function (l) {
  return "[object Array]" === Object.prototype.toString.call(l);
};
class AssetPackLoader {
  static GetRequestAsJsonFromArray(l) {
    const w = new AssetPackLoader();
    w.addRequestArray(l);
    return w.getRequestAsJson();
  }
  constructor() {
    this._files = {
      jsons: [],
      png: [],
    };
    this.loadFuncDict = this.request = null;
  }
  fillRequestDataFrom(l) {
    console.assert(l, "data is: ", l);
    IsArray(l) || console.error("TODO: implement for object that isnt array");
    this.request = l;
  }
  supplyLoadFunctionDictionary(l, w) {
    this.loadFuncDict = (function (h, t) {
      return {
        begin: function () {
          h.load.on(
            "loaderror",
            function (a) {
              console.warn("error loading: ", a);
            },
            h
          );
          h.load.once("complete", function () {
            h.load.removeAllListeners();
            h.load.reset();
            t();
          });
        },
        audio: function (a, d) {
          h.load.audio(a, [d + "/" + a + ".mp3", d + "/" + a + ".ogg"]);
        },
        font: function (a, d) {
          h.load.bitmapFont(a, d + "/" + a + ".png", d + "/" + a + ".xml");
        },
        text: (a, d) => {
          h.load.text(a, d + "/" + a + ".txt");
        },
        json: function (a, d) {
          h.load.json(a, d + "/" + a + ".json");
        },
        png: function (a, d) {
          h.load.image(a, d + "/" + a + ".png");
        },
        spine: (a, d) => {
          h.load.spine(a, d + "/" + a + ".json", d + "/" + a + ".atlas");
        },
        multiatlas: (a, d) => {
          h.load.multiatlas("megaset", "megaset/megaset.json");
        },
      };
    })(l, w);
  }
  load() {
    console.assert(
      null != this.loadFuncDict,
      "load func dict: ",
      this.loadFuncDict
    );
    console.assert(this.request, "request: ", this.request);
    this.loadFuncDict.begin();
    for (const w in this.request) {
      var l = this.request[w];
      const h = l.path,
        t = l.type,
        a = l.files;
      if (l.mode && ((l = l.mode), "sequential" == l.def))
        for (let d = l.from; d <= l.to; d++) a.push(l.base + d);
      for (const d in a)
        (l = a[d]),
          null == this.loadFuncDict[t] &&
            console.error("loader dict didnt implement: ", t),
          this.loadFuncDict[t](l, h);
    }
  }
  getRequestAsJson() {
    return JSON.parse(JSON.stringify(this.request));
  }
  addRequestArray(l) {
    this.request && console.error("TODO: implement request merge");
    this.request = l;
  }
}
var commonjsGlobal =
  "undefined" !== typeof globalThis
    ? globalThis
    : "undefined" !== typeof window
    ? window
    : "undefined" !== typeof global
    ? global
    : "undefined" !== typeof self
    ? self
    : {};

function getDefaultExportFromCjs(l) {
  return l && l.__esModule && Object.prototype.hasOwnProperty.call(l, "default")
    ? l["default"]
    : l;
}
var phaser = {
  exports: {},
};
(function (l, w) {
  (function (h, t) {
    l.exports = t();
  })(commonjsGlobal, function () {
    return (function (h) {
      function t(d) {
        if (a[d]) return a[d].exports;
        var k = (a[d] = {
          i: d,
          l: !1,
          exports: {},
        });
        h[d].call(k.exports, k, k.exports, t);
        k.l = !0;
        return k.exports;
      }
      var a = {};
      t.m = h;
      t.c = a;
      t.d = function (d, k, e) {
        t.o(d, k) ||
          Object.defineProperty(d, k, {
            enumerable: !0,
            get: e,
          });
      };
      t.r = function (d) {
        "undefined" !== typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(d, Symbol.toStringTag, {
            value: "Module",
          });
        Object.defineProperty(d, "__esModule", {
          value: !0,
        });
      };
      t.t = function (d, k) {
        k & 1 && (d = t(d));
        if (k & 8 || (k & 4 && "object" === typeof d && d && d.__esModule))
          return d;
        var e = Object.create(null);
        t.r(e);
        Object.defineProperty(e, "default", {
          enumerable: !0,
          value: d,
        });
        if (k & 2 && "string" != typeof d)
          for (var b in d)
            t.d(
              e,
              b,
              function (c) {
                return d[c];
              }.bind(null, b)
            );
        return e;
      };
      t.n = function (d) {
        var k =
          d && d.__esModule
            ? function () {
                return d["default"];
              }
            : function () {
                return d;
              };
        t.d(k, "a", k);
        return k;
      };
      t.o = function (d, k) {
        return Object.prototype.hasOwnProperty.call(d, k);
      };
      t.p = "";
      return t((t.s = 1528));
    })([
      function (h, t) {
        function a(e, b, c, f) {
          for (var g in b)
            if (b.hasOwnProperty(g)) {
              var m;
              var n = (m = c) ? b[g] : Object.getOwnPropertyDescriptor(b, g);
              !m && n.value && "object" === typeof n.value && (n = n.value);
              n &&
              ((n.get && "function" === typeof n.get) ||
                (n.set && "function" === typeof n.set))
                ? ("undefined" === typeof n.enumerable && (n.enumerable = !0),
                  "undefined" === typeof n.configurable &&
                    (n.configurable = !0),
                  (m = n))
                : (m = !1);
              if (!1 !== m) {
                (n = Object.getOwnPropertyDescriptor((f || e).prototype, g))
                  ? (n.value && "object" === typeof n.value && (n = n.value),
                    (n = !1 === n.configurable ? !0 : !1))
                  : (n = !1);
                if (n) {
                  if (k.ignoreFinals) continue;
                  throw Error(
                    "cannot override final property '" +
                      g +
                      "', set Class.ignoreFinals = true to skip"
                  );
                }
                Object.defineProperty(e.prototype, g, m);
              } else e.prototype[g] = b[g];
            }
        }

        function d(e, b) {
          if (b) {
            Array.isArray(b) || (b = [b]);
            for (var c = 0; c < b.length; c++) a(e, b[c].prototype || b[c]);
          }
        }

        function k(e) {
          e || (e = {});
          if (e.initialize) {
            if ("function" !== typeof e.initialize)
              throw Error("initialize must be a function");
            var b = e.initialize;
            delete e.initialize;
          } else if (e.Extends) {
            var c = e.Extends;
            b = function () {
              c.apply(this, arguments);
            };
          } else b = function () {};
          if (e.Extends) {
            b.prototype = Object.create(e.Extends.prototype);
            b.prototype.constructor = b;
            var f = e.Extends;
            delete e.Extends;
          } else b.prototype.constructor = b;
          var g = null;
          e.Mixins && ((g = e.Mixins), delete e.Mixins);
          d(b, g);
          a(b, e, !0, f);
          return b;
        }
        k.extend = a;
        k.mixin = d;
        k.ignoreFinals = !1;
        h.exports = k;
      },
      function (h, t) {
        h.exports = function () {};
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          var e = typeof a;
          return a && "number" !== e && "string" !== e
            ? a.hasOwnProperty(d) && void 0 !== a[d]
              ? a[d]
              : k
            : k;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(124),
          k = new t({
            initialize: function (e, b) {
              this.y = this.x = 0;
              "object" === typeof e
                ? ((this.x = e.x || 0), (this.y = e.y || 0))
                : (void 0 === b && (b = e),
                  (this.x = e || 0),
                  (this.y = b || 0));
            },
            clone: function () {
              return new k(this.x, this.y);
            },
            copy: function (e) {
              this.x = e.x || 0;
              this.y = e.y || 0;
              return this;
            },
            setFromObject: function (e) {
              this.x = e.x || 0;
              this.y = e.y || 0;
              return this;
            },
            set: function (e, b) {
              void 0 === b && (b = e);
              this.x = e;
              this.y = b;
              return this;
            },
            setTo: function (e, b) {
              return this.set(e, b);
            },
            setToPolar: function (e, b) {
              null == b && (b = 1);
              this.x = Math.cos(e) * b;
              this.y = Math.sin(e) * b;
              return this;
            },
            equals: function (e) {
              return this.x === e.x && this.y === e.y;
            },
            fuzzyEquals: function (e, b) {
              return d(this.x, e.x, b) && d(this.y, e.y, b);
            },
            angle: function () {
              var e = Math.atan2(this.y, this.x);
              0 > e && (e += 2 * Math.PI);
              return e;
            },
            setAngle: function (e) {
              return this.setToPolar(e, this.length());
            },
            add: function (e) {
              this.x += e.x;
              this.y += e.y;
              return this;
            },
            subtract: function (e) {
              this.x -= e.x;
              this.y -= e.y;
              return this;
            },
            multiply: function (e) {
              this.x *= e.x;
              this.y *= e.y;
              return this;
            },
            scale: function (e) {
              isFinite(e)
                ? ((this.x *= e), (this.y *= e))
                : (this.y = this.x = 0);
              return this;
            },
            divide: function (e) {
              this.x /= e.x;
              this.y /= e.y;
              return this;
            },
            negate: function () {
              this.x = -this.x;
              this.y = -this.y;
              return this;
            },
            distance: function (e) {
              var b = e.x - this.x;
              e = e.y - this.y;
              return Math.sqrt(b * b + e * e);
            },
            distanceSq: function (e) {
              var b = e.x - this.x;
              e = e.y - this.y;
              return b * b + e * e;
            },
            length: function () {
              var e = this.x,
                b = this.y;
              return Math.sqrt(e * e + b * b);
            },
            setLength: function (e) {
              return this.normalize().scale(e);
            },
            lengthSq: function () {
              var e = this.x,
                b = this.y;
              return e * e + b * b;
            },
            normalize: function () {
              var e = this.x,
                b = this.y,
                c = e * e + b * b;
              0 < c &&
                ((c = 1 / Math.sqrt(c)), (this.x = e * c), (this.y = b * c));
              return this;
            },
            normalizeRightHand: function () {
              var e = this.x;
              this.x = -1 * this.y;
              this.y = e;
              return this;
            },
            normalizeLeftHand: function () {
              var e = this.x;
              this.x = this.y;
              this.y = -1 * e;
              return this;
            },
            dot: function (e) {
              return this.x * e.x + this.y * e.y;
            },
            cross: function (e) {
              return this.x * e.y - this.y * e.x;
            },
            lerp: function (e, b) {
              void 0 === b && (b = 0);
              var c = this.x,
                f = this.y;
              this.x = c + b * (e.x - c);
              this.y = f + b * (e.y - f);
              return this;
            },
            transformMat3: function (e) {
              var b = this.x,
                c = this.y;
              e = e.val;
              this.x = e[0] * b + e[3] * c + e[6];
              this.y = e[1] * b + e[4] * c + e[7];
              return this;
            },
            transformMat4: function (e) {
              var b = this.x,
                c = this.y;
              e = e.val;
              this.x = e[0] * b + e[4] * c + e[12];
              this.y = e[1] * b + e[5] * c + e[13];
              return this;
            },
            reset: function () {
              this.y = this.x = 0;
              return this;
            },
            limit: function (e) {
              var b = this.length();
              b && b > e && this.scale(e / b);
              return this;
            },
            reflect: function (e) {
              e = e.clone().normalize();
              return this.subtract(e.scale(2 * this.dot(e)));
            },
            mirror: function (e) {
              return this.reflect(e).negate();
            },
            rotate: function (e) {
              var b = Math.cos(e);
              e = Math.sin(e);
              return this.set(b * this.x - e * this.y, e * this.x + b * this.y);
            },
          });
        k.ZERO = new k();
        k.RIGHT = new k(1, 0);
        k.LEFT = new k(-1, 0);
        k.UP = new k(0, -1);
        k.DOWN = new k(0, 1);
        k.ONE = new k(1, 1);
        h.exports = k;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(56);
        a = new t({
          initialize: function (k, e) {
            void 0 === k && (k = 0);
            void 0 === e && (e = k);
            this.type = d.POINT;
            this.x = k;
            this.y = e;
          },
          setTo: function (k, e) {
            void 0 === k && (k = 0);
            void 0 === e && (e = k);
            this.x = k;
            this.y = e;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(24),
          k = a(20),
          e = new t({
            initialize: function (b) {
              this.scene = b;
              this.systems = b.sys;
              this.events = b.sys.events;
              this.displayList;
              this.updateList;
              this.events.once(k.BOOT, this.boot, this);
              this.events.on(k.START, this.start, this);
            },
            boot: function () {
              this.displayList = this.systems.displayList;
              this.updateList = this.systems.updateList;
              this.events.once(k.DESTROY, this.destroy, this);
            },
            start: function () {
              this.events.once(k.SHUTDOWN, this.shutdown, this);
            },
            existing: function (b) {
              (b.renderCanvas || b.renderWebGL) && this.displayList.add(b);
              b.preUpdate && this.updateList.add(b);
              return b;
            },
            shutdown: function () {
              this.events.off(k.SHUTDOWN, this.shutdown, this);
            },
            destroy: function () {
              this.shutdown();
              this.events.off(k.START, this.start, this);
              this.updateList =
                this.displayList =
                this.events =
                this.systems =
                this.scene =
                  null;
            },
          });
        e.register = function (b, c) {
          e.prototype.hasOwnProperty(b) || (e.prototype[b] = c);
        };
        e.remove = function (b) {
          e.prototype.hasOwnProperty(b) && delete e.prototype[b];
        };
        d.register("GameObjectFactory", e, "add");
        h.exports = e;
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          if (a && "number" !== typeof a) {
            if (a.hasOwnProperty(d)) return a[d];
            if (-1 !== d.indexOf(".")) {
              d = d.split(".");
              for (var e = k, b = 0; b < d.length; b++)
                if (a.hasOwnProperty(d[b])) (e = a[d[b]]), (a = a[d[b]]);
                else {
                  e = k;
                  break;
                }
              return e;
            }
          }
          return k;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          if ("object" !== typeof a || a.nodeType || a === a.window) return !1;
          try {
            if (
              a.constructor &&
              !{}.hasOwnProperty.call(a.constructor.prototype, "isPrototypeOf")
            )
              return !1;
          } catch (d) {
            return !1;
          }
          return !0;
        };
      },
      function (h, t) {
        var a = {};
        h.exports = {
          install: function (d) {
            for (var k in a) d[k] = a[k];
          },
          register: function (d, k) {
            a[d] = k;
          },
          destroy: function () {
            a = {};
          },
        };
      },
      function (h, t, a) {
        function d() {}

        function k(m, n, q) {
          this.fn = m;
          this.context = n;
          this.once = q || !1;
        }

        function e(m, n, q, r, u) {
          if ("function" !== typeof q)
            throw new TypeError("The listener must be a function");
          q = new k(q, r || m, u);
          n = g ? g + n : n;
          m._events[n]
            ? m._events[n].fn
              ? (m._events[n] = [m._events[n], q])
              : m._events[n].push(q)
            : ((m._events[n] = q), m._eventsCount++);
          return m;
        }

        function b(m, n) {
          0 === --m._eventsCount ? (m._events = new d()) : delete m._events[n];
        }

        function c() {
          this._events = new d();
          this._eventsCount = 0;
        }
        var f = Object.prototype.hasOwnProperty,
          g = "~";
        Object.create &&
          ((d.prototype = Object.create(null)), new d().__proto__ || (g = !1));
        c.prototype.eventNames = function () {
          var m = [],
            n,
            q;
          if (0 === this._eventsCount) return m;
          for (q in (n = this._events))
            f.call(n, q) && m.push(g ? q.slice(1) : q);
          return Object.getOwnPropertySymbols
            ? m.concat(Object.getOwnPropertySymbols(n))
            : m;
        };
        c.prototype.listeners = function (m) {
          m = this._events[g ? g + m : m];
          if (!m) return [];
          if (m.fn) return [m.fn];
          for (var n = 0, q = m.length, r = Array(q); n < q; n++)
            r[n] = m[n].fn;
          return r;
        };
        c.prototype.listenerCount = function (m) {
          return (m = this._events[g ? g + m : m]) ? (m.fn ? 1 : m.length) : 0;
        };
        c.prototype.emit = function (m, n, q, r, u, v) {
          var x = g ? g + m : m;
          if (!this._events[x]) return !1;
          x = this._events[x];
          var y = arguments.length,
            z;
          if (x.fn) {
            x.once && this.removeListener(m, x.fn, void 0, !0);
            switch (y) {
              case 1:
                return x.fn.call(x.context), !0;
              case 2:
                return x.fn.call(x.context, n), !0;
              case 3:
                return x.fn.call(x.context, n, q), !0;
              case 4:
                return x.fn.call(x.context, n, q, r), !0;
              case 5:
                return x.fn.call(x.context, n, q, r, u), !0;
              case 6:
                return x.fn.call(x.context, n, q, r, u, v), !0;
            }
            var A = 1;
            for (z = Array(y - 1); A < y; A++) z[A - 1] = arguments[A];
            x.fn.apply(x.context, z);
          } else {
            var B = x.length;
            for (A = 0; A < B; A++)
              switch (
                (x[A].once && this.removeListener(m, x[A].fn, void 0, !0), y)
              ) {
                case 1:
                  x[A].fn.call(x[A].context);
                  break;
                case 2:
                  x[A].fn.call(x[A].context, n);
                  break;
                case 3:
                  x[A].fn.call(x[A].context, n, q);
                  break;
                case 4:
                  x[A].fn.call(x[A].context, n, q, r);
                  break;
                default:
                  if (!z) {
                    var D = 1;
                    for (z = Array(y - 1); D < y; D++) z[D - 1] = arguments[D];
                  }
                  x[A].fn.apply(x[A].context, z);
              }
          }
          return !0;
        };
        c.prototype.on = function (m, n, q) {
          return e(this, m, n, q, !1);
        };
        c.prototype.once = function (m, n, q) {
          return e(this, m, n, q, !0);
        };
        c.prototype.removeListener = function (m, n, q, r) {
          m = g ? g + m : m;
          if (!this._events[m]) return this;
          if (!n) return b(this, m), this;
          var u = this._events[m];
          if (u.fn)
            u.fn !== n ||
              (r && !u.once) ||
              (q && u.context !== q) ||
              b(this, m);
          else {
            for (var v = 0, x = [], y = u.length; v < y; v++)
              (u[v].fn !== n ||
                (r && !u[v].once) ||
                (q && u[v].context !== q)) &&
                x.push(u[v]);
            x.length
              ? (this._events[m] = 1 === x.length ? x[0] : x)
              : b(this, m);
          }
          return this;
        };
        c.prototype.removeAllListeners = function (m) {
          m
            ? ((m = g ? g + m : m), this._events[m] && b(this, m))
            : ((this._events = new d()), (this._eventsCount = 0));
          return this;
        };
        c.prototype.off = c.prototype.removeListener;
        c.prototype.addListener = c.prototype.on;
        c.prefixed = g;
        c.EventEmitter = c;
        h.exports = c;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(57),
          k = a(171),
          e = a(306),
          b = a(56),
          c = a(47),
          f = a(174);
        a = new t({
          initialize: function (g, m, n, q) {
            void 0 === g && (g = 0);
            void 0 === m && (m = 0);
            void 0 === n && (n = 0);
            void 0 === q && (q = 0);
            this.type = b.RECTANGLE;
            this.x = g;
            this.y = m;
            this.width = n;
            this.height = q;
          },
          contains: function (g, m) {
            return d(this, g, m);
          },
          getPoint: function (g, m) {
            return k(this, g, m);
          },
          getPoints: function (g, m, n) {
            return e(this, g, m, n);
          },
          getRandomPoint: function (g) {
            return f(this, g);
          },
          setTo: function (g, m, n, q) {
            this.x = g;
            this.y = m;
            this.width = n;
            this.height = q;
            return this;
          },
          setEmpty: function () {
            return this.setTo(0, 0, 0, 0);
          },
          setPosition: function (g, m) {
            void 0 === m && (m = g);
            this.x = g;
            this.y = m;
            return this;
          },
          setSize: function (g, m) {
            void 0 === m && (m = g);
            this.width = g;
            this.height = m;
            return this;
          },
          isEmpty: function () {
            return 0 >= this.width || 0 >= this.height;
          },
          getLineA: function (g) {
            void 0 === g && (g = new c());
            g.setTo(this.x, this.y, this.right, this.y);
            return g;
          },
          getLineB: function (g) {
            void 0 === g && (g = new c());
            g.setTo(this.right, this.y, this.right, this.bottom);
            return g;
          },
          getLineC: function (g) {
            void 0 === g && (g = new c());
            g.setTo(this.right, this.bottom, this.x, this.bottom);
            return g;
          },
          getLineD: function (g) {
            void 0 === g && (g = new c());
            g.setTo(this.x, this.bottom, this.x, this.y);
            return g;
          },
          left: {
            get: function () {
              return this.x;
            },
            set: function (g) {
              this.width = g >= this.right ? 0 : this.right - g;
              this.x = g;
            },
          },
          right: {
            get: function () {
              return this.x + this.width;
            },
            set: function (g) {
              this.width = g <= this.x ? 0 : g - this.x;
            },
          },
          top: {
            get: function () {
              return this.y;
            },
            set: function (g) {
              this.height = g >= this.bottom ? 0 : this.bottom - g;
              this.y = g;
            },
          },
          bottom: {
            get: function () {
              return this.y + this.height;
            },
            set: function (g) {
              this.height = g <= this.y ? 0 : g - this.y;
            },
          },
          centerX: {
            get: function () {
              return this.x + this.width / 2;
            },
            set: function (g) {
              this.x = g - this.width / 2;
            },
          },
          centerY: {
            get: function () {
              return this.y + this.height / 2;
            },
            set: function (g) {
              this.y = g - this.height / 2;
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          Alpha: a(607),
          AlphaSingle: a(303),
          BlendMode: a(304),
          ComputedSize: a(608),
          Crop: a(609),
          Depth: a(305),
          Flip: a(610),
          GetBounds: a(611),
          Mask: a(309),
          Origin: a(632),
          PathFollower: a(633),
          Pipeline: a(167),
          ScrollFactor: a(312),
          Size: a(634),
          Texture: a(635),
          TextureCrop: a(636),
          Tint: a(637),
          ToJSON: a(176),
          Transform: a(313),
          TransformMatrix: a(25),
          Visible: a(314),
        };
      },
      function (h, t) {
        h.exports = {
          getTintFromFloats: function (a, d, k, e) {
            return (
              (((((255 * e) | 0) & 255) << 24) |
                ((((255 * a) | 0) & 255) << 16) |
                ((((255 * d) | 0) & 255) << 8) |
                (((255 * k) | 0) & 255)) >>>
              0
            );
          },
          getTintAppendFloatAlpha: function (a, d) {
            return (((((255 * d) | 0) & 255) << 24) | a) >>> 0;
          },
          getTintAppendFloatAlphaAndSwap: function (a, d) {
            return (
              (((((255 * d) | 0) & 255) << 24) |
                (((a | 0) & 255) << 16) |
                ((((a >> 8) | 0) & 255) << 8) |
                (((a >> 16) | 0) & 255)) >>>
              0
            );
          },
          getFloatsFromUintRGB: function (a) {
            return [
              (((a >> 16) | 0) & 255) / 255,
              (((a >> 8) | 0) & 255) / 255,
              ((a | 0) & 255) / 255,
            ];
          },
          checkShaderMax: function (a, d) {
            (d && -1 !== d) || (d = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS));
            for (var k = a.createShader(a.FRAGMENT_SHADER); ; ) {
              for (
                var e =
                    "precision mediump float;\nvoid main(void){\nfloat test = 0.1;\n%forloop%\ngl_FragColor = vec4(0.0);\n}"
                      .replace,
                  b = "",
                  c = 0;
                c < d;
                ++c
              )
                0 < c && (b += "\nelse "),
                  c < d - 1 && (b += "if(test == " + c + ".0){}");
              e = e.call(
                "precision mediump float;\nvoid main(void){\nfloat test = 0.1;\n%forloop%\ngl_FragColor = vec4(0.0);\n}",
                /%forloop%/gi,
                b
              );
              a.shaderSource(k, e);
              a.compileShader(k);
              if (a.getShaderParameter(k, a.COMPILE_STATUS)) break;
              else d = (d / 2) | 0;
            }
            return d;
          },
          parseFragmentShaderMaxTextures: function (a, d) {
            if (!a) return "";
            for (var k = "", e = 0; e < d; e++)
              0 < e && (k += "\n\telse "),
                e < d - 1 && (k += "if (outTexId < " + e + ".5)"),
                (k += "\n\t{"),
                (k +=
                  "\n\t\ttexture = texture2D(uMainSampler[" +
                  e +
                  "], outTexCoord);"),
                (k += "\n\t}");
            a = a.replace(/%count%/gi, d.toString());
            return a.replace(/%forloop%/gi, k);
          },
        };
      },
      function (h, t, a) {
        var d = a(193),
          k = a(6);
        h.exports = function (e, b, c) {
          e = k(e, b, null);
          if (null === e) return c;
          if (Array.isArray(e)) return d.RND.pick(e);
          if ("object" === typeof e) {
            if (e.hasOwnProperty("randInt"))
              return d.RND.integerInRange(e.randInt[0], e.randInt[1]);
            if (e.hasOwnProperty("randFloat"))
              return d.RND.realInRange(e.randFloat[0], e.randFloat[1]);
          } else if ("function" === typeof e) return e(b);
          return e;
        };
      },
      function (h, t) {
        h.exports = {
          PI2: 2 * Math.PI,
          TAU: 0.5 * Math.PI,
          EPSILON: 1e-6,
          DEG_TO_RAD: Math.PI / 180,
          RAD_TO_DEG: 180 / Math.PI,
          RND: null,
          MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,
          MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(176),
          k = a(101),
          e = a(9),
          b = a(75),
          c = a(20),
          f = new t({
            Extends: e,
            initialize: function (g, m) {
              e.call(this);
              this.scene = g;
              this.displayList = null;
              this.type = m;
              this.state = 0;
              this.parentContainer = null;
              this.name = "";
              this.active = !0;
              this.tabIndex = -1;
              this.data = null;
              this.renderFlags = 15;
              this.cameraFilter = 0;
              this.body = this.input = null;
              this.ignoreDestroy = !1;
              this.on(b.ADDED_TO_SCENE, this.addedToScene, this);
              this.on(b.REMOVED_FROM_SCENE, this.removedFromScene, this);
              g.sys.queueDepthSort();
            },
            setActive: function (g) {
              this.active = g;
              return this;
            },
            setName: function (g) {
              this.name = g;
              return this;
            },
            setState: function (g) {
              this.state = g;
              return this;
            },
            setDataEnabled: function () {
              this.data || (this.data = new k(this));
              return this;
            },
            setData: function (g, m) {
              this.data || (this.data = new k(this));
              this.data.set(g, m);
              return this;
            },
            incData: function (g, m) {
              this.data || (this.data = new k(this));
              this.data.inc(g, m);
              return this;
            },
            toggleData: function (g) {
              this.data || (this.data = new k(this));
              this.data.toggle(g);
              return this;
            },
            getData: function (g) {
              this.data || (this.data = new k(this));
              return this.data.get(g);
            },
            setInteractive: function (g, m, n) {
              this.scene.sys.input.enable(this, g, m, n);
              return this;
            },
            disableInteractive: function () {
              this.input && (this.input.enabled = !1);
              return this;
            },
            removeInteractive: function () {
              this.scene.sys.input.clear(this);
              this.input = void 0;
              return this;
            },
            addedToScene: function () {},
            removedFromScene: function () {},
            update: function () {},
            toJSON: function () {
              return d(this);
            },
            willRender: function (g) {
              return !(
                f.RENDER_MASK !== this.renderFlags ||
                (0 !== this.cameraFilter && this.cameraFilter & g.id)
              );
            },
            getIndexList: function () {
              for (var g = this, m = this.parentContainer, n = []; m; )
                if ((n.unshift(m.getIndex(g)), (g = m), m.parentContainer))
                  m = m.parentContainer;
                else break;
              this.displayList
                ? n.unshift(this.displayList.getIndex(g))
                : n.unshift(this.scene.sys.displayList.getIndex(g));
              return n;
            },
            addToDisplayList: function (g) {
              void 0 === g && (g = this.scene.sys.displayList);
              this.displayList &&
                this.displayList !== g &&
                this.removeFromDisplayList();
              g.exists(this) ||
                ((this.displayList = g),
                g.add(this, !0),
                g.queueDepthSort(),
                this.emit(b.ADDED_TO_SCENE, this, this.scene),
                g.events.emit(c.ADDED_TO_SCENE, this, this.scene));
              return this;
            },
            addToUpdateList: function () {
              this.scene &&
                this.preUpdate &&
                this.scene.sys.updateList.add(this);
              return this;
            },
            removeFromDisplayList: function () {
              var g = this.displayList || this.scene.sys.displayList;
              g.exists(this) &&
                (g.remove(this, !0),
                g.queueDepthSort(),
                (this.displayList = null),
                this.emit(b.REMOVED_FROM_SCENE, this, this.scene),
                g.events.emit(c.REMOVED_FROM_SCENE, this, this.scene));
              return this;
            },
            removeFromUpdateList: function () {
              this.scene &&
                this.preUpdate &&
                this.scene.sys.updateList.remove(this);
              return this;
            },
            destroy: function (g) {
              this.scene &&
                !this.ignoreDestroy &&
                (void 0 === g && (g = !1),
                this.preDestroy && this.preDestroy.call(this),
                this.emit(b.DESTROY, this, g),
                this.removeAllListeners(),
                this.postPipelines && this.resetPostPipeline(!0),
                this.removeFromDisplayList(),
                this.removeFromUpdateList(),
                this.input &&
                  (this.scene.sys.input.clear(this), (this.input = void 0)),
                this.data && (this.data.destroy(), (this.data = void 0)),
                this.body && (this.body.destroy(), (this.body = void 0)),
                (this.visible = this.active = !1),
                (this.parentContainer = this.scene = void 0));
            },
          });
        f.RENDER_MASK = 15;
        h.exports = f;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(24),
          k = a(20),
          e = new t({
            initialize: function (b) {
              this.scene = b;
              this.systems = b.sys;
              this.events = b.sys.events;
              this.displayList;
              this.updateList;
              this.events.once(k.BOOT, this.boot, this);
              this.events.on(k.START, this.start, this);
            },
            boot: function () {
              this.displayList = this.systems.displayList;
              this.updateList = this.systems.updateList;
              this.events.once(k.DESTROY, this.destroy, this);
            },
            start: function () {
              this.events.once(k.SHUTDOWN, this.shutdown, this);
            },
            shutdown: function () {
              this.events.off(k.SHUTDOWN, this.shutdown, this);
            },
            destroy: function () {
              this.shutdown();
              this.events.off(k.START, this.start, this);
              this.updateList =
                this.displayList =
                this.events =
                this.systems =
                this.scene =
                  null;
            },
          });
        e.register = function (b, c) {
          e.prototype.hasOwnProperty(b) || (e.prototype[b] = c);
        };
        e.remove = function (b) {
          e.prototype.hasOwnProperty(b) && delete e.prototype[b];
        };
        d.register("GameObjectCreator", e, "make");
        h.exports = e;
      },
      function (h, t, a) {
        var d = a(7),
          k = function () {
            var e,
              b,
              c,
              f = arguments[0] || {},
              g = 1,
              m = arguments.length,
              n = !1;
            "boolean" === typeof f &&
              ((n = f), (f = arguments[1] || {}), (g = 2));
            m === g && ((f = this), --g);
            for (; g < m; g++)
              if (null != (e = arguments[g]))
                for (b in e) {
                  var q = f[b];
                  var r = e[b];
                  f !== r &&
                    (n && r && (d(r) || (c = Array.isArray(r)))
                      ? (c
                          ? ((c = !1), (q = q && Array.isArray(q) ? q : []))
                          : (q = q && d(q) ? q : {}),
                        (f[b] = k(n, q, r)))
                      : void 0 !== r && (f[b] = r));
                }
            return f;
          };
        h.exports = k;
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          return Math.max(d, Math.min(k, a));
        };
      },
      function (h, t, a) {
        t = a(25);
        var d = new t(),
          k = new t(),
          e = new t(),
          b = {
            camera: d,
            sprite: k,
            calc: e,
          };
        h.exports = function (c, f, g) {
          k.applyITRS(c.x, c.y, c.rotation, c.scaleX, c.scaleY);
          d.copyFrom(f.matrix);
          g
            ? (d.multiplyWithOffset(
                g,
                -f.scrollX * c.scrollFactorX,
                -f.scrollY * c.scrollFactorY
              ),
              (k.e = c.x),
              (k.f = c.y))
            : ((k.e -= f.scrollX * c.scrollFactorX),
              (k.f -= f.scrollY * c.scrollFactorY));
          d.multiply(k, e);
          return b;
        };
      },
      function (h, t, a) {
        h.exports = {
          ADDED_TO_SCENE: a(656),
          BOOT: a(657),
          CREATE: a(658),
          DESTROY: a(659),
          PAUSE: a(660),
          POST_UPDATE: a(661),
          PRE_RENDER: a(662),
          PRE_UPDATE: a(663),
          READY: a(664),
          REMOVED_FROM_SCENE: a(665),
          RENDER: a(666),
          RESUME: a(667),
          SHUTDOWN: a(668),
          SLEEP: a(669),
          START: a(670),
          TRANSITION_COMPLETE: a(671),
          TRANSITION_INIT: a(672),
          TRANSITION_OUT: a(673),
          TRANSITION_START: a(674),
          TRANSITION_WAKE: a(675),
          UPDATE: a(676),
          WAKE: a(677),
        };
      },
      function (h, t) {
        h.exports = {
          LOADER_IDLE: 0,
          LOADER_LOADING: 1,
          LOADER_PROCESSING: 2,
          LOADER_COMPLETE: 3,
          LOADER_SHUTDOWN: 4,
          LOADER_DESTROYED: 5,
          FILE_PENDING: 10,
          FILE_LOADING: 11,
          FILE_LOADED: 12,
          FILE_FAILED: 13,
          FILE_PROCESSING: 14,
          FILE_ERRORED: 16,
          FILE_COMPLETE: 17,
          FILE_DESTROYED: 18,
          FILE_POPULATED: 19,
        };
      },
      function (h, t, a) {
        h.exports = {
          BLUR: a(612),
          BOOT: a(613),
          CONTEXT_LOST: a(614),
          CONTEXT_RESTORED: a(615),
          DESTROY: a(616),
          FOCUS: a(617),
          HIDDEN: a(618),
          PAUSE: a(619),
          POST_RENDER: a(620),
          POST_STEP: a(621),
          PRE_RENDER: a(622),
          PRE_STEP: a(623),
          READY: a(624),
          RESUME: a(625),
          STEP: a(626),
          VISIBLE: a(627),
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(95),
          e = a(2),
          b = a(155),
          c = a(240),
          f = a(517),
          g = a(156);
        a = new t({
          initialize: function (m, n) {
            this.loader = m;
            this.cache = e(n, "cache", !1);
            this.type = e(n, "type", !1);
            var q = (this.key = e(n, "key", !1));
            m.prefix && "" !== m.prefix && (this.key = m.prefix + q);
            if (!this.type || !this.key)
              throw Error("Invalid Loader." + this.type + " key");
            var r = e(n, "url");
            void 0 === r
              ? (r = m.path + q + "." + e(n, "extension", ""))
              : "string" !== typeof r ||
                r.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ||
                (r = m.path + r);
            this.url = r;
            this.src = "";
            this.xhrSettings = g(e(n, "responseType", void 0));
            e(n, "xhrSettings", !1) &&
              (this.xhrSettings = c(this.xhrSettings, e(n, "xhrSettings", {})));
            this.xhrLoader = null;
            this.state =
              "function" === typeof this.url
                ? d.FILE_POPULATED
                : d.FILE_PENDING;
            this.bytesTotal = 0;
            this.percentComplete = this.bytesLoaded = -1;
            this.data = this.crossOrigin = void 0;
            this.config = e(n, "config", {});
            this.multiFile;
            this.linkFile;
          },
          setLink: function (m) {
            this.linkFile = m;
            m.linkFile = this;
          },
          resetXHR: function () {
            this.xhrLoader &&
              ((this.xhrLoader.onload = void 0),
              (this.xhrLoader.onerror = void 0),
              (this.xhrLoader.onprogress = void 0));
          },
          load: function () {
            this.state === d.FILE_POPULATED
              ? this.loader.nextFile(this, !0)
              : ((this.state = d.FILE_LOADING),
                (this.src = b(this, this.loader.baseURL)),
                0 === this.src.indexOf("data:")
                  ? console.warn(
                      "Local data URIs are not supported: " + this.key
                    )
                  : (this.xhrLoader = f(this, this.loader.xhr)));
          },
          onLoad: function (m, n) {
            var q =
              m.responseURL &&
              (0 === m.responseURL.indexOf("file://") ||
                0 === m.responseURL.indexOf("capacitor://")) &&
              0 === n.target.status;
            n = !(n.target && 200 !== n.target.status) || q;
            4 === m.readyState &&
              400 <= m.status &&
              599 >= m.status &&
              (n = !1);
            this.state = d.FILE_LOADED;
            this.resetXHR();
            this.loader.nextFile(this, n);
          },
          onError: function () {
            this.resetXHR();
            this.loader.nextFile(this, !1);
          },
          onProgress: function (m) {
            m.lengthComputable &&
              ((this.bytesLoaded = m.loaded),
              (this.bytesTotal = m.total),
              (this.percentComplete = Math.min(
                this.bytesLoaded / this.bytesTotal,
                1
              )),
              this.loader.emit(k.FILE_PROGRESS, this, this.percentComplete));
          },
          onProcess: function () {
            this.state = d.FILE_PROCESSING;
            this.onProcessComplete();
          },
          onProcessComplete: function () {
            this.state = d.FILE_COMPLETE;
            if (this.multiFile) this.multiFile.onFileComplete(this);
            this.loader.fileProcessComplete(this);
          },
          onProcessError: function () {
            this.state = d.FILE_ERRORED;
            if (this.multiFile) this.multiFile.onFileFailed(this);
            this.loader.fileProcessComplete(this);
          },
          hasCacheConflict: function () {
            return this.cache && this.cache.exists(this.key);
          },
          addToCache: function () {
            this.cache && this.cache.add(this.key, this.data);
            this.pendingDestroy();
          },
          pendingDestroy: function (m) {
            void 0 === m && (m = this.data);
            var n = this.key,
              q = this.type;
            this.loader.emit(k.FILE_COMPLETE, n, q, m);
            this.loader.emit(k.FILE_KEY_COMPLETE + q + "-" + n, n, q, m);
            this.loader.flagForRemoval(this);
          },
          destroy: function () {
            this.data =
              this.linkFile =
              this.multiFile =
              this.xhrSettings =
              this.cache =
              this.loader =
                null;
          },
        });
        a.createObjectURL = function (m, n, q) {
          if ("function" === typeof URL) m.src = URL.createObjectURL(n);
          else {
            var r = new FileReader();
            r.onload = function () {
              m.removeAttribute("crossOrigin");
              m.src =
                "data:" + (n.type || q) + ";base64," + r.result.split(",")[1];
            };
            r.onerror = m.onerror;
            r.readAsDataURL(n);
          }
        };
        a.revokeObjectURL = function (m) {
          "function" === typeof URL && URL.revokeObjectURL(m.src);
        };
        h.exports = a;
      },
      function (h, t) {
        var a = {},
          d = {};
        h.exports = {
          register: function (k, e, b, c) {
            void 0 === c && (c = !1);
            a[k] = {
              plugin: e,
              mapping: b,
              custom: c,
            };
          },
          registerCustom: function (k, e, b, c) {
            d[k] = {
              plugin: e,
              mapping: b,
              data: c,
            };
          },
          hasCore: function (k) {
            return a.hasOwnProperty(k);
          },
          hasCustom: function (k) {
            return d.hasOwnProperty(k);
          },
          getCore: function (k) {
            return a[k];
          },
          getCustom: function (k) {
            return d[k];
          },
          getCustomClass: function (k) {
            return d.hasOwnProperty(k) ? d[k].plugin : null;
          },
          remove: function (k) {
            a.hasOwnProperty(k) && delete a[k];
          },
          removeCustom: function (k) {
            d.hasOwnProperty(k) && delete d[k];
          },
          destroyCorePlugins: function () {
            for (var k in a) a.hasOwnProperty(k) && delete a[k];
          },
          destroyCustomPlugins: function () {
            for (var k in d) d.hasOwnProperty(k) && delete d[k];
          },
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(14),
          k = a(3);
        a = new t({
          initialize: function (e, b, c, f, g, m) {
            void 0 === e && (e = 1);
            void 0 === b && (b = 0);
            void 0 === c && (c = 0);
            void 0 === f && (f = 1);
            void 0 === g && (g = 0);
            void 0 === m && (m = 0);
            this.matrix = new Float32Array([e, b, c, f, g, m, 0, 0, 1]);
            this.decomposedMatrix = {
              translateX: 0,
              translateY: 0,
              scaleX: 1,
              scaleY: 1,
              rotation: 0,
            };
          },
          a: {
            get: function () {
              return this.matrix[0];
            },
            set: function (e) {
              this.matrix[0] = e;
            },
          },
          b: {
            get: function () {
              return this.matrix[1];
            },
            set: function (e) {
              this.matrix[1] = e;
            },
          },
          c: {
            get: function () {
              return this.matrix[2];
            },
            set: function (e) {
              this.matrix[2] = e;
            },
          },
          d: {
            get: function () {
              return this.matrix[3];
            },
            set: function (e) {
              this.matrix[3] = e;
            },
          },
          e: {
            get: function () {
              return this.matrix[4];
            },
            set: function (e) {
              this.matrix[4] = e;
            },
          },
          f: {
            get: function () {
              return this.matrix[5];
            },
            set: function (e) {
              this.matrix[5] = e;
            },
          },
          tx: {
            get: function () {
              return this.matrix[4];
            },
            set: function (e) {
              this.matrix[4] = e;
            },
          },
          ty: {
            get: function () {
              return this.matrix[5];
            },
            set: function (e) {
              this.matrix[5] = e;
            },
          },
          rotation: {
            get: function () {
              return (
                Math.acos(this.a / this.scaleX) *
                (0 > Math.atan(-this.c / this.a) ? -1 : 1)
              );
            },
          },
          rotationNormalized: {
            get: function () {
              var e = this.matrix,
                b = e[0],
                c = e[1],
                f = e[2];
              e = e[3];
              return b || c
                ? 0 < c
                  ? Math.acos(b / this.scaleX)
                  : -Math.acos(b / this.scaleX)
                : f || e
                ? d.TAU -
                  (0 < e
                    ? Math.acos(-f / this.scaleY)
                    : -Math.acos(f / this.scaleY))
                : 0;
            },
          },
          scaleX: {
            get: function () {
              return Math.sqrt(this.a * this.a + this.b * this.b);
            },
          },
          scaleY: {
            get: function () {
              return Math.sqrt(this.c * this.c + this.d * this.d);
            },
          },
          loadIdentity: function () {
            var e = this.matrix;
            e[0] = 1;
            e[1] = 0;
            e[2] = 0;
            e[3] = 1;
            e[4] = 0;
            e[5] = 0;
            return this;
          },
          translate: function (e, b) {
            var c = this.matrix;
            c[4] = c[0] * e + c[2] * b + c[4];
            c[5] = c[1] * e + c[3] * b + c[5];
            return this;
          },
          scale: function (e, b) {
            var c = this.matrix;
            c[0] *= e;
            c[1] *= e;
            c[2] *= b;
            c[3] *= b;
            return this;
          },
          rotate: function (e) {
            var b = Math.sin(e);
            e = Math.cos(e);
            var c = this.matrix,
              f = c[0],
              g = c[1],
              m = c[2],
              n = c[3];
            c[0] = f * e + m * b;
            c[1] = g * e + n * b;
            c[2] = f * -b + m * e;
            c[3] = g * -b + n * e;
            return this;
          },
          multiply: function (e, b) {
            var c = this.matrix,
              f = e.matrix;
            e = c[0];
            var g = c[1],
              m = c[2],
              n = c[3],
              q = c[4];
            c = c[5];
            var r = f[0],
              u = f[1],
              v = f[2],
              x = f[3],
              y = f[4];
            f = f[5];
            b = void 0 === b ? this : b;
            b.a = r * e + u * m;
            b.b = r * g + u * n;
            b.c = v * e + x * m;
            b.d = v * g + x * n;
            b.e = y * e + f * m + q;
            b.f = y * g + f * n + c;
            return b;
          },
          multiplyWithOffset: function (e, b, c) {
            var f = this.matrix,
              g = e.matrix;
            e = f[0];
            var m = f[1],
              n = f[2],
              q = f[3],
              r = f[4],
              u = f[5],
              v = g[0],
              x = g[1],
              y = g[2],
              z = g[3],
              A = g[4];
            g = g[5];
            f[0] = v * e + x * n;
            f[1] = v * m + x * q;
            f[2] = y * e + z * n;
            f[3] = y * m + z * q;
            f[4] = A * e + g * n + (b * e + c * n + r);
            f[5] = A * m + g * q + (b * m + c * q + u);
            return this;
          },
          transform: function (e, b, c, f, g, m) {
            var n = this.matrix,
              q = n[0],
              r = n[1],
              u = n[2],
              v = n[3],
              x = n[4],
              y = n[5];
            n[0] = e * q + b * u;
            n[1] = e * r + b * v;
            n[2] = c * q + f * u;
            n[3] = c * r + f * v;
            n[4] = g * q + m * u + x;
            n[5] = g * r + m * v + y;
            return this;
          },
          transformPoint: function (e, b, c) {
            void 0 === c &&
              (c = {
                x: 0,
                y: 0,
              });
            var f = this.matrix,
              g = f[1],
              m = f[3],
              n = f[5];
            c.x = e * f[0] + b * f[2] + f[4];
            c.y = e * g + b * m + n;
            return c;
          },
          invert: function () {
            var e = this.matrix,
              b = e[0],
              c = e[1],
              f = e[2],
              g = e[3],
              m = e[4],
              n = e[5],
              q = b * g - c * f;
            e[0] = g / q;
            e[1] = -c / q;
            e[2] = -f / q;
            e[3] = b / q;
            e[4] = (f * n - g * m) / q;
            e[5] = -(b * n - c * m) / q;
            return this;
          },
          copyFrom: function (e) {
            var b = this.matrix;
            b[0] = e.a;
            b[1] = e.b;
            b[2] = e.c;
            b[3] = e.d;
            b[4] = e.e;
            b[5] = e.f;
            return this;
          },
          copyFromArray: function (e) {
            var b = this.matrix;
            b[0] = e[0];
            b[1] = e[1];
            b[2] = e[2];
            b[3] = e[3];
            b[4] = e[4];
            b[5] = e[5];
            return this;
          },
          copyToContext: function (e) {
            var b = this.matrix;
            e.transform(b[0], b[1], b[2], b[3], b[4], b[5]);
            return e;
          },
          setToContext: function (e) {
            var b = this.matrix;
            e.setTransform(b[0], b[1], b[2], b[3], b[4], b[5]);
            return e;
          },
          copyToArray: function (e) {
            var b = this.matrix;
            void 0 === e
              ? (e = [b[0], b[1], b[2], b[3], b[4], b[5]])
              : ((e[0] = b[0]),
                (e[1] = b[1]),
                (e[2] = b[2]),
                (e[3] = b[3]),
                (e[4] = b[4]),
                (e[5] = b[5]));
            return e;
          },
          setTransform: function (e, b, c, f, g, m) {
            var n = this.matrix;
            n[0] = e;
            n[1] = b;
            n[2] = c;
            n[3] = f;
            n[4] = g;
            n[5] = m;
            return this;
          },
          decomposeMatrix: function () {
            var e = this.decomposedMatrix,
              b = this.matrix,
              c = b[0],
              f = b[1],
              g = b[2],
              m = b[3],
              n = c * m - f * g;
            e.translateX = b[4];
            e.translateY = b[5];
            c || f
              ? ((g = Math.sqrt(c * c + f * f)),
                (e.rotation = 0 < f ? Math.acos(c / g) : -Math.acos(c / g)),
                (e.scaleX = g),
                (e.scaleY = n / g))
              : g || m
              ? ((c = Math.sqrt(g * g + m * m)),
                (e.rotation =
                  0.5 * Math.PI -
                  (0 < m ? Math.acos(-g / c) : -Math.acos(g / c))),
                (e.scaleX = n / c),
                (e.scaleY = c))
              : ((e.rotation = 0), (e.scaleX = 0), (e.scaleY = 0));
            return e;
          },
          applyITRS: function (e, b, c, f, g) {
            var m = this.matrix,
              n = Math.sin(c);
            c = Math.cos(c);
            m[4] = e;
            m[5] = b;
            m[0] = c * f;
            m[1] = n * f;
            m[2] = -n * g;
            m[3] = c * g;
            return this;
          },
          applyInverse: function (e, b, c) {
            void 0 === c && (c = new k());
            var f = this.matrix,
              g = f[0],
              m = f[1],
              n = f[2],
              q = f[3],
              r = f[4];
            f = f[5];
            var u = 1 / (g * q + n * -m);
            c.x = q * u * e + -n * u * b + (f * n - r * q) * u;
            c.y = g * u * b + -m * u * e + (-f * g + r * m) * u;
            return c;
          },
          getX: function (e, b) {
            return e * this.a + b * this.c + this.e;
          },
          getY: function (e, b) {
            return e * this.b + b * this.d + this.f;
          },
          getXRound: function (e, b, c) {
            e = this.getX(e, b);
            c && (e = Math.round(e));
            return e;
          },
          getYRound: function (e, b, c) {
            e = this.getY(e, b);
            c && (e = Math.round(e));
            return e;
          },
          getCSSMatrix: function () {
            var e = this.matrix;
            return (
              "matrix(" +
              e[0] +
              "," +
              e[1] +
              "," +
              e[2] +
              "," +
              e[3] +
              "," +
              e[4] +
              "," +
              e[5] +
              ")"
            );
          },
          destroy: function () {
            this.decomposedMatrix = this.matrix = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(2);
        h.exports = function (k, e, b, c, f, g) {
          void 0 === k && (k = 0);
          void 0 === e && (e = 0);
          void 0 === b && (b = g.width);
          void 0 === c && (c = g.height);
          f || (f = {});
          var m = d(f, "isNotEmpty", !1),
            n = d(f, "isColliding", !1);
          f = d(f, "hasInterestingFace", !1);
          0 > k && ((b += k), (k = 0));
          0 > e && ((c += e), (e = 0));
          k + b > g.width && (b = Math.max(g.width - k, 0));
          e + c > g.height && (c = Math.max(g.height - e, 0));
          for (var q = [], r = e; r < e + c; r++)
            for (var u = k; u < k + b; u++) {
              var v = g.data[r][u];
              null === v ||
                (m && -1 === v.index) ||
                (!((n && !v.collides) || (f && !v.hasInterestingFace)) &&
                  q.push(v));
            }
          return q;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b, c) {
          void 0 === e && (e = 0);
          void 0 === b && (b = 0);
          void 0 === c && (c = 1);
          var f = 0,
            g = a.length;
          if (1 === c) for (; b < g; b++) (a[b][d] = k + f * e), f++;
          else for (; 0 <= b; b--) (a[b][d] = k + f * e), f++;
          return a;
        };
      },
      function (h, t, a) {
        var d = a(35),
          k = a(13);
        h.exports = function (e, b, c) {
          b.x = k(c, "x", 0);
          b.y = k(c, "y", 0);
          b.depth = k(c, "depth", 0);
          b.flipX = k(c, "flipX", !1);
          b.flipY = k(c, "flipY", !1);
          var f = k(c, "scale", null);
          "number" === typeof f
            ? b.setScale(f)
            : null !== f &&
              ((b.scaleX = k(f, "x", 1)), (b.scaleY = k(f, "y", 1)));
          f = k(c, "scrollFactor", null);
          "number" === typeof f
            ? b.setScrollFactor(f)
            : null !== f &&
              ((b.scrollFactorX = k(f, "x", 1)),
              (b.scrollFactorY = k(f, "y", 1)));
          b.rotation = k(c, "rotation", 0);
          f = k(c, "angle", null);
          null !== f && (b.angle = f);
          b.alpha = k(c, "alpha", 1);
          var g = k(c, "origin", null);
          "number" === typeof g
            ? b.setOrigin(g)
            : null !== g &&
              ((f = k(g, "x", 0.5)), (g = k(g, "y", 0.5)), b.setOrigin(f, g));
          b.blendMode = k(c, "blendMode", d.NORMAL);
          b.visible = k(c, "visible", !0);
          k(c, "add", !0) && e.sys.displayList.add(b);
          b.preUpdate && e.sys.updateList.add(b);
          return b;
        };
      },
      function (h, t) {
        h.exports = {
          ORTHOGONAL: 0,
          ISOMETRIC: 1,
          STAGGERED: 2,
          HEXAGONAL: 3,
        };
      },
      function (h, t, a) {
        var d = a(19);
        h.exports = function (k, e, b, c, f) {
          var g = c.alpha * b.alpha;
          if (0 >= g) return !1;
          c = d(b, c, f).calc;
          e.globalCompositeOperation = k.blendModes[b.blendMode];
          e.globalAlpha = g;
          e.save();
          c.setToContext(e);
          e.imageSmoothingEnabled = !(
            !k.antialias ||
            (b.frame && b.frame.source.scaleMode)
          );
          return !0;
        };
      },
      function (h, t, a) {
        var d = a(33),
          k = a(192),
          e = [],
          b = !1;
        h.exports = (function () {
          var c = function (m, n, q, r, u) {
              void 0 === n && (n = 1);
              void 0 === q && (q = 1);
              void 0 === r && (r = d.CANVAS);
              void 0 === u && (u = !1);
              var v = f(r);
              null === v
                ? ((v = {
                    parent: m,
                    canvas: document.createElement("canvas"),
                    type: r,
                  }),
                  r === d.CANVAS && e.push(v))
                : (v.parent = m);
              m = v.canvas;
              u && (v.parent = m);
              m.width = n;
              m.height = q;
              b && r === d.CANVAS && k.disable(m.getContext("2d"));
              return m;
            },
            f = function (m) {
              void 0 === m && (m = d.CANVAS);
              if (m === d.WEBGL) return null;
              for (var n = 0; n < e.length; n++) {
                var q = e[n];
                if (!q.parent && q.type === m) return q;
              }
              return null;
            },
            g = function () {
              var m = 0;
              e.forEach(function (n) {
                n.parent && m++;
              });
              return m;
            };
          return {
            create2D: function (m, n, q) {
              return c(m, n, q, d.CANVAS);
            },
            create: c,
            createWebGL: function (m, n, q) {
              return c(m, n, q, d.WEBGL);
            },
            disableSmoothing: function () {
              b = !0;
            },
            enableSmoothing: function () {
              b = !1;
            },
            first: f,
            free: function () {
              return e.length - g();
            },
            pool: e,
            remove: function (m) {
              var n = m instanceof HTMLCanvasElement;
              e.forEach(function (q) {
                if ((n && q.canvas === m) || (!n && q.parent === m))
                  (q.parent = null),
                    (q.canvas.width = 1),
                    (q.canvas.height = 1);
              });
            },
            total: g,
          };
        })();
      },
      function (h, t) {
        var a = {};
        h.exports = a;
        (function () {
          a._nextId = 0;
          a._seed = 0;
          a._nowStartTime = +new Date();
          a.extend = function (d, k) {
            if ("boolean" === typeof k) {
              var e = 2;
              var b = k;
            } else (e = 1), (b = !0);
            for (; e < arguments.length; e++) {
              var c = arguments[e];
              if (c)
                for (var f in c)
                  b && c[f] && c[f].constructor === Object
                    ? d[f] && d[f].constructor !== Object
                      ? (d[f] = c[f])
                      : ((d[f] = d[f] || {}), a.extend(d[f], b, c[f]))
                    : (d[f] = c[f]);
            }
            return d;
          };
          a.clone = function (d, k) {
            return a.extend({}, k, d);
          };
          a.keys = function (d) {
            if (Object.keys) return Object.keys(d);
            var k = [],
              e;
            for (e in d) k.push(e);
            return k;
          };
          a.values = function (d) {
            var k = [];
            if (Object.keys) {
              for (var e = Object.keys(d), b = 0; b < e.length; b++)
                k.push(d[e[b]]);
              return k;
            }
            for (e in d) k.push(d[e]);
            return k;
          };
          a.get = function (d, k, e, b) {
            k = k.split(".").slice(e, b);
            for (e = 0; e < k.length; e += 1) d = d[k[e]];
            return d;
          };
          a.set = function (d, k, e, b, c) {
            b = k.split(".").slice(b, c);
            return (a.get(d, k, 0, -1)[b[b.length - 1]] = e);
          };
          a.shuffle = function (d) {
            for (var k = d.length - 1; 0 < k; k--) {
              var e = Math.floor(a.random() * (k + 1)),
                b = d[k];
              d[k] = d[e];
              d[e] = b;
            }
            return d;
          };
          a.choose = function (d) {
            return d[Math.floor(a.random() * d.length)];
          };
          a.isElement = function (d) {
            return "undefined" !== typeof HTMLElement
              ? d instanceof HTMLElement
              : !!(d && d.nodeType && d.nodeName);
          };
          a.isArray = function (d) {
            return "[object Array]" === Object.prototype.toString.call(d);
          };
          a.isFunction = function (d) {
            return "function" === typeof d;
          };
          a.isPlainObject = function (d) {
            return "object" === typeof d && d.constructor === Object;
          };
          a.isString = function (d) {
            return "[object String]" === Object.prototype.toString.call(d);
          };
          a.clamp = function (d, k, e) {
            return d < k ? k : d > e ? e : d;
          };
          a.sign = function (d) {
            return 0 > d ? -1 : 1;
          };
          a.now = function () {
            if ("undefined" !== typeof window && window.performance) {
              if (window.performance.now) return window.performance.now();
              if (window.performance.webkitNow)
                return window.performance.webkitNow();
            }
            return new Date() - a._nowStartTime;
          };
          a.random = function (d, k) {
            d = "undefined" !== typeof d ? d : 0;
            a._seed = (9301 * a._seed + 49297) % 233280;
            return (
              d + (a._seed / 233280) * (("undefined" !== typeof k ? k : 1) - d)
            );
          };
          a.colorToNumber = function (d) {
            d = d.replace("#", "");
            3 == d.length &&
              (d =
                d.charAt(0) +
                d.charAt(0) +
                d.charAt(1) +
                d.charAt(1) +
                d.charAt(2) +
                d.charAt(2));
            return parseInt(d, 16);
          };
          a.logLevel = 1;
          a.log = function () {
            console &&
              0 < a.logLevel &&
              3 >= a.logLevel &&
              console.log.apply(
                console,
                ["matter-js:"].concat(Array.prototype.slice.call(arguments))
              );
          };
          a.info = function () {
            console &&
              0 < a.logLevel &&
              2 >= a.logLevel &&
              console.info.apply(
                console,
                ["matter-js:"].concat(Array.prototype.slice.call(arguments))
              );
          };
          a.warn = function () {
            console &&
              0 < a.logLevel &&
              3 >= a.logLevel &&
              console.warn.apply(
                console,
                ["matter-js:"].concat(Array.prototype.slice.call(arguments))
              );
          };
          a.nextId = function () {
            return a._nextId++;
          };
          a.indexOf = function (d, k) {
            if (d.indexOf) return d.indexOf(k);
            for (var e = 0; e < d.length; e++) if (d[e] === k) return e;
            return -1;
          };
          a.map = function (d, k) {
            if (d.map) return d.map(k);
            for (var e = [], b = 0; b < d.length; b += 1) e.push(k(d[b]));
            return e;
          };
          a.topologicalSort = function (d) {
            var k = [],
              e = [],
              b = [],
              c;
            for (c in d) e[c] || b[c] || a._topologicalSort(c, e, b, d, k);
            return k;
          };
          a._topologicalSort = function (d, k, e, b, c) {
            var f = b[d] || [];
            e[d] = !0;
            for (var g = 0; g < f.length; g += 1) {
              var m = f[g];
              e[m] || k[m] || a._topologicalSort(m, k, e, b, c);
            }
            e[d] = !1;
            k[d] = !0;
            c.push(d);
          };
          a.chain = function () {
            for (var d = [], k = 0; k < arguments.length; k += 1) {
              var e = arguments[k];
              e._chained ? d.push.apply(d, e._chained) : d.push(e);
            }
            k = function () {
              for (
                var b, c = Array(arguments.length), f = 0, g = arguments.length;
                f < g;
                f++
              )
                c[f] = arguments[f];
              for (f = 0; f < d.length; f += 1)
                (g = d[f].apply(b, c)), "undefined" !== typeof g && (b = g);
              return b;
            };
            k._chained = d;
            return k;
          };
          a.chainPathBefore = function (d, k, e) {
            return a.set(d, k, a.chain(e, a.get(d, k)));
          };
          a.chainPathAfter = function (d, k, e) {
            return a.set(d, k, a.chain(a.get(d, k), e));
          };
        })();
      },
      function (h, t, a) {
        t = {
          VERSION: "3.55.2",
          BlendModes: a(35),
          ScaleModes: a(168),
          AUTO: 0,
          CANVAS: 1,
          WEBGL: 2,
          HEADLESS: 3,
          FOREVER: -1,
          NONE: 4,
          UP: 5,
          DOWN: 6,
          LEFT: 7,
          RIGHT: 8,
        };
        h.exports = t;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(11),
          k = a(15),
          e = a(47);
        a = new t({
          Extends: k,
          Mixins: [
            d.AlphaSingle,
            d.BlendMode,
            d.Depth,
            d.GetBounds,
            d.Mask,
            d.Origin,
            d.Pipeline,
            d.ScrollFactor,
            d.Transform,
            d.Visible,
          ],
          initialize: function (b, c, f) {
            void 0 === c && (c = "Shape");
            k.call(this, b, c);
            this.geom = f;
            this.pathData = [];
            this.pathIndexes = [];
            this.fillColor = 16777215;
            this.fillAlpha = 1;
            this.strokeColor = 16777215;
            this.lineWidth = this.strokeAlpha = 1;
            this.isStroked = this.isFilled = !1;
            this.closePath = !0;
            this._tempLine = new e();
            this.height = this.width = 0;
            this.initPipeline();
          },
          setFillStyle: function (b, c) {
            void 0 === c && (c = 1);
            void 0 === b
              ? (this.isFilled = !1)
              : ((this.fillColor = b),
                (this.fillAlpha = c),
                (this.isFilled = !0));
            return this;
          },
          setStrokeStyle: function (b, c, f) {
            void 0 === f && (f = 1);
            void 0 === b
              ? (this.isStroked = !1)
              : ((this.lineWidth = b),
                (this.strokeColor = c),
                (this.strokeAlpha = f),
                (this.isStroked = !0));
            return this;
          },
          setClosePath: function (b) {
            this.closePath = b;
            return this;
          },
          setSize: function (b, c) {
            this.width = b;
            this.height = c;
            return this;
          },
          setDisplaySize: function (b, c) {
            this.displayWidth = b;
            this.displayHeight = c;
            return this;
          },
          preDestroy: function () {
            this._tempLine = this.geom = null;
            this.pathData = [];
            this.pathIndexes = [];
          },
          displayWidth: {
            get: function () {
              return this.scaleX * this.width;
            },
            set: function (b) {
              this.scaleX = b / this.width;
            },
          },
          displayHeight: {
            get: function () {
              return this.scaleY * this.height;
            },
            set: function (b) {
              this.scaleY = b / this.height;
            },
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = {
          SKIP_CHECK: -1,
          NORMAL: 0,
          ADD: 1,
          MULTIPLY: 2,
          SCREEN: 3,
          OVERLAY: 4,
          DARKEN: 5,
          LIGHTEN: 6,
          COLOR_DODGE: 7,
          COLOR_BURN: 8,
          HARD_LIGHT: 9,
          SOFT_LIGHT: 10,
          DIFFERENCE: 11,
          EXCLUSION: 12,
          HUE: 13,
          SATURATION: 14,
          COLOR: 15,
          LUMINOSITY: 16,
          ERASE: 17,
          SOURCE_IN: 18,
          SOURCE_OUT: 19,
          SOURCE_ATOP: 20,
          DESTINATION_OVER: 21,
          DESTINATION_IN: 22,
          DESTINATION_OUT: 23,
          DESTINATION_ATOP: 24,
          LIGHTER: 25,
          COPY: 26,
          XOR: 27,
        };
      },
      function (h, t, a) {
        var d = a(14);
        h.exports = function (k) {
          return k * d.DEG_TO_RAD;
        };
      },
      function (h, t, a) {
        h.exports = {
          DESTROY: a(743),
          FADE_IN_COMPLETE: a(744),
          FADE_IN_START: a(745),
          FADE_OUT_COMPLETE: a(746),
          FADE_OUT_START: a(747),
          FLASH_COMPLETE: a(748),
          FLASH_START: a(749),
          FOLLOW_UPDATE: a(750),
          PAN_COMPLETE: a(751),
          PAN_START: a(752),
          POST_RENDER: a(753),
          PRE_RENDER: a(754),
          ROTATE_COMPLETE: a(755),
          ROTATE_START: a(756),
          SHAKE_COMPLETE: a(757),
          SHAKE_START: a(758),
          ZOOM_COMPLETE: a(759),
          ZOOM_START: a(760),
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(103),
          k = a(328),
          e = a(188),
          b = a(329),
          c = new t({
            initialize: function (f, g, m, n) {
              void 0 === f && (f = 0);
              void 0 === g && (g = 0);
              void 0 === m && (m = 0);
              void 0 === n && (n = 255);
              this.b = this.g = this.r = 0;
              this.a = 255;
              this._v = this._s = this._h = 0;
              this._locked = !1;
              this.gl = [0, 0, 0, 1];
              this._color32 = this._color = 0;
              this._rgba = "";
              this.setTo(f, g, m, n);
            },
            transparent: function () {
              this._locked = !0;
              this.alpha = this.blue = this.green = this.red = 0;
              this._locked = !1;
              return this.update(!0);
            },
            setTo: function (f, g, m, n, q) {
              void 0 === n && (n = 255);
              void 0 === q && (q = !0);
              this._locked = !0;
              this.red = f;
              this.green = g;
              this.blue = m;
              this.alpha = n;
              this._locked = !1;
              return this.update(q);
            },
            setGLTo: function (f, g, m, n) {
              void 0 === n && (n = 1);
              this.redGL = f;
              this.greenGL = g;
              this.blueGL = m;
              this.alphaGL = n;
              this._locked = !1;
              return this.update(!0);
            },
            setFromRGB: function (f) {
              this._locked = !0;
              this.red = f.r;
              this.green = f.g;
              this.blue = f.b;
              f.hasOwnProperty("a") && (this.alpha = f.a);
              this._locked = !1;
              return this.update(!0);
            },
            setFromHSV: function (f, g, m) {
              return e(f, g, m, this);
            },
            update: function (f) {
              void 0 === f && (f = !1);
              if (this._locked) return this;
              var g = this.r,
                m = this.g,
                n = this.b,
                q = this.a;
              this._color = d(g, m, n);
              this._color32 = k(g, m, n, q);
              this._rgba =
                "rgba(" + g + "," + m + "," + n + "," + q / 255 + ")";
              f && b(g, m, n, this);
              return this;
            },
            updateHSV: function () {
              b(this.r, this.g, this.b, this);
              return this;
            },
            clone: function () {
              return new c(this.r, this.g, this.b, this.a);
            },
            gray: function (f) {
              return this.setTo(f, f, f);
            },
            random: function (f, g) {
              void 0 === f && (f = 0);
              void 0 === g && (g = 255);
              return this.setTo(
                Math.floor(f + Math.random() * (g - f)),
                Math.floor(f + Math.random() * (g - f)),
                Math.floor(f + Math.random() * (g - f))
              );
            },
            randomGray: function (f, g) {
              void 0 === f && (f = 0);
              void 0 === g && (g = 255);
              f = Math.floor(f + Math.random() * (g - f));
              return this.setTo(f, f, f);
            },
            saturate: function (f) {
              this.s += f / 100;
              return this;
            },
            desaturate: function (f) {
              this.s -= f / 100;
              return this;
            },
            lighten: function (f) {
              this.v += f / 100;
              return this;
            },
            darken: function (f) {
              this.v -= f / 100;
              return this;
            },
            brighten: function (f) {
              var g = this.r,
                m = this.g,
                n = this.b;
              g = Math.max(0, Math.min(255, g - Math.round(255 * -(f / 100))));
              m = Math.max(0, Math.min(255, m - Math.round(255 * -(f / 100))));
              n = Math.max(0, Math.min(255, n - Math.round(255 * -(f / 100))));
              return this.setTo(g, m, n);
            },
            color: {
              get: function () {
                return this._color;
              },
            },
            color32: {
              get: function () {
                return this._color32;
              },
            },
            rgba: {
              get: function () {
                return this._rgba;
              },
            },
            redGL: {
              get: function () {
                return this.gl[0];
              },
              set: function (f) {
                this.gl[0] = Math.min(Math.abs(f), 1);
                this.r = Math.floor(255 * this.gl[0]);
                this.update(!0);
              },
            },
            greenGL: {
              get: function () {
                return this.gl[1];
              },
              set: function (f) {
                this.gl[1] = Math.min(Math.abs(f), 1);
                this.g = Math.floor(255 * this.gl[1]);
                this.update(!0);
              },
            },
            blueGL: {
              get: function () {
                return this.gl[2];
              },
              set: function (f) {
                this.gl[2] = Math.min(Math.abs(f), 1);
                this.b = Math.floor(255 * this.gl[2]);
                this.update(!0);
              },
            },
            alphaGL: {
              get: function () {
                return this.gl[3];
              },
              set: function (f) {
                this.gl[3] = Math.min(Math.abs(f), 1);
                this.a = Math.floor(255 * this.gl[3]);
                this.update();
              },
            },
            red: {
              get: function () {
                return this.r;
              },
              set: function (f) {
                f = Math.floor(Math.abs(f));
                this.r = Math.min(f, 255);
                this.gl[0] = f / 255;
                this.update(!0);
              },
            },
            green: {
              get: function () {
                return this.g;
              },
              set: function (f) {
                f = Math.floor(Math.abs(f));
                this.g = Math.min(f, 255);
                this.gl[1] = f / 255;
                this.update(!0);
              },
            },
            blue: {
              get: function () {
                return this.b;
              },
              set: function (f) {
                f = Math.floor(Math.abs(f));
                this.b = Math.min(f, 255);
                this.gl[2] = f / 255;
                this.update(!0);
              },
            },
            alpha: {
              get: function () {
                return this.a;
              },
              set: function (f) {
                f = Math.floor(Math.abs(f));
                this.a = Math.min(f, 255);
                this.gl[3] = f / 255;
                this.update();
              },
            },
            h: {
              get: function () {
                return this._h;
              },
              set: function (f) {
                this._h = f;
                e(f, this._s, this._v, this);
              },
            },
            s: {
              get: function () {
                return this._s;
              },
              set: function (f) {
                this._s = f;
                e(this._h, f, this._v, this);
              },
            },
            v: {
              get: function () {
                return this._v;
              },
              set: function (f) {
                this._v = f;
                e(this._h, this._s, f, this);
              },
            },
          });
        h.exports = c;
      },
      function (h, t, a) {
        var d = new (a(0))({
          initialize: function (k, e, b) {
            this.z = this.y = this.x = 0;
            "object" === typeof k
              ? ((this.x = k.x || 0), (this.y = k.y || 0), (this.z = k.z || 0))
              : ((this.x = k || 0), (this.y = e || 0), (this.z = b || 0));
          },
          up: function () {
            this.x = 0;
            this.y = 1;
            this.z = 0;
            return this;
          },
          min: function (k) {
            this.x = Math.min(this.x, k.x);
            this.y = Math.min(this.y, k.y);
            this.z = Math.min(this.z, k.z);
            return this;
          },
          max: function (k) {
            this.x = Math.max(this.x, k.x);
            this.y = Math.max(this.y, k.y);
            this.z = Math.max(this.z, k.z);
            return this;
          },
          clone: function () {
            return new d(this.x, this.y, this.z);
          },
          addVectors: function (k, e) {
            this.x = k.x + e.x;
            this.y = k.y + e.y;
            this.z = k.z + e.z;
            return this;
          },
          crossVectors: function (k, e) {
            var b = k.x,
              c = k.y;
            k = k.z;
            var f = e.x,
              g = e.y;
            e = e.z;
            this.x = c * e - k * g;
            this.y = k * f - b * e;
            this.z = b * g - c * f;
            return this;
          },
          equals: function (k) {
            return this.x === k.x && this.y === k.y && this.z === k.z;
          },
          copy: function (k) {
            this.x = k.x;
            this.y = k.y;
            this.z = k.z || 0;
            return this;
          },
          set: function (k, e, b) {
            "object" === typeof k
              ? ((this.x = k.x || 0), (this.y = k.y || 0), (this.z = k.z || 0))
              : ((this.x = k || 0), (this.y = e || 0), (this.z = b || 0));
            return this;
          },
          setFromMatrixPosition: function (k) {
            return this.fromArray(k.val, 12);
          },
          setFromMatrixColumn: function (k, e) {
            return this.fromArray(k.val, 4 * e);
          },
          fromArray: function (k, e) {
            void 0 === e && (e = 0);
            this.x = k[e];
            this.y = k[e + 1];
            this.z = k[e + 2];
            return this;
          },
          add: function (k) {
            this.x += k.x;
            this.y += k.y;
            this.z += k.z || 0;
            return this;
          },
          addScalar: function (k) {
            this.x += k;
            this.y += k;
            this.z += k;
            return this;
          },
          addScale: function (k, e) {
            this.x += k.x * e;
            this.y += k.y * e;
            this.z += k.z * e || 0;
            return this;
          },
          subtract: function (k) {
            this.x -= k.x;
            this.y -= k.y;
            this.z -= k.z || 0;
            return this;
          },
          multiply: function (k) {
            this.x *= k.x;
            this.y *= k.y;
            this.z *= k.z || 1;
            return this;
          },
          scale: function (k) {
            isFinite(k)
              ? ((this.x *= k), (this.y *= k), (this.z *= k))
              : (this.z = this.y = this.x = 0);
            return this;
          },
          divide: function (k) {
            this.x /= k.x;
            this.y /= k.y;
            this.z /= k.z || 1;
            return this;
          },
          negate: function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
          },
          distance: function (k) {
            var e = k.x - this.x,
              b = k.y - this.y;
            k = k.z - this.z || 0;
            return Math.sqrt(e * e + b * b + k * k);
          },
          distanceSq: function (k) {
            var e = k.x - this.x,
              b = k.y - this.y;
            k = k.z - this.z || 0;
            return e * e + b * b + k * k;
          },
          length: function () {
            var k = this.x,
              e = this.y,
              b = this.z;
            return Math.sqrt(k * k + e * e + b * b);
          },
          lengthSq: function () {
            var k = this.x,
              e = this.y,
              b = this.z;
            return k * k + e * e + b * b;
          },
          normalize: function () {
            var k = this.x,
              e = this.y,
              b = this.z,
              c = k * k + e * e + b * b;
            0 < c &&
              ((c = 1 / Math.sqrt(c)),
              (this.x = k * c),
              (this.y = e * c),
              (this.z = b * c));
            return this;
          },
          dot: function (k) {
            return this.x * k.x + this.y * k.y + this.z * k.z;
          },
          cross: function (k) {
            var e = this.x,
              b = this.y,
              c = this.z,
              f = k.x,
              g = k.y;
            k = k.z;
            this.x = b * k - c * g;
            this.y = c * f - e * k;
            this.z = e * g - b * f;
            return this;
          },
          lerp: function (k, e) {
            void 0 === e && (e = 0);
            var b = this.x,
              c = this.y,
              f = this.z;
            this.x = b + e * (k.x - b);
            this.y = c + e * (k.y - c);
            this.z = f + e * (k.z - f);
            return this;
          },
          applyMatrix3: function (k) {
            var e = this.x,
              b = this.y,
              c = this.z;
            k = k.val;
            this.x = k[0] * e + k[3] * b + k[6] * c;
            this.y = k[1] * e + k[4] * b + k[7] * c;
            this.z = k[2] * e + k[5] * b + k[8] * c;
            return this;
          },
          applyMatrix4: function (k) {
            var e = this.x,
              b = this.y,
              c = this.z;
            k = k.val;
            var f = 1 / (k[3] * e + k[7] * b + k[11] * c + k[15]);
            this.x = (k[0] * e + k[4] * b + k[8] * c + k[12]) * f;
            this.y = (k[1] * e + k[5] * b + k[9] * c + k[13]) * f;
            this.z = (k[2] * e + k[6] * b + k[10] * c + k[14]) * f;
            return this;
          },
          transformMat3: function (k) {
            var e = this.x,
              b = this.y,
              c = this.z;
            k = k.val;
            this.x = e * k[0] + b * k[3] + c * k[6];
            this.y = e * k[1] + b * k[4] + c * k[7];
            this.z = e * k[2] + b * k[5] + c * k[8];
            return this;
          },
          transformMat4: function (k) {
            var e = this.x,
              b = this.y,
              c = this.z;
            k = k.val;
            this.x = k[0] * e + k[4] * b + k[8] * c + k[12];
            this.y = k[1] * e + k[5] * b + k[9] * c + k[13];
            this.z = k[2] * e + k[6] * b + k[10] * c + k[14];
            return this;
          },
          transformCoordinates: function (k) {
            var e = this.x,
              b = this.y,
              c = this.z;
            k = k.val;
            var f = e * k[1] + b * k[5] + c * k[9] + k[13],
              g = e * k[2] + b * k[6] + c * k[10] + k[14],
              m = e * k[3] + b * k[7] + c * k[11] + k[15];
            this.x = (e * k[0] + b * k[4] + c * k[8] + k[12]) / m;
            this.y = f / m;
            this.z = g / m;
            return this;
          },
          transformQuat: function (k) {
            var e = this.x,
              b = this.y,
              c = this.z,
              f = k.x,
              g = k.y,
              m = k.z;
            k = k.w;
            var n = k * e + g * c - m * b,
              q = k * b + m * e - f * c,
              r = k * c + f * b - g * e;
            e = -f * e - g * b - m * c;
            this.x = n * k + e * -f + q * -m - r * -g;
            this.y = q * k + e * -g + r * -f - n * -m;
            this.z = r * k + e * -m + n * -g - q * -f;
            return this;
          },
          project: function (k) {
            var e = this.x,
              b = this.y,
              c = this.z;
            k = k.val;
            var f = k[1],
              g = k[2],
              m = k[5],
              n = k[6],
              q = k[9],
              r = k[10],
              u = k[13],
              v = k[14],
              x = 1 / (e * k[3] + b * k[7] + c * k[11] + k[15]);
            this.x = (e * k[0] + b * k[4] + c * k[8] + k[12]) * x;
            this.y = (e * f + b * m + c * q + u) * x;
            this.z = (e * g + b * n + c * r + v) * x;
            return this;
          },
          projectViewMatrix: function (k, e) {
            return this.applyMatrix4(k).applyMatrix4(e);
          },
          unprojectViewMatrix: function (k, e) {
            return this.applyMatrix4(k).applyMatrix4(e);
          },
          unproject: function (k, e) {
            var b = k.w,
              c = b - this.y - 1 - k.y,
              f = this.z;
            this.x = (2 * (this.x - k.x)) / k.z - 1;
            this.y = (2 * c) / b - 1;
            this.z = 2 * f - 1;
            return this.project(e);
          },
          reset: function () {
            this.z = this.y = this.x = 0;
            return this;
          },
        });
        d.ZERO = new d();
        d.RIGHT = new d(1, 0, 0);
        d.LEFT = new d(-1, 0, 0);
        d.UP = new d(0, -1, 0);
        d.DOWN = new d(0, 1, 0);
        d.FORWARD = new d(0, 0, 1);
        d.BACK = new d(0, 0, -1);
        d.ONE = new d(1, 1, 1);
        h.exports = d;
      },
      function (h, t) {
        h.exports = {
          CSV: 0,
          TILED_JSON: 1,
          ARRAY_2D: 2,
          WELTMEISTER: 3,
        };
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(64),
          e = a(83),
          b = a(165),
          c = a(32),
          f = a(84),
          g = a(271);
        (function () {
          d._inertiaScale = 4;
          d._nextCollidingGroupId = 1;
          d._nextNonCollidingGroupId = -1;
          d._nextCategory = 1;
          d.create = function (n) {
            var q = {
              id: c.nextId(),
              type: "body",
              label: "Body",
              parts: [],
              plugin: {},
              angle: 0,
              vertices: null,
              position: {
                x: 0,
                y: 0,
              },
              force: {
                x: 0,
                y: 0,
              },
              torque: 0,
              positionImpulse: {
                x: 0,
                y: 0,
              },
              previousPositionImpulse: {
                x: 0,
                y: 0,
              },
              constraintImpulse: {
                x: 0,
                y: 0,
                angle: 0,
              },
              totalContacts: 0,
              speed: 0,
              angularSpeed: 0,
              velocity: {
                x: 0,
                y: 0,
              },
              angularVelocity: 0,
              isSensor: !1,
              isStatic: !1,
              isSleeping: !1,
              motion: 0,
              sleepThreshold: 60,
              density: 0.001,
              restitution: 0,
              friction: 0.1,
              frictionStatic: 0.5,
              frictionAir: 0.01,
              collisionFilter: {
                category: 1,
                mask: 4294967295,
                group: 0,
              },
              slop: 0.05,
              timeScale: 1,
              events: null,
              bounds: null,
              chamfer: null,
              circleRadius: 0,
              positionPrev: null,
              anglePrev: 0,
              parent: null,
              axes: null,
              area: 0,
              mass: 0,
              inverseMass: 0,
              inertia: 0,
              inverseInertia: 0,
              _original: null,
              render: {
                visible: !0,
                opacity: 1,
                sprite: {
                  xOffset: 0,
                  yOffset: 0,
                },
                fillColor: null,
                fillOpacity: null,
                lineColor: null,
                lineOpacity: null,
                lineThickness: null,
              },
              gameObject: null,
              scale: {
                x: 1,
                y: 1,
              },
              centerOfMass: {
                x: 0,
                y: 0,
              },
              centerOffset: {
                x: 0,
                y: 0,
              },
              gravityScale: {
                x: 1,
                y: 1,
              },
              ignoreGravity: !1,
              ignorePointer: !1,
              onCollideCallback: null,
              onCollideEndCallback: null,
              onCollideActiveCallback: null,
              onCollideWith: {},
            };
            !n.hasOwnProperty("position") && n.hasOwnProperty("vertices")
              ? (n.position = k.centre(n.vertices))
              : n.hasOwnProperty("vertices") ||
                (q.vertices = k.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"));
            q = c.extend(q, n);
            m(q, n);
            q.setOnCollideWith = function (r, u) {
              u
                ? (this.onCollideWith[r.id] = u)
                : delete this.onCollideWith[r.id];
              return this;
            };
            return q;
          };
          d.nextGroup = function (n) {
            return n ? d._nextNonCollidingGroupId-- : d._nextCollidingGroupId++;
          };
          d.nextCategory = function () {
            d._nextCategory <<= 1;
            return d._nextCategory;
          };
          var m = function (n, q) {
            q = q || {};
            d.set(n, {
              bounds: n.bounds || f.create(n.vertices),
              positionPrev: n.positionPrev || e.clone(n.position),
              anglePrev: n.anglePrev || n.angle,
              vertices: n.vertices,
              parts: n.parts || [n],
              isStatic: n.isStatic,
              isSleeping: n.isSleeping,
              parent: n.parent || n,
            });
            var r = n.bounds;
            k.rotate(n.vertices, n.angle, n.position);
            g.rotate(n.axes, n.angle);
            f.update(r, n.vertices, n.velocity);
            d.set(n, {
              axes: q.axes || n.axes,
              area: q.area || n.area,
              mass: q.mass || n.mass,
              inertia: q.inertia || n.inertia,
            });
            if (1 === n.parts.length) {
              q = n.centerOfMass;
              var u = n.centerOffset,
                v = r.max.x - r.min.x,
                x = r.max.y - r.min.y;
              q.x = -(r.min.x - n.position.x) / v;
              q.y = -(r.min.y - n.position.y) / x;
              u.x = v * q.x;
              u.y = x * q.y;
            }
          };
          d.set = function (n, q, r) {
            if ("string" === typeof q) {
              var u = q;
              q = {};
              q[u] = r;
            }
            for (u in q)
              if (Object.prototype.hasOwnProperty.call(q, u))
                switch (((r = q[u]), u)) {
                  case "isStatic":
                    d.setStatic(n, r);
                    break;
                  case "isSleeping":
                    b.set(n, r);
                    break;
                  case "mass":
                    d.setMass(n, r);
                    break;
                  case "density":
                    d.setDensity(n, r);
                    break;
                  case "inertia":
                    d.setInertia(n, r);
                    break;
                  case "vertices":
                    d.setVertices(n, r);
                    break;
                  case "position":
                    d.setPosition(n, r);
                    break;
                  case "angle":
                    d.setAngle(n, r);
                    break;
                  case "velocity":
                    d.setVelocity(n, r);
                    break;
                  case "angularVelocity":
                    d.setAngularVelocity(n, r);
                    break;
                  case "parts":
                    d.setParts(n, r);
                    break;
                  case "centre":
                    d.setCentre(n, r);
                    break;
                  default:
                    n[u] = r;
                }
          };
          d.setStatic = function (n, q) {
            for (var r = 0; r < n.parts.length; r++) {
              var u = n.parts[r];
              (u.isStatic = q)
                ? ((u._original = {
                    restitution: u.restitution,
                    friction: u.friction,
                    mass: u.mass,
                    inertia: u.inertia,
                    density: u.density,
                    inverseMass: u.inverseMass,
                    inverseInertia: u.inverseInertia,
                  }),
                  (u.restitution = 0),
                  (u.friction = 1),
                  (u.mass = u.inertia = u.density = Infinity),
                  (u.inverseMass = u.inverseInertia = 0),
                  (u.positionPrev.x = u.position.x),
                  (u.positionPrev.y = u.position.y),
                  (u.anglePrev = u.angle),
                  (u.angularVelocity = 0),
                  (u.speed = 0),
                  (u.angularSpeed = 0),
                  (u.motion = 0))
                : u._original &&
                  ((u.restitution = u._original.restitution),
                  (u.friction = u._original.friction),
                  (u.mass = u._original.mass),
                  (u.inertia = u._original.inertia),
                  (u.density = u._original.density),
                  (u.inverseMass = u._original.inverseMass),
                  (u.inverseInertia = u._original.inverseInertia),
                  (u._original = null));
            }
          };
          d.setMass = function (n, q) {
            n.inertia = (n.inertia / (n.mass / 6)) * (q / 6);
            n.inverseInertia = 1 / n.inertia;
            n.mass = q;
            n.inverseMass = 1 / n.mass;
            n.density = n.mass / n.area;
          };
          d.setDensity = function (n, q) {
            d.setMass(n, q * n.area);
            n.density = q;
          };
          d.setInertia = function (n, q) {
            n.inertia = q;
            n.inverseInertia = 1 / n.inertia;
          };
          d.setVertices = function (n, q) {
            n.vertices = q[0].body === n ? q : k.create(q, n);
            n.axes = g.fromVertices(n.vertices);
            n.area = k.area(n.vertices);
            d.setMass(n, n.density * n.area);
            q = k.centre(n.vertices);
            k.translate(n.vertices, q, -1);
            d.setInertia(n, d._inertiaScale * k.inertia(n.vertices, n.mass));
            k.translate(n.vertices, n.position);
            f.update(n.bounds, n.vertices, n.velocity);
          };
          d.setParts = function (n, q, r) {
            var u;
            q = q.slice(0);
            n.parts.length = 0;
            n.parts.push(n);
            n.parent = n;
            for (u = 0; u < q.length; u++) {
              var v = q[u];
              v !== n && ((v.parent = n), n.parts.push(v));
            }
            if (1 !== n.parts.length) {
              if ("undefined" !== typeof r ? r : 1) {
                r = [];
                for (u = 0; u < q.length; u++) r = r.concat(q[u].vertices);
                k.clockwiseSort(r);
                q = k.hull(r);
                u = k.centre(q);
                d.setVertices(n, q);
                k.translate(n.vertices, u);
              }
              q = d._totalProperties(n);
              u = q.centre.x;
              r = q.centre.y;
              v = n.bounds;
              var x = n.centerOfMass,
                y = n.centerOffset;
              f.update(v, n.vertices, n.velocity);
              x.x = -(v.min.x - u) / (v.max.x - v.min.x);
              x.y = -(v.min.y - r) / (v.max.y - v.min.y);
              y.x = u;
              y.y = r;
              n.area = q.area;
              n.parent = n;
              n.position.x = u;
              n.position.y = r;
              n.positionPrev.x = u;
              n.positionPrev.y = r;
              d.setMass(n, q.mass);
              d.setInertia(n, q.inertia);
              d.setPosition(n, q.centre);
            }
          };
          d.setCentre = function (n, q, r) {
            r
              ? ((n.positionPrev.x += q.x),
                (n.positionPrev.y += q.y),
                (n.position.x += q.x),
                (n.position.y += q.y))
              : ((n.positionPrev.x = q.x - (n.position.x - n.positionPrev.x)),
                (n.positionPrev.y = q.y - (n.position.y - n.positionPrev.y)),
                (n.position.x = q.x),
                (n.position.y = q.y));
          };
          d.setPosition = function (n, q) {
            q = e.sub(q, n.position);
            n.positionPrev.x += q.x;
            n.positionPrev.y += q.y;
            for (var r = 0; r < n.parts.length; r++) {
              var u = n.parts[r];
              u.position.x += q.x;
              u.position.y += q.y;
              k.translate(u.vertices, q);
              f.update(u.bounds, u.vertices, n.velocity);
            }
          };
          d.setAngle = function (n, q) {
            q -= n.angle;
            n.anglePrev += q;
            for (var r = 0; r < n.parts.length; r++) {
              var u = n.parts[r];
              u.angle += q;
              k.rotate(u.vertices, q, n.position);
              g.rotate(u.axes, q);
              f.update(u.bounds, u.vertices, n.velocity);
              0 < r && e.rotateAbout(u.position, q, n.position, u.position);
            }
          };
          d.setVelocity = function (n, q) {
            n.positionPrev.x = n.position.x - q.x;
            n.positionPrev.y = n.position.y - q.y;
            n.velocity.x = q.x;
            n.velocity.y = q.y;
            n.speed = e.magnitude(n.velocity);
          };
          d.setAngularVelocity = function (n, q) {
            n.anglePrev = n.angle - q;
            n.angularVelocity = q;
            n.angularSpeed = Math.abs(n.angularVelocity);
          };
          d.translate = function (n, q) {
            d.setPosition(n, e.add(n.position, q));
          };
          d.rotate = function (n, q, r) {
            if (r) {
              var u = Math.cos(q),
                v = Math.sin(q),
                x = n.position.x - r.x,
                y = n.position.y - r.y;
              d.setPosition(n, {
                x: r.x + (x * u - y * v),
                y: r.y + (x * v + y * u),
              });
            }
            d.setAngle(n, n.angle + q);
          };
          d.scale = function (n, q, r, u) {
            var v = 0,
              x = 0;
            u = u || n.position;
            for (var y = 0; y < n.parts.length; y++) {
              var z = n.parts[y];
              z.scale.x = q;
              z.scale.y = r;
              k.scale(z.vertices, q, r, u);
              z.axes = g.fromVertices(z.vertices);
              z.area = k.area(z.vertices);
              d.setMass(z, n.density * z.area);
              k.translate(z.vertices, {
                x: -z.position.x,
                y: -z.position.y,
              });
              d.setInertia(z, d._inertiaScale * k.inertia(z.vertices, z.mass));
              k.translate(z.vertices, {
                x: z.position.x,
                y: z.position.y,
              });
              0 < y && ((v += z.area), (x += z.inertia));
              z.position.x = u.x + (z.position.x - u.x) * q;
              z.position.y = u.y + (z.position.y - u.y) * r;
              f.update(z.bounds, z.vertices, n.velocity);
            }
            1 < n.parts.length &&
              ((n.area = v),
              n.isStatic || (d.setMass(n, n.density * v), d.setInertia(n, x)));
            n.circleRadius &&
              (n.circleRadius = q === r ? n.circleRadius * q : null);
          };
          d.update = function (n, q, r, u) {
            q = Math.pow(q * r * n.timeScale, 2);
            r = 1 - n.frictionAir * r * n.timeScale;
            var v = n.position.y - n.positionPrev.y;
            n.velocity.x =
              (n.position.x - n.positionPrev.x) * r * u +
              (n.force.x / n.mass) * q;
            n.velocity.y = v * r * u + (n.force.y / n.mass) * q;
            n.positionPrev.x = n.position.x;
            n.positionPrev.y = n.position.y;
            n.position.x += n.velocity.x;
            n.position.y += n.velocity.y;
            n.angularVelocity =
              (n.angle - n.anglePrev) * r * u + (n.torque / n.inertia) * q;
            n.anglePrev = n.angle;
            n.angle += n.angularVelocity;
            n.speed = e.magnitude(n.velocity);
            n.angularSpeed = Math.abs(n.angularVelocity);
            for (u = 0; u < n.parts.length; u++)
              (q = n.parts[u]),
                k.translate(q.vertices, n.velocity),
                0 < u &&
                  ((q.position.x += n.velocity.x),
                  (q.position.y += n.velocity.y)),
                0 !== n.angularVelocity &&
                  (k.rotate(q.vertices, n.angularVelocity, n.position),
                  g.rotate(q.axes, n.angularVelocity),
                  0 < u &&
                    e.rotateAbout(
                      q.position,
                      n.angularVelocity,
                      n.position,
                      q.position
                    )),
                f.update(q.bounds, q.vertices, n.velocity);
          };
          d.applyForce = function (n, q, r) {
            n.force.x += r.x;
            n.force.y += r.y;
            n.torque += (q.x - n.position.x) * r.y - (q.y - n.position.y) * r.x;
          };
          d._totalProperties = function (n) {
            for (
              var q = {
                  mass: 0,
                  area: 0,
                  inertia: 0,
                  centre: {
                    x: 0,
                    y: 0,
                  },
                },
                r = 1 === n.parts.length ? 0 : 1;
              r < n.parts.length;
              r++
            ) {
              var u = n.parts[r],
                v = Infinity !== u.mass ? u.mass : 1;
              q.mass += v;
              q.area += u.area;
              q.inertia += u.inertia;
              q.centre = e.add(q.centre, e.mult(u.position, v));
            }
            q.centre = e.div(q.centre, q.mass);
            return q;
          };
        })();
      },
      function (h, t) {
        h.exports = function (a) {
          return a.y + a.height - a.height * a.originY;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a.x - a.width * a.originX;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a.x + a.width - a.width * a.originX;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a.y - a.height * a.originY;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b, c) {
          void 0 === e && (e = 0);
          void 0 === b && (b = 0);
          void 0 === c && (c = 1);
          var f = 0,
            g = a.length;
          if (1 === c) for (; b < g; b++) (a[b][d] += k + f * e), f++;
          else for (; 0 <= b; b--) (a[b][d] += k + f * e), f++;
          return a;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(307),
          k = a(172),
          e = a(56),
          b = a(173),
          c = a(3);
        a = new t({
          initialize: function (f, g, m, n) {
            void 0 === f && (f = 0);
            void 0 === g && (g = 0);
            void 0 === m && (m = 0);
            void 0 === n && (n = 0);
            this.type = e.LINE;
            this.x1 = f;
            this.y1 = g;
            this.x2 = m;
            this.y2 = n;
          },
          getPoint: function (f, g) {
            return d(this, f, g);
          },
          getPoints: function (f, g, m) {
            return k(this, f, g, m);
          },
          getRandomPoint: function (f) {
            return b(this, f);
          },
          setTo: function (f, g, m, n) {
            void 0 === f && (f = 0);
            void 0 === g && (g = 0);
            void 0 === m && (m = 0);
            void 0 === n && (n = 0);
            this.x1 = f;
            this.y1 = g;
            this.x2 = m;
            this.y2 = n;
            return this;
          },
          getPointA: function (f) {
            void 0 === f && (f = new c());
            f.set(this.x1, this.y1);
            return f;
          },
          getPointB: function (f) {
            void 0 === f && (f = new c());
            f.set(this.x2, this.y2);
            return f;
          },
          left: {
            get: function () {
              return Math.min(this.x1, this.x2);
            },
            set: function (f) {
              this.x1 <= this.x2 ? (this.x1 = f) : (this.x2 = f);
            },
          },
          right: {
            get: function () {
              return Math.max(this.x1, this.x2);
            },
            set: function (f) {
              this.x1 > this.x2 ? (this.x1 = f) : (this.x2 = f);
            },
          },
          top: {
            get: function () {
              return Math.min(this.y1, this.y2);
            },
            set: function (f) {
              this.y1 <= this.y2 ? (this.y1 = f) : (this.y2 = f);
            },
          },
          bottom: {
            get: function () {
              return Math.max(this.y1, this.y2);
            },
            set: function (f) {
              this.y1 > this.y2 ? (this.y1 = f) : (this.y2 = f);
            },
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          k = k ? k : d.fillColor;
          a.fillStyle =
            "rgba(" +
            ((k & 16711680) >>> 16) +
            "," +
            ((k & 65280) >>> 8) +
            "," +
            (k & 255) +
            "," +
            (e ? e : d.fillAlpha) +
            ")";
        };
      },
      function (h, t, a) {
        t = new (a(0))({
          initialize: function (d, k, e, b) {
            var c = [];
            b.forEach(function (f) {
              f && c.push(f);
            });
            this.loader = d;
            this.type = k;
            this.key = e;
            this.multiKeyIndex = d.multiKeyIndex++;
            this.files = c;
            this.complete = !1;
            this.pending = c.length;
            this.failed = 0;
            this.config = {};
            this.baseURL = d.baseURL;
            this.path = d.path;
            this.prefix = d.prefix;
            for (d = 0; d < c.length; d++) c[d].multiFile = this;
          },
          isReadyToProcess: function () {
            return 0 === this.pending && 0 === this.failed && !this.complete;
          },
          addToMultiFile: function (d) {
            this.files.push(d);
            d.multiFile = this;
            this.pending++;
            this.complete = !1;
            return this;
          },
          onFileComplete: function (d) {
            -1 !== this.files.indexOf(d) && this.pending--;
          },
          onFileFailed: function (d) {
            -1 !== this.files.indexOf(d) && this.failed++;
          },
        });
        h.exports = t;
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          a -= k;
          d -= e;
          return Math.sqrt(a * a + d * d);
        };
      },
      function (h, t, a) {
        h.exports = {
          BOOT: a(922),
          DESTROY: a(923),
          DRAG_END: a(924),
          DRAG_ENTER: a(925),
          DRAG: a(926),
          DRAG_LEAVE: a(927),
          DRAG_OVER: a(928),
          DRAG_START: a(929),
          DROP: a(930),
          GAME_OUT: a(931),
          GAME_OVER: a(932),
          GAMEOBJECT_DOWN: a(933),
          GAMEOBJECT_DRAG_END: a(934),
          GAMEOBJECT_DRAG_ENTER: a(935),
          GAMEOBJECT_DRAG: a(936),
          GAMEOBJECT_DRAG_LEAVE: a(937),
          GAMEOBJECT_DRAG_OVER: a(938),
          GAMEOBJECT_DRAG_START: a(939),
          GAMEOBJECT_DROP: a(940),
          GAMEOBJECT_MOVE: a(941),
          GAMEOBJECT_OUT: a(942),
          GAMEOBJECT_OVER: a(943),
          GAMEOBJECT_POINTER_DOWN: a(944),
          GAMEOBJECT_POINTER_MOVE: a(945),
          GAMEOBJECT_POINTER_OUT: a(946),
          GAMEOBJECT_POINTER_OVER: a(947),
          GAMEOBJECT_POINTER_UP: a(948),
          GAMEOBJECT_POINTER_WHEEL: a(949),
          GAMEOBJECT_UP: a(950),
          GAMEOBJECT_WHEEL: a(951),
          MANAGER_BOOT: a(952),
          MANAGER_PROCESS: a(953),
          MANAGER_UPDATE: a(954),
          POINTER_DOWN: a(955),
          POINTER_DOWN_OUTSIDE: a(956),
          POINTER_MOVE: a(957),
          POINTER_OUT: a(958),
          POINTER_OVER: a(959),
          POINTER_UP: a(960),
          POINTER_UP_OUTSIDE: a(961),
          POINTER_WHEEL: a(962),
          POINTERLOCK_CHANGE: a(963),
          PRE_UPDATE: a(964),
          SHUTDOWN: a(965),
          START: a(966),
          UPDATE: a(967),
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          a.y = d + a.height * a.originY;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          a.x = d + a.width * a.originX;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          a.x = d - a.width + a.width * a.originX;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          a.y = d - a.height + a.height * a.originY;
          return a;
        };
      },
      function (h, t) {
        h.exports = {
          CIRCLE: 0,
          ELLIPSE: 1,
          LINE: 2,
          POINT: 3,
          POLYGON: 4,
          RECTANGLE: 5,
          TRIANGLE: 6,
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          return 0 >= a.width || 0 >= a.height
            ? !1
            : a.x <= d && a.x + a.width >= d && a.y <= k && a.y + a.height >= k;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(175),
          k = a(9),
          e = a(374),
          b = a(2),
          c = a(69),
          f = a(91),
          g = a(141),
          m = a(12),
          n = a(375);
        a = new t({
          Extends: k,
          initialize: function (q) {
            k.call(this);
            var r = q.game,
              u = r.renderer,
              v = u.gl;
            this.name = b(q, "name", "WebGLPipeline");
            this.game = r;
            this.renderer = u;
            this.manager;
            this.gl = v;
            this.view = r.canvas;
            this.vertexCapacity =
              this.vertexCount =
              this.height =
              this.width =
                0;
            this.vertexData;
            this.vertexBuffer;
            this.topology = b(q, "topology", v.TRIANGLES);
            this.bytes;
            this.vertexViewF32;
            this.vertexViewU32;
            this.active = !0;
            this.currentUnit = 0;
            this.forceZero = b(q, "forceZero", !1);
            this.isPostFX = this.hasBooted = !1;
            this.renderTargets = [];
            this.currentRenderTarget;
            this.shaders = [];
            this.currentShader;
            this.projectionMatrix;
            this.projectionHeight = this.projectionWidth = 0;
            this.config = q;
            this.glReset = !1;
          },
          boot: function () {
            var q,
              r = this.gl,
              u = this.config,
              v = this.renderer;
            this.isPostFX || (this.projectionMatrix = new c().identity());
            var x = this.renderTargets,
              y = b(u, "renderTarget", !1);
            "boolean" === typeof y && y && (y = 1);
            var z = v.width,
              A = v.height;
            if ("number" === typeof y)
              for (q = 0; q < y; q++) x.push(new g(v, z, A, 1, 0, !0));
            else if (Array.isArray(y))
              for (q = 0; q < y.length; q++) {
                var B = b(y[q], "scale", 1),
                  D = b(y[q], "minFilter", 0),
                  E = b(y[q], "autoClear", 1);
                x.push(new g(v, z, A, B, D, E));
              }
            x.length && (this.currentRenderTarget = x[0]);
            this.setShadersFromConfig(u);
            x = this.shaders;
            for (q = y = 0; q < x.length; q++)
              x[q].vertexSize > y && (y = x[q].vertexSize);
            this.vertexCapacity = 6 * b(u, "batchSize", v.config.batchSize);
            this.vertexData = q = new ArrayBuffer(this.vertexCapacity * y);
            this.bytes = new Uint8Array(q);
            this.vertexViewF32 = new Float32Array(q);
            this.vertexViewU32 = new Uint32Array(q);
            (u = b(u, "vertices", null))
              ? (this.vertexViewF32.set(u),
                (this.vertexBuffer = v.createVertexBuffer(q, r.STATIC_DRAW)))
              : (this.vertexBuffer = v.createVertexBuffer(
                  q.byteLength,
                  r.DYNAMIC_DRAW
                ));
            this.setVertexBuffer();
            for (q = x.length - 1; 0 <= q; q--) x[q].rebind();
            this.hasBooted = !0;
            v.on(f.RESIZE, this.resize, this);
            v.on(f.PRE_RENDER, this.onPreRender, this);
            v.on(f.RENDER, this.onRender, this);
            v.on(f.POST_RENDER, this.onPostRender, this);
            this.emit(e.BOOT, this);
            this.onBoot();
          },
          onBoot: function () {},
          onResize: function () {},
          setShader: function (q, r) {
            var u = this.renderer;
            if (
              q !== this.currentShader ||
              u.currentProgram !== this.currentShader.program
            )
              this.flush(),
                u.resetTextures(),
                this.setVertexBuffer() && !r && (r = !0),
                q.bind(r, !1),
                (this.currentShader = q);
            return this;
          },
          getShaderByName: function (q) {
            for (var r = this.shaders, u = 0; u < r.length; u++)
              if (r[u].name === q) return r[u];
          },
          setShadersFromConfig: function (q) {
            var r,
              u = this.shaders,
              v = this.renderer;
            for (r = 0; r < u.length; r++) u[r].destroy();
            u = b(q, "vertShader", null);
            var x = m.parseFragmentShaderMaxTextures(
                b(q, "fragShader", null),
                v.maxTextures
              ),
              y = b(q, "attributes", null);
            q = b(q, "shaders", []);
            var z = q.length;
            if (0 === z)
              u && x && (this.shaders = [new n(this, "default", u, x, d(y))]);
            else {
              var A = [];
              for (r = 0; r < z; r++) {
                var B = q[r],
                  D = b(B, "name", "default"),
                  E = b(B, "vertShader", u),
                  C = m.parseFragmentShaderMaxTextures(
                    b(B, "fragShader", x),
                    v.maxTextures
                  );
                B = b(B, "attributes", y);
                E && C && A.push(new n(this, D, E, C, d(B)));
              }
              this.shaders = A;
            }
            0 === this.shaders.length
              ? console.warn(
                  "Pipeline: " + this.name + " - Invalid shader config"
                )
              : (this.currentShader = this.shaders[0]);
            return this;
          },
          setGameObject: function (q, r) {
            void 0 === r && (r = q.frame);
            return (this.currentUnit = this.renderer.setTextureSource(
              r.source
            ));
          },
          shouldFlush: function (q) {
            void 0 === q && (q = 0);
            return this.vertexCount + q > this.vertexCapacity;
          },
          resize: function (q, r) {
            (q === this.width && r === this.height) || this.flush();
            this.width = q;
            this.height = r;
            for (var u = this.renderTargets, v = 0; v < u.length; v++)
              u[v].resize(q, r);
            this.setProjectionMatrix(q, r);
            this.emit(e.RESIZE, q, r, this);
            this.onResize(q, r);
            return this;
          },
          setProjectionMatrix: function (q, r) {
            var u = this.projectionMatrix;
            if (!u) return this;
            this.projectionWidth = q;
            this.projectionHeight = r;
            u.ortho(0, q, r, 0, -1e3, 1e3);
            q = this.shaders;
            for (r = 0; r < q.length; r++) {
              var v = q[r];
              v.hasUniform("uProjectionMatrix") &&
                (v.resetUniform("uProjectionMatrix"),
                v.setMatrix4fv("uProjectionMatrix", !1, u.val, v));
            }
            return this;
          },
          updateProjectionMatrix: function () {
            if (this.projectionMatrix) {
              var q = this.renderer.projectionWidth,
                r = this.renderer.projectionHeight;
              (this.projectionWidth === q && this.projectionHeight === r) ||
                this.setProjectionMatrix(q, r);
            }
          },
          bind: function (q) {
            void 0 === q && (q = this.currentShader);
            if (this.glReset) return this.rebind(q);
            var r = this.setVertexBuffer();
            q.bind(r);
            this.currentShader = q;
            this.emit(e.BIND, this, q);
            this.onActive(q);
            return this;
          },
          rebind: function (q) {
            this.setVertexBuffer();
            for (var r = this.shaders, u = r.length - 1; 0 <= u; u--) {
              var v = r[u].rebind();
              (q && v !== q) || (this.currentShader = v);
            }
            this.emit(e.REBIND, this.currentShader);
            this.onActive(this.currentShader);
            this.onRebind();
            this.glReset = !1;
            return this;
          },
          setVertexBuffer: function () {
            var q = this.gl,
              r = this.vertexBuffer;
            return q.getParameter(q.ARRAY_BUFFER_BINDING) !== r
              ? (q.bindBuffer(q.ARRAY_BUFFER, r), !0)
              : !1;
          },
          preBatch: function (q) {
            this.currentRenderTarget && this.currentRenderTarget.bind();
            this.onPreBatch(q);
            return this;
          },
          postBatch: function (q) {
            this.onDraw(this.currentRenderTarget);
            this.onPostBatch(q);
            return this;
          },
          onDraw: function () {},
          unbind: function () {
            this.currentRenderTarget && this.currentRenderTarget.unbind();
          },
          flush: function (q) {
            void 0 === q && (q = !1);
            if (0 < this.vertexCount) {
              this.emit(e.BEFORE_FLUSH, this, q);
              this.onBeforeFlush(q);
              var r = this.gl,
                u = this.vertexCount,
                v = this.currentShader.vertexSize;
              this.active &&
                (this.setVertexBuffer(),
                u === this.vertexCapacity
                  ? r.bufferData(
                      r.ARRAY_BUFFER,
                      this.vertexData,
                      r.DYNAMIC_DRAW
                    )
                  : r.bufferSubData(
                      r.ARRAY_BUFFER,
                      0,
                      this.bytes.subarray(0, u * v)
                    ),
                r.drawArrays(this.topology, 0, u));
              this.vertexCount = 0;
              this.emit(e.AFTER_FLUSH, this, q);
              this.onAfterFlush(q);
            }
            return this;
          },
          onActive: function () {},
          onBind: function () {},
          onRebind: function () {},
          onBatch: function () {},
          onPreBatch: function () {},
          onPostBatch: function () {},
          onPreRender: function () {},
          onRender: function () {},
          onPostRender: function () {},
          onBeforeFlush: function () {},
          onAfterFlush: function () {},
          batchVert: function (q, r, u, v, x, y, z) {
            var A = this.vertexViewF32,
              B = this.vertexViewU32,
              D =
                this.vertexCount * this.currentShader.vertexComponentCount - 1;
            A[++D] = q;
            A[++D] = r;
            A[++D] = u;
            A[++D] = v;
            A[++D] = x;
            A[++D] = y;
            B[++D] = z;
            this.vertexCount++;
          },
          batchQuad: function (
            q,
            r,
            u,
            v,
            x,
            y,
            z,
            A,
            B,
            D,
            E,
            C,
            F,
            G,
            H,
            K,
            I,
            M,
            N,
            P
          ) {
            void 0 === P && (P = this.currentUnit);
            var J = !1;
            this.shouldFlush(6) &&
              (this.flush(), (J = !0), (P = this.setTexture2D(N)));
            this.batchVert(r, u, D, E, P, M, G);
            this.batchVert(v, x, D, F, P, M, K);
            this.batchVert(y, z, C, F, P, M, I);
            this.batchVert(r, u, D, E, P, M, G);
            this.batchVert(y, z, C, F, P, M, I);
            this.batchVert(A, B, C, E, P, M, H);
            this.onBatch(q);
            return J;
          },
          batchTri: function (
            q,
            r,
            u,
            v,
            x,
            y,
            z,
            A,
            B,
            D,
            E,
            C,
            F,
            G,
            H,
            K,
            I
          ) {
            void 0 === I && (I = this.currentUnit);
            var M = !1;
            this.shouldFlush(3) &&
              (this.flush(), (M = !0), (I = this.setTexture2D(K)));
            this.batchVert(r, u, A, B, I, H, C);
            this.batchVert(v, x, A, E, I, H, F);
            this.batchVert(y, z, D, E, I, H, G);
            this.onBatch(q);
            return M;
          },
          drawFillRect: function (q, r, u, v, x, y, z, A) {
            void 0 === z && (z = this.renderer.whiteTexture.glTexture);
            void 0 === A && (A = !0);
            q = Math.floor(q);
            r = Math.floor(r);
            u = Math.floor(q + u);
            v = Math.floor(r + v);
            var B = this.setTexture2D(z);
            x = m.getTintAppendFloatAlphaAndSwap(x, y);
            y = 0;
            var D = 1;
            A && ((y = 1), (D = 0));
            this.batchQuad(
              null,
              q,
              r,
              q,
              v,
              u,
              v,
              u,
              r,
              0,
              y,
              1,
              D,
              x,
              x,
              x,
              x,
              0,
              z,
              B
            );
          },
          setTexture2D: function (q) {
            void 0 === q && (q = this.renderer.whiteTexture.glTexture);
            return (this.currentUnit = this.renderer.setTexture2D(q));
          },
          bindTexture: function (q, r) {
            void 0 === r && (r = 0);
            var u = this.gl;
            u.activeTexture(u.TEXTURE0 + r);
            u.bindTexture(u.TEXTURE_2D, q);
            return this;
          },
          bindRenderTarget: function (q, r) {
            return this.bindTexture(q.texture, r);
          },
          setTime: function (q) {
            this.set1f(q, this.game.loop.getDuration());
            return this;
          },
          set1f: function (q, r, u) {
            void 0 === u && (u = this.currentShader);
            u.set1f(q, r);
            return this;
          },
          set2f: function (q, r, u, v) {
            void 0 === v && (v = this.currentShader);
            v.set2f(q, r, u);
            return this;
          },
          set3f: function (q, r, u, v, x) {
            void 0 === x && (x = this.currentShader);
            x.set3f(q, r, u, v);
            return this;
          },
          set4f: function (q, r, u, v, x, y) {
            void 0 === y && (y = this.currentShader);
            y.set4f(q, r, u, v, x);
            return this;
          },
          set1fv: function (q, r, u) {
            void 0 === u && (u = this.currentShader);
            u.set1fv(q, r);
            return this;
          },
          set2fv: function (q, r, u) {
            void 0 === u && (u = this.currentShader);
            u.set2fv(q, r);
            return this;
          },
          set3fv: function (q, r, u) {
            void 0 === u && (u = this.currentShader);
            u.set3fv(q, r);
            return this;
          },
          set4fv: function (q, r, u) {
            void 0 === u && (u = this.currentShader);
            u.set4fv(q, r);
            return this;
          },
          set1iv: function (q, r, u) {
            void 0 === u && (u = this.currentShader);
            u.set1iv(q, r);
            return this;
          },
          set2iv: function (q, r, u) {
            void 0 === u && (u = this.currentShader);
            u.set2iv(q, r);
            return this;
          },
          set3iv: function (q, r, u) {
            void 0 === u && (u = this.currentShader);
            u.set3iv(q, r);
            return this;
          },
          set4iv: function (q, r, u) {
            void 0 === u && (u = this.currentShader);
            u.set4iv(q, r);
            return this;
          },
          set1i: function (q, r, u) {
            void 0 === u && (u = this.currentShader);
            u.set1i(q, r);
            return this;
          },
          set2i: function (q, r, u, v) {
            void 0 === v && (v = this.currentShader);
            v.set2i(q, r, u);
            return this;
          },
          set3i: function (q, r, u, v, x) {
            void 0 === x && (x = this.currentShader);
            x.set3i(q, r, u, v);
            return this;
          },
          set4i: function (q, r, u, v, x, y) {
            void 0 === y && (y = this.currentShader);
            y.set4i(q, r, u, v, x);
            return this;
          },
          setMatrix2fv: function (q, r, u, v) {
            void 0 === v && (v = this.currentShader);
            v.setMatrix2fv(q, r, u);
            return this;
          },
          setMatrix3fv: function (q, r, u, v) {
            void 0 === v && (v = this.currentShader);
            v.setMatrix3fv(q, r, u);
            return this;
          },
          setMatrix4fv: function (q, r, u, v) {
            void 0 === v && (v = this.currentShader);
            v.setMatrix4fv(q, r, u);
            return this;
          },
          destroy: function () {
            this.emit(e.DESTROY, this);
            var q,
              r = this.shaders;
            for (q = 0; q < r.length; q++) r[q].destroy();
            r = this.renderTargets;
            for (q = 0; q < r.length; q++) r[q].destroy();
            this.gl.deleteBuffer(this.vertexBuffer);
            q = this.renderer;
            q.off(f.RESIZE, this.resize, this);
            q.off(f.PRE_RENDER, this.onPreRender, this);
            q.off(f.RENDER, this.onRender, this);
            q.off(f.POST_RENDER, this.onPostRender, this);
            this.removeAllListeners();
            this.currentRenderTarget =
              this.currentShader =
              this.vertexBuffer =
              this.vertexData =
              this.vertexViewU32 =
              this.vertexViewF32 =
              this.bytes =
              this.renderTargets =
              this.shaders =
              this.view =
              this.gl =
              this.manager =
              this.renderer =
              this.game =
                null;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        function d(C, F, G) {
          G = G || 2;
          var H = F && F.length,
            K = H ? F[0] * G : C.length,
            I = k(C, 0, K, G, !0),
            M = [];
          if (!I || I.next === I.prev) return M;
          var N;
          if (H) {
            var P = G;
            H = [];
            var J;
            var L = 0;
            for (J = F.length; L < J; L++) {
              var O = F[L] * P;
              var Q = L < J - 1 ? F[L + 1] * P : C.length;
              O = k(C, O, Q, P, !1);
              O === O.next && (O.steiner = !0);
              Q = H;
              var S = Q.push,
                R = O,
                T = O;
              do {
                if (R.x < T.x || (R.x === T.x && R.y < T.y)) T = R;
                R = R.next;
              } while (R !== O);
              S.call(Q, T);
            }
            H.sort(f);
            for (L = 0; L < H.length; L++) {
              P = H[L];
              F = I;
              if ((F = g(P, F))) (P = z(F, P)), e(F, F.next), e(P, P.next);
              I = e(I, I.next);
            }
          }
          if (C.length > 80 * G) {
            var U = (N = C[0]);
            var V = (H = C[1]);
            for (P = G; P < K; P += G)
              (L = C[P]),
                (F = C[P + 1]),
                L < U && (U = L),
                F < V && (V = F),
                L > N && (N = L),
                F > H && (H = F);
            N = Math.max(N - U, H - V);
            N = 0 !== N ? 1 / N : 0;
          }
          b(I, M, G, U, V, N);
          return M;
        }

        function k(C, F, G, H, K) {
          if (K === 0 < E(C, F, G, H))
            for (K = F; K < G; K += H) var I = A(K, C[K], C[K + 1], I);
          else for (K = G - H; K >= F; K -= H) I = A(K, C[K], C[K + 1], I);
          I && r(I, I.next) && (B(I), (I = I.next));
          return I;
        }

        function e(C, F) {
          if (!C) return C;
          F || (F = C);
          do {
            var G = !1;
            if (C.steiner || (!r(C, C.next) && 0 !== q(C.prev, C, C.next)))
              C = C.next;
            else {
              B(C);
              C = F = C.prev;
              if (C === C.next) break;
              G = !0;
            }
          } while (G || C !== F);
          return F;
        }

        function b(C, F, G, H, K, I, M) {
          if (C) {
            if (!M && I) {
              var N = C,
                P = N;
              do
                null === P.z && (P.z = m(P.x, P.y, H, K, I)),
                  (P.prevZ = P.prev),
                  (P = P.nextZ = P.next);
              while (P !== N);
              P.prevZ.nextZ = null;
              P.prevZ = null;
              N = P;
              var J,
                L,
                O,
                Q,
                S = 1;
              do {
                P = N;
                var R = (N = null);
                for (L = 0; P; ) {
                  L++;
                  var T = P;
                  for (J = O = 0; J < S && (O++, (T = T.nextZ), T); J++);
                  for (Q = S; 0 < O || (0 < Q && T); )
                    0 !== O && (0 === Q || !T || P.z <= T.z)
                      ? ((J = P), (P = P.nextZ), O--)
                      : ((J = T), (T = T.nextZ), Q--),
                      R ? (R.nextZ = J) : (N = J),
                      (J.prevZ = R),
                      (R = J);
                  P = T;
                }
                R.nextZ = null;
                S *= 2;
              } while (1 < L);
            }
            for (N = C; C.prev !== C.next; ) {
              P = C.prev;
              T = C.next;
              if (I) R = c(C, H, K, I);
              else
                a: if (
                  ((R = C),
                  (L = R.prev),
                  (O = R),
                  (S = R.next),
                  0 <= q(L, O, S))
                )
                  R = !1;
                else {
                  for (J = R.next.next; J !== R.prev; ) {
                    if (
                      n(L.x, L.y, O.x, O.y, S.x, S.y, J.x, J.y) &&
                      0 <= q(J.prev, J, J.next)
                    ) {
                      R = !1;
                      break a;
                    }
                    J = J.next;
                  }
                  R = !0;
                }
              if (R)
                F.push(P.i / G),
                  F.push(C.i / G),
                  F.push(T.i / G),
                  B(C),
                  (N = C = T.next);
              else if (((C = T), C === N)) {
                if (!M) b(e(C), F, G, H, K, I, 1);
                else if (1 === M) {
                  C = e(C);
                  M = F;
                  N = G;
                  P = C;
                  do
                    (T = P.prev),
                      (R = P.next.next),
                      !r(T, R) &&
                        u(T, P, P.next, R) &&
                        y(T, R) &&
                        y(R, T) &&
                        (M.push(T.i / N),
                        M.push(P.i / N),
                        M.push(R.i / N),
                        B(P),
                        B(P.next),
                        (P = C = R)),
                      (P = P.next);
                  while (P !== C);
                  C = e(P);
                  b(C, F, G, H, K, I, 2);
                } else if (2 === M)
                  a: {
                    M = C;
                    do {
                      for (N = M.next.next; N !== M.prev; ) {
                        if ((P = M.i !== N.i)) {
                          P = M;
                          T = N;
                          if ((R = P.next.i !== T.i && P.prev.i !== T.i)) {
                            b: {
                              R = P;
                              do {
                                if (
                                  R.i !== P.i &&
                                  R.next.i !== P.i &&
                                  R.i !== T.i &&
                                  R.next.i !== T.i &&
                                  u(R, R.next, P, T)
                                ) {
                                  R = !0;
                                  break b;
                                }
                                R = R.next;
                              } while (R !== P);
                              R = !1;
                            }
                            R = !R;
                          }
                          if (R) {
                            if ((R = y(P, T) && y(T, P))) {
                              R = P;
                              L = !1;
                              O = (P.x + T.x) / 2;
                              S = (P.y + T.y) / 2;
                              do
                                R.y > S !== R.next.y > S &&
                                  R.next.y !== R.y &&
                                  O <
                                    ((R.next.x - R.x) * (S - R.y)) /
                                      (R.next.y - R.y) +
                                      R.x &&
                                  (L = !L),
                                  (R = R.next);
                              while (R !== P);
                              R = L;
                            }
                            R =
                              (R &&
                                (q(P.prev, P, T.prev) || q(P, T.prev, T))) ||
                              (r(P, T) &&
                                0 < q(P.prev, P, P.next) &&
                                0 < q(T.prev, T, T.next));
                          }
                          P = R;
                        }
                        if (P) {
                          C = z(M, N);
                          M = e(M, M.next);
                          C = e(C, C.next);
                          b(M, F, G, H, K, I);
                          b(C, F, G, H, K, I);
                          break a;
                        }
                        N = N.next;
                      }
                      M = M.next;
                    } while (M !== C);
                  }
                break;
              }
            }
          }
        }

        function c(C, F, G, H) {
          var K = C.prev,
            I = C.next;
          if (0 <= q(K, C, I)) return !1;
          var M = K.x > C.x ? (K.x > I.x ? K.x : I.x) : C.x > I.x ? C.x : I.x,
            N = K.y > C.y ? (K.y > I.y ? K.y : I.y) : C.y > I.y ? C.y : I.y,
            P = m(
              K.x < C.x ? (K.x < I.x ? K.x : I.x) : C.x < I.x ? C.x : I.x,
              K.y < C.y ? (K.y < I.y ? K.y : I.y) : C.y < I.y ? C.y : I.y,
              F,
              G,
              H
            );
          F = m(M, N, F, G, H);
          G = C.prevZ;
          for (H = C.nextZ; G && G.z >= P && H && H.z <= F; ) {
            if (
              G !== C.prev &&
              G !== C.next &&
              n(K.x, K.y, C.x, C.y, I.x, I.y, G.x, G.y) &&
              0 <= q(G.prev, G, G.next)
            )
              return !1;
            G = G.prevZ;
            if (
              H !== C.prev &&
              H !== C.next &&
              n(K.x, K.y, C.x, C.y, I.x, I.y, H.x, H.y) &&
              0 <= q(H.prev, H, H.next)
            )
              return !1;
            H = H.nextZ;
          }
          for (; G && G.z >= P; ) {
            if (
              G !== C.prev &&
              G !== C.next &&
              n(K.x, K.y, C.x, C.y, I.x, I.y, G.x, G.y) &&
              0 <= q(G.prev, G, G.next)
            )
              return !1;
            G = G.prevZ;
          }
          for (; H && H.z <= F; ) {
            if (
              H !== C.prev &&
              H !== C.next &&
              n(K.x, K.y, C.x, C.y, I.x, I.y, H.x, H.y) &&
              0 <= q(H.prev, H, H.next)
            )
              return !1;
            H = H.nextZ;
          }
          return !0;
        }

        function f(C, F) {
          return C.x - F.x;
        }

        function g(C, F) {
          var G = F,
            H = C.x,
            K = C.y,
            I = -Infinity;
          do {
            if (K <= G.y && K >= G.next.y && G.next.y !== G.y) {
              var M = G.x + ((K - G.y) * (G.next.x - G.x)) / (G.next.y - G.y);
              if (M <= H && M > I) {
                I = M;
                if (M === H) {
                  if (K === G.y) return G;
                  if (K === G.next.y) return G.next;
                }
                var N = G.x < G.next.x ? G : G.next;
              }
            }
            G = G.next;
          } while (G !== F);
          if (!N) return null;
          if (H === I) return N;
          F = N;
          M = N.x;
          var P = N.y,
            J = Infinity;
          G = N;
          do {
            if (
              H >= G.x &&
              G.x >= M &&
              H !== G.x &&
              n(K < P ? H : I, K, M, P, K < P ? I : H, K, G.x, G.y)
            ) {
              var L = Math.abs(K - G.y) / (H - G.x);
              var O;
              if (
                (O = y(G, C)) &&
                !(O = L < J) &&
                (O = L === J) &&
                !(O = G.x > N.x) &&
                (O = G.x === N.x)
              ) {
                O = N;
                var Q = G;
                O = 0 > q(O.prev, O, Q.prev) && 0 > q(Q.next, O, O.next);
              }
              O && ((N = G), (J = L));
            }
            G = G.next;
          } while (G !== F);
          return N;
        }

        function m(C, F, G, H, K) {
          C = 32767 * (C - G) * K;
          F = 32767 * (F - H) * K;
          C = (C | (C << 8)) & 16711935;
          C = (C | (C << 4)) & 252645135;
          C = (C | (C << 2)) & 858993459;
          F = (F | (F << 8)) & 16711935;
          F = (F | (F << 4)) & 252645135;
          F = (F | (F << 2)) & 858993459;
          return (
            ((C | (C << 1)) & 1431655765) | (((F | (F << 1)) & 1431655765) << 1)
          );
        }

        function n(C, F, G, H, K, I, M, N) {
          return (
            0 <= (K - M) * (F - N) - (C - M) * (I - N) &&
            0 <= (C - M) * (H - N) - (G - M) * (F - N) &&
            0 <= (G - M) * (I - N) - (K - M) * (H - N)
          );
        }

        function q(C, F, G) {
          return (F.y - C.y) * (G.x - F.x) - (F.x - C.x) * (G.y - F.y);
        }

        function r(C, F) {
          return C.x === F.x && C.y === F.y;
        }

        function u(C, F, G, H) {
          var K = x(q(C, F, G)),
            I = x(q(C, F, H)),
            M = x(q(G, H, C)),
            N = x(q(G, H, F));
          return (K !== I && M !== N) ||
            (0 === K && v(C, G, F)) ||
            (0 === I && v(C, H, F)) ||
            (0 === M && v(G, C, H)) ||
            (0 === N && v(G, F, H))
            ? !0
            : !1;
        }

        function v(C, F, G) {
          return (
            F.x <= Math.max(C.x, G.x) &&
            F.x >= Math.min(C.x, G.x) &&
            F.y <= Math.max(C.y, G.y) &&
            F.y >= Math.min(C.y, G.y)
          );
        }

        function x(C) {
          return 0 < C ? 1 : 0 > C ? -1 : 0;
        }

        function y(C, F) {
          return 0 > q(C.prev, C, C.next)
            ? 0 <= q(C, F, C.next) && 0 <= q(C, C.prev, F)
            : 0 > q(C, F, C.prev) || 0 > q(C, C.next, F);
        }

        function z(C, F) {
          var G = new D(C.i, C.x, C.y),
            H = new D(F.i, F.x, F.y),
            K = C.next,
            I = F.prev;
          C.next = F;
          F.prev = C;
          G.next = K;
          K.prev = G;
          H.next = G;
          G.prev = H;
          I.next = H;
          H.prev = I;
          return H;
        }

        function A(C, F, G, H) {
          C = new D(C, F, G);
          H
            ? ((C.next = H.next), (C.prev = H), (H.next.prev = C), (H.next = C))
            : ((C.prev = C), (C.next = C));
          return C;
        }

        function B(C) {
          C.next.prev = C.prev;
          C.prev.next = C.next;
          C.prevZ && (C.prevZ.nextZ = C.nextZ);
          C.nextZ && (C.nextZ.prevZ = C.prevZ);
        }

        function D(C, F, G) {
          this.i = C;
          this.x = F;
          this.y = G;
          this.nextZ = this.prevZ = this.z = this.next = this.prev = null;
          this.steiner = !1;
        }

        function E(C, F, G, H) {
          for (var K = 0, I = G - H; F < G; F += H)
            (K += (C[I] - C[F]) * (C[F + 1] + C[I + 1])), (I = F);
          return K;
        }
        d.deviation = function (C, F, G, H) {
          var K = F && F.length,
            I = Math.abs(E(C, 0, K ? F[0] * G : C.length, G));
          if (K) {
            K = 0;
            for (var M = F.length; K < M; K++)
              I -= Math.abs(
                E(C, F[K] * G, K < M - 1 ? F[K + 1] * G : C.length, G)
              );
          }
          for (K = F = 0; K < H.length; K += 3) {
            M = H[K] * G;
            var N = H[K + 1] * G,
              P = H[K + 2] * G;
            F += Math.abs(
              (C[M] - C[P]) * (C[N + 1] - C[M + 1]) -
                (C[M] - C[N]) * (C[P + 1] - C[M + 1])
            );
          }
          return 0 === I && 0 === F ? 0 : Math.abs((F - I) / I);
        };
        d.flatten = function (C) {
          for (
            var F = C[0][0].length,
              G = {
                vertices: [],
                holes: [],
                dimensions: F,
              },
              H = 0,
              K = 0;
            K < C.length;
            K++
          ) {
            for (var I = 0; I < C[K].length; I++)
              for (var M = 0; M < F; M++) G.vertices.push(C[K][I][M]);
            0 < K && ((H += C[K - 1].length), G.holes.push(H));
          }
          return G;
        };
        h.exports = d;
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          k = k ? k : d.strokeColor;
          a.strokeStyle =
            "rgba(" +
            ((k & 16711680) >>> 16) +
            "," +
            ((k & 65280) >>> 8) +
            "," +
            (k & 255) +
            "," +
            (e ? e : d.strokeAlpha) +
            ")";
          a.lineWidth = d.lineWidth;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(6),
          f = a(7),
          g = new t({
            Extends: k,
            initialize: function (m, n, q, r, u) {
              var v = "json";
              if (f(n)) {
                var x = n;
                n = b(x, "key");
                q = b(x, "url");
                r = b(x, "xhrSettings");
                v = b(x, "extension", v);
                u = b(x, "dataKey", u);
              }
              k.call(this, m, {
                type: "json",
                cache: m.cacheManager.json,
                extension: v,
                responseType: "text",
                key: n,
                url: q,
                xhrSettings: r,
                config: u,
              });
              f(q) &&
                ((this.data = u ? c(q, u) : q),
                (this.state = d.FILE_POPULATED));
            },
            onProcess: function () {
              if (this.state !== d.FILE_POPULATED) {
                this.state = d.FILE_PROCESSING;
                try {
                  var m = JSON.parse(this.xhrLoader.responseText);
                } catch (q) {
                  throw (
                    (console.warn("Invalid JSON: " + this.key),
                    this.onProcessError(),
                    q)
                  );
                }
                var n = this.config;
                this.data = "string" === typeof n ? c(m, n, m) : m;
              }
              this.onProcessComplete();
            },
          });
        e.register("json", function (m, n, q, r) {
          if (Array.isArray(m))
            for (n = 0; n < m.length; n++) this.addFile(new g(this, m[n]));
          else this.addFile(new g(this, m, n, r, q));
          return this;
        });
        h.exports = g;
      },
      function (h, t) {
        h.exports = {
          DYNAMIC_BODY: 0,
          STATIC_BODY: 1,
          GROUP: 2,
          TILEMAPLAYER: 3,
          FACING_NONE: 10,
          FACING_UP: 11,
          FACING_DOWN: 12,
          FACING_LEFT: 13,
          FACING_RIGHT: 14,
        };
      },
      function (h, t, a) {
        var d = a(158),
          k = a(26);
        h.exports = function (e, b, c, f, g) {
          for (var m = k(e, b, c, f, null, g), n = 0; n < m.length; n++) {
            var q = m[n];
            q &&
              (q.collides
                ? ((e = d(q.x, q.y - 1, !0, g)),
                  (b = d(q.x, q.y + 1, !0, g)),
                  (c = d(q.x - 1, q.y, !0, g)),
                  (f = d(q.x + 1, q.y, !0, g)),
                  (q.faceTop = e && e.collides ? !1 : !0),
                  (q.faceBottom = b && b.collides ? !1 : !0),
                  (q.faceLeft = c && c.collides ? !1 : !0),
                  (q.faceRight = f && f.collides ? !1 : !0))
                : q.resetFaces());
          }
        };
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(83),
          e = a(32);
        (function () {
          d.create = function (b, c) {
            for (var f = [], g = 0; g < b.length; g++) {
              var m = b[g];
              m = {
                x: m.x,
                y: m.y,
                index: g,
                body: c,
                isInternal: !1,
                contact: null,
                offset: null,
              };
              m.contact = {
                vertex: m,
                normalImpulse: 0,
                tangentImpulse: 0,
              };
              f.push(m);
            }
            return f;
          };
          d.fromPath = function (b, c) {
            var f = [];
            b.replace(/L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/gi, function (g, m, n) {
              f.push({
                x: parseFloat(m),
                y: parseFloat(n),
              });
            });
            return d.create(f, c);
          };
          d.centre = function (b) {
            for (
              var c = d.area(b, !0),
                f = {
                  x: 0,
                  y: 0,
                },
                g,
                m,
                n = 0;
              n < b.length;
              n++
            )
              (m = (n + 1) % b.length),
                (g = k.cross(b[n], b[m])),
                (g = k.mult(k.add(b[n], b[m]), g)),
                (f = k.add(f, g));
            return k.div(f, 6 * c);
          };
          d.mean = function (b) {
            for (
              var c = {
                  x: 0,
                  y: 0,
                },
                f = 0;
              f < b.length;
              f++
            )
              (c.x += b[f].x), (c.y += b[f].y);
            return k.div(c, b.length);
          };
          d.area = function (b, c) {
            for (var f = 0, g = b.length - 1, m = 0; m < b.length; m++)
              (f += (b[g].x - b[m].x) * (b[g].y + b[m].y)), (g = m);
            return c ? f / 2 : Math.abs(f) / 2;
          };
          d.inertia = function (b, c) {
            for (var f = 0, g = 0, m, n, q = 0; q < b.length; q++)
              (n = (q + 1) % b.length),
                (m = Math.abs(k.cross(b[n], b[q]))),
                (f +=
                  m *
                  (k.dot(b[n], b[n]) + k.dot(b[n], b[q]) + k.dot(b[q], b[q]))),
                (g += m);
            return (c / 6) * (f / g);
          };
          d.translate = function (b, c, f) {
            var g;
            if (f)
              for (g = 0; g < b.length; g++)
                (b[g].x += c.x * f), (b[g].y += c.y * f);
            else
              for (g = 0; g < b.length; g++) (b[g].x += c.x), (b[g].y += c.y);
            return b;
          };
          d.rotate = function (b, c, f) {
            if (0 !== c) {
              var g = Math.cos(c);
              c = Math.sin(c);
              for (var m = 0; m < b.length; m++) {
                var n = b[m],
                  q = n.x - f.x,
                  r = n.y - f.y;
                n.x = f.x + (q * g - r * c);
                n.y = f.y + (q * c + r * g);
              }
              return b;
            }
          };
          d.contains = function (b, c) {
            for (var f = 0; f < b.length; f++) {
              var g = b[f],
                m = b[(f + 1) % b.length];
              if (0 < (c.x - g.x) * (m.y - g.y) + (c.y - g.y) * (g.x - m.x))
                return !1;
            }
            return !0;
          };
          d.scale = function (b, c, f, g) {
            if (1 === c && 1 === f) return b;
            g = g || d.centre(b);
            for (var m, n = 0; n < b.length; n++)
              (m = b[n]),
                (m = k.sub(m, g)),
                (b[n].x = g.x + m.x * c),
                (b[n].y = g.y + m.y * f);
            return b;
          };
          d.chamfer = function (b, c, f, g, m) {
            c = "number" === typeof c ? [c] : c || [8];
            f = "undefined" !== typeof f ? f : -1;
            g = g || 2;
            m = m || 14;
            for (var n = [], q = 0; q < b.length; q++) {
              var r = b[0 <= q - 1 ? q - 1 : b.length - 1],
                u = b[q],
                v = b[(q + 1) % b.length],
                x = c[q < c.length ? q : c.length - 1];
              if (0 === x) n.push(u);
              else {
                r = k.normalise({
                  x: u.y - r.y,
                  y: r.x - u.x,
                });
                var y = k.normalise({
                    x: v.y - u.y,
                    y: u.x - v.x,
                  }),
                  z = Math.sqrt(2 * Math.pow(x, 2));
                v = k.mult(e.clone(r), x);
                var A = k.normalise(k.mult(k.add(r, y), 0.5));
                u = k.sub(u, k.mult(A, z));
                z = f;
                -1 === f && (z = 1.75 * Math.pow(x, 0.32));
                z = e.clamp(z, g, m);
                1 === z % 2 && (z += 1);
                x = Math.acos(k.dot(r, y)) / z;
                for (r = 0; r < z; r++) n.push(k.add(k.rotate(v, x * r), u));
              }
            }
            return n;
          };
          d.clockwiseSort = function (b) {
            var c = d.mean(b);
            b.sort(function (f, g) {
              return k.angle(c, f) - k.angle(c, g);
            });
            return b;
          };
          d.isConvex = function (b) {
            var c = 0,
              f = b.length,
              g;
            if (3 > f) return null;
            for (g = 0; g < f; g++) {
              var m = (g + 1) % f;
              var n = (g + 2) % f;
              var q = (b[m].x - b[g].x) * (b[n].y - b[m].y);
              q -= (b[m].y - b[g].y) * (b[n].x - b[m].x);
              0 > q ? (c |= 1) : 0 < q && (c |= 2);
              if (3 === c) return !1;
            }
            return 0 !== c ? !0 : null;
          };
          d.hull = function (b) {
            var c = [],
              f = [],
              g,
              m;
            b = b.slice(0);
            b.sort(function (n, q) {
              var r = n.x - q.x;
              return 0 !== r ? r : n.y - q.y;
            });
            for (m = 0; m < b.length; m += 1) {
              for (
                g = b[m];
                2 <= f.length &&
                0 >= k.cross3(f[f.length - 2], f[f.length - 1], g);

              )
                f.pop();
              f.push(g);
            }
            for (m = b.length - 1; 0 <= m; --m) {
              for (
                g = b[m];
                2 <= c.length &&
                0 >= k.cross3(c[c.length - 2], c[c.length - 1], g);

              )
                c.pop();
              c.push(g);
            }
            c.pop();
            f.pop();
            return c.concat(f);
          };
        })();
      },
      function (h, t, a) {
        t = a(0);
        var d = a(66),
          k = a(300),
          e = a(301),
          b = a(56),
          c = a(170);
        a = new t({
          initialize: function (f, g, m) {
            void 0 === f && (f = 0);
            void 0 === g && (g = 0);
            void 0 === m && (m = 0);
            this.type = b.CIRCLE;
            this.x = f;
            this.y = g;
            this._radius = m;
            this._diameter = 2 * m;
          },
          contains: function (f, g) {
            return d(this, f, g);
          },
          getPoint: function (f, g) {
            return k(this, f, g);
          },
          getPoints: function (f, g, m) {
            return e(this, f, g, m);
          },
          getRandomPoint: function (f) {
            return c(this, f);
          },
          setTo: function (f, g, m) {
            this.x = f;
            this.y = g;
            this._radius = m;
            this._diameter = 2 * m;
            return this;
          },
          setEmpty: function () {
            this._diameter = this._radius = 0;
            return this;
          },
          setPosition: function (f, g) {
            void 0 === g && (g = f);
            this.x = f;
            this.y = g;
            return this;
          },
          isEmpty: function () {
            return 0 >= this._radius;
          },
          radius: {
            get: function () {
              return this._radius;
            },
            set: function (f) {
              this._radius = f;
              this._diameter = 2 * f;
            },
          },
          diameter: {
            get: function () {
              return this._diameter;
            },
            set: function (f) {
              this._diameter = f;
              this._radius = 0.5 * f;
            },
          },
          left: {
            get: function () {
              return this.x - this._radius;
            },
            set: function (f) {
              this.x = f + this._radius;
            },
          },
          right: {
            get: function () {
              return this.x + this._radius;
            },
            set: function (f) {
              this.x = f - this._radius;
            },
          },
          top: {
            get: function () {
              return this.y - this._radius;
            },
            set: function (f) {
              this.y = f + this._radius;
            },
          },
          bottom: {
            get: function () {
              return this.y + this._radius;
            },
            set: function (f) {
              this.y = f - this._radius;
            },
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          return 0 < a.radius &&
            d >= a.left &&
            d <= a.right &&
            k >= a.top &&
            k <= a.bottom
            ? (a.x - d) * (a.x - d) + (a.y - k) * (a.y - k) <=
                a.radius * a.radius
            : !1;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return Math.sqrt(
            (a.x2 - a.x1) * (a.x2 - a.x1) + (a.y2 - a.y1) * (a.y2 - a.y1)
          );
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          k -= d;
          return d + ((((a - d) % k) + k) % k);
        };
      },
      function (h, t, a) {
        t = a(0);
        a = a(39);
        var d = new t({
            initialize: function (g) {
              this.val = new Float32Array(16);
              g ? this.copy(g) : this.identity();
            },
            clone: function () {
              return new d(this);
            },
            set: function (g) {
              return this.copy(g);
            },
            setValues: function (
              g,
              m,
              n,
              q,
              r,
              u,
              v,
              x,
              y,
              z,
              A,
              B,
              D,
              E,
              C,
              F
            ) {
              var G = this.val;
              G[0] = g;
              G[1] = m;
              G[2] = n;
              G[3] = q;
              G[4] = r;
              G[5] = u;
              G[6] = v;
              G[7] = x;
              G[8] = y;
              G[9] = z;
              G[10] = A;
              G[11] = B;
              G[12] = D;
              G[13] = E;
              G[14] = C;
              G[15] = F;
              return this;
            },
            copy: function (g) {
              g = g.val;
              return this.setValues(
                g[0],
                g[1],
                g[2],
                g[3],
                g[4],
                g[5],
                g[6],
                g[7],
                g[8],
                g[9],
                g[10],
                g[11],
                g[12],
                g[13],
                g[14],
                g[15]
              );
            },
            fromArray: function (g) {
              return this.setValues(
                g[0],
                g[1],
                g[2],
                g[3],
                g[4],
                g[5],
                g[6],
                g[7],
                g[8],
                g[9],
                g[10],
                g[11],
                g[12],
                g[13],
                g[14],
                g[15]
              );
            },
            zero: function () {
              return this.setValues(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
              );
            },
            transform: function (g, m, n) {
              n = k.fromQuat(n).val;
              var q = m.x,
                r = m.y;
              m = m.z;
              return this.setValues(
                n[0] * q,
                n[1] * q,
                n[2] * q,
                0,
                n[4] * r,
                n[5] * r,
                n[6] * r,
                0,
                n[8] * m,
                n[9] * m,
                n[10] * m,
                0,
                g.x,
                g.y,
                g.z,
                1
              );
            },
            xyz: function (g, m, n) {
              this.identity();
              var q = this.val;
              q[12] = g;
              q[13] = m;
              q[14] = n;
              return this;
            },
            scaling: function (g, m, n) {
              this.zero();
              var q = this.val;
              q[0] = g;
              q[5] = m;
              q[10] = n;
              q[15] = 1;
              return this;
            },
            identity: function () {
              return this.setValues(
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
              );
            },
            transpose: function () {
              var g = this.val,
                m = g[1],
                n = g[2],
                q = g[3],
                r = g[6],
                u = g[7],
                v = g[11];
              g[1] = g[4];
              g[2] = g[8];
              g[3] = g[12];
              g[4] = m;
              g[6] = g[9];
              g[7] = g[13];
              g[8] = n;
              g[9] = r;
              g[11] = g[14];
              g[12] = q;
              g[13] = u;
              g[14] = v;
              return this;
            },
            getInverse: function (g) {
              this.copy(g);
              return this.invert();
            },
            invert: function () {
              var g = this.val,
                m = g[0],
                n = g[1],
                q = g[2],
                r = g[3],
                u = g[4],
                v = g[5],
                x = g[6],
                y = g[7],
                z = g[8],
                A = g[9],
                B = g[10],
                D = g[11],
                E = g[12],
                C = g[13],
                F = g[14];
              g = g[15];
              var G = m * v - n * u,
                H = m * x - q * u,
                K = m * y - r * u,
                I = n * x - q * v,
                M = n * y - r * v,
                N = q * y - r * x,
                P = z * C - A * E,
                J = z * F - B * E,
                L = z * g - D * E,
                O = A * F - B * C,
                Q = A * g - D * C,
                S = B * g - D * F,
                R = G * S - H * Q + K * O + I * L - M * J + N * P;
              if (!R) return this;
              R = 1 / R;
              return this.setValues(
                (v * S - x * Q + y * O) * R,
                (q * Q - n * S - r * O) * R,
                (C * N - F * M + g * I) * R,
                (B * M - A * N - D * I) * R,
                (x * L - u * S - y * J) * R,
                (m * S - q * L + r * J) * R,
                (F * K - E * N - g * H) * R,
                (z * N - B * K + D * H) * R,
                (u * Q - v * L + y * P) * R,
                (n * L - m * Q - r * P) * R,
                (E * M - C * K + g * G) * R,
                (A * K - z * M - D * G) * R,
                (v * J - u * O - x * P) * R,
                (m * O - n * J + q * P) * R,
                (C * H - E * I - F * G) * R,
                (z * I - A * H + B * G) * R
              );
            },
            adjoint: function () {
              var g = this.val,
                m = g[0],
                n = g[1],
                q = g[2],
                r = g[3],
                u = g[4],
                v = g[5],
                x = g[6],
                y = g[7],
                z = g[8],
                A = g[9],
                B = g[10],
                D = g[11],
                E = g[12],
                C = g[13],
                F = g[14];
              g = g[15];
              return this.setValues(
                v * (B * g - D * F) - A * (x * g - y * F) + C * (x * D - y * B),
                -(
                  n * (B * g - D * F) -
                  A * (q * g - r * F) +
                  C * (q * D - r * B)
                ),
                n * (x * g - y * F) - v * (q * g - r * F) + C * (q * y - r * x),
                -(
                  n * (x * D - y * B) -
                  v * (q * D - r * B) +
                  A * (q * y - r * x)
                ),
                -(
                  u * (B * g - D * F) -
                  z * (x * g - y * F) +
                  E * (x * D - y * B)
                ),
                m * (B * g - D * F) - z * (q * g - r * F) + E * (q * D - r * B),
                -(
                  m * (x * g - y * F) -
                  u * (q * g - r * F) +
                  E * (q * y - r * x)
                ),
                m * (x * D - y * B) - u * (q * D - r * B) + z * (q * y - r * x),
                u * (A * g - D * C) - z * (v * g - y * C) + E * (v * D - y * A),
                -(
                  m * (A * g - D * C) -
                  z * (n * g - r * C) +
                  E * (n * D - r * A)
                ),
                m * (v * g - y * C) - u * (n * g - r * C) + E * (n * y - r * v),
                -(
                  m * (v * D - y * A) -
                  u * (n * D - r * A) +
                  z * (n * y - r * v)
                ),
                -(
                  u * (A * F - B * C) -
                  z * (v * F - x * C) +
                  E * (v * B - x * A)
                ),
                m * (A * F - B * C) - z * (n * F - q * C) + E * (n * B - q * A),
                -(
                  m * (v * F - x * C) -
                  u * (n * F - q * C) +
                  E * (n * x - q * v)
                ),
                m * (v * B - x * A) - u * (n * B - q * A) + z * (n * x - q * v)
              );
            },
            determinant: function () {
              var g = this.val,
                m = g[0],
                n = g[1],
                q = g[2],
                r = g[3],
                u = g[4],
                v = g[5],
                x = g[6],
                y = g[7],
                z = g[8],
                A = g[9],
                B = g[10],
                D = g[11],
                E = g[12],
                C = g[13],
                F = g[14];
              g = g[15];
              return (
                (m * v - n * u) * (B * g - D * F) -
                (m * x - q * u) * (A * g - D * C) +
                (m * y - r * u) * (A * F - B * C) +
                (n * x - q * v) * (z * g - D * E) -
                (n * y - r * v) * (z * F - B * E) +
                (q * y - r * x) * (z * C - A * E)
              );
            },
            multiply: function (g) {
              var m = this.val,
                n = m[0],
                q = m[1],
                r = m[2],
                u = m[3],
                v = m[4],
                x = m[5],
                y = m[6],
                z = m[7],
                A = m[8],
                B = m[9],
                D = m[10],
                E = m[11],
                C = m[12],
                F = m[13],
                G = m[14],
                H = m[15];
              g = g.val;
              var K = g[0],
                I = g[1],
                M = g[2],
                N = g[3];
              m[0] = K * n + I * v + M * A + N * C;
              m[1] = K * q + I * x + M * B + N * F;
              m[2] = K * r + I * y + M * D + N * G;
              m[3] = K * u + I * z + M * E + N * H;
              K = g[4];
              I = g[5];
              M = g[6];
              N = g[7];
              m[4] = K * n + I * v + M * A + N * C;
              m[5] = K * q + I * x + M * B + N * F;
              m[6] = K * r + I * y + M * D + N * G;
              m[7] = K * u + I * z + M * E + N * H;
              K = g[8];
              I = g[9];
              M = g[10];
              N = g[11];
              m[8] = K * n + I * v + M * A + N * C;
              m[9] = K * q + I * x + M * B + N * F;
              m[10] = K * r + I * y + M * D + N * G;
              m[11] = K * u + I * z + M * E + N * H;
              K = g[12];
              I = g[13];
              M = g[14];
              N = g[15];
              m[12] = K * n + I * v + M * A + N * C;
              m[13] = K * q + I * x + M * B + N * F;
              m[14] = K * r + I * y + M * D + N * G;
              m[15] = K * u + I * z + M * E + N * H;
              return this;
            },
            multiplyLocal: function (g) {
              var m = this.val;
              g = g.val;
              return this.setValues(
                m[0] * g[0] + m[1] * g[4] + m[2] * g[8] + m[3] * g[12],
                m[0] * g[1] + m[1] * g[5] + m[2] * g[9] + m[3] * g[13],
                m[0] * g[2] + m[1] * g[6] + m[2] * g[10] + m[3] * g[14],
                m[0] * g[3] + m[1] * g[7] + m[2] * g[11] + m[3] * g[15],
                m[4] * g[0] + m[5] * g[4] + m[6] * g[8] + m[7] * g[12],
                m[4] * g[1] + m[5] * g[5] + m[6] * g[9] + m[7] * g[13],
                m[4] * g[2] + m[5] * g[6] + m[6] * g[10] + m[7] * g[14],
                m[4] * g[3] + m[5] * g[7] + m[6] * g[11] + m[7] * g[15],
                m[8] * g[0] + m[9] * g[4] + m[10] * g[8] + m[11] * g[12],
                m[8] * g[1] + m[9] * g[5] + m[10] * g[9] + m[11] * g[13],
                m[8] * g[2] + m[9] * g[6] + m[10] * g[10] + m[11] * g[14],
                m[8] * g[3] + m[9] * g[7] + m[10] * g[11] + m[11] * g[15],
                m[12] * g[0] + m[13] * g[4] + m[14] * g[8] + m[15] * g[12],
                m[12] * g[1] + m[13] * g[5] + m[14] * g[9] + m[15] * g[13],
                m[12] * g[2] + m[13] * g[6] + m[14] * g[10] + m[15] * g[14],
                m[12] * g[3] + m[13] * g[7] + m[14] * g[11] + m[15] * g[15]
              );
            },
            premultiply: function (g) {
              return this.multiplyMatrices(g, this);
            },
            multiplyMatrices: function (g, m) {
              var n = g.val,
                q = m.val;
              m = n[0];
              g = n[4];
              var r = n[8],
                u = n[12],
                v = n[1],
                x = n[5],
                y = n[9],
                z = n[13],
                A = n[2],
                B = n[6],
                D = n[10],
                E = n[14],
                C = n[3],
                F = n[7],
                G = n[11];
              n = n[15];
              var H = q[0],
                K = q[4],
                I = q[8],
                M = q[12],
                N = q[1],
                P = q[5],
                J = q[9],
                L = q[13],
                O = q[2],
                Q = q[6],
                S = q[10],
                R = q[14],
                T = q[3],
                U = q[7],
                V = q[11];
              q = q[15];
              return this.setValues(
                m * H + g * N + r * O + u * T,
                v * H + x * N + y * O + z * T,
                A * H + B * N + D * O + E * T,
                C * H + F * N + G * O + n * T,
                m * K + g * P + r * Q + u * U,
                v * K + x * P + y * Q + z * U,
                A * K + B * P + D * Q + E * U,
                C * K + F * P + G * Q + n * U,
                m * I + g * J + r * S + u * V,
                v * I + x * J + y * S + z * V,
                A * I + B * J + D * S + E * V,
                C * I + F * J + G * S + n * V,
                m * M + g * L + r * R + u * q,
                v * M + x * L + y * R + z * q,
                A * M + B * L + D * R + E * q,
                C * M + F * L + G * R + n * q
              );
            },
            translate: function (g) {
              return this.translateXYZ(g.x, g.y, g.z);
            },
            translateXYZ: function (g, m, n) {
              var q = this.val;
              q[12] = q[0] * g + q[4] * m + q[8] * n + q[12];
              q[13] = q[1] * g + q[5] * m + q[9] * n + q[13];
              q[14] = q[2] * g + q[6] * m + q[10] * n + q[14];
              q[15] = q[3] * g + q[7] * m + q[11] * n + q[15];
              return this;
            },
            scale: function (g) {
              return this.scaleXYZ(g.x, g.y, g.z);
            },
            scaleXYZ: function (g, m, n) {
              var q = this.val;
              q[0] *= g;
              q[1] *= g;
              q[2] *= g;
              q[3] *= g;
              q[4] *= m;
              q[5] *= m;
              q[6] *= m;
              q[7] *= m;
              q[8] *= n;
              q[9] *= n;
              q[10] *= n;
              q[11] *= n;
              return this;
            },
            makeRotationAxis: function (g, m) {
              var n = Math.cos(m);
              m = Math.sin(m);
              var q = 1 - n,
                r = g.x,
                u = g.y;
              g = g.z;
              var v = q * r,
                x = q * u;
              return this.setValues(
                v * r + n,
                v * u - m * g,
                v * g + m * u,
                0,
                v * u + m * g,
                x * u + n,
                x * g - m * r,
                0,
                v * g - m * u,
                x * g + m * r,
                q * g * g + n,
                0,
                0,
                0,
                0,
                1
              );
            },
            rotate: function (g, m) {
              var n = this.val,
                q = m.x,
                r = m.y;
              m = m.z;
              var u = Math.sqrt(q * q + r * r + m * m);
              if (1e-6 > Math.abs(u)) return this;
              u = 1 / u;
              q *= u;
              r *= u;
              m *= u;
              var v = Math.sin(g),
                x = Math.cos(g),
                y = 1 - x;
              g = n[0];
              u = n[1];
              var z = n[2],
                A = n[3],
                B = n[4],
                D = n[5],
                E = n[6],
                C = n[7],
                F = n[8],
                G = n[9],
                H = n[10],
                K = n[11],
                I = q * q * y + x,
                M = r * q * y + m * v,
                N = m * q * y - r * v,
                P = q * r * y - m * v,
                J = r * r * y + x,
                L = m * r * y + q * v,
                O = q * m * y + r * v;
              q = r * m * y - q * v;
              r = m * m * y + x;
              return this.setValues(
                g * I + B * M + F * N,
                u * I + D * M + G * N,
                z * I + E * M + H * N,
                A * I + C * M + K * N,
                g * P + B * J + F * L,
                u * P + D * J + G * L,
                z * P + E * J + H * L,
                A * P + C * J + K * L,
                g * O + B * q + F * r,
                u * O + D * q + G * r,
                z * O + E * q + H * r,
                A * O + C * q + K * r,
                n[12],
                n[13],
                n[14],
                n[15]
              );
            },
            rotateX: function (g) {
              var m = this.val,
                n = Math.sin(g);
              g = Math.cos(g);
              var q = m[4],
                r = m[5],
                u = m[6],
                v = m[7],
                x = m[8],
                y = m[9],
                z = m[10],
                A = m[11];
              m[4] = q * g + x * n;
              m[5] = r * g + y * n;
              m[6] = u * g + z * n;
              m[7] = v * g + A * n;
              m[8] = x * g - q * n;
              m[9] = y * g - r * n;
              m[10] = z * g - u * n;
              m[11] = A * g - v * n;
              return this;
            },
            rotateY: function (g) {
              var m = this.val,
                n = Math.sin(g);
              g = Math.cos(g);
              var q = m[0],
                r = m[1],
                u = m[2],
                v = m[3],
                x = m[8],
                y = m[9],
                z = m[10],
                A = m[11];
              m[0] = q * g - x * n;
              m[1] = r * g - y * n;
              m[2] = u * g - z * n;
              m[3] = v * g - A * n;
              m[8] = q * n + x * g;
              m[9] = r * n + y * g;
              m[10] = u * n + z * g;
              m[11] = v * n + A * g;
              return this;
            },
            rotateZ: function (g) {
              var m = this.val,
                n = Math.sin(g);
              g = Math.cos(g);
              var q = m[0],
                r = m[1],
                u = m[2],
                v = m[3],
                x = m[4],
                y = m[5],
                z = m[6],
                A = m[7];
              m[0] = q * g + x * n;
              m[1] = r * g + y * n;
              m[2] = u * g + z * n;
              m[3] = v * g + A * n;
              m[4] = x * g - q * n;
              m[5] = y * g - r * n;
              m[6] = z * g - u * n;
              m[7] = A * g - v * n;
              return this;
            },
            fromRotationTranslation: function (g, m) {
              var n = g.x,
                q = g.y,
                r = g.z,
                u = g.w,
                v = n + n,
                x = q + q,
                y = r + r;
              g = n * v;
              var z = n * x;
              n *= y;
              var A = q * x;
              q *= y;
              r *= y;
              v *= u;
              x *= u;
              u *= y;
              return this.setValues(
                1 - (A + r),
                z + u,
                n - x,
                0,
                z - u,
                1 - (g + r),
                q + v,
                0,
                n + x,
                q - v,
                1 - (g + A),
                0,
                m.x,
                m.y,
                m.z,
                1
              );
            },
            fromQuat: function (g) {
              var m = g.x,
                n = g.y,
                q = g.z,
                r = g.w,
                u = m + m,
                v = n + n,
                x = q + q;
              g = m * u;
              var y = m * v;
              m *= x;
              var z = n * v;
              n *= x;
              q *= x;
              u *= r;
              v *= r;
              r *= x;
              return this.setValues(
                1 - (z + q),
                y + r,
                m - v,
                0,
                y - r,
                1 - (g + q),
                n + u,
                0,
                m + v,
                n - u,
                1 - (g + z),
                0,
                0,
                0,
                0,
                1
              );
            },
            frustum: function (g, m, n, q, r, u) {
              var v = 1 / (m - g),
                x = 1 / (q - n),
                y = 1 / (r - u);
              return this.setValues(
                2 * r * v,
                0,
                0,
                0,
                0,
                2 * r * x,
                0,
                0,
                (m + g) * v,
                (q + n) * x,
                (u + r) * y,
                -1,
                0,
                0,
                u * r * 2 * y,
                0
              );
            },
            perspective: function (g, m, n, q) {
              g = 1 / Math.tan(g / 2);
              var r = 1 / (n - q);
              return this.setValues(
                g / m,
                0,
                0,
                0,
                0,
                g,
                0,
                0,
                0,
                0,
                (q + n) * r,
                -1,
                0,
                0,
                2 * q * n * r,
                0
              );
            },
            perspectiveLH: function (g, m, n, q) {
              return this.setValues(
                (2 * n) / g,
                0,
                0,
                0,
                0,
                (2 * n) / m,
                0,
                0,
                0,
                0,
                -q / (n - q),
                1,
                0,
                0,
                (n * q) / (n - q),
                0
              );
            },
            ortho: function (g, m, n, q, r, u) {
              var v = g - m,
                x = n - q,
                y = r - u;
              v = 0 === v ? v : 1 / v;
              x = 0 === x ? x : 1 / x;
              y = 0 === y ? y : 1 / y;
              return this.setValues(
                -2 * v,
                0,
                0,
                0,
                0,
                -2 * x,
                0,
                0,
                0,
                0,
                2 * y,
                0,
                (g + m) * v,
                (q + n) * x,
                (u + r) * y,
                1
              );
            },
            lookAtRH: function (g, m, n) {
              var q = this.val;
              f.subVectors(g, m);
              0 === f.getLengthSquared() && (f.z = 1);
              f.normalize();
              b.crossVectors(n, f);
              0 === b.getLengthSquared() &&
                (1 === Math.abs(n.z) ? (f.x += 1e-4) : (f.z += 1e-4),
                f.normalize(),
                b.crossVectors(n, f));
              b.normalize();
              c.crossVectors(f, b);
              q[0] = b.x;
              q[1] = b.y;
              q[2] = b.z;
              q[4] = c.x;
              q[5] = c.y;
              q[6] = c.z;
              q[8] = f.x;
              q[9] = f.y;
              q[10] = f.z;
              return this;
            },
            lookAt: function (g, m, n) {
              var q = g.x,
                r = g.y;
              g = g.z;
              var u = n.x,
                v = n.y,
                x = n.z,
                y = m.x;
              n = m.y;
              var z = m.z;
              if (
                1e-6 > Math.abs(q - y) &&
                1e-6 > Math.abs(r - n) &&
                1e-6 > Math.abs(g - z)
              )
                return this.identity();
              m = q - y;
              n = r - n;
              z = g - z;
              y = 1 / Math.sqrt(m * m + n * n + z * z);
              m *= y;
              n *= y;
              z *= y;
              var A = v * z - x * n;
              x = x * m - u * z;
              u = u * n - v * m;
              (y = Math.sqrt(A * A + x * x + u * u))
                ? ((y = 1 / y), (A *= y), (x *= y), (u *= y))
                : (u = x = A = 0);
              v = n * u - z * x;
              var B = z * A - m * u,
                D = m * x - n * A;
              (y = Math.sqrt(v * v + B * B + D * D))
                ? ((y = 1 / y), (v *= y), (B *= y), (D *= y))
                : (D = B = v = 0);
              return this.setValues(
                A,
                v,
                m,
                0,
                x,
                B,
                n,
                0,
                u,
                D,
                z,
                0,
                -(A * q + x * r + u * g),
                -(v * q + B * r + D * g),
                -(m * q + n * r + z * g),
                1
              );
            },
            yawPitchRoll: function (g, m, n) {
              this.zero();
              k.zero();
              e.zero();
              var q = this.val,
                r = k.val,
                u = e.val,
                v = Math.sin(n);
              n = Math.cos(n);
              q[10] = 1;
              q[15] = 1;
              q[0] = n;
              q[1] = v;
              q[4] = -v;
              q[5] = n;
              v = Math.sin(m);
              n = Math.cos(m);
              r[0] = 1;
              r[15] = 1;
              r[5] = n;
              r[10] = n;
              r[9] = -v;
              r[6] = v;
              v = Math.sin(g);
              n = Math.cos(g);
              u[5] = 1;
              u[15] = 1;
              u[0] = n;
              u[2] = -v;
              u[8] = v;
              u[10] = n;
              this.multiplyLocal(k);
              this.multiplyLocal(e);
              return this;
            },
            setWorldMatrix: function (g, m, n, q, r) {
              this.yawPitchRoll(g.y, g.x, g.z);
              k.scaling(n.x, n.y, n.z);
              e.xyz(m.x, m.y, m.z);
              this.multiplyLocal(k);
              this.multiplyLocal(e);
              q && this.multiplyLocal(q);
              r && this.multiplyLocal(r);
              return this;
            },
            multiplyToMat4: function (g, m) {
              var n = this.val;
              g = g.val;
              var q = n[0],
                r = n[1],
                u = n[2],
                v = n[3],
                x = n[4],
                y = n[5],
                z = n[6],
                A = n[7],
                B = n[8],
                D = n[9],
                E = n[10],
                C = n[11],
                F = n[12],
                G = n[13],
                H = n[14];
              n = n[15];
              var K = g[1],
                I = g[2],
                M = g[3],
                N = g[4],
                P = g[5],
                J = g[6],
                L = g[7],
                O = g[8],
                Q = g[9],
                S = g[10],
                R = g[11],
                T = g[12],
                U = g[13],
                V = g[14],
                X = g[15];
              return m.setValues(
                g[0] * q + K * x + I * B + M * F,
                K * r + K * y + I * D + M * G,
                I * u + K * z + I * E + M * H,
                M * v + K * A + I * C + M * n,
                N * q + P * x + J * B + L * F,
                N * r + P * y + J * D + L * G,
                N * u + P * z + J * E + L * H,
                N * v + P * A + J * C + L * n,
                O * q + Q * x + S * B + R * F,
                O * r + Q * y + S * D + R * G,
                O * u + Q * z + S * E + R * H,
                O * v + Q * A + S * C + R * n,
                T * q + U * x + V * B + X * F,
                T * r + U * y + V * D + X * G,
                T * u + U * z + V * E + X * H,
                T * v + U * A + V * C + X * n
              );
            },
            fromRotationXYTranslation: function (g, m, n) {
              var q = m.x,
                r = m.y;
              m = m.z;
              var u = Math.sin(g.x),
                v = Math.cos(g.x),
                x = Math.sin(g.y);
              g = Math.cos(g.y);
              var y = q,
                z = r,
                A = m,
                B = -u,
                D = -(B * x),
                E = -(v * x);
              B *= g;
              var C = v * g;
              n ||
                ((y = g * q + x * m),
                (z = D * q + v * r + B * m),
                (A = E * q + u * r + C * m));
              return this.setValues(
                g,
                D,
                E,
                0,
                0,
                v,
                u,
                0,
                x,
                B,
                C,
                0,
                y,
                z,
                A,
                1
              );
            },
            getMaxScaleOnAxis: function () {
              var g = this.val;
              return Math.sqrt(
                Math.max(
                  g[0] * g[0] + g[1] * g[1] + g[2] * g[2],
                  g[4] * g[4] + g[5] * g[5] + g[6] * g[6],
                  g[8] * g[8] + g[9] * g[9] + g[10] * g[10]
                )
              );
            },
          }),
          k = new d(),
          e = new d(),
          b = new a(),
          c = new a(),
          f = new a();
        h.exports = d;
      },
      function (h, t, a) {
        h.exports = {
          COMPLETE: a(987),
          DECODED: a(988),
          DECODED_ALL: a(989),
          DESTROY: a(990),
          DETUNE: a(991),
          GLOBAL_DETUNE: a(992),
          GLOBAL_MUTE: a(993),
          GLOBAL_RATE: a(994),
          GLOBAL_VOLUME: a(995),
          LOOP: a(996),
          LOOPED: a(997),
          MUTE: a(998),
          PAN: a(999),
          PAUSE_ALL: a(1e3),
          PAUSE: a(1001),
          PLAY: a(1002),
          RATE: a(1003),
          RESUME_ALL: a(1004),
          RESUME: a(1005),
          SEEK: a(1006),
          STOP_ALL: a(1007),
          STOP: a(1008),
          UNLOCKED: a(1009),
          VOLUME: a(1010),
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(7),
          f = new t({
            Extends: k,
            initialize: function v(m, n, q, r, u) {
              var x = "png";
              if (c(n)) {
                u = n;
                n = b(u, "key");
                q = b(u, "url");
                var y = b(u, "normalMap");
                r = b(u, "xhrSettings");
                x = b(u, "extension", x);
                u = b(u, "frameConfig");
              }
              Array.isArray(q) && ((y = q[1]), (q = q[0]));
              k.call(this, m, {
                type: "image",
                cache: m.textureManager,
                extension: x,
                responseType: "blob",
                key: n,
                url: q,
                xhrSettings: r,
                config: u,
              });
              y &&
                ((n = new v(m, this.key, y, r, u)),
                (n.type = "normalMap"),
                this.setLink(n),
                m.addFile(n));
            },
            onProcess: function () {
              this.state = d.FILE_PROCESSING;
              this.data = new Image();
              this.data.crossOrigin = this.crossOrigin;
              var m = this;
              this.data.onload = function () {
                k.revokeObjectURL(m.data);
                m.onProcessComplete();
              };
              this.data.onerror = function () {
                k.revokeObjectURL(m.data);
                m.onProcessError();
              };
              k.createObjectURL(
                this.data,
                this.xhrLoader.response,
                "image/png"
              );
            },
            addToCache: function () {
              var m = this.linkFile;
              if (m && m.state === d.FILE_COMPLETE) {
                var n =
                  "image" === this.type
                    ? this.cache.addImage(this.key, this.data, m.data)
                    : this.cache.addImage(m.key, m.data, this.data);
                this.pendingDestroy(n);
                m.pendingDestroy(n);
              } else
                m ||
                  ((n = this.cache.addImage(this.key, this.data)),
                  this.pendingDestroy(n));
            },
          });
        e.register("image", function (m, n, q) {
          if (Array.isArray(m))
            for (n = 0; n < m.length; n++) this.addFile(new f(this, m[n]));
          else this.addFile(new f(this, m, n, q));
          return this;
        });
        h.exports = f;
      },
      function (h, t) {
        h.exports = function (a, d) {
          d ? a.setCollision(!0, !0, !0, !0, !1) : a.resetCollision(!1);
        };
      },
      function (h, t, a) {
        var d = a(164);
        t = a(0);
        var k = a(11),
          e = a(15);
        a = a(1065);
        a = new t({
          Extends: e,
          Mixins: [
            k.Alpha,
            k.BlendMode,
            k.Depth,
            k.Flip,
            k.GetBounds,
            k.Mask,
            k.Origin,
            k.Pipeline,
            k.ScrollFactor,
            k.Size,
            k.TextureCrop,
            k.Tint,
            k.Transform,
            k.Visible,
            a,
          ],
          initialize: function (b, c, f, g, m) {
            e.call(this, b, "Sprite");
            this._crop = this.resetCropObject();
            this.anims = new d(this);
            this.setTexture(g, m);
            this.setPosition(c, f);
            this.setSizeToFrame();
            this.setOriginFromFrame();
            this.initPipeline();
          },
          addedToScene: function () {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function () {
            this.scene.sys.updateList.remove(this);
          },
          preUpdate: function (b, c) {
            this.anims.update(b, c);
          },
          play: function (b, c) {
            return this.anims.play(b, c);
          },
          playReverse: function (b, c) {
            return this.anims.playReverse(b, c);
          },
          playAfterDelay: function (b, c) {
            return this.anims.playAfterDelay(b, c);
          },
          playAfterRepeat: function (b, c) {
            return this.anims.playAfterRepeat(b, c);
          },
          chain: function (b) {
            return this.anims.chain(b);
          },
          stop: function () {
            return this.anims.stop();
          },
          stopAfterDelay: function (b) {
            return this.anims.stopAfterDelay(b);
          },
          stopAfterRepeat: function (b) {
            return this.anims.stopAfterRepeat(b);
          },
          stopOnFrame: function (b) {
            return this.anims.stopOnFrame(b);
          },
          toJSON: function () {
            return k.ToJSON(this);
          },
          preDestroy: function () {
            this.anims.destroy();
            this.anims = void 0;
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d) {
          if (!(d >= a.length)) {
            for (var k = a.length - 1, e = a[d]; d < k; d++) a[d] = a[d + 1];
            a.length = k;
            return e;
          }
        };
      },
      function (h, t, a) {
        h.exports = {
          ADDED_TO_SCENE: a(643),
          DESTROY: a(644),
          REMOVED_FROM_SCENE: a(645),
          VIDEO_COMPLETE: a(646),
          VIDEO_CREATED: a(647),
          VIDEO_ERROR: a(648),
          VIDEO_LOOP: a(649),
          VIDEO_PLAY: a(650),
          VIDEO_SEEKED: a(651),
          VIDEO_SEEKING: a(652),
          VIDEO_STOP: a(653),
          VIDEO_TIMEOUT: a(654),
          VIDEO_UNLOCKED: a(655),
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          void 0 === k && (k = 0);
          if (0 === d) return a;
          a = d * Math.floor((a - k) / d);
          return e ? (k + a) / d : k + a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          var d = {},
            k;
          for (k in a)
            Array.isArray(a[k]) ? (d[k] = a[k].slice(0)) : (d[k] = a[k]);
          return d;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          a = a.length;
          if (0 > d || d > a || d >= k || k > a || d + k > a) {
            if (e) throw Error("Range Error: Values outside acceptable range");
            return !1;
          }
          return !0;
        };
      },
      function (h, t) {
        function a(k, e) {
          return String(k).localeCompare(e);
        }

        function d(k, e, b, c) {
          var f = k.length,
            g = 0,
            m = 2 * b,
            n,
            q;
          for (n = 0; n < f; n += m) {
            var r = n + b;
            var u = r + b;
            r > f && (r = f);
            u > f && (u = f);
            var v = n;
            for (q = r; ; )
              if (v < r && q < u)
                0 >= e(k[v], k[q]) ? (c[g++] = k[v++]) : (c[g++] = k[q++]);
              else if (v < r) c[g++] = k[v++];
              else if (q < u) c[g++] = k[q++];
              else break;
          }
        }
        h.exports = function (k, e) {
          void 0 === e && (e = a);
          var b = k;
          var c = b.length;
          if (!(1 >= c))
            for (var f = Array(c), g = 1; g < c; g *= 2) {
              d(b, e, g, f);
              var m = b;
              b = f;
              f = m;
            }
          b !== k && d(b, null, k.length, k);
          return k;
        };
      },
      function (h, t, a) {
        var d = a(134),
          k = a(205);
        h.exports = function (e, b) {
          var c = d.Power0;
          if ("string" === typeof e)
            if (d.hasOwnProperty(e)) c = d[e];
            else {
              var f = "";
              e.indexOf(".") &&
                ((f = e.substr(e.indexOf(".") + 1)),
                "in" === f.toLowerCase()
                  ? (f = "easeIn")
                  : "out" === f.toLowerCase()
                  ? (f = "easeOut")
                  : "inout" === f.toLowerCase() && (f = "easeInOut"));
              e = k(e.substr(0, e.indexOf(".") + 1) + f);
              d.hasOwnProperty(e) && (c = d[e]);
            }
          else "function" === typeof e ? (c = e) : Array.isArray(e);
          if (!b) return c;
          var g = b.slice(0);
          g.unshift(0);
          return function (m) {
            g[0] = m;
            return c.apply(this, g);
          };
        };
      },
      function (h, t, a) {
        var d = a(12);
        h.exports = function (k, e, b, c, f) {
          var g = k.strokeTint;
          b = d.getTintAppendFloatAlpha(e.strokeColor, e.strokeAlpha * b);
          g.TL = b;
          g.TR = b;
          g.BL = b;
          g.BR = b;
          g = e.pathData;
          b = g.length - 1;
          var m = e.lineWidth,
            n = m / 2,
            q = g[0] - c,
            r = g[1] - f;
          e.closePath || (b -= 2);
          for (var u = 2; u < b; u += 2) {
            var v = g[u] - c,
              x = g[u + 1] - f;
            k.batchLine(
              q,
              r,
              v,
              x,
              n,
              n,
              m,
              u - 2,
              e.closePath ? u === b - 1 : !1
            );
            q = v;
            r = x;
          }
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(115),
          k = a(476),
          e = a(477),
          b = a(56),
          c = a(47),
          f = a(181);
        a = new t({
          initialize: function (g, m, n, q, r, u) {
            void 0 === g && (g = 0);
            void 0 === m && (m = 0);
            void 0 === n && (n = 0);
            void 0 === q && (q = 0);
            void 0 === r && (r = 0);
            void 0 === u && (u = 0);
            this.type = b.TRIANGLE;
            this.x1 = g;
            this.y1 = m;
            this.x2 = n;
            this.y2 = q;
            this.x3 = r;
            this.y3 = u;
          },
          contains: function (g, m) {
            return d(this, g, m);
          },
          getPoint: function (g, m) {
            return k(this, g, m);
          },
          getPoints: function (g, m, n) {
            return e(this, g, m, n);
          },
          getRandomPoint: function (g) {
            return f(this, g);
          },
          setTo: function (g, m, n, q, r, u) {
            void 0 === g && (g = 0);
            void 0 === m && (m = 0);
            void 0 === n && (n = 0);
            void 0 === q && (q = 0);
            void 0 === r && (r = 0);
            void 0 === u && (u = 0);
            this.x1 = g;
            this.y1 = m;
            this.x2 = n;
            this.y2 = q;
            this.x3 = r;
            this.y3 = u;
            return this;
          },
          getLineA: function (g) {
            void 0 === g && (g = new c());
            g.setTo(this.x1, this.y1, this.x2, this.y2);
            return g;
          },
          getLineB: function (g) {
            void 0 === g && (g = new c());
            g.setTo(this.x2, this.y2, this.x3, this.y3);
            return g;
          },
          getLineC: function (g) {
            void 0 === g && (g = new c());
            g.setTo(this.x3, this.y3, this.x1, this.y1);
            return g;
          },
          left: {
            get: function () {
              return Math.min(this.x1, this.x2, this.x3);
            },
            set: function (g) {
              g =
                this.x1 <= this.x2 && this.x1 <= this.x3
                  ? this.x1 - g
                  : this.x2 <= this.x1 && this.x2 <= this.x3
                  ? this.x2 - g
                  : this.x3 - g;
              this.x1 -= g;
              this.x2 -= g;
              this.x3 -= g;
            },
          },
          right: {
            get: function () {
              return Math.max(this.x1, this.x2, this.x3);
            },
            set: function (g) {
              g =
                this.x1 >= this.x2 && this.x1 >= this.x3
                  ? this.x1 - g
                  : this.x2 >= this.x1 && this.x2 >= this.x3
                  ? this.x2 - g
                  : this.x3 - g;
              this.x1 -= g;
              this.x2 -= g;
              this.x3 -= g;
            },
          },
          top: {
            get: function () {
              return Math.min(this.y1, this.y2, this.y3);
            },
            set: function (g) {
              g =
                this.y1 <= this.y2 && this.y1 <= this.y3
                  ? this.y1 - g
                  : this.y2 <= this.y1 && this.y2 <= this.y3
                  ? this.y2 - g
                  : this.y3 - g;
              this.y1 -= g;
              this.y2 -= g;
              this.y3 -= g;
            },
          },
          bottom: {
            get: function () {
              return Math.max(this.y1, this.y2, this.y3);
            },
            set: function (g) {
              g =
                this.y1 >= this.y2 && this.y1 >= this.y3
                  ? this.y1 - g
                  : this.y2 >= this.y1 && this.y2 >= this.y3
                  ? this.y2 - g
                  : this.y3 - g;
              this.y1 -= g;
              this.y2 -= g;
              this.y3 -= g;
            },
          },
        });
        h.exports = a;
      },
      function (h, t) {
        var a = {};
        h.exports = a;
        (function () {
          a.create = function (d, k) {
            return {
              x: d || 0,
              y: k || 0,
            };
          };
          a.clone = function (d) {
            return {
              x: d.x,
              y: d.y,
            };
          };
          a.magnitude = function (d) {
            return Math.sqrt(d.x * d.x + d.y * d.y);
          };
          a.magnitudeSquared = function (d) {
            return d.x * d.x + d.y * d.y;
          };
          a.rotate = function (d, k, e) {
            var b = Math.cos(k);
            k = Math.sin(k);
            e || (e = {});
            var c = d.x * b - d.y * k;
            e.y = d.x * k + d.y * b;
            e.x = c;
            return e;
          };
          a.rotateAbout = function (d, k, e, b) {
            var c = Math.cos(k);
            k = Math.sin(k);
            b || (b = {});
            var f = e.x + ((d.x - e.x) * c - (d.y - e.y) * k);
            b.y = e.y + ((d.x - e.x) * k + (d.y - e.y) * c);
            b.x = f;
            return b;
          };
          a.normalise = function (d) {
            var k = a.magnitude(d);
            return 0 === k
              ? {
                  x: 0,
                  y: 0,
                }
              : {
                  x: d.x / k,
                  y: d.y / k,
                };
          };
          a.dot = function (d, k) {
            return d.x * k.x + d.y * k.y;
          };
          a.cross = function (d, k) {
            return d.x * k.y - d.y * k.x;
          };
          a.cross3 = function (d, k, e) {
            return (k.x - d.x) * (e.y - d.y) - (k.y - d.y) * (e.x - d.x);
          };
          a.add = function (d, k, e) {
            e || (e = {});
            e.x = d.x + k.x;
            e.y = d.y + k.y;
            return e;
          };
          a.sub = function (d, k, e) {
            e || (e = {});
            e.x = d.x - k.x;
            e.y = d.y - k.y;
            return e;
          };
          a.mult = function (d, k) {
            return {
              x: d.x * k,
              y: d.y * k,
            };
          };
          a.div = function (d, k) {
            return {
              x: d.x / k,
              y: d.y / k,
            };
          };
          a.perp = function (d, k) {
            k = !0 === k ? -1 : 1;
            return {
              x: k * -d.y,
              y: k * d.x,
            };
          };
          a.neg = function (d) {
            return {
              x: -d.x,
              y: -d.y,
            };
          };
          a.angle = function (d, k) {
            return Math.atan2(k.y - d.y, k.x - d.x);
          };
          a._temp = [
            a.create(),
            a.create(),
            a.create(),
            a.create(),
            a.create(),
            a.create(),
          ];
        })();
      },
      function (h, t) {
        var a = {};
        h.exports = a;
        (function () {
          a.create = function (d) {
            var k = {
              min: {
                x: 0,
                y: 0,
              },
              max: {
                x: 0,
                y: 0,
              },
            };
            d && a.update(k, d);
            return k;
          };
          a.update = function (d, k, e) {
            d.min.x = Infinity;
            d.max.x = -Infinity;
            d.min.y = Infinity;
            d.max.y = -Infinity;
            for (var b = 0; b < k.length; b++) {
              var c = k[b];
              c.x > d.max.x && (d.max.x = c.x);
              c.x < d.min.x && (d.min.x = c.x);
              c.y > d.max.y && (d.max.y = c.y);
              c.y < d.min.y && (d.min.y = c.y);
            }
            e &&
              (0 < e.x ? (d.max.x += e.x) : (d.min.x += e.x),
              0 < e.y ? (d.max.y += e.y) : (d.min.y += e.y));
          };
          a.contains = function (d, k) {
            return (
              k.x >= d.min.x &&
              k.x <= d.max.x &&
              k.y >= d.min.y &&
              k.y <= d.max.y
            );
          };
          a.overlaps = function (d, k) {
            return (
              d.min.x <= k.max.x &&
              d.max.x >= k.min.x &&
              d.max.y >= k.min.y &&
              d.min.y <= k.max.y
            );
          };
          a.translate = function (d, k) {
            d.min.x += k.x;
            d.max.x += k.x;
            d.min.y += k.y;
            d.max.y += k.y;
          };
          a.shift = function (d, k) {
            var e = d.max.x - d.min.x,
              b = d.max.y - d.min.y;
            d.min.x = k.x;
            d.max.x = k.x + e;
            d.min.y = k.y;
            d.max.y = k.y + b;
          };
        })();
      },
      function (h, t, a) {
        var d = a(29);
        t = a(0);
        var k = a(11),
          e = a(502);
        a = new t({
          Mixins: [k.Alpha, k.Flip, k.Visible],
          initialize: function (b, c, f, g, m, n, q, r) {
            this.layer = b;
            this.index = c;
            this.x = f;
            this.y = g;
            this.width = m;
            this.height = n;
            this.right;
            this.bottom;
            this.baseWidth = void 0 !== q ? q : m;
            this.baseHeight = void 0 !== r ? r : n;
            this.pixelY = this.pixelX = 0;
            this.updatePixelXY();
            this.properties = {};
            this.rotation = 0;
            this.faceBottom =
              this.faceTop =
              this.faceRight =
              this.faceLeft =
              this.collideDown =
              this.collideUp =
              this.collideRight =
              this.collideLeft =
                !1;
            this.collisionCallback = void 0;
            this.collisionCallbackContext = this;
            this.tint = 16777215;
            this.physics = {};
          },
          containsPoint: function (b, c) {
            return !(
              b < this.pixelX ||
              c < this.pixelY ||
              b > this.right ||
              c > this.bottom
            );
          },
          copy: function (b) {
            this.index = b.index;
            this.alpha = b.alpha;
            this.properties = b.properties;
            this.visible = b.visible;
            this.setFlip(b.flipX, b.flipY);
            this.tint = b.tint;
            this.rotation = b.rotation;
            this.collideUp = b.collideUp;
            this.collideDown = b.collideDown;
            this.collideLeft = b.collideLeft;
            this.collideRight = b.collideRight;
            this.collisionCallback = b.collisionCallback;
            this.collisionCallbackContext = b.collisionCallbackContext;
            return this;
          },
          getCollisionGroup: function () {
            return this.tileset
              ? this.tileset.getTileCollisionGroup(this.index)
              : null;
          },
          getTileData: function () {
            return this.tileset ? this.tileset.getTileData(this.index) : null;
          },
          getLeft: function (b) {
            var c = this.tilemapLayer;
            return c ? c.tileToWorldX(this.x, b) : this.x * this.baseWidth;
          },
          getRight: function (b) {
            var c = this.tilemapLayer;
            return c
              ? this.getLeft(b) + this.width * c.scaleX
              : this.getLeft(b) + this.width;
          },
          getTop: function (b) {
            var c = this.tilemapLayer;
            return c
              ? c.tileToWorldY(this.y, b) -
                  (this.height - this.baseHeight) * c.scaleY
              : this.y * this.baseHeight - (this.height - this.baseHeight);
          },
          getBottom: function (b) {
            var c = this.tilemapLayer;
            return c
              ? this.getTop(b) + this.height * c.scaleY
              : this.getTop(b) + this.height;
          },
          getBounds: function (b, c) {
            void 0 === c && (c = new e());
            c.x = this.getLeft();
            c.y = this.getTop();
            c.width = this.getRight() - c.x;
            c.height = this.getBottom() - c.y;
            return c;
          },
          getCenterX: function (b) {
            return (this.getLeft(b) + this.getRight(b)) / 2;
          },
          getCenterY: function (b) {
            return (this.getTop(b) + this.getBottom(b)) / 2;
          },
          intersects: function (b, c, f, g) {
            return !(
              f <= this.pixelX ||
              g <= this.pixelY ||
              b >= this.right ||
              c >= this.bottom
            );
          },
          isInteresting: function (b, c) {
            return b && c
              ? this.canCollide || this.hasInterestingFace
              : b
              ? this.collides
              : c
              ? this.hasInterestingFace
              : !1;
          },
          resetCollision: function (b) {
            void 0 === b && (b = !0);
            this.faceRight =
              this.faceLeft =
              this.faceBottom =
              this.faceTop =
              this.collideDown =
              this.collideUp =
              this.collideRight =
              this.collideLeft =
                !1;
            b &&
              this.tilemapLayer &&
              this.tilemapLayer.calculateFacesAt(this.x, this.y);
            return this;
          },
          resetFaces: function () {
            this.faceRight =
              this.faceLeft =
              this.faceBottom =
              this.faceTop =
                !1;
            return this;
          },
          setCollision: function (b, c, f, g, m) {
            void 0 === c && (c = b);
            void 0 === f && (f = b);
            void 0 === g && (g = b);
            void 0 === m && (m = !0);
            this.collideLeft = b;
            this.collideRight = c;
            this.collideUp = f;
            this.collideDown = g;
            this.faceLeft = b;
            this.faceRight = c;
            this.faceTop = f;
            this.faceBottom = g;
            m &&
              this.tilemapLayer &&
              this.tilemapLayer.calculateFacesAt(this.x, this.y);
            return this;
          },
          setCollisionCallback: function (b, c) {
            null === b
              ? (this.collisionCallbackContext = this.collisionCallback =
                  void 0)
              : ((this.collisionCallback = b),
                (this.collisionCallbackContext = c));
            return this;
          },
          setSize: function (b, c, f, g) {
            void 0 !== b && (this.width = b);
            void 0 !== c && (this.height = c);
            void 0 !== f && (this.baseWidth = f);
            void 0 !== g && (this.baseHeight = g);
            this.updatePixelXY();
            return this;
          },
          updatePixelXY: function () {
            var b = this.layer.orientation;
            b === d.ORTHOGONAL
              ? ((this.pixelX = this.x * this.baseWidth),
                (this.pixelY = this.y * this.baseHeight))
              : b === d.ISOMETRIC
              ? ((this.pixelX = (this.x - this.y) * this.baseWidth * 0.5),
                (this.pixelY = (this.x + this.y) * this.baseHeight * 0.5))
              : b === d.STAGGERED
              ? ((this.pixelX =
                  this.x * this.baseWidth +
                  (this.y % 2) * (this.baseWidth / 2)),
                (this.pixelY = (this.baseHeight / 2) * this.y))
              : b === d.HEXAGONAL &&
                ((b = this.layer.hexSideLength),
                (b = (this.baseHeight - b) / 2 + b),
                (this.pixelX =
                  this.x * this.baseWidth +
                  (this.y % 2) * (this.baseWidth / 2)),
                (this.pixelY = this.y * b));
            this.right = this.pixelX + this.baseWidth;
            this.bottom = this.pixelY + this.baseHeight;
            return this;
          },
          destroy: function () {
            this.properties =
              this.collisionCallbackContext =
              this.collisionCallback =
                void 0;
          },
          canCollide: {
            get: function () {
              return (
                this.collideLeft ||
                this.collideRight ||
                this.collideUp ||
                this.collideDown ||
                void 0 !== this.collisionCallback
              );
            },
          },
          collides: {
            get: function () {
              return (
                this.collideLeft ||
                this.collideRight ||
                this.collideUp ||
                this.collideDown
              );
            },
          },
          hasInterestingFace: {
            get: function () {
              return (
                this.faceTop ||
                this.faceBottom ||
                this.faceLeft ||
                this.faceRight
              );
            },
          },
          tileset: {
            get: function () {
              var b = this.layer.tilemapLayer;
              return b && (b = b.gidMap[this.index]) ? b : null;
            },
          },
          tilemapLayer: {
            get: function () {
              return this.layer.tilemapLayer;
            },
          },
          tilemap: {
            get: function () {
              var b = this.tilemapLayer;
              return b ? b.tilemap : null;
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(64),
          e = a(32),
          b = a(41),
          c = a(84),
          f = a(83),
          g = a(1393);
        (function () {
          d.rectangle = function (m, n, q, r, u) {
            u = u || {};
            m = {
              label: "Rectangle Body",
              position: {
                x: m,
                y: n,
              },
              vertices: k.fromPath(
                "L 0 0 L " + q + " 0 L " + q + " " + r + " L 0 " + r
              ),
            };
            u.chamfer &&
              ((n = u.chamfer),
              (m.vertices = k.chamfer(
                m.vertices,
                n.radius,
                n.quality,
                n.qualityMin,
                n.qualityMax
              )),
              delete u.chamfer);
            return b.create(e.extend({}, m, u));
          };
          d.trapezoid = function (m, n, q, r, u, v) {
            v = v || {};
            u *= 0.5;
            var x = q * u;
            q = x + (1 - 2 * u) * q;
            var y = q + x;
            m = {
              label: "Trapezoid Body",
              position: {
                x: m,
                y: n,
              },
              vertices: k.fromPath(
                0.5 > u
                  ? "L 0 0 L " +
                      x +
                      " " +
                      -r +
                      " L " +
                      q +
                      " " +
                      -r +
                      " L " +
                      y +
                      " 0"
                  : "L 0 0 L " + q + " " + -r + " L " + y + " 0"
              ),
            };
            v.chamfer &&
              ((n = v.chamfer),
              (m.vertices = k.chamfer(
                m.vertices,
                n.radius,
                n.quality,
                n.qualityMin,
                n.qualityMax
              )),
              delete v.chamfer);
            return b.create(e.extend({}, m, v));
          };
          d.circle = function (m, n, q, r, u) {
            r = r || {};
            var v = {
              label: "Circle Body",
              circleRadius: q,
            };
            u = Math.ceil(Math.max(10, Math.min(u || 25, q)));
            1 === u % 2 && (u += 1);
            return d.polygon(m, n, u, q, e.extend({}, v, r));
          };
          d.polygon = function (m, n, q, r, u) {
            u = u || {};
            if (3 > q) return d.circle(m, n, r, u);
            for (
              var v = (2 * Math.PI) / q, x = "", y = 0.5 * v, z = 0;
              z < q;
              z += 1
            ) {
              var A = y + z * v,
                B = Math.sin(A) * r;
              x +=
                "L " + (Math.cos(A) * r).toFixed(3) + " " + B.toFixed(3) + " ";
            }
            m = {
              label: "Polygon Body",
              position: {
                x: m,
                y: n,
              },
              vertices: k.fromPath(x),
            };
            u.chamfer &&
              ((n = u.chamfer),
              (m.vertices = k.chamfer(
                m.vertices,
                n.radius,
                n.quality,
                n.qualityMin,
                n.qualityMax
              )),
              delete u.chamfer);
            return b.create(e.extend({}, m, u));
          };
          d.fromVertices = function (m, n, q, r, u, v, x) {
            var y, z;
            r = r || {};
            var A = [];
            u = "undefined" !== typeof u ? u : !1;
            v = "undefined" !== typeof v ? v : 0.01;
            x = "undefined" !== typeof x ? x : 10;
            g ||
              e.warn(
                "Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull."
              );
            e.isArray(q[0]) || (q = [q]);
            for (z = 0; z < q.length; z += 1) {
              var B = q[z];
              if ((y = k.isConvex(B)) || !g)
                (B = y ? k.clockwiseSort(B) : k.hull(B)),
                  A.push({
                    position: {
                      x: m,
                      y: n,
                    },
                    vertices: B,
                  });
              else
                for (
                  y = B.map(function (E) {
                    return [E.x, E.y];
                  }),
                    g.makeCCW(y),
                    !1 !== v && g.removeCollinearPoints(y, v),
                    B = g.quickDecomp(y),
                    y = 0;
                  y < B.length;
                  y++
                ) {
                  var D = B[y].map(function (E) {
                    return {
                      x: E[0],
                      y: E[1],
                    };
                  });
                  (0 < x && k.area(D) < x) ||
                    A.push({
                      position: k.centre(D),
                      vertices: D,
                    });
                }
            }
            for (y = 0; y < A.length; y++) A[y] = b.create(e.extend(A[y], r));
            u && d.flagCoincidentParts(A, 5);
            return 1 < A.length
              ? ((q = b.create(
                  e.extend(
                    {
                      parts: A.slice(0),
                    },
                    r
                  )
                )),
                b.setPosition(q, {
                  x: m,
                  y: n,
                }),
                q)
              : A[0];
          };
          d.flagCoincidentParts = function (m, n) {
            void 0 === n && (n = 5);
            for (var q = 0; q < m.length; q++)
              for (var r = m[q], u = q + 1; u < m.length; u++) {
                var v = m[u];
                if (c.overlaps(r.bounds, v.bounds))
                  for (
                    var x = r.vertices, y = v.vertices, z = 0;
                    z < r.vertices.length;
                    z++
                  )
                    for (var A = 0; A < v.vertices.length; A++) {
                      var B = f.magnitudeSquared(
                          f.sub(x[(z + 1) % x.length], y[A])
                        ),
                        D = f.magnitudeSquared(
                          f.sub(x[z], y[(A + 1) % y.length])
                        );
                      B < n &&
                        D < n &&
                        ((x[z].isInternal = !0), (y[A].isInternal = !0));
                    }
              }
            return m;
          };
        })();
      },
      function (h, t) {
        h.exports = function (a) {
          return a.x - a.width * a.originX + 0.5 * a.width;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          a.x = d + a.width * a.originX - 0.5 * a.width;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a.y - a.height * a.originY + 0.5 * a.height;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          a.y = d + a.height * a.originY - 0.5 * a.height;
          return a;
        };
      },
      function (h, t, a) {
        h.exports = {
          POST_RENDER: a(628),
          PRE_RENDER: a(629),
          RENDER: a(630),
          RESIZE: a(631),
        };
      },
      function (h, t) {
        h.exports = {
          BITMAPMASK_PIPELINE: "BitmapMaskPipeline",
          LIGHT_PIPELINE: "Light2D",
          POINTLIGHT_PIPELINE: "PointLightPipeline",
          SINGLE_PIPELINE: "SinglePipeline",
          MULTI_PIPELINE: "MultiPipeline",
          ROPE_PIPELINE: "RopePipeline",
          GRAPHICS_PIPELINE: "GraphicsPipeline",
          POSTFX_PIPELINE: "PostFXPipeline",
          UTILITY_PIPELINE: "UtilityPipeline",
        };
      },
      function (h, t, a) {
        var d = a(74);
        h.exports = function (k, e, b, c) {
          void 0 === c && (c = k);
          if (!Array.isArray(e)) {
            var f = k.indexOf(e);
            return -1 !== f ? (d(k, f), b && b.call(c, e), e) : null;
          }
          for (var g = e.length - 1, m = []; 0 <= g; ) {
            var n = e[g];
            f = k.indexOf(n);
            -1 !== f && (d(k, f), m.push(n), b && b.call(c, n));
            g--;
          }
          return m;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(199),
          k = a(10),
          e = a(3);
        a = new t({
          initialize: function (b) {
            this.type = b;
            this.defaultDivisions = 5;
            this.arcLengthDivisions = 100;
            this.cacheArcLengths = [];
            this.active = this.needsUpdate = !0;
            this._tmpVec2A = new e();
            this._tmpVec2B = new e();
          },
          draw: function (b, c) {
            void 0 === c && (c = 32);
            return b.strokePoints(this.getPoints(c));
          },
          getBounds: function (b, c) {
            b || (b = new k());
            void 0 === c && (c = 16);
            var f = this.getLength();
            c > f && (c = f / 2);
            return d(this.getSpacedPoints(Math.max(1, Math.round(f / c))), b);
          },
          getDistancePoints: function (b) {
            var c = this.getLength();
            return this.getSpacedPoints(Math.max(1, c / b));
          },
          getEndPoint: function (b) {
            void 0 === b && (b = new e());
            return this.getPointAt(1, b);
          },
          getLength: function () {
            var b = this.getLengths();
            return b[b.length - 1];
          },
          getLengths: function (b) {
            void 0 === b && (b = this.arcLengthDivisions);
            if (this.cacheArcLengths.length === b + 1 && !this.needsUpdate)
              return this.cacheArcLengths;
            this.needsUpdate = !1;
            var c = [],
              f = this.getPoint(0, this._tmpVec2A),
              g = 0;
            c.push(0);
            for (var m = 1; m <= b; m++) {
              var n = this.getPoint(m / b, this._tmpVec2B);
              g += n.distance(f);
              c.push(g);
              f.copy(n);
            }
            return (this.cacheArcLengths = c);
          },
          getPointAt: function (b, c) {
            b = this.getUtoTmapping(b);
            return this.getPoint(b, c);
          },
          getPoints: function (b, c, f) {
            void 0 === f && (f = []);
            b || (b = c ? this.getLength() / c : this.defaultDivisions);
            for (c = 0; c <= b; c++) f.push(this.getPoint(c / b));
            return f;
          },
          getRandomPoint: function (b) {
            void 0 === b && (b = new e());
            return this.getPoint(Math.random(), b);
          },
          getSpacedPoints: function (b, c, f) {
            void 0 === f && (f = []);
            b || (b = c ? this.getLength() / c : this.defaultDivisions);
            for (c = 0; c <= b; c++) {
              var g = this.getUtoTmapping(c / b, null, b);
              f.push(this.getPoint(g));
            }
            return f;
          },
          getStartPoint: function (b) {
            void 0 === b && (b = new e());
            return this.getPointAt(0, b);
          },
          getTangent: function (b, c) {
            void 0 === c && (c = new e());
            var f = b - 1e-4;
            b += 1e-4;
            0 > f && (f = 0);
            1 < b && (b = 1);
            this.getPoint(f, this._tmpVec2A);
            this.getPoint(b, c);
            return c.subtract(this._tmpVec2A).normalize();
          },
          getTangentAt: function (b, c) {
            b = this.getUtoTmapping(b);
            return this.getTangent(b, c);
          },
          getTFromDistance: function (b, c) {
            return 0 >= b ? 0 : this.getUtoTmapping(0, b, c);
          },
          getUtoTmapping: function (b, c, f) {
            f = this.getLengths(f);
            var g = f.length;
            c = c ? Math.min(c, f[g - 1]) : b * f[g - 1];
            for (var m = 0, n = g - 1, q; m <= n; )
              if (((b = Math.floor(m + (n - m) / 2)), (q = f[b] - c), 0 > q))
                m = b + 1;
              else if (0 < q) n = b - 1;
              else {
                n = b;
                break;
              }
            b = n;
            if (f[b] === c) return b / (g - 1);
            m = f[b];
            return (b + (c - m) / (f[b + 1] - m)) / (g - 1);
          },
          updateArcLengths: function () {
            this.needsUpdate = !0;
            this.getLengths();
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          ADD: a(968),
          COMPLETE: a(969),
          FILE_COMPLETE: a(970),
          FILE_KEY_COMPLETE: a(971),
          FILE_LOAD_ERROR: a(972),
          FILE_LOAD: a(973),
          FILE_PROGRESS: a(974),
          POST_PROCESS: a(975),
          PROGRESS: a(976),
          START: a(977),
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e, b) {
          void 0 === b && (b = new d());
          var c = k.x1,
            f = k.y1,
            g = k.x2;
          k = k.y2;
          var m = e.x1,
            n = e.y1,
            q = e.x2,
            r = e.y2;
          e = (r - n) * (g - c) - (q - m) * (k - f);
          if (0 === e) return !1;
          q = ((q - m) * (f - n) - (r - n) * (c - m)) / e;
          m = ((g - c) * (f - n) - (k - f) * (c - m)) / e;
          return 0 <= q && 1 >= q && 0 <= m && 1 >= m
            ? ((b.x = c + q * (g - c)), (b.y = f + q * (k - f)), !0)
            : !1;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return Math.atan2(a.y2 - a.y1, a.x2 - a.x1);
        };
      },
      function (h, t, a) {
        var d = a(18);
        h.exports = function (k, e, b) {
          k = d(k, 0, 1);
          return (b - e) * k + e;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          return a ? (a.hasOwnProperty(d) ? a[d] : k) : k;
        };
      },
      function (h, t) {
        h.exports = {
          CREATED: 0,
          INIT: 1,
          DELAY: 2,
          OFFSET_DELAY: 3,
          PENDING_RENDER: 4,
          PLAYING_FORWARD: 5,
          PLAYING_BACKWARD: 6,
          HOLD_DELAY: 7,
          REPEAT_DELAY: 8,
          COMPLETE: 9,
          PENDING_ADD: 20,
          PAUSED: 21,
          LOOP_DELAY: 22,
          ACTIVE: 23,
          COMPLETE_DELAY: 24,
          PENDING_REMOVE: 25,
          REMOVED: 26,
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(315);
        a = new t({
          initialize: function (k, e) {
            this.parent = k;
            this.events = e;
            e || (this.events = k.events ? k.events : k);
            this.list = {};
            this.values = {};
            this._frozen = !1;
            if (!k.hasOwnProperty("sys") && this.events)
              this.events.once(d.DESTROY, this.destroy, this);
          },
          get: function (k) {
            var e = this.list;
            if (Array.isArray(k)) {
              for (var b = [], c = 0; c < k.length; c++) b.push(e[k[c]]);
              return b;
            }
            return e[k];
          },
          getAll: function () {
            var k = {},
              e;
            for (e in this.list)
              this.list.hasOwnProperty(e) && (k[e] = this.list[e]);
            return k;
          },
          query: function (k) {
            var e = {},
              b;
            for (b in this.list)
              this.list.hasOwnProperty(b) &&
                b.match(k) &&
                (e[b] = this.list[b]);
            return e;
          },
          set: function (k, e) {
            if (this._frozen) return this;
            if ("string" === typeof k) return this.setValue(k, e);
            for (var b in k) this.setValue(b, k[b]);
            return this;
          },
          inc: function (k, e) {
            if (this._frozen) return this;
            void 0 === e && (e = 1);
            var b = this.get(k);
            void 0 === b && (b = 0);
            this.set(k, b + e);
            return this;
          },
          toggle: function (k) {
            if (this._frozen) return this;
            this.set(k, !this.get(k));
            return this;
          },
          setValue: function (k, e) {
            if (this._frozen) return this;
            if (this.has(k)) this.values[k] = e;
            else {
              var b = this,
                c = this.list,
                f = this.events,
                g = this.parent;
              Object.defineProperty(this.values, k, {
                enumerable: !0,
                configurable: !0,
                get: function () {
                  return c[k];
                },
                set: function (m) {
                  if (!b._frozen) {
                    var n = c[k];
                    c[k] = m;
                    f.emit(d.CHANGE_DATA, g, k, m, n);
                    f.emit(d.CHANGE_DATA_KEY + k, g, m, n);
                  }
                },
              });
              c[k] = e;
              f.emit(d.SET_DATA, g, k, e);
            }
            return this;
          },
          each: function (k, e) {
            for (
              var b = [this.parent, null, void 0], c = 1;
              c < arguments.length;
              c++
            )
              b.push(arguments[c]);
            for (var f in this.list)
              (b[1] = f), (b[2] = this.list[f]), k.apply(e, b);
            return this;
          },
          merge: function (k, e) {
            void 0 === e && (e = !0);
            for (var b in k)
              k.hasOwnProperty(b) &&
                (e || (!e && !this.has(b))) &&
                this.setValue(b, k[b]);
            return this;
          },
          remove: function (k) {
            if (this._frozen) return this;
            if (Array.isArray(k))
              for (var e = 0; e < k.length; e++) this.removeValue(k[e]);
            else return this.removeValue(k);
            return this;
          },
          removeValue: function (k) {
            if (this.has(k)) {
              var e = this.list[k];
              delete this.list[k];
              delete this.values[k];
              this.events.emit(d.REMOVE_DATA, this.parent, k, e);
            }
            return this;
          },
          pop: function (k) {
            var e = void 0;
            !this._frozen &&
              this.has(k) &&
              ((e = this.list[k]),
              delete this.list[k],
              delete this.values[k],
              this.events.emit(d.REMOVE_DATA, this.parent, k, e));
            return e;
          },
          has: function (k) {
            return this.list.hasOwnProperty(k);
          },
          setFreeze: function (k) {
            this._frozen = k;
            return this;
          },
          reset: function () {
            for (var k in this.list) delete this.list[k], delete this.values[k];
            this._frozen = !1;
            return this;
          },
          destroy: function () {
            this.reset();
            this.events.off(d.CHANGE_DATA);
            this.events.off(d.SET_DATA);
            this.events.off(d.REMOVE_DATA);
            this.parent = null;
          },
          freeze: {
            get: function () {
              return this._frozen;
            },
            set: function (k) {
              this._frozen = k ? !0 : !1;
            },
          },
          count: {
            get: function () {
              var k = 0,
                e;
              for (e in this.list) void 0 !== this.list[e] && k++;
              return k;
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = new (a(0))({
          initialize: function (d) {
            this.entries = {};
            this.size = 0;
            if (Array.isArray(d))
              for (var k = 0; k < d.length; k++) this.set(d[k][0], d[k][1]);
          },
          set: function (d, k) {
            this.has(d) || this.size++;
            this.entries[d] = k;
            return this;
          },
          get: function (d) {
            if (this.has(d)) return this.entries[d];
          },
          getArray: function () {
            var d = [],
              k = this.entries,
              e;
            for (e in k) d.push(k[e]);
            return d;
          },
          has: function (d) {
            return this.entries.hasOwnProperty(d);
          },
          delete: function (d) {
            this.has(d) && (delete this.entries[d], this.size--);
            return this;
          },
          clear: function () {
            Object.keys(this.entries).forEach(function (d) {
              delete this.entries[d];
            }, this);
            this.size = 0;
            return this;
          },
          keys: function () {
            return Object.keys(this.entries);
          },
          values: function () {
            var d = [],
              k = this.entries,
              e;
            for (e in k) d.push(k[e]);
            return d;
          },
          dump: function () {
            var d = this.entries;
            console.group("Map");
            for (var k in d);
            console.groupEnd();
          },
          each: function (d) {
            var k = this.entries,
              e;
            for (e in k) if (!1 === d(e, k[e])) break;
            return this;
          },
          contains: function (d) {
            var k = this.entries,
              e;
            for (e in k) if (k[e] === d) return !0;
            return !1;
          },
          merge: function (d, k) {
            void 0 === k && (k = !1);
            var e = this.entries;
            d = d.entries;
            for (var b in d)
              e.hasOwnProperty(b) && k ? (e[b] = d[b]) : this.set(b, d[b]);
            return this;
          },
        });
        h.exports = t;
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          return (a << 16) | (d << 8) | k;
        };
      },
      function (h, t, a) {
        h.exports = {
          ENTER_FULLSCREEN: a(800),
          FULLSCREEN_FAILED: a(801),
          FULLSCREEN_UNSUPPORTED: a(802),
          LEAVE_FULLSCREEN: a(803),
          ORIENTATION_CHANGE: a(804),
          RESIZE: a(805),
        };
      },
      function (h, t, a) {
        t = a(807);
        a = {
          android: !1,
          chromeOS: !1,
          cordova: !1,
          crosswalk: !1,
          desktop: !1,
          ejecta: !1,
          electron: !1,
          iOS: !1,
          iOSVersion: 0,
          iPad: !1,
          iPhone: !1,
          kindle: !1,
          linux: !1,
          macOS: !1,
          node: !1,
          nodeWebkit: !1,
          pixelRatio: 1,
          webApp: !1,
          windows: !1,
          windowsPhone: !1,
        };
        if ("function" !== typeof importScripts) {
          var d = navigator.userAgent;
          /Windows/.test(d)
            ? (a.windows = !0)
            : /Mac OS/.test(d) && !/like Mac OS/.test(d)
            ? navigator.maxTouchPoints && 2 < navigator.maxTouchPoints
              ? ((a.iOS = !0),
                (a.iPad = !0),
                navigator.appVersion.match(/Version\/(\d+)/),
                (a.iOSVersion = parseInt(RegExp.$1, 10)))
              : (a.macOS = !0)
            : /Android/.test(d)
            ? (a.android = !0)
            : /Linux/.test(d)
            ? (a.linux = !0)
            : /iP[ao]d|iPhone/i.test(d)
            ? ((a.iOS = !0),
              navigator.appVersion.match(/OS (\d+)/),
              (a.iOSVersion = parseInt(RegExp.$1, 10)),
              (a.iPhone = -1 !== d.toLowerCase().indexOf("iphone")),
              (a.iPad = -1 !== d.toLowerCase().indexOf("ipad")))
            : /Kindle/.test(d) ||
              /\bKF[A-Z][A-Z]+/.test(d) ||
              /Silk.*Mobile Safari/.test(d)
            ? (a.kindle = !0)
            : /CrOS/.test(d) && (a.chromeOS = !0);
          if (/Windows Phone/i.test(d) || /IEMobile/i.test(d))
            (a.android = !1),
              (a.iOS = !1),
              (a.macOS = !1),
              (a.windows = !0),
              (a.windowsPhone = !0);
          var k = /Silk/.test(d);
          if (a.windows || a.macOS || (a.linux && !k) || a.chromeOS)
            a.desktop = !0;
          if (a.windowsPhone || (/Windows NT/i.test(d) && /Touch/i.test(d)))
            a.desktop = !1;
          navigator.standalone && (a.webApp = !0);
          "function" !== typeof importScripts &&
            (void 0 !== window.cordova && (a.cordova = !0),
            void 0 !== window.ejecta && (a.ejecta = !0));
          "undefined" !== typeof t &&
            t.versions &&
            t.versions.node &&
            (a.node = !0);
          a.node &&
            "object" === typeof t.versions &&
            ((a.nodeWebkit = !!t.versions["node-webkit"]),
            (a.electron = !!t.versions.electron));
          /Crosswalk/.test(d) && (a.crosswalk = !0);
          a.pixelRatio = window.devicePixelRatio || 1;
        }
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          ADD: a(861),
          ERROR: a(862),
          LOAD: a(863),
          READY: a(864),
          REMOVE: a(865),
        };
      },
      function (h, t) {
        h.exports = {
          BYTE: {
            enum: 5120,
            size: 1,
          },
          UNSIGNED_BYTE: {
            enum: 5121,
            size: 1,
          },
          SHORT: {
            enum: 5122,
            size: 2,
          },
          UNSIGNED_SHORT: {
            enum: 5123,
            size: 2,
          },
          INT: {
            enum: 5124,
            size: 4,
          },
          UNSIGNED_INT: {
            enum: 5125,
            size: 4,
          },
          FLOAT: {
            enum: 5126,
            size: 4,
          },
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(59),
          k = a(2),
          e = a(878),
          b = a(879),
          c = a(25),
          f = a(12),
          g = a(107),
          m = a(58);
        a = new t({
          Extends: m,
          initialize: function (n) {
            var q = n.game.renderer,
              r = k(n, "fragShader", e);
            n.fragShader = f.parseFragmentShaderMaxTextures(r, q.maxTextures);
            n.vertShader = k(n, "vertShader", b);
            n.attributes = k(n, "attributes", [
              {
                name: "inPosition",
                size: 2,
              },
              {
                name: "inTexCoord",
                size: 2,
              },
              {
                name: "inTexId",
              },
              {
                name: "inTintEffect",
              },
              {
                name: "inTint",
                size: 4,
                type: g.UNSIGNED_BYTE,
                normalized: !0,
              },
            ]);
            m.call(this, n);
            this._tempMatrix1 = new c();
            this._tempMatrix2 = new c();
            this._tempMatrix3 = new c();
            this.calcMatrix = new c();
            this.tempTriangle = [
              {
                x: 0,
                y: 0,
                width: 0,
              },
              {
                x: 0,
                y: 0,
                width: 0,
              },
              {
                x: 0,
                y: 0,
                width: 0,
              },
              {
                x: 0,
                y: 0,
                width: 0,
              },
            ];
            this.strokeTint = {
              TL: 0,
              TR: 0,
              BL: 0,
              BR: 0,
            };
            this.fillTint = {
              TL: 0,
              TR: 0,
              BL: 0,
              BR: 0,
            };
            this.currentFrame = {
              u0: 0,
              v0: 0,
              u1: 1,
              v1: 1,
            };
            this.firstQuad = [0, 0, 0, 0, 0];
            this.prevQuad = [0, 0, 0, 0, 0];
            this.polygonCache = [];
          },
          boot: function () {
            m.prototype.boot.call(this);
            this.currentShader.set1iv(
              "uMainSampler",
              this.renderer.textureIndexes
            );
          },
          batchSprite: function (n, q, r) {
            this.manager.set(this, n);
            var u = this._tempMatrix1,
              v = this._tempMatrix2,
              x = this._tempMatrix3,
              y = n.frame,
              z = y.glTexture,
              A = y.u0,
              B = y.v0,
              D = y.u1,
              E = y.v1,
              C = y.x,
              F = y.y,
              G = y.cutWidth,
              H = y.cutHeight,
              K = y.customPivot,
              I = n.displayOriginX,
              M = n.displayOriginY,
              N = -I + C;
            C = -M + F;
            n.isCropped &&
              ((N = n._crop),
              (N.flipX === n.flipX && N.flipY === n.flipY) ||
                y.updateCropUVs(N, n.flipX, n.flipY),
              (A = N.u0),
              (B = N.v0),
              (D = N.u1),
              (E = N.v1),
              (G = N.width),
              (H = N.height),
              (C = N.x),
              (F = N.y),
              (N = -I + C),
              (C = -M + F));
            var P = (F = 1);
            n.flipX && (K || (N += -y.realWidth + 2 * I), (F = -1));
            if (n.flipY || (y.source.isGLTexture && !z.flipY))
              K || (C += -y.realHeight + 2 * M), (P = -1);
            v.applyITRS(n.x, n.y, n.rotation, n.scaleX * F, n.scaleY * P);
            u.copyFrom(q.matrix);
            r
              ? (u.multiplyWithOffset(
                  r,
                  -q.scrollX * n.scrollFactorX,
                  -q.scrollY * n.scrollFactorY
                ),
                (v.e = n.x),
                (v.f = n.y))
              : ((v.e -= q.scrollX * n.scrollFactorX),
                (v.f -= q.scrollY * n.scrollFactorY));
            u.multiply(v, x);
            I = N + G;
            G = C + H;
            M = q.roundPixels;
            H = x.getXRound(N, C, M);
            r = x.getYRound(N, C, M);
            u = x.getXRound(N, G, M);
            N = x.getYRound(N, G, M);
            v = x.getXRound(I, G, M);
            G = x.getYRound(I, G, M);
            K = x.getXRound(I, C, M);
            x = x.getYRound(I, C, M);
            M = f.getTintAppendFloatAlpha;
            F = q.alpha;
            q = M(n.tintTopLeft, F * n._alphaTL);
            C = M(n.tintTopRight, F * n._alphaTR);
            I = M(n.tintBottomLeft, F * n._alphaBL);
            M = M(n.tintBottomRight, F * n._alphaBR);
            this.shouldFlush(6) && this.flush();
            y = this.setGameObject(n, y);
            this.manager.preBatch(n);
            this.batchQuad(
              n,
              H,
              r,
              u,
              N,
              v,
              G,
              K,
              x,
              A,
              B,
              D,
              E,
              q,
              C,
              I,
              M,
              n.tintFill,
              z,
              y
            );
            this.manager.postBatch(n);
          },
          batchTexture: function (
            n,
            q,
            r,
            u,
            v,
            x,
            y,
            z,
            A,
            B,
            D,
            E,
            C,
            F,
            G,
            H,
            K,
            I,
            M,
            N,
            P,
            J,
            L,
            O,
            Q,
            S,
            R,
            T,
            U,
            V,
            X,
            W
          ) {
            this.manager.set(this, n);
            var Z = this._tempMatrix1,
              aa = this._tempMatrix2,
              Y = this._tempMatrix3,
              ba = I / r + R,
              da = M / u + T,
              ea = (I + N) / r + R,
              fa = (M + P) / u + T,
              ca = y,
              la = z;
            I = -H;
            M = -K;
            if (n.isCropped) {
              ba = n._crop;
              ea = ba.width;
              fa = ba.height;
              ca = ea;
              la = fa;
              y = ea;
              z = fa;
              I = ba.x;
              M = ba.y;
              var ja = I,
                ia = M;
              E && (ja = N - ba.x - ea);
              C && (ia = P - ba.y - fa);
              ba = ja / r + R;
              da = ia / u + T;
              ea = (ja + ea) / r + R;
              fa = (ia + fa) / u + T;
              I = -H + I;
              M = -K + M;
            }
            C ^= !X && q.isRenderTexture ? 1 : 0;
            E && ((ca *= -1), (I += y));
            C && ((la *= -1), (M += z));
            r = I + ca;
            la = M + la;
            aa.applyITRS(v, x, D, A, B);
            Z.copyFrom(U.matrix);
            V
              ? (Z.multiplyWithOffset(V, -U.scrollX * F, -U.scrollY * G),
                (aa.e = v),
                (aa.f = x))
              : ((aa.e -= U.scrollX * F), (aa.f -= U.scrollY * G));
            Z.multiply(aa, Y);
            B = U.roundPixels;
            v = Y.getXRound(I, M, B);
            x = Y.getYRound(I, M, B);
            A = Y.getXRound(I, la, B);
            D = Y.getYRound(I, la, B);
            F = Y.getXRound(r, la, B);
            G = Y.getYRound(r, la, B);
            U = Y.getXRound(r, M, B);
            Y = Y.getYRound(r, M, B);
            void 0 === W && (W = this.renderer.setTexture2D(q));
            n && this.manager.preBatch(n);
            this.batchQuad(
              n,
              v,
              x,
              A,
              D,
              F,
              G,
              U,
              Y,
              ba,
              da,
              ea,
              fa,
              J,
              L,
              O,
              Q,
              S,
              q,
              W
            );
            n && this.manager.postBatch(n);
          },
          batchTextureFrame: function (n, q, r, u, v, x, y) {
            this.manager.set(this);
            var z = this._tempMatrix1.copyFrom(x);
            x = this._tempMatrix2;
            var A = q + n.width,
              B = r + n.height;
            y ? z.multiply(y, x) : (x = z);
            y = x.getX(q, r);
            z = x.getY(q, r);
            var D = x.getX(q, B);
            q = x.getY(q, B);
            var E = x.getX(A, B);
            B = x.getY(A, B);
            var C = x.getX(A, r);
            r = x.getY(A, r);
            x = this.renderer.setTextureSource(n.source);
            u = f.getTintAppendFloatAlpha(u, v);
            this.batchQuad(
              null,
              y,
              z,
              D,
              q,
              E,
              B,
              C,
              r,
              n.u0,
              n.v0,
              n.u1,
              n.v1,
              u,
              u,
              u,
              u,
              0,
              n.glTexture,
              x
            );
          },
          batchFillRect: function (n, q, r, u, v, x) {
            this.renderer.pipelines.set(this);
            var y = this.calcMatrix;
            x && x.multiply(v, y);
            x = n + r;
            var z = q + u;
            u = y.getX(n, q);
            r = y.getY(n, q);
            v = y.getX(n, z);
            n = y.getY(n, z);
            var A = y.getX(x, z);
            z = y.getY(x, z);
            var B = y.getX(x, q);
            q = y.getY(x, q);
            y = this.fillTint;
            this.batchQuad(
              null,
              u,
              r,
              v,
              n,
              A,
              z,
              B,
              q,
              0,
              0,
              1,
              1,
              y.TL,
              y.TR,
              y.BL,
              y.BR,
              2
            );
          },
          batchFillTriangle: function (n, q, r, u, v, x, y, z) {
            this.renderer.pipelines.set(this);
            var A = this.calcMatrix;
            z && z.multiply(y, A);
            y = A.getX(n, q);
            n = A.getY(n, q);
            q = A.getX(r, u);
            r = A.getY(r, u);
            u = A.getX(v, x);
            v = A.getY(v, x);
            x = this.fillTint;
            this.batchTri(
              null,
              y,
              n,
              q,
              r,
              u,
              v,
              0,
              0,
              1,
              1,
              x.TL,
              x.TR,
              x.BL,
              2
            );
          },
          batchStrokeTriangle: function (n, q, r, u, v, x, y, z, A) {
            var B = this.tempTriangle;
            B[0].x = n;
            B[0].y = q;
            B[0].width = y;
            B[1].x = r;
            B[1].y = u;
            B[1].width = y;
            B[2].x = v;
            B[2].y = x;
            B[2].width = y;
            B[3].x = n;
            B[3].y = q;
            B[3].width = y;
            this.batchStrokePath(B, y, !1, z, A);
          },
          batchFillPath: function (n, q, r) {
            this.renderer.pipelines.set(this);
            var u = this.calcMatrix;
            r && r.multiply(q, u);
            q = n.length;
            r = this.polygonCache;
            for (
              var v,
                x = this.fillTint.TL,
                y = this.fillTint.TR,
                z = this.fillTint.BL,
                A = 0;
              A < q;
              ++A
            )
              (v = n[A]), r.push(v.x, v.y);
            n = d(r);
            q = n.length;
            for (v = 0; v < q; v += 3) {
              var B = 2 * n[v + 0];
              A = 2 * n[v + 1];
              var D = 2 * n[v + 2],
                E = r[B + 0],
                C = r[B + 1];
              B = r[A + 0];
              var F = r[A + 1];
              A = r[D + 0];
              var G = r[D + 1];
              D = u.getX(E, C);
              E = u.getY(E, C);
              C = u.getX(B, F);
              B = u.getY(B, F);
              F = u.getX(A, G);
              A = u.getY(A, G);
              this.batchTri(null, D, E, C, B, F, A, 0, 0, 1, 1, x, y, z, 2);
            }
            r.length = 0;
          },
          batchStrokePath: function (n, q, r, u, v) {
            this.renderer.pipelines.set(this);
            this.prevQuad[4] = 0;
            this.firstQuad[4] = 0;
            for (var x = n.length - 1, y = 0; y < x; y++) {
              var z = n[y],
                A = n[y + 1];
              this.batchLine(
                z.x,
                z.y,
                A.x,
                A.y,
                z.width / 2,
                A.width / 2,
                q,
                y,
                !r && y === x - 1,
                u,
                v
              );
            }
          },
          batchLine: function (n, q, r, u, v, x, y, z, A, B, D) {
            this.renderer.pipelines.set(this);
            var E = this.calcMatrix;
            D && D.multiply(B, E);
            B = r - n;
            D = u - q;
            var C = Math.sqrt(B * B + D * D);
            B = (v * (u - q)) / C;
            D = (v * (n - r)) / C;
            var F = (x * (u - q)) / C,
              G = (x * (n - r)) / C;
            C = r - F;
            var H = u - G;
            x = n - B;
            v = q - D;
            r += F;
            F = u + G;
            B = n + B;
            G = q + D;
            q = E.getX(C, H);
            n = E.getY(C, H);
            u = E.getX(x, v);
            x = E.getY(x, v);
            v = E.getX(r, F);
            r = E.getY(r, F);
            D = E.getX(B, G);
            E = E.getY(B, G);
            F = this.strokeTint;
            B = F.TL;
            C = F.TR;
            H = F.BL;
            F = F.BR;
            this.batchQuad(
              null,
              D,
              E,
              u,
              x,
              q,
              n,
              v,
              r,
              0,
              0,
              1,
              1,
              B,
              C,
              H,
              F,
              2
            );
            2 >= y ||
              ((y = this.prevQuad),
              (G = this.firstQuad),
              0 < z && y[4]
                ? this.batchQuad(
                    null,
                    D,
                    E,
                    u,
                    x,
                    y[0],
                    y[1],
                    y[2],
                    y[3],
                    0,
                    0,
                    1,
                    1,
                    B,
                    C,
                    H,
                    F,
                    2
                  )
                : ((G[0] = D), (G[1] = E), (G[2] = u), (G[3] = x), (G[4] = 1)),
              A && G[4]
                ? this.batchQuad(
                    null,
                    q,
                    n,
                    v,
                    r,
                    G[0],
                    G[1],
                    G[2],
                    G[3],
                    0,
                    0,
                    1,
                    1,
                    B,
                    C,
                    H,
                    F,
                    2
                  )
                : ((y[0] = q), (y[1] = n), (y[2] = v), (y[3] = r), (y[4] = 1)));
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(18),
          k = a(17),
          e = new t({
            initialize: function (b, c, f, g, m, n, q) {
              this.texture = b;
              this.name = c;
              this.source = b.source[f];
              this.sourceIndex = f;
              this.glTexture = this.source.glTexture;
              this.cutX;
              this.cutY;
              this.cutWidth;
              this.cutHeight;
              this.y = this.x = 0;
              this.width;
              this.height;
              this.halfWidth;
              this.halfHeight;
              this.centerX;
              this.centerY;
              this.pivotY = this.pivotX = 0;
              this.rotated = this.customPivot = !1;
              this.autoRound = -1;
              this.customData = {};
              this.v1 = this.u1 = this.v0 = this.u0 = 0;
              this.data = {
                cut: {
                  x: 0,
                  y: 0,
                  w: 0,
                  h: 0,
                  r: 0,
                  b: 0,
                },
                trim: !1,
                sourceSize: {
                  w: 0,
                  h: 0,
                },
                spriteSourceSize: {
                  x: 0,
                  y: 0,
                  w: 0,
                  h: 0,
                  r: 0,
                  b: 0,
                },
                radius: 0,
                drawImage: {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0,
                },
              };
              this.setSize(n, q, g, m);
            },
            setSize: function (b, c, f, g) {
              void 0 === f && (f = 0);
              void 0 === g && (g = 0);
              this.cutX = f;
              this.cutY = g;
              this.cutWidth = b;
              this.cutHeight = c;
              this.width = b;
              this.height = c;
              this.halfWidth = Math.floor(0.5 * b);
              this.halfHeight = Math.floor(0.5 * c);
              this.centerX = Math.floor(b / 2);
              this.centerY = Math.floor(c / 2);
              var m = this.data,
                n = m.cut;
              n.x = f;
              n.y = g;
              n.w = b;
              n.h = c;
              n.r = f + b;
              n.b = g + c;
              m.sourceSize.w = b;
              m.sourceSize.h = c;
              m.spriteSourceSize.w = b;
              m.spriteSourceSize.h = c;
              m.radius = 0.5 * Math.sqrt(b * b + c * c);
              m = m.drawImage;
              m.x = f;
              m.y = g;
              m.width = b;
              m.height = c;
              return this.updateUVs();
            },
            setTrim: function (b, c, f, g, m, n) {
              var q = this.data,
                r = q.spriteSourceSize;
              q.trim = !0;
              q.sourceSize.w = b;
              q.sourceSize.h = c;
              r.x = f;
              r.y = g;
              r.w = m;
              r.h = n;
              r.r = f + m;
              r.b = g + n;
              this.x = f;
              this.y = g;
              this.width = m;
              this.height = n;
              this.halfWidth = 0.5 * m;
              this.halfHeight = 0.5 * n;
              this.centerX = Math.floor(m / 2);
              this.centerY = Math.floor(n / 2);
              return this.updateUVs();
            },
            setCropUVs: function (b, c, f, g, m, n, q) {
              var r = this.cutX,
                u = this.cutY,
                v = this.cutWidth,
                x = this.cutHeight,
                y = this.realWidth,
                z = this.realHeight;
              c = d(c, 0, y);
              f = d(f, 0, z);
              g = d(g, 0, y - c);
              m = d(m, 0, z - f);
              y = r + c;
              var A = u + f;
              z = g;
              var B = m,
                D = this.data;
              D.trim
                ? ((A = D.spriteSourceSize),
                  (g = d(g, 0, v - c)),
                  (m = d(m, 0, x - f)),
                  (z = c + g),
                  (y = f + m),
                  A.r < c || A.b < f || A.x > z || A.y > y
                    ? (B = z = A = y = 0)
                    : ((c = Math.max(A.x, c)),
                      (f = Math.max(A.y, f)),
                      (g = Math.min(A.r, z) - c),
                      (m = Math.min(A.b, y) - f),
                      (z = g),
                      (B = m),
                      (y = n ? r + (v - (c - A.x) - g) : r + (c - A.x)),
                      (A = q ? u + (x - (f - A.y) - m) : u + (f - A.y))))
                : (n && (y = r + (v - c - g)), q && (A = u + (x - f - m)));
              r = this.source.width;
              u = this.source.height;
              b.u0 = Math.max(0, y / r);
              b.v0 = Math.max(0, A / u);
              b.u1 = Math.min(1, (y + z) / r);
              b.v1 = Math.min(1, (A + B) / u);
              b.x = c;
              b.y = f;
              b.cx = y;
              b.cy = A;
              b.cw = z;
              b.ch = B;
              b.width = g;
              b.height = m;
              b.flipX = n;
              b.flipY = q;
              return b;
            },
            updateCropUVs: function (b, c, f) {
              return this.setCropUVs(b, b.x, b.y, b.width, b.height, c, f);
            },
            setUVs: function (b, c, f, g, m, n) {
              var q = this.data.drawImage;
              q.width = b;
              q.height = c;
              this.u0 = f;
              this.v0 = g;
              this.u1 = m;
              this.v1 = n;
              return this;
            },
            updateUVs: function () {
              var b = this.cutX,
                c = this.cutY,
                f = this.cutWidth,
                g = this.cutHeight,
                m = this.data.drawImage;
              m.width = f;
              m.height = g;
              m = this.source.width;
              var n = this.source.height;
              this.u0 = b / m;
              this.v0 = c / n;
              this.u1 = (b + f) / m;
              this.v1 = (c + g) / n;
              return this;
            },
            updateUVsInverted: function () {
              var b = this.source.width,
                c = this.source.height;
              this.u0 = (this.cutX + this.cutHeight) / b;
              this.v0 = this.cutY / c;
              this.u1 = this.cutX / b;
              this.v1 = (this.cutY + this.cutWidth) / c;
              return this;
            },
            clone: function () {
              var b = new e(this.texture, this.name, this.sourceIndex);
              b.cutX = this.cutX;
              b.cutY = this.cutY;
              b.cutWidth = this.cutWidth;
              b.cutHeight = this.cutHeight;
              b.x = this.x;
              b.y = this.y;
              b.width = this.width;
              b.height = this.height;
              b.halfWidth = this.halfWidth;
              b.halfHeight = this.halfHeight;
              b.centerX = this.centerX;
              b.centerY = this.centerY;
              b.rotated = this.rotated;
              b.data = k(!0, b.data, this.data);
              b.updateUVs();
              return b;
            },
            destroy: function () {
              this.data =
                this.customData =
                this.glTexture =
                this.texture =
                this.source =
                  null;
            },
            realWidth: {
              get: function () {
                return this.data.sourceSize.w;
              },
            },
            realHeight: {
              get: function () {
                return this.data.sourceSize.h;
              },
            },
            radius: {
              get: function () {
                return this.data.radius;
              },
            },
            trimmed: {
              get: function () {
                return this.data.trim;
              },
            },
            canvasData: {
              get: function () {
                return this.data.drawImage;
              },
            },
          });
        h.exports = e;
      },
      function (h, t, a) {
        var d = a(208);
        t = a(0);
        var k = a(1),
          e = a(79);
        a = new t({
          initialize: function (b) {
            this.parent = b;
            this.list = [];
            this.position = 0;
            this.removeCallback = this.addCallback = k;
            this._sortKey = "";
          },
          add: function (b, c) {
            return c
              ? d.Add(this.list, b)
              : d.Add(this.list, b, 0, this.addCallback, this);
          },
          addAt: function (b, c, f) {
            return f
              ? d.AddAt(this.list, b, c)
              : d.AddAt(this.list, b, c, 0, this.addCallback, this);
          },
          getAt: function (b) {
            return this.list[b];
          },
          getIndex: function (b) {
            return this.list.indexOf(b);
          },
          sort: function (b, c) {
            if (!b) return this;
            void 0 === c &&
              (c = function (f, g) {
                return f[b] - g[b];
              });
            e(this.list, c);
            return this;
          },
          getByName: function (b) {
            return d.GetFirst(this.list, "name", b);
          },
          getRandom: function (b, c) {
            return d.GetRandom(this.list, b, c);
          },
          getFirst: function (b, c, f, g) {
            return d.GetFirst(this.list, b, c, f, g);
          },
          getAll: function (b, c, f, g) {
            return d.GetAll(this.list, b, c, f, g);
          },
          count: function (b, c) {
            return d.CountAllMatching(this.list, b, c);
          },
          swap: function (b, c) {
            d.Swap(this.list, b, c);
          },
          moveTo: function (b, c) {
            return d.MoveTo(this.list, b, c);
          },
          moveAbove: function (b, c) {
            return d.MoveAbove(this.list, b, c);
          },
          moveBelow: function (b, c) {
            return d.MoveBelow(this.list, b, c);
          },
          remove: function (b, c) {
            return c
              ? d.Remove(this.list, b)
              : d.Remove(this.list, b, this.removeCallback, this);
          },
          removeAt: function (b, c) {
            return c
              ? d.RemoveAt(this.list, b)
              : d.RemoveAt(this.list, b, this.removeCallback, this);
          },
          removeBetween: function (b, c, f) {
            return f
              ? d.RemoveBetween(this.list, b, c)
              : d.RemoveBetween(this.list, b, c, this.removeCallback, this);
          },
          removeAll: function (b) {
            for (var c = this.list.length; c--; ) this.remove(this.list[c], b);
            return this;
          },
          bringToTop: function (b) {
            return d.BringToTop(this.list, b);
          },
          sendToBack: function (b) {
            return d.SendToBack(this.list, b);
          },
          moveUp: function (b) {
            d.MoveUp(this.list, b);
            return b;
          },
          moveDown: function (b) {
            d.MoveDown(this.list, b);
            return b;
          },
          reverse: function () {
            this.list.reverse();
            return this;
          },
          shuffle: function () {
            d.Shuffle(this.list);
            return this;
          },
          replace: function (b, c) {
            return d.Replace(this.list, b, c);
          },
          exists: function (b) {
            return -1 < this.list.indexOf(b);
          },
          setAll: function (b, c, f, g) {
            d.SetAll(this.list, b, c, f, g);
            return this;
          },
          each: function (b, c) {
            for (var f = [null], g = 2; g < arguments.length; g++)
              f.push(arguments[g]);
            for (g = 0; g < this.list.length; g++)
              (f[0] = this.list[g]), b.apply(c, f);
          },
          shutdown: function () {
            this.removeAll();
            this.list = [];
          },
          destroy: function () {
            this.removeAll();
            this.removeCallback = this.addCallback = this.parent = null;
          },
          length: {
            get: function () {
              return this.list.length;
            },
          },
          first: {
            get: function () {
              this.position = 0;
              return 0 < this.list.length ? this.list[0] : null;
            },
          },
          last: {
            get: function () {
              return 0 < this.list.length
                ? ((this.position = this.list.length - 1),
                  this.list[this.position])
                : null;
            },
          },
          next: {
            get: function () {
              return this.position < this.list.length
                ? (this.position++, this.list[this.position])
                : null;
            },
          },
          previous: {
            get: function () {
              return 0 < this.position
                ? (this.position--, this.list[this.position])
                : null;
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(112),
          k = a(445),
          e = a(446),
          b = a(56),
          c = a(180);
        a = new t({
          initialize: function (f, g, m, n) {
            void 0 === f && (f = 0);
            void 0 === g && (g = 0);
            void 0 === m && (m = 0);
            void 0 === n && (n = 0);
            this.type = b.ELLIPSE;
            this.x = f;
            this.y = g;
            this.width = m;
            this.height = n;
          },
          contains: function (f, g) {
            return d(this, f, g);
          },
          getPoint: function (f, g) {
            return k(this, f, g);
          },
          getPoints: function (f, g, m) {
            return e(this, f, g, m);
          },
          getRandomPoint: function (f) {
            return c(this, f);
          },
          setTo: function (f, g, m, n) {
            this.x = f;
            this.y = g;
            this.width = m;
            this.height = n;
            return this;
          },
          setEmpty: function () {
            this.height = this.width = 0;
            return this;
          },
          setPosition: function (f, g) {
            void 0 === g && (g = f);
            this.x = f;
            this.y = g;
            return this;
          },
          setSize: function (f, g) {
            void 0 === g && (g = f);
            this.width = f;
            this.height = g;
            return this;
          },
          isEmpty: function () {
            return 0 >= this.width || 0 >= this.height;
          },
          getMinorRadius: function () {
            return Math.min(this.width, this.height) / 2;
          },
          getMajorRadius: function () {
            return Math.max(this.width, this.height) / 2;
          },
          left: {
            get: function () {
              return this.x - this.width / 2;
            },
            set: function (f) {
              this.x = f + this.width / 2;
            },
          },
          right: {
            get: function () {
              return this.x + this.width / 2;
            },
            set: function (f) {
              this.x = f - this.width / 2;
            },
          },
          top: {
            get: function () {
              return this.y - this.height / 2;
            },
            set: function (f) {
              this.y = f + this.height / 2;
            },
          },
          bottom: {
            get: function () {
              return this.y + this.height / 2;
            },
            set: function (f) {
              this.y = f - this.height / 2;
            },
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          if (0 >= a.width || 0 >= a.height) return !1;
          d = (d - a.x) / a.width;
          a = (k - a.y) / a.height;
          return 0.25 > d * d + a * a;
        };
      },
      function (h, t, a) {
        var d = a(275);
        t = a(0);
        var k = a(75),
          e = a(9),
          b = a(207),
          c = a(2),
          f = a(6),
          g = a(7),
          m = a(437),
          n = a(149),
          q = a(73);
        a = new t({
          Extends: e,
          initialize: function (r, u, v) {
            e.call(this);
            v
              ? u && !Array.isArray(u) && (u = [u])
              : Array.isArray(u)
              ? g(u[0]) && ((v = u), (u = null))
              : g(u) && ((v = u), (u = null));
            this.scene = r;
            this.children = new n();
            this.isParent = !0;
            this.type = "Group";
            this.classType = c(v, "classType", q);
            this.name = c(v, "name", "");
            this.active = c(v, "active", !0);
            this.maxSize = c(v, "maxSize", -1);
            this.defaultKey = c(v, "defaultKey", null);
            this.defaultFrame = c(v, "defaultFrame", null);
            this.runChildUpdate = c(v, "runChildUpdate", !1);
            this.createCallback = c(v, "createCallback", null);
            this.removeCallback = c(v, "removeCallback", null);
            this.createMultipleCallback = c(v, "createMultipleCallback", null);
            this.internalCreateCallback = c(v, "internalCreateCallback", null);
            this.internalRemoveCallback = c(v, "internalRemoveCallback", null);
            u && this.addMultiple(u);
            v && this.createMultiple(v);
            this.on(k.ADDED_TO_SCENE, this.addedToScene, this);
            this.on(k.REMOVED_FROM_SCENE, this.removedFromScene, this);
          },
          addedToScene: function () {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function () {
            this.scene.sys.updateList.remove(this);
          },
          create: function (r, u, v, x, y, z) {
            void 0 === r && (r = 0);
            void 0 === u && (u = 0);
            void 0 === v && (v = this.defaultKey);
            void 0 === x && (x = this.defaultFrame);
            void 0 === y && (y = !0);
            void 0 === z && (z = !0);
            if (this.isFull()) return null;
            r = new this.classType(this.scene, r, u, v, x);
            r.addToDisplayList(this.scene.sys.displayList);
            r.addToUpdateList();
            r.visible = y;
            r.setActive(z);
            this.add(r);
            return r;
          },
          createMultiple: function (r) {
            if (this.isFull()) return [];
            Array.isArray(r) || (r = [r]);
            var u = [];
            if (r[0].key)
              for (var v = 0; v < r.length; v++) {
                var x = this.createFromConfig(r[v]);
                u = u.concat(x);
              }
            return u;
          },
          createFromConfig: function (r) {
            if (this.isFull()) return [];
            this.classType = c(r, "classType", this.classType);
            var u = c(r, "key", void 0),
              v = c(r, "frame", null),
              x = c(r, "visible", !0),
              y = c(r, "active", !0),
              z = [];
            if (void 0 === u) return z;
            Array.isArray(u) || (u = [u]);
            Array.isArray(v) || (v = [v]);
            var A = c(r, "repeat", 0),
              B = c(r, "randomKey", !1),
              D = c(r, "randomFrame", !1),
              E = c(r, "yoyo", !1),
              C = c(r, "quantity", !1),
              F = c(r, "frameQuantity", 1),
              G = c(r, "max", 0);
            u = m(u, v, {
              max: G,
              qty: C ? C : F,
              random: B,
              randomB: D,
              repeat: A,
              yoyo: E,
            });
            r.createCallback && (this.createCallback = r.createCallback);
            r.removeCallback && (this.removeCallback = r.removeCallback);
            for (v = 0; v < u.length; v++) {
              A = this.create(0, 0, u[v].a, u[v].b, x, y);
              if (!A) break;
              z.push(A);
            }
            x = f(r, "setXY.x", 0);
            y = f(r, "setXY.y", 0);
            u = f(r, "setXY.stepX", 0);
            v = f(r, "setXY.stepY", 0);
            d.SetXY(z, x, y, u, v);
            x = f(r, "setRotation.value", 0);
            y = f(r, "setRotation.step", 0);
            d.SetRotation(z, x, y);
            x = f(r, "setScale.x", 1);
            y = f(r, "setScale.y", x);
            u = f(r, "setScale.stepX", 0);
            v = f(r, "setScale.stepY", 0);
            d.SetScale(z, x, y, u, v);
            x = f(r, "setOrigin.x", 0.5);
            y = f(r, "setOrigin.y", x);
            u = f(r, "setOrigin.stepX", 0);
            v = f(r, "setOrigin.stepY", 0);
            d.SetOrigin(z, x, y, u, v);
            x = f(r, "setAlpha.value", 1);
            y = f(r, "setAlpha.step", 0);
            d.SetAlpha(z, x, y);
            x = f(r, "setDepth.value", 0);
            y = f(r, "setDepth.step", 0);
            d.SetDepth(z, x, y);
            x = f(r, "setScrollFactor.x", 1);
            y = f(r, "setScrollFactor.y", x);
            u = f(r, "setScrollFactor.stepX", 0);
            v = f(r, "setScrollFactor.stepY", 0);
            d.SetScrollFactor(z, x, y, u, v);
            x = c(r, "hitArea", null);
            y = c(r, "hitAreaCallback", null);
            x && d.SetHitArea(z, x, y);
            (r = c(r, "gridAlign", !1)) && d.GridAlign(z, r);
            this.createMultipleCallback &&
              this.createMultipleCallback.call(this, z);
            return z;
          },
          preUpdate: function (r, u) {
            if (this.runChildUpdate && 0 !== this.children.size)
              for (
                var v = this.children.entries.slice(), x = 0;
                x < v.length;
                x++
              ) {
                var y = v[x];
                y.active && y.update(r, u);
              }
          },
          add: function (r, u) {
            void 0 === u && (u = !1);
            if (this.isFull()) return this;
            this.children.set(r);
            this.internalCreateCallback &&
              this.internalCreateCallback.call(this, r);
            this.createCallback && this.createCallback.call(this, r);
            u &&
              (r.addToDisplayList(this.scene.sys.displayList),
              r.addToUpdateList());
            r.on(k.DESTROY, this.remove, this);
            return this;
          },
          addMultiple: function (r, u) {
            void 0 === u && (u = !1);
            if (Array.isArray(r))
              for (var v = 0; v < r.length; v++) this.add(r[v], u);
            return this;
          },
          remove: function (r, u, v) {
            void 0 === u && (u = !1);
            void 0 === v && (v = !1);
            if (!this.children.contains(r)) return this;
            this.children.delete(r);
            this.internalRemoveCallback &&
              this.internalRemoveCallback.call(this, r);
            this.removeCallback && this.removeCallback.call(this, r);
            r.off(k.DESTROY, this.remove, this);
            v
              ? r.destroy()
              : u && (r.removeFromDisplayList(), r.removeFromUpdateList());
            return this;
          },
          clear: function (r, u) {
            void 0 === r && (r = !1);
            void 0 === u && (u = !1);
            for (var v = this.children, x = 0; x < v.size; x++) {
              var y = v.entries[x];
              y.off(k.DESTROY, this.remove, this);
              u
                ? y.destroy()
                : r && (y.removeFromDisplayList(), y.removeFromUpdateList());
            }
            this.children.clear();
            return this;
          },
          contains: function (r) {
            return this.children.contains(r);
          },
          getChildren: function () {
            return this.children.entries;
          },
          getLength: function () {
            return this.children.size;
          },
          getMatching: function (r, u, v, x) {
            return b(this.children.entries, r, u, v, x);
          },
          getFirst: function (r, u, v, x, y, z, A) {
            return this.getHandler(!0, 1, r, u, v, x, y, z, A);
          },
          getFirstNth: function (r, u, v, x, y, z, A, B) {
            return this.getHandler(!0, r, u, v, x, y, z, A, B);
          },
          getLast: function (r, u, v, x, y, z, A) {
            return this.getHandler(!1, 1, r, u, v, x, y, z, A);
          },
          getLastNth: function (r, u, v, x, y, z, A, B) {
            return this.getHandler(!1, r, u, v, x, y, z, A, B);
          },
          getHandler: function (r, u, v, x, y, z, A, B, D) {
            void 0 === v && (v = !1);
            void 0 === x && (x = !1);
            var E = 0,
              C = this.children.entries;
            if (r)
              for (r = 0; r < C.length; r++) {
                var F = C[r];
                if (F.active === v) {
                  if ((E++, E === u)) break;
                } else F = null;
              }
            else
              for (r = C.length - 1; 0 <= r; r--)
                if (((F = C[r]), F.active === v)) {
                  if ((E++, E === u)) break;
                } else F = null;
            return F
              ? ("number" === typeof y && (F.x = y),
                "number" === typeof z && (F.y = z),
                F)
              : x
              ? this.create(y, z, A, B, D)
              : null;
          },
          get: function (r, u, v, x, y) {
            return this.getFirst(!1, !0, r, u, v, x, y);
          },
          getFirstAlive: function (r, u, v, x, y, z) {
            return this.getFirst(!0, r, u, v, x, y, z);
          },
          getFirstDead: function (r, u, v, x, y, z) {
            return this.getFirst(!1, r, u, v, x, y, z);
          },
          playAnimation: function (r, u) {
            d.PlayAnimation(this.children.entries, r, u);
            return this;
          },
          isFull: function () {
            return -1 === this.maxSize
              ? !1
              : this.children.size >= this.maxSize;
          },
          countActive: function (r) {
            void 0 === r && (r = !0);
            for (var u = 0, v = 0; v < this.children.size; v++)
              this.children.entries[v].active === r && u++;
            return u;
          },
          getTotalUsed: function () {
            return this.countActive();
          },
          getTotalFree: function () {
            var r = this.getTotalUsed();
            return (-1 === this.maxSize ? 999999999999 : this.maxSize) - r;
          },
          setActive: function (r) {
            this.active = r;
            return this;
          },
          setName: function (r) {
            this.name = r;
            return this;
          },
          propertyValueSet: function (r, u, v, x, y) {
            d.PropertyValueSet(this.children.entries, r, u, v, x, y);
            return this;
          },
          propertyValueInc: function (r, u, v, x, y) {
            d.PropertyValueInc(this.children.entries, r, u, v, x, y);
            return this;
          },
          setX: function (r, u) {
            d.SetX(this.children.entries, r, u);
            return this;
          },
          setY: function (r, u) {
            d.SetY(this.children.entries, r, u);
            return this;
          },
          setXY: function (r, u, v, x) {
            d.SetXY(this.children.entries, r, u, v, x);
            return this;
          },
          incX: function (r, u) {
            d.IncX(this.children.entries, r, u);
            return this;
          },
          incY: function (r, u) {
            d.IncY(this.children.entries, r, u);
            return this;
          },
          incXY: function (r, u, v, x) {
            d.IncXY(this.children.entries, r, u, v, x);
            return this;
          },
          shiftPosition: function (r, u, v) {
            d.ShiftPosition(this.children.entries, r, u, v);
            return this;
          },
          angle: function (r, u) {
            d.Angle(this.children.entries, r, u);
            return this;
          },
          rotate: function (r, u) {
            d.Rotate(this.children.entries, r, u);
            return this;
          },
          rotateAround: function (r, u) {
            d.RotateAround(this.children.entries, r, u);
            return this;
          },
          rotateAroundDistance: function (r, u, v) {
            d.RotateAroundDistance(this.children.entries, r, u, v);
            return this;
          },
          setAlpha: function (r, u) {
            d.SetAlpha(this.children.entries, r, u);
            return this;
          },
          setTint: function (r, u, v, x) {
            d.SetTint(this.children.entries, r, u, v, x);
            return this;
          },
          setOrigin: function (r, u, v, x) {
            d.SetOrigin(this.children.entries, r, u, v, x);
            return this;
          },
          scaleX: function (r, u) {
            d.ScaleX(this.children.entries, r, u);
            return this;
          },
          scaleY: function (r, u) {
            d.ScaleY(this.children.entries, r, u);
            return this;
          },
          scaleXY: function (r, u, v, x) {
            d.ScaleXY(this.children.entries, r, u, v, x);
            return this;
          },
          setDepth: function (r, u) {
            d.SetDepth(this.children.entries, r, u);
            return this;
          },
          setBlendMode: function (r) {
            d.SetBlendMode(this.children.entries, r);
            return this;
          },
          setHitArea: function (r, u) {
            d.SetHitArea(this.children.entries, r, u);
            return this;
          },
          shuffle: function () {
            d.Shuffle(this.children.entries);
            return this;
          },
          kill: function (r) {
            this.children.contains(r) && r.setActive(!1);
          },
          killAndHide: function (r) {
            this.children.contains(r) && (r.setActive(!1), r.setVisible(!1));
          },
          setVisible: function (r, u, v) {
            d.SetVisible(this.children.entries, r, u, v);
            return this;
          },
          toggleVisible: function () {
            d.ToggleVisible(this.children.entries);
            return this;
          },
          destroy: function (r, u) {
            void 0 === r && (r = !1);
            void 0 === u && (u = !1);
            this.scene &&
              !this.ignoreDestroy &&
              (this.emit(k.DESTROY, this),
              this.removeAllListeners(),
              this.scene.sys.updateList.remove(this),
              this.clear(u, r),
              (this.children = this.scene = void 0));
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(12);
        h.exports = function (k, e, b, c, f, g) {
          c = d.getTintAppendFloatAlpha(b.fillColor, b.fillAlpha * c);
          for (
            var m = b.pathData, n = b.pathIndexes, q = 0;
            q < n.length;
            q += 3
          ) {
            var r = 2 * n[q],
              u = 2 * n[q + 1],
              v = 2 * n[q + 2],
              x = m[r + 0] - f,
              y = m[r + 1] - g;
            r = m[u + 0] - f;
            var z = m[u + 1] - g;
            u = m[v + 0] - f;
            var A = m[v + 1] - g;
            v = e.getX(x, y);
            x = e.getY(x, y);
            y = e.getX(r, z);
            r = e.getY(r, z);
            z = e.getX(u, A);
            u = e.getY(u, A);
            k.batchTri(b, v, x, y, r, z, u, 0, 0, 1, 1, c, c, c, 2);
          }
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          var e = a.x3 - a.x1,
            b = a.y3 - a.y1,
            c = a.x2 - a.x1,
            f = a.y2 - a.y1;
          d -= a.x1;
          var g = k - a.y1;
          a = e * e + b * b;
          k = e * c + b * f;
          e = e * d + b * g;
          b = c * c + f * f;
          c = c * d + f * g;
          f = a * b - k * k;
          f = 0 === f ? 0 : 1 / f;
          d = (b * e - k * c) * f;
          a = (a * c - k * e) * f;
          return 0 <= d && 0 <= a && 1 > d + a;
        };
      },
      function (h, t, a) {
        function d(b, c, f, g) {
          b -= f;
          c -= g;
          return Math.sqrt(b * b + c * c);
        }
        t = a(0);
        var k = a(10),
          e = a(3);
        a = new t({
          initialize: function (b, c, f) {
            this.vertex1 = b;
            this.vertex2 = c;
            this.vertex3 = f;
            this.bounds = new k();
            this._inCenter = new e();
          },
          getInCenter: function (b) {
            void 0 === b && (b = !0);
            var c = this.vertex1,
              f = this.vertex2,
              g = this.vertex3;
            if (b) {
              b = c.x;
              c = c.y;
              var m = f.x;
              f = f.y;
              var n = g.x;
              g = g.y;
            } else
              (b = c.vx),
                (c = c.vy),
                (m = f.vx),
                (f = f.vy),
                (n = g.vx),
                (g = g.vy);
            var q = d(n, g, m, f),
              r = d(b, c, n, g),
              u = d(m, f, b, c),
              v = q + r + u;
            return this._inCenter.set(
              (b * q + m * r + n * u) / v,
              (c * q + f * r + g * u) / v
            );
          },
          contains: function (b, c, f) {
            var g = this.vertex1,
              m = this.vertex2,
              n = this.vertex3,
              q = g.vx,
              r = g.vy,
              u = m.vx,
              v = m.vy,
              x = n.vx,
              y = n.vy;
            if (f) {
              x = f.a;
              y = f.b;
              var z = f.c,
                A = f.d,
                B = f.e;
              f = f.f;
              q = g.vx * x + g.vy * z + B;
              r = g.vx * y + g.vy * A + f;
              u = m.vx * x + m.vy * z + B;
              v = m.vx * y + m.vy * A + f;
              x = n.vx * x + n.vy * z + B;
              y = n.vx * y + n.vy * A + f;
            }
            g = x - q;
            m = y - r;
            u -= q;
            v -= r;
            b -= q;
            n = c - r;
            c = g * g + m * m;
            r = g * u + m * v;
            q = g * b + m * n;
            g = u * u + v * v;
            b = u * b + v * n;
            v = c * g - r * r;
            v = 0 === v ? 0 : 1 / v;
            u = (g * q - r * b) * v;
            c = (c * b - r * q) * v;
            return 0 <= u && 0 <= c && 1 > u + c;
          },
          isCounterClockwise: function (b) {
            var c = this.vertex1,
              f = this.vertex2,
              g = this.vertex3;
            c = (f.vx - c.vx) * (g.vy - c.vy) - (f.vy - c.vy) * (g.vx - c.vx);
            return 0 >= b ? 0 <= c : 0 > c;
          },
          load: function (b, c, f, g, m) {
            f = this.vertex1.load(b, c, f, g, m);
            f = this.vertex2.load(b, c, f, g, m);
            return (f = this.vertex3.load(b, c, f, g, m));
          },
          transformCoordinatesLocal: function (b, c, f, g) {
            this.vertex1.transformCoordinatesLocal(b, c, f, g);
            this.vertex2.transformCoordinatesLocal(b, c, f, g);
            this.vertex3.transformCoordinatesLocal(b, c, f, g);
            return this;
          },
          updateBounds: function () {
            var b = this.vertex1,
              c = this.vertex2,
              f = this.vertex3,
              g = this.bounds;
            g.x = Math.min(b.vx, c.vx, f.vx);
            g.y = Math.min(b.vy, c.vy, f.vy);
            g.width = Math.max(b.vx, c.vx, f.vx) - g.x;
            g.height = Math.max(b.vy, c.vy, f.vy) - g.y;
            return this;
          },
          isInView: function (b, c, f, g, m, n, q, r, u, v, x) {
            var y = this.vertex1.update(m, n, q, r, u, v, x, g),
              z = this.vertex2.update(m, n, q, r, u, v, x, g);
            g = this.vertex3.update(m, n, q, r, u, v, x, g);
            if (
              (0 >= y.ta && 0 >= z.ta && 0 >= g.ta) ||
              (c && !this.isCounterClockwise(f))
            )
              return !1;
            c = this.bounds;
            c.x = Math.min(y.tx, z.tx, g.tx);
            c.y = Math.min(y.ty, z.ty, g.ty);
            c.width = Math.max(y.tx, z.tx, g.tx) - c.x;
            c.height = Math.max(y.ty, z.ty, g.ty) - c.y;
            y = b.x + b.width;
            z = b.y + b.height;
            return 0 >= c.width ||
              0 >= c.height ||
              0 >= b.width ||
              0 >= b.height
              ? !1
              : !(c.right < b.x || c.bottom < b.y || c.x > y || c.y > z);
          },
          translate: function (b, c) {
            void 0 === c && (c = 0);
            var f = this.vertex1,
              g = this.vertex2,
              m = this.vertex3;
            f.x += b;
            f.y += c;
            g.x += b;
            g.y += c;
            m.x += b;
            m.y += c;
            return this;
          },
          x: {
            get: function () {
              return this.getInCenter().x;
            },
            set: function (b) {
              var c = this.getInCenter();
              this.translate(b - c.x, 0);
            },
          },
          y: {
            get: function () {
              return this.getInCenter().y;
            },
            set: function (b) {
              var c = this.getInCenter();
              this.translate(0, b - c.y);
            },
          },
          alpha: {
            get: function () {
              return (
                (this.vertex1.alpha + this.vertex2.alpha + this.vertex3.alpha) /
                3
              );
            },
            set: function (b) {
              this.vertex1.alpha = b;
              this.vertex2.alpha = b;
              this.vertex3.alpha = b;
            },
          },
          depth: {
            get: function () {
              return (this.vertex1.vz + this.vertex2.vz + this.vertex3.vz) / 3;
            },
          },
          destroy: function () {
            this.vertex3 = this.vertex2 = this.vertex1 = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(12),
          k = a(39);
        a = new t({
          Extends: k,
          initialize: function (e, b, c, f, g, m, n, q, r, u) {
            void 0 === m && (m = 16777215);
            void 0 === n && (n = 1);
            void 0 === q && (q = 0);
            void 0 === r && (r = 0);
            void 0 === u && (u = 0);
            k.call(this, e, b, c);
            this.vz = this.vy = this.vx = 0;
            this.nx = q;
            this.ny = r;
            this.nz = u;
            this.u = f;
            this.v = g;
            this.color = m;
            this.alpha = n;
            this.ta = this.ty = this.tx = 0;
          },
          setUVs: function (e, b) {
            this.u = e;
            this.v = b;
            return this;
          },
          transformCoordinatesLocal: function (e, b, c, f) {
            var g = this.x,
              m = this.y,
              n = this.z;
            e = e.val;
            var q = g * e[1] + m * e[5] + n * e[9] + e[13],
              r = g * e[2] + m * e[6] + n * e[10] + e[14],
              u = g * e[3] + m * e[7] + n * e[11] + e[15];
            this.vx = ((g * e[0] + m * e[4] + n * e[8] + e[12]) / u) * b;
            this.vy = -(q / u) * c;
            this.vz = 0 >= f ? r / u : -(r / u);
          },
          update: function (e, b, c, f, g, m, n, q) {
            e = this.vx * e + this.vy * c + g;
            b = this.vx * b + this.vy * f + m;
            n && ((e = Math.round(e)), (b = Math.round(b)));
            this.tx = e;
            this.ty = b;
            this.ta = this.alpha * q;
            return this;
          },
          load: function (e, b, c, f, g) {
            e[++c] = this.tx;
            e[++c] = this.ty;
            e[++c] = this.u;
            e[++c] = this.v;
            e[++c] = f;
            e[++c] = g;
            b[++c] = d.getTintAppendFloatAlpha(this.color, this.ta);
            return c;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(166),
          e = a(32),
          b = a(84),
          c = a(41);
        (function () {
          d.create = function (f) {
            return e.extend(
              {
                id: e.nextId(),
                type: "composite",
                parent: null,
                isModified: !1,
                bodies: [],
                constraints: [],
                composites: [],
                label: "Composite",
                plugin: {},
              },
              f
            );
          };
          d.setModified = function (f, g, m, n) {
            k.trigger(f, "compositeModified", f);
            f.isModified = g;
            m && f.parent && d.setModified(f.parent, g, m, n);
            if (n)
              for (var q = 0; q < f.composites.length; q++)
                d.setModified(f.composites[q], g, m, n);
          };
          d.add = function (f, g) {
            var m = [].concat(g);
            k.trigger(f, "beforeAdd", {
              object: g,
            });
            for (var n = 0; n < m.length; n++) {
              var q = m[n];
              switch (q.type) {
                case "body":
                  if (q.parent !== q) {
                    e.warn(
                      "Composite.add: skipped adding a compound body part (you must add its parent instead)"
                    );
                    break;
                  }
                  d.addBody(f, q);
                  break;
                case "constraint":
                  d.addConstraint(f, q);
                  break;
                case "composite":
                  d.addComposite(f, q);
                  break;
                case "mouseConstraint":
                  d.addConstraint(f, q.constraint);
              }
            }
            k.trigger(f, "afterAdd", {
              object: g,
            });
            return f;
          };
          d.remove = function (f, g, m) {
            var n = [].concat(g);
            k.trigger(f, "beforeRemove", {
              object: g,
            });
            for (var q = 0; q < n.length; q++) {
              var r = n[q];
              switch (r.type) {
                case "body":
                  d.removeBody(f, r, m);
                  break;
                case "constraint":
                  d.removeConstraint(f, r, m);
                  break;
                case "composite":
                  d.removeComposite(f, r, m);
                  break;
                case "mouseConstraint":
                  d.removeConstraint(f, r.constraint);
              }
            }
            k.trigger(f, "afterRemove", {
              object: g,
            });
            return f;
          };
          d.addComposite = function (f, g) {
            f.composites.push(g);
            g.parent = f;
            d.setModified(f, !0, !0, !1);
            return f;
          };
          d.removeComposite = function (f, g, m) {
            var n = f.composites.indexOf(g);
            -1 !== n &&
              (d.removeCompositeAt(f, n), d.setModified(f, !0, !0, !1));
            if (m)
              for (m = 0; m < f.composites.length; m++)
                d.removeComposite(f.composites[m], g, !0);
            return f;
          };
          d.removeCompositeAt = function (f, g) {
            f.composites.splice(g, 1);
            d.setModified(f, !0, !0, !1);
            return f;
          };
          d.addBody = function (f, g) {
            f.bodies.push(g);
            d.setModified(f, !0, !0, !1);
            return f;
          };
          d.removeBody = function (f, g, m) {
            var n = f.bodies.indexOf(g);
            -1 !== n && (d.removeBodyAt(f, n), d.setModified(f, !0, !0, !1));
            if (m)
              for (m = 0; m < f.composites.length; m++)
                d.removeBody(f.composites[m], g, !0);
            return f;
          };
          d.removeBodyAt = function (f, g) {
            f.bodies.splice(g, 1);
            d.setModified(f, !0, !0, !1);
            return f;
          };
          d.addConstraint = function (f, g) {
            f.constraints.push(g);
            d.setModified(f, !0, !0, !1);
            return f;
          };
          d.removeConstraint = function (f, g, m) {
            var n = f.constraints.indexOf(g);
            -1 !== n && d.removeConstraintAt(f, n);
            if (m)
              for (m = 0; m < f.composites.length; m++)
                d.removeConstraint(f.composites[m], g, !0);
            return f;
          };
          d.removeConstraintAt = function (f, g) {
            f.constraints.splice(g, 1);
            d.setModified(f, !0, !0, !1);
            return f;
          };
          d.clear = function (f, g, m) {
            if (m)
              for (m = 0; m < f.composites.length; m++)
                d.clear(f.composites[m], g, !0);
            g
              ? (f.bodies = f.bodies.filter(function (n) {
                  return n.isStatic;
                }))
              : (f.bodies.length = 0);
            f.constraints.length = 0;
            f.composites.length = 0;
            d.setModified(f, !0, !0, !1);
            return f;
          };
          d.allBodies = function (f) {
            for (
              var g = [].concat(f.bodies), m = 0;
              m < f.composites.length;
              m++
            )
              g = g.concat(d.allBodies(f.composites[m]));
            return g;
          };
          d.allConstraints = function (f) {
            for (
              var g = [].concat(f.constraints), m = 0;
              m < f.composites.length;
              m++
            )
              g = g.concat(d.allConstraints(f.composites[m]));
            return g;
          };
          d.allComposites = function (f) {
            for (
              var g = [].concat(f.composites), m = 0;
              m < f.composites.length;
              m++
            )
              g = g.concat(d.allComposites(f.composites[m]));
            return g;
          };
          d.get = function (f, g, m) {
            switch (m) {
              case "body":
                var n = d.allBodies(f);
                break;
              case "constraint":
                n = d.allConstraints(f);
                break;
              case "composite":
                n = d.allComposites(f).concat(f);
            }
            if (!n) return null;
            f = n.filter(function (q) {
              return q.id.toString() === g.toString();
            });
            return 0 === f.length ? null : f[0];
          };
          d.move = function (f, g, m) {
            d.remove(f, g);
            d.add(m, g);
            return f;
          };
          d.rebase = function (f) {
            for (
              var g = d
                  .allBodies(f)
                  .concat(d.allConstraints(f))
                  .concat(d.allComposites(f)),
                m = 0;
              m < g.length;
              m++
            )
              g[m].id = e.nextId();
            d.setModified(f, !0, !0, !1);
            return f;
          };
          d.translate = function (f, g, m) {
            m = m ? d.allBodies(f) : f.bodies;
            for (var n = 0; n < m.length; n++) c.translate(m[n], g);
            d.setModified(f, !0, !0, !1);
            return f;
          };
          d.rotate = function (f, g, m, n) {
            var q = Math.cos(g),
              r = Math.sin(g);
            n = n ? d.allBodies(f) : f.bodies;
            for (var u = 0; u < n.length; u++) {
              var v = n[u],
                x = v.position.x - m.x,
                y = v.position.y - m.y;
              c.setPosition(v, {
                x: m.x + (x * q - y * r),
                y: m.y + (x * r + y * q),
              });
              c.rotate(v, g);
            }
            d.setModified(f, !0, !0, !1);
            return f;
          };
          d.scale = function (f, g, m, n, q) {
            q = q ? d.allBodies(f) : f.bodies;
            for (var r = 0; r < q.length; r++) {
              var u = q[r];
              c.setPosition(u, {
                x: n.x + (u.position.x - n.x) * g,
                y: n.y + (u.position.y - n.y) * m,
              });
              c.scale(u, g, m);
            }
            d.setModified(f, !0, !0, !1);
            return f;
          };
          d.bounds = function (f) {
            f = d.allBodies(f);
            for (var g = [], m = 0; m < f.length; m += 1) {
              var n = f[m];
              g.push(n.bounds.min, n.bounds.max);
            }
            return b.create(g);
          };
        })();
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          return 0 <= a && a < k.width && 0 <= d && d < k.height;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(29),
          k = a(2);
        a = new t({
          initialize: function (e) {
            void 0 === e && (e = {});
            this.name = k(e, "name", "layer");
            this.x = k(e, "x", 0);
            this.y = k(e, "y", 0);
            this.width = k(e, "width", 0);
            this.height = k(e, "height", 0);
            this.tileWidth = k(e, "tileWidth", 0);
            this.tileHeight = k(e, "tileHeight", 0);
            this.baseTileWidth = k(e, "baseTileWidth", this.tileWidth);
            this.baseTileHeight = k(e, "baseTileHeight", this.tileHeight);
            this.orientation = k(e, "orientation", d.ORTHOGONAL);
            this.widthInPixels = k(
              e,
              "widthInPixels",
              this.width * this.baseTileWidth
            );
            this.heightInPixels = k(
              e,
              "heightInPixels",
              this.height * this.baseTileHeight
            );
            this.alpha = k(e, "alpha", 1);
            this.visible = k(e, "visible", !0);
            this.properties = k(e, "properties", []);
            this.indexes = k(e, "indexes", []);
            this.collideIndexes = k(e, "collideIndexes", []);
            this.callbacks = k(e, "callbacks", []);
            this.bodies = k(e, "bodies", []);
            this.data = k(e, "data", []);
            this.tilemapLayer = k(e, "tilemapLayer", null);
            this.hexSideLength = k(e, "hexSideLength", 0);
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(29),
          k = a(2);
        a = new t({
          initialize: function (e) {
            void 0 === e && (e = {});
            this.name = k(e, "name", "map");
            this.width = k(e, "width", 0);
            this.height = k(e, "height", 0);
            this.infinite = k(e, "infinite", !1);
            this.tileWidth = k(e, "tileWidth", 0);
            this.tileHeight = k(e, "tileHeight", 0);
            this.widthInPixels = k(
              e,
              "widthInPixels",
              this.width * this.tileWidth
            );
            this.heightInPixels = k(
              e,
              "heightInPixels",
              this.height * this.tileHeight
            );
            this.format = k(e, "format", null);
            this.orientation = k(e, "orientation", d.ORTHOGONAL);
            this.renderOrder = k(e, "renderOrder", "right-down");
            this.version = k(e, "version", "1");
            this.properties = k(e, "properties", {});
            this.layers = k(e, "layers", []);
            this.images = k(e, "images", []);
            this.objects = k(e, "objects", {});
            this.collision = k(e, "collision", {});
            this.tilesets = k(e, "tilesets", []);
            this.imageCollections = k(e, "imageCollections", []);
            this.tiles = k(e, "tiles", []);
            this.hexSideLength = k(e, "hexSideLength", 0);
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = new (a(0))({
          initialize: function (d, k, e, b, c, f, g, m) {
            if (void 0 === e || 0 >= e) e = 32;
            if (void 0 === b || 0 >= b) b = 32;
            void 0 === c && (c = 0);
            void 0 === f && (f = 0);
            void 0 === g && (g = {});
            void 0 === m && (m = {});
            this.name = d;
            this.firstgid = k;
            this.tileWidth = e;
            this.tileHeight = b;
            this.tileMargin = c;
            this.tileSpacing = f;
            this.tileProperties = g;
            this.tileData = m;
            this.glTexture = this.image = null;
            this.total = this.columns = this.rows = 0;
            this.texCoordinates = [];
          },
          getTileProperties: function (d) {
            return this.containsTileIndex(d)
              ? this.tileProperties[d - this.firstgid]
              : null;
          },
          getTileData: function (d) {
            return this.containsTileIndex(d)
              ? this.tileData[d - this.firstgid]
              : null;
          },
          getTileCollisionGroup: function (d) {
            return (d = this.getTileData(d)) && d.objectgroup
              ? d.objectgroup
              : null;
          },
          containsTileIndex: function (d) {
            return d >= this.firstgid && d < this.firstgid + this.total;
          },
          getTileTextureCoordinates: function (d) {
            return this.containsTileIndex(d)
              ? this.texCoordinates[d - this.firstgid]
              : null;
          },
          setImage: function (d) {
            this.image = d;
            this.glTexture = d.get().source.glTexture;
            this.updateTileData(
              this.image.source[0].width,
              this.image.source[0].height
            );
            return this;
          },
          setTileSize: function (d, k) {
            void 0 !== d && (this.tileWidth = d);
            void 0 !== k && (this.tileHeight = k);
            this.image &&
              this.updateTileData(
                this.image.source[0].width,
                this.image.source[0].height
              );
            return this;
          },
          setSpacing: function (d, k) {
            void 0 !== d && (this.tileMargin = d);
            void 0 !== k && (this.tileSpacing = k);
            this.image &&
              this.updateTileData(
                this.image.source[0].width,
                this.image.source[0].height
              );
            return this;
          },
          updateTileData: function (d, k) {
            k =
              (k - 2 * this.tileMargin + this.tileSpacing) /
              (this.tileHeight + this.tileSpacing);
            d =
              (d - 2 * this.tileMargin + this.tileSpacing) /
              (this.tileWidth + this.tileSpacing);
            (0 === k % 1 && 0 === d % 1) ||
              console.warn(
                "Image tile area not tile size multiple in: " + this.name
              );
            k = Math.floor(k);
            d = Math.floor(d);
            this.rows = k;
            this.columns = d;
            this.total = k * d;
            this.texCoordinates.length = 0;
            k = d = this.tileMargin;
            for (var e = 0; e < this.rows; e++) {
              for (var b = 0; b < this.columns; b++)
                this.texCoordinates.push({
                  x: d,
                  y: k,
                }),
                  (d += this.tileWidth + this.tileSpacing);
              d = this.tileMargin;
              k += this.tileHeight + this.tileSpacing;
            }
            return this;
          },
        });
        h.exports = t;
      },
      function (h, t) {
        h.exports = {
          TOP_LEFT: 0,
          TOP_CENTER: 1,
          TOP_RIGHT: 2,
          LEFT_TOP: 3,
          LEFT_CENTER: 4,
          LEFT_BOTTOM: 5,
          CENTER: 6,
          RIGHT_TOP: 7,
          RIGHT_CENTER: 8,
          RIGHT_BOTTOM: 9,
          BOTTOM_LEFT: 10,
          BOTTOM_CENTER: 11,
          BOTTOM_RIGHT: 12,
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          void 0 === k && (k = 1e-4);
          return Math.abs(a - d) < k;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(11),
          k = a(15);
        a = a(1068);
        a = new t({
          Extends: k,
          Mixins: [
            d.Alpha,
            d.BlendMode,
            d.Depth,
            d.Flip,
            d.GetBounds,
            d.Mask,
            d.Origin,
            d.Pipeline,
            d.ScrollFactor,
            d.Size,
            d.TextureCrop,
            d.Tint,
            d.Transform,
            d.Visible,
            a,
          ],
          initialize: function (e, b, c, f, g) {
            k.call(this, e, "Image");
            this._crop = this.resetCropObject();
            this.setTexture(f, g);
            this.setPosition(b, c);
            this.setSizeToFrame();
            this.setOriginFromFrame();
            this.initPipeline();
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d) {
          return a.hasOwnProperty(d);
        };
      },
      function (h, t, a) {
        var d = a(77);
        h.exports = function (k, e) {
          k = d(k);
          for (var b in e) k.hasOwnProperty(b) || (k[b] = e[b]);
          return k;
        };
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(64),
          e = a(83),
          b = a(165),
          c = a(84),
          f = a(271),
          g = a(32);
        (function () {
          d._warming = 0.4;
          d._torqueDampen = 1;
          d._minLength = 1e-6;
          d.create = function (m) {
            m.bodyA &&
              !m.pointA &&
              (m.pointA = {
                x: 0,
                y: 0,
              });
            m.bodyB &&
              !m.pointB &&
              (m.pointB = {
                x: 0,
                y: 0,
              });
            var n = m.bodyA ? e.add(m.bodyA.position, m.pointA) : m.pointA,
              q = m.bodyB ? e.add(m.bodyB.position, m.pointB) : m.pointB;
            n = e.magnitude(e.sub(n, q));
            m.length = "undefined" !== typeof m.length ? m.length : n;
            m.id = m.id || g.nextId();
            m.label = m.label || "Constraint";
            m.type = "constraint";
            m.stiffness = m.stiffness || (0 < m.length ? 1 : 0.7);
            m.damping = m.damping || 0;
            m.angularStiffness = m.angularStiffness || 0;
            m.angleA = m.bodyA ? m.bodyA.angle : m.angleA;
            m.angleB = m.bodyB ? m.bodyB.angle : m.angleB;
            m.plugin = {};
            n = {
              visible: !0,
              type: "line",
              anchors: !0,
              lineColor: null,
              lineOpacity: null,
              lineThickness: null,
              pinSize: null,
              anchorColor: null,
              anchorSize: null,
            };
            0 === m.length && 0.1 < m.stiffness
              ? ((n.type = "pin"), (n.anchors = !1))
              : 0.9 > m.stiffness && (n.type = "spring");
            m.render = g.extend(n, m.render);
            return m;
          };
          d.preSolveAll = function (m) {
            for (var n = 0; n < m.length; n += 1) {
              var q = m[n],
                r = q.constraintImpulse;
              q.isStatic ||
                (0 === r.x && 0 === r.y && 0 === r.angle) ||
                ((q.position.x += r.x),
                (q.position.y += r.y),
                (q.angle += r.angle));
            }
          };
          d.solveAll = function (m, n) {
            for (var q = 0; q < m.length; q += 1) {
              var r = m[q],
                u = !r.bodyA || (r.bodyA && r.bodyA.isStatic);
              r = !r.bodyB || (r.bodyB && r.bodyB.isStatic);
              (u || r) && d.solve(m[q], n);
            }
            for (q = 0; q < m.length; q += 1)
              (r = m[q]),
                (u = !r.bodyA || (r.bodyA && r.bodyA.isStatic)),
                (r = !r.bodyB || (r.bodyB && r.bodyB.isStatic)),
                u || r || d.solve(m[q], n);
          };
          d.solve = function (m, n) {
            var q = m.bodyA,
              r = m.bodyB,
              u = m.pointA,
              v = m.pointB;
            if (q || r) {
              q &&
                !q.isStatic &&
                (e.rotate(u, q.angle - m.angleA, u), (m.angleA = q.angle));
              r &&
                !r.isStatic &&
                (e.rotate(v, r.angle - m.angleB, v), (m.angleB = r.angle));
              var x = u,
                y = v;
              q && (x = e.add(q.position, u));
              r && (y = e.add(r.position, v));
              if (x && y) {
                var z = e.sub(x, y),
                  A = e.magnitude(z);
                A < d._minLength && (A = d._minLength);
                n = e.mult(
                  z,
                  ((A - m.length) / A) *
                    (1 > m.stiffness ? m.stiffness * n : m.stiffness)
                );
                x = (q ? q.inverseMass : 0) + (r ? r.inverseMass : 0);
                y =
                  x + ((q ? q.inverseInertia : 0) + (r ? r.inverseInertia : 0));
                if (m.damping) {
                  var B = e.create();
                  var D = e.div(z, A);
                  B = e.sub(
                    (r && e.sub(r.position, r.positionPrev)) || B,
                    (q && e.sub(q.position, q.positionPrev)) || B
                  );
                  B = e.dot(D, B);
                }
                q &&
                  !q.isStatic &&
                  ((z = q.inverseMass / x),
                  (q.constraintImpulse.x -= n.x * z),
                  (q.constraintImpulse.y -= n.y * z),
                  (q.position.x -= n.x * z),
                  (q.position.y -= n.y * z),
                  m.damping &&
                    ((q.positionPrev.x -= m.damping * D.x * B * z),
                    (q.positionPrev.y -= m.damping * D.y * B * z)),
                  (u =
                    (e.cross(u, n) / y) *
                    d._torqueDampen *
                    q.inverseInertia *
                    (1 - m.angularStiffness)),
                  (q.constraintImpulse.angle -= u),
                  (q.angle -= u));
                r &&
                  !r.isStatic &&
                  ((z = r.inverseMass / x),
                  (r.constraintImpulse.x += n.x * z),
                  (r.constraintImpulse.y += n.y * z),
                  (r.position.x += n.x * z),
                  (r.position.y += n.y * z),
                  m.damping &&
                    ((r.positionPrev.x += m.damping * D.x * B * z),
                    (r.positionPrev.y += m.damping * D.y * B * z)),
                  (u =
                    (e.cross(v, n) / y) *
                    d._torqueDampen *
                    r.inverseInertia *
                    (1 - m.angularStiffness)),
                  (r.constraintImpulse.angle += u),
                  (r.angle += u));
              }
            }
          };
          d.postSolveAll = function (m) {
            for (var n = 0; n < m.length; n++) {
              var q = m[n],
                r = q.constraintImpulse;
              if (!(q.isStatic || (0 === r.x && 0 === r.y && 0 === r.angle))) {
                b.set(q, !1);
                for (var u = 0; u < q.parts.length; u++) {
                  var v = q.parts[u];
                  k.translate(v.vertices, r);
                  0 < u && ((v.position.x += r.x), (v.position.y += r.y));
                  0 !== r.angle &&
                    (k.rotate(v.vertices, r.angle, q.position),
                    f.rotate(v.axes, r.angle),
                    0 < u &&
                      e.rotateAbout(
                        v.position,
                        r.angle,
                        q.position,
                        v.position
                      ));
                  c.update(v.bounds, v.vertices, q.velocity);
                }
                r.angle *= d._warming;
                r.x *= d._warming;
                r.y *= d._warming;
              }
            }
          };
          d.pointAWorld = function (m) {
            return {
              x: (m.bodyA ? m.bodyA.position.x : 0) + m.pointA.x,
              y: (m.bodyA ? m.bodyA.position.y : 0) + m.pointA.y,
            };
          };
          d.pointBWorld = function (m) {
            return {
              x: (m.bodyB ? m.bodyB.position.x : 0) + m.pointB.x,
              y: (m.bodyB ? m.bodyB.position.y : 0) + m.pointB.y,
            };
          };
        })();
      },
      function (h, t, a) {
        var d = a(35),
          k = a(65),
          e = a(66);
        t = a(0);
        var b = a(11),
          c = a(15),
          f = a(10),
          g = a(57);
        a = new t({
          Extends: c,
          Mixins: [
            b.Depth,
            b.GetBounds,
            b.Origin,
            b.Transform,
            b.ScrollFactor,
            b.Visible,
          ],
          initialize: function (m, n, q, r, u) {
            void 0 === r && (r = 1);
            void 0 === u && (u = r);
            c.call(this, m, "Zone");
            this.setPosition(n, q);
            this.width = r;
            this.height = u;
            this.blendMode = d.NORMAL;
            this.updateDisplayOrigin();
          },
          displayWidth: {
            get: function () {
              return this.scaleX * this.width;
            },
            set: function (m) {
              this.scaleX = m / this.width;
            },
          },
          displayHeight: {
            get: function () {
              return this.scaleY * this.height;
            },
            set: function (m) {
              this.scaleY = m / this.height;
            },
          },
          setSize: function (m, n, q) {
            void 0 === q && (q = !0);
            this.width = m;
            this.height = n;
            this.updateDisplayOrigin();
            var r = this.input;
            q &&
              r &&
              !r.customHitArea &&
              ((r.hitArea.width = m), (r.hitArea.height = n));
            return this;
          },
          setDisplaySize: function (m, n) {
            this.displayWidth = m;
            this.displayHeight = n;
            return this;
          },
          setCircleDropZone: function (m) {
            return this.setDropZone(new k(0, 0, m), e);
          },
          setRectangleDropZone: function (m, n) {
            return this.setDropZone(new f(0, 0, m, n), g);
          },
          setDropZone: function (m, n) {
            void 0 === m
              ? this.setRectangleDropZone(this.width, this.height)
              : this.input || this.setInteractive(m, n, !0);
            return this;
          },
          setAlpha: function () {},
          setBlendMode: function () {},
          renderCanvas: function (m, n, q) {
            q.addToRenderList(n);
          },
          renderWebGL: function (m, n, q) {
            q.addToRenderList(n);
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a) {
          return 2 * (a.width + a.height);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          for (var d = a.length - 1; 0 < d; d--) {
            var k = Math.floor(Math.random() * (d + 1)),
              e = a[d];
            a[d] = a[k];
            a[k] = e;
          }
          return a;
        };
      },
      function (h, t, a) {
        h.exports = {
          ADD_ANIMATION: a(724),
          ANIMATION_COMPLETE: a(725),
          ANIMATION_COMPLETE_KEY: a(726),
          ANIMATION_REPEAT: a(727),
          ANIMATION_RESTART: a(728),
          ANIMATION_START: a(729),
          ANIMATION_STOP: a(730),
          ANIMATION_UPDATE: a(731),
          PAUSE_ALL: a(732),
          REMOVE_ANIMATION: a(733),
          RESUME_ALL: a(734),
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(11),
          k = a(36),
          e = a(9),
          b = a(37),
          c = a(10),
          f = a(25),
          g = a(187),
          m = a(3);
        a = new t({
          Extends: e,
          Mixins: [d.Alpha, d.Visible],
          initialize: function (n, q, r, u) {
            void 0 === n && (n = 0);
            void 0 === q && (q = 0);
            void 0 === r && (r = 0);
            void 0 === u && (u = 0);
            e.call(this);
            this.scene;
            this.sceneManager;
            this.scaleManager;
            this.cameraManager;
            this.id = 0;
            this.name = "";
            this.useBounds = this.roundPixels = !1;
            this.worldView = new c();
            this.dirty = !0;
            this._x = n;
            this._y = q;
            this._width = r;
            this._height = u;
            this._bounds = new c();
            this._scrollY = this._scrollX = 0;
            this._zoomY = this._zoomX = 1;
            this._rotation = 0;
            this.matrix = new f();
            this.transparent = !0;
            this.backgroundColor = g("rgba(0,0,0,0)");
            this.disableCull = !1;
            this.culledObjects = [];
            this.midPoint = new m(r / 2, u / 2);
            this.originY = this.originX = 0.5;
            this._customViewport = !1;
            this._maskCamera = this.mask = null;
            this.renderList = [];
          },
          addToRenderList: function (n) {
            this.renderList.push(n);
          },
          setOrigin: function (n, q) {
            void 0 === n && (n = 0.5);
            void 0 === q && (q = n);
            this.originX = n;
            this.originY = q;
            return this;
          },
          getScroll: function (n, q, r) {
            void 0 === r && (r = new m());
            var u = 0.5 * this.height;
            r.x = n - 0.5 * this.width;
            r.y = q - u;
            this.useBounds &&
              ((r.x = this.clampX(r.x)), (r.y = this.clampY(r.y)));
            return r;
          },
          centerOnX: function (n) {
            var q = 0.5 * this.width;
            this.midPoint.x = n;
            this.scrollX = n - q;
            this.useBounds && (this.scrollX = this.clampX(this.scrollX));
            return this;
          },
          centerOnY: function (n) {
            var q = 0.5 * this.height;
            this.midPoint.y = n;
            this.scrollY = n - q;
            this.useBounds && (this.scrollY = this.clampY(this.scrollY));
            return this;
          },
          centerOn: function (n, q) {
            this.centerOnX(n);
            this.centerOnY(q);
            return this;
          },
          centerToBounds: function () {
            if (this.useBounds) {
              var n = this._bounds,
                q = 0.5 * this.width,
                r = 0.5 * this.height;
              this.midPoint.set(n.centerX, n.centerY);
              this.scrollX = n.centerX - q;
              this.scrollY = n.centerY - r;
            }
            return this;
          },
          centerToSize: function () {
            this.scrollX = 0.5 * this.width;
            this.scrollY = 0.5 * this.height;
            return this;
          },
          cull: function (n) {
            if (this.disableCull) return n;
            var q = this.matrix.matrix,
              r = q[0],
              u = q[1],
              v = q[2],
              x = q[3];
            if (!(r * x - u * v)) return n;
            var y = q[4];
            q = q[5];
            for (
              var z = this.scrollX,
                A = this.scrollY,
                B = this.y,
                D = B + this.height,
                E = this.x,
                C = E + this.width,
                F = this.culledObjects,
                G = n.length,
                H = (F.length = 0);
              H < G;
              ++H
            ) {
              var K = n[H];
              if (!K.hasOwnProperty("width") || K.parentContainer) F.push(K);
              else {
                var I = K.width,
                  M = K.height,
                  N = K.x - z * K.scrollFactorX - I * K.originX,
                  P = K.y - A * K.scrollFactorY - M * K.originY,
                  J = N * r + P * v + y,
                  L = N * u + P * x + q,
                  O = (N + I) * u + (P + M) * x + q;
                (N + I) * r + (P + M) * v + y > E &&
                  J < C &&
                  O > B &&
                  L < D &&
                  F.push(K);
              }
            }
            return F;
          },
          getWorldPoint: function (n, q, r) {
            void 0 === r && (r = new m());
            var u = this.matrix.matrix,
              v = u[0],
              x = u[1],
              y = u[2],
              z = u[3],
              A = u[4];
            u = u[5];
            var B = v * z - x * y;
            if (!B) return (r.x = n), (r.y = q), r;
            B = 1 / B;
            var D = Math.cos(this.rotation),
              E = Math.sin(this.rotation),
              C = this.scrollX,
              F = this.scrollY;
            n += (C * D - F * E) * this.zoomX;
            q += (C * E + F * D) * this.zoomY;
            r.x = n * z * B + q * -y * B + (y * u - z * A) * B;
            r.y = n * -x * B + q * v * B + (x * A - v * u) * B;
            return r;
          },
          ignore: function (n) {
            var q = this.id;
            Array.isArray(n) || (n = [n]);
            for (var r = 0; r < n.length; r++) {
              var u = n[r];
              Array.isArray(u)
                ? this.ignore(u)
                : u.isParent
                ? this.ignore(u.getChildren())
                : (u.cameraFilter |= q);
            }
            return this;
          },
          preRender: function () {
            this.renderList.length = 0;
            var n = this.width,
              q = this.height,
              r = 0.5 * n,
              u = 0.5 * q,
              v = this.zoomX,
              x = this.zoomY,
              y = this.matrix,
              z = n * this.originX,
              A = q * this.originY,
              B = this.scrollX,
              D = this.scrollY;
            this.useBounds && ((B = this.clampX(B)), (D = this.clampY(D)));
            this.roundPixels && ((z = Math.round(z)), (A = Math.round(A)));
            this.scrollX = B;
            this.scrollY = D;
            r = B + r;
            u = D + u;
            this.midPoint.set(r, u);
            n /= v;
            q /= x;
            this.worldView.setTo(r - n / 2, u - q / 2, n, q);
            y.applyITRS(this.x + z, this.y + A, this.rotation, v, x);
            y.translate(-z, -A);
          },
          clampX: function (n) {
            var q = this._bounds,
              r = this.displayWidth,
              u = q.x + (r - this.width) / 2;
            q = Math.max(u, u + q.width - r);
            n < u ? (n = u) : n > q && (n = q);
            return n;
          },
          clampY: function (n) {
            var q = this._bounds,
              r = this.displayHeight,
              u = q.y + (r - this.height) / 2;
            q = Math.max(u, u + q.height - r);
            n < u ? (n = u) : n > q && (n = q);
            return n;
          },
          removeBounds: function () {
            this.useBounds = !1;
            this.dirty = !0;
            this._bounds.setEmpty();
            return this;
          },
          setAngle: function (n) {
            void 0 === n && (n = 0);
            this.rotation = k(n);
            return this;
          },
          setBackgroundColor: function (n) {
            void 0 === n && (n = "rgba(0,0,0,0)");
            this.backgroundColor = g(n);
            this.transparent = 0 === this.backgroundColor.alpha;
            return this;
          },
          setBounds: function (n, q, r, u, v) {
            void 0 === v && (v = !1);
            this._bounds.setTo(n, q, r, u);
            this.useBounds = this.dirty = !0;
            v
              ? this.centerToBounds()
              : ((this.scrollX = this.clampX(this.scrollX)),
                (this.scrollY = this.clampY(this.scrollY)));
            return this;
          },
          getBounds: function (n) {
            void 0 === n && (n = new c());
            var q = this._bounds;
            n.setTo(q.x, q.y, q.width, q.height);
            return n;
          },
          setName: function (n) {
            void 0 === n && (n = "");
            this.name = n;
            return this;
          },
          setPosition: function (n, q) {
            void 0 === q && (q = n);
            this.x = n;
            this.y = q;
            return this;
          },
          setRotation: function (n) {
            void 0 === n && (n = 0);
            this.rotation = n;
            return this;
          },
          setRoundPixels: function (n) {
            this.roundPixels = n;
            return this;
          },
          setScene: function (n) {
            this.scene &&
              this._customViewport &&
              this.sceneManager.customViewports--;
            this.scene = n;
            n = n.sys;
            this.sceneManager = n.game.scene;
            this.scaleManager = n.scale;
            this.cameraManager = n.cameras;
            this.updateSystem();
            return this;
          },
          setScroll: function (n, q) {
            void 0 === q && (q = n);
            this.scrollX = n;
            this.scrollY = q;
            return this;
          },
          setSize: function (n, q) {
            void 0 === q && (q = n);
            this.width = n;
            this.height = q;
            return this;
          },
          setViewport: function (n, q, r, u) {
            this.x = n;
            this.y = q;
            this.width = r;
            this.height = u;
            return this;
          },
          setZoom: function (n, q) {
            void 0 === n && (n = 1);
            void 0 === q && (q = n);
            0 === n && (n = 0.001);
            0 === q && (q = 0.001);
            this.zoomX = n;
            this.zoomY = q;
            return this;
          },
          setMask: function (n, q) {
            void 0 === q && (q = !0);
            this.mask = n;
            this._maskCamera = q ? this.cameraManager.default : this;
            return this;
          },
          clearMask: function (n) {
            void 0 === n && (n = !1);
            n && this.mask && this.mask.destroy();
            this.mask = null;
            return this;
          },
          toJSON: function () {
            var n = {
              name: this.name,
              x: this.x,
              y: this.y,
              width: this.width,
              height: this.height,
              zoom: this.zoom,
              rotation: this.rotation,
              roundPixels: this.roundPixels,
              scrollX: this.scrollX,
              scrollY: this.scrollY,
              backgroundColor: this.backgroundColor.rgba,
            };
            this.useBounds &&
              (n.bounds = {
                x: this._bounds.x,
                y: this._bounds.y,
                width: this._bounds.width,
                height: this._bounds.height,
              });
            return n;
          },
          update: function () {},
          updateSystem: function () {
            if (this.scaleManager) {
              var n =
                  0 !== this._x ||
                  0 !== this._y ||
                  this.scaleManager.width !== this._width ||
                  this.scaleManager.height !== this._height,
                q = this.sceneManager;
              n && !this._customViewport
                ? q.customViewports++
                : !n && this._customViewport && q.customViewports--;
              this.dirty = !0;
              this._customViewport = n;
            }
          },
          destroy: function () {
            this.emit(b.DESTROY, this);
            this.removeAllListeners();
            this.matrix.destroy();
            this.culledObjects = [];
            this._customViewport && this.sceneManager.customViewports--;
            this.renderList = [];
            this.cameraManager =
              this.sceneManager =
              this.scaleManager =
              this.scene =
              this._bounds =
                null;
          },
          x: {
            get: function () {
              return this._x;
            },
            set: function (n) {
              this._x = n;
              this.updateSystem();
            },
          },
          y: {
            get: function () {
              return this._y;
            },
            set: function (n) {
              this._y = n;
              this.updateSystem();
            },
          },
          width: {
            get: function () {
              return this._width;
            },
            set: function (n) {
              this._width = n;
              this.updateSystem();
            },
          },
          height: {
            get: function () {
              return this._height;
            },
            set: function (n) {
              this._height = n;
              this.updateSystem();
            },
          },
          scrollX: {
            get: function () {
              return this._scrollX;
            },
            set: function (n) {
              this._scrollX = n;
              this.dirty = !0;
            },
          },
          scrollY: {
            get: function () {
              return this._scrollY;
            },
            set: function (n) {
              this._scrollY = n;
              this.dirty = !0;
            },
          },
          zoom: {
            get: function () {
              return (this._zoomX + this._zoomY) / 2;
            },
            set: function (n) {
              this._zoomY = this._zoomX = n;
              this.dirty = !0;
            },
          },
          zoomX: {
            get: function () {
              return this._zoomX;
            },
            set: function (n) {
              this._zoomX = n;
              this.dirty = !0;
            },
          },
          zoomY: {
            get: function () {
              return this._zoomY;
            },
            set: function (n) {
              this._zoomY = n;
              this.dirty = !0;
            },
          },
          rotation: {
            get: function () {
              return this._rotation;
            },
            set: function (n) {
              this._rotation = n;
              this.dirty = !0;
            },
          },
          centerX: {
            get: function () {
              return this.x + 0.5 * this.width;
            },
          },
          centerY: {
            get: function () {
              return this.y + 0.5 * this.height;
            },
          },
          displayWidth: {
            get: function () {
              return this.width / this.zoomX;
            },
          },
          displayHeight: {
            get: function () {
              return this.height / this.zoomY;
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(334);
        var d = a(335),
          k = a(336),
          e = a(337),
          b = a(338),
          c = a(339),
          f = a(340),
          g = a(341),
          m = a(342),
          n = a(343),
          q = a(344);
        a = a(345);
        h.exports = {
          Power0: f,
          Power1: g.Out,
          Power2: e.Out,
          Power3: m.Out,
          Power4: n.Out,
          Linear: f,
          Quad: g.Out,
          Cubic: e.Out,
          Quart: m.Out,
          Quint: n.Out,
          Sine: q.Out,
          Expo: c.Out,
          Circ: k.Out,
          Elastic: b.Out,
          Back: t.Out,
          Bounce: d.Out,
          Stepped: a,
          "Quad.easeIn": g.In,
          "Cubic.easeIn": e.In,
          "Quart.easeIn": m.In,
          "Quint.easeIn": n.In,
          "Sine.easeIn": q.In,
          "Expo.easeIn": c.In,
          "Circ.easeIn": k.In,
          "Elastic.easeIn": b.In,
          "Back.easeIn": t.In,
          "Bounce.easeIn": d.In,
          "Quad.easeOut": g.Out,
          "Cubic.easeOut": e.Out,
          "Quart.easeOut": m.Out,
          "Quint.easeOut": n.Out,
          "Sine.easeOut": q.Out,
          "Expo.easeOut": c.Out,
          "Circ.easeOut": k.Out,
          "Elastic.easeOut": b.Out,
          "Back.easeOut": t.Out,
          "Bounce.easeOut": d.Out,
          "Quad.easeInOut": g.InOut,
          "Cubic.easeInOut": e.InOut,
          "Quart.easeInOut": m.InOut,
          "Quint.easeInOut": n.InOut,
          "Sine.easeInOut": q.InOut,
          "Expo.easeInOut": c.InOut,
          "Circ.easeInOut": k.InOut,
          "Elastic.easeInOut": b.InOut,
          "Back.easeInOut": t.InOut,
          "Bounce.easeInOut": d.InOut,
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          return (d - a) * k + a;
        };
      },
      function (h, t, a) {
        t = a(105);
        a = {
          chrome: !1,
          chromeVersion: 0,
          edge: !1,
          firefox: !1,
          firefoxVersion: 0,
          ie: !1,
          ieVersion: 0,
          mobileSafari: !1,
          opera: !1,
          safari: !1,
          safariVersion: 0,
          silk: !1,
          trident: !1,
          tridentVersion: 0,
        };
        var d = navigator.userAgent;
        /Edge\/\d+/.test(d)
          ? (a.edge = !0)
          : /Chrome\/(\d+)/.test(d) && !t.windowsPhone
          ? ((a.chrome = !0), (a.chromeVersion = parseInt(RegExp.$1, 10)))
          : /Firefox\D+(\d+)/.test(d)
          ? ((a.firefox = !0), (a.firefoxVersion = parseInt(RegExp.$1, 10)))
          : /AppleWebKit/.test(d) && t.iOS
          ? (a.mobileSafari = !0)
          : /MSIE (\d+\.\d+);/.test(d)
          ? ((a.ie = !0), (a.ieVersion = parseInt(RegExp.$1, 10)))
          : /Opera/.test(d)
          ? (a.opera = !0)
          : /Safari/.test(d) && !t.windowsPhone
          ? (a.safari = !0)
          : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(d) &&
            ((a.ie = !0),
            (a.trident = !0),
            (a.tridentVersion = parseInt(RegExp.$1, 10)),
            (a.ieVersion = parseInt(RegExp.$3, 10)));
        /Silk/.test(d) && (a.silk = !0);
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d) {
          return Math.random() * (d - a) + a;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return 0 < a && 0 === (a & (a - 1)) && 0 < d && 0 === (d & (d - 1));
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          void 0 === k && (k = 0);
          if (0 === d) return a;
          a = d * Math.ceil((a - k) / d);
          return e ? (k + a) / d : k + a;
        };
      },
      function (h, t, a) {
        var d = new (a(0))({
          initialize: function (k, e, b, c) {
            this.w = this.z = this.y = this.x = 0;
            "object" === typeof k
              ? ((this.x = k.x || 0),
                (this.y = k.y || 0),
                (this.z = k.z || 0),
                (this.w = k.w || 0))
              : ((this.x = k || 0),
                (this.y = e || 0),
                (this.z = b || 0),
                (this.w = c || 0));
          },
          clone: function () {
            return new d(this.x, this.y, this.z, this.w);
          },
          copy: function (k) {
            this.x = k.x;
            this.y = k.y;
            this.z = k.z || 0;
            this.w = k.w || 0;
            return this;
          },
          equals: function (k) {
            return (
              this.x === k.x &&
              this.y === k.y &&
              this.z === k.z &&
              this.w === k.w
            );
          },
          set: function (k, e, b, c) {
            "object" === typeof k
              ? ((this.x = k.x || 0),
                (this.y = k.y || 0),
                (this.z = k.z || 0),
                (this.w = k.w || 0))
              : ((this.x = k || 0),
                (this.y = e || 0),
                (this.z = b || 0),
                (this.w = c || 0));
            return this;
          },
          add: function (k) {
            this.x += k.x;
            this.y += k.y;
            this.z += k.z || 0;
            this.w += k.w || 0;
            return this;
          },
          subtract: function (k) {
            this.x -= k.x;
            this.y -= k.y;
            this.z -= k.z || 0;
            this.w -= k.w || 0;
            return this;
          },
          scale: function (k) {
            this.x *= k;
            this.y *= k;
            this.z *= k;
            this.w *= k;
            return this;
          },
          length: function () {
            var k = this.x,
              e = this.y,
              b = this.z,
              c = this.w;
            return Math.sqrt(k * k + e * e + b * b + c * c);
          },
          lengthSq: function () {
            var k = this.x,
              e = this.y,
              b = this.z,
              c = this.w;
            return k * k + e * e + b * b + c * c;
          },
          normalize: function () {
            var k = this.x,
              e = this.y,
              b = this.z,
              c = this.w,
              f = k * k + e * e + b * b + c * c;
            0 < f &&
              ((f = 1 / Math.sqrt(f)),
              (this.x = k * f),
              (this.y = e * f),
              (this.z = b * f),
              (this.w = c * f));
            return this;
          },
          dot: function (k) {
            return this.x * k.x + this.y * k.y + this.z * k.z + this.w * k.w;
          },
          lerp: function (k, e) {
            void 0 === e && (e = 0);
            var b = this.x,
              c = this.y,
              f = this.z,
              g = this.w;
            this.x = b + e * (k.x - b);
            this.y = c + e * (k.y - c);
            this.z = f + e * (k.z - f);
            this.w = g + e * (k.w - g);
            return this;
          },
          multiply: function (k) {
            this.x *= k.x;
            this.y *= k.y;
            this.z *= k.z || 1;
            this.w *= k.w || 1;
            return this;
          },
          divide: function (k) {
            this.x /= k.x;
            this.y /= k.y;
            this.z /= k.z || 1;
            this.w /= k.w || 1;
            return this;
          },
          distance: function (k) {
            var e = k.x - this.x,
              b = k.y - this.y,
              c = k.z - this.z || 0;
            k = k.w - this.w || 0;
            return Math.sqrt(e * e + b * b + c * c + k * k);
          },
          distanceSq: function (k) {
            var e = k.x - this.x,
              b = k.y - this.y,
              c = k.z - this.z || 0;
            k = k.w - this.w || 0;
            return e * e + b * b + c * c + k * k;
          },
          negate: function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this;
          },
          transformMat4: function (k) {
            var e = this.x,
              b = this.y,
              c = this.z,
              f = this.w;
            k = k.val;
            this.x = k[0] * e + k[4] * b + k[8] * c + k[12] * f;
            this.y = k[1] * e + k[5] * b + k[9] * c + k[13] * f;
            this.z = k[2] * e + k[6] * b + k[10] * c + k[14] * f;
            this.w = k[3] * e + k[7] * b + k[11] * c + k[15] * f;
            return this;
          },
          transformQuat: function (k) {
            var e = this.x,
              b = this.y,
              c = this.z,
              f = k.x,
              g = k.y,
              m = k.z;
            k = k.w;
            var n = k * e + g * c - m * b,
              q = k * b + m * e - f * c,
              r = k * c + f * b - g * e;
            e = -f * e - g * b - m * c;
            this.x = n * k + e * -f + q * -m - r * -g;
            this.y = q * k + e * -g + r * -f - n * -m;
            this.z = r * k + e * -m + n * -g - q * -f;
            return this;
          },
          reset: function () {
            this.w = this.z = this.y = this.x = 0;
            return this;
          },
        });
        d.prototype.sub = d.prototype.subtract;
        d.prototype.mul = d.prototype.multiply;
        d.prototype.div = d.prototype.divide;
        d.prototype.dist = d.prototype.distance;
        d.prototype.distSq = d.prototype.distanceSq;
        d.prototype.len = d.prototype.length;
        d.prototype.lenSq = d.prototype.lengthSq;
        h.exports = d;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(91);
        a = new t({
          initialize: function (k, e, b, c, f, g, m) {
            void 0 === c && (c = 1);
            void 0 === f && (f = 0);
            void 0 === g && (g = !0);
            void 0 === m && (m = !1);
            this.renderer = k;
            this.texture = this.framebuffer = null;
            this.height = this.width = 0;
            this.scale = c;
            this.minFilter = f;
            this.autoClear = g;
            this.autoResize = !1;
            this.resize(e, b);
            m && this.setAutoResize(!0);
          },
          setAutoResize: function (k) {
            k && !this.autoResize
              ? (this.renderer.on(d.RESIZE, this.resize, this),
                (this.autoResize = !0))
              : !k &&
                this.autoResize &&
                (this.renderer.off(d.RESIZE, this.resize, this),
                (this.autoResize = !1));
            return this;
          },
          resize: function (k, e) {
            var b = e * this.scale;
            if (k * this.scale !== this.width || b !== this.height)
              (b = this.renderer),
                b.deleteFramebuffer(this.framebuffer),
                b.deleteTexture(this.texture),
                (k *= this.scale),
                (e *= this.scale),
                (k = Math.round(k)),
                (e = Math.round(e)),
                0 >= k && (k = 1),
                0 >= e && (e = 1),
                (this.texture = b.createTextureFromSource(
                  null,
                  k,
                  e,
                  this.minFilter
                )),
                (this.framebuffer = b.createFramebuffer(
                  k,
                  e,
                  this.texture,
                  !1
                )),
                (this.width = k),
                (this.height = e);
            return this;
          },
          bind: function (k, e, b) {
            void 0 === k && (k = !1);
            k && this.renderer.flush();
            e && b && this.resize(e, b);
            this.renderer.pushFramebuffer(this.framebuffer, !1, !1, !1);
            k && this.adjustViewport();
            this.autoClear &&
              ((k = this.renderer.gl),
              k.clearColor(0, 0, 0, 0),
              k.clear(k.COLOR_BUFFER_BIT));
          },
          adjustViewport: function () {
            var k = this.renderer.gl;
            k.viewport(0, 0, this.width, this.height);
            k.disable(k.SCISSOR_TEST);
          },
          clear: function () {
            var k = this.renderer,
              e = k.gl;
            k.pushFramebuffer(this.framebuffer);
            e.disable(e.SCISSOR_TEST);
            e.clearColor(0, 0, 0, 0);
            e.clear(e.COLOR_BUFFER_BIT);
            k.popFramebuffer();
            k.resetScissor();
          },
          unbind: function (k) {
            void 0 === k && (k = !1);
            var e = this.renderer;
            k && e.flush();
            return e.popFramebuffer();
          },
          destroy: function () {
            var k = this.renderer;
            k.deleteFramebuffer(this.framebuffer);
            k.deleteTexture(this.texture);
            k.off(d.RESIZE, this.resize, this);
            this.texture = this.framebuffer = this.renderer = null;
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d) {
          var k;
          if (d)
            "string" === typeof d
              ? (k = document.getElementById(d))
              : "object" === typeof d && 1 === d.nodeType && (k = d);
          else if (a.parentElement || null === d) return a;
          k || (k = document.body);
          k.appendChild(a);
          return a;
        };
      },
      function (h, t) {
        h.exports = {
          BACKSPACE: 8,
          TAB: 9,
          ENTER: 13,
          SHIFT: 16,
          CTRL: 17,
          ALT: 18,
          PAUSE: 19,
          CAPS_LOCK: 20,
          ESC: 27,
          SPACE: 32,
          PAGE_UP: 33,
          PAGE_DOWN: 34,
          END: 35,
          HOME: 36,
          LEFT: 37,
          UP: 38,
          RIGHT: 39,
          DOWN: 40,
          PRINT_SCREEN: 42,
          INSERT: 45,
          DELETE: 46,
          ZERO: 48,
          ONE: 49,
          TWO: 50,
          THREE: 51,
          FOUR: 52,
          FIVE: 53,
          SIX: 54,
          SEVEN: 55,
          EIGHT: 56,
          NINE: 57,
          NUMPAD_ZERO: 96,
          NUMPAD_ONE: 97,
          NUMPAD_TWO: 98,
          NUMPAD_THREE: 99,
          NUMPAD_FOUR: 100,
          NUMPAD_FIVE: 101,
          NUMPAD_SIX: 102,
          NUMPAD_SEVEN: 103,
          NUMPAD_EIGHT: 104,
          NUMPAD_NINE: 105,
          NUMPAD_ADD: 107,
          NUMPAD_SUBTRACT: 109,
          A: 65,
          B: 66,
          C: 67,
          D: 68,
          E: 69,
          F: 70,
          G: 71,
          H: 72,
          I: 73,
          J: 74,
          K: 75,
          L: 76,
          M: 77,
          N: 78,
          O: 79,
          P: 80,
          Q: 81,
          R: 82,
          S: 83,
          T: 84,
          U: 85,
          V: 86,
          W: 87,
          X: 88,
          Y: 89,
          Z: 90,
          F1: 112,
          F2: 113,
          F3: 114,
          F4: 115,
          F5: 116,
          F6: 117,
          F7: 118,
          F8: 119,
          F9: 120,
          F10: 121,
          F11: 122,
          F12: 123,
          SEMICOLON: 186,
          PLUS: 187,
          COMMA: 188,
          MINUS: 189,
          PERIOD: 190,
          FORWARD_SLASH: 191,
          BACK_SLASH: 220,
          QUOTES: 222,
          BACKTICK: 192,
          OPEN_BRACKET: 219,
          CLOSED_BRACKET: 221,
          SEMICOLON_FIREFOX: 59,
          COLON: 58,
          COMMA_FIREFOX_WINDOWS: 60,
          COMMA_FIREFOX: 62,
          BRACKET_RIGHT_FIREFOX: 174,
          BRACKET_LEFT_FIREFOX: 175,
        };
      },
      function (h, t) {
        h.exports = {
          PENDING: 0,
          INIT: 1,
          START: 2,
          LOADING: 3,
          CREATING: 4,
          RUNNING: 5,
          PAUSED: 6,
          SLEEPING: 7,
          SHUTDOWN: 8,
          DESTROYED: 9,
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(77),
          k = a(9),
          e = a(70),
          b = a(22),
          c = a(1),
          f = a(207),
          g = a(428);
        a = new t({
          Extends: k,
          initialize: function (m) {
            k.call(this);
            this.game = m;
            this.jsonCache = m.cache.json;
            this.sounds = [];
            this.mute = !1;
            this.volume = 1;
            this.pauseOnBlur = !0;
            this._rate = 1;
            this._detune = 0;
            this.locked = this.locked || !1;
            this.unlocked = !1;
            m.events.on(b.BLUR, this.onGameBlur, this);
            m.events.on(b.FOCUS, this.onGameFocus, this);
            m.events.on(b.PRE_STEP, this.update, this);
            m.events.once(b.DESTROY, this.destroy, this);
          },
          add: c,
          addAudioSprite: function (m, n) {
            void 0 === n && (n = {});
            var q = this.add(m, n);
            q.spritemap = this.jsonCache.get(m).spritemap;
            for (var r in q.spritemap)
              if (q.spritemap.hasOwnProperty(r)) {
                m = d(n);
                var u = q.spritemap[r];
                m.loop = u.hasOwnProperty("loop") ? u.loop : !1;
                q.addMarker({
                  name: r,
                  start: u.start,
                  duration: u.end - u.start,
                  config: m,
                });
              }
            return q;
          },
          get: function (m) {
            return g(this.sounds, "key", m);
          },
          getAll: function (m) {
            return f(this.sounds, "key", m);
          },
          play: function (m, n) {
            m = this.add(m);
            m.once(e.COMPLETE, m.destroy, m);
            return n
              ? n.name
                ? (m.addMarker(n), m.play(n.name))
                : m.play(n)
              : m.play();
          },
          playAudioSprite: function (m, n, q) {
            m = this.addAudioSprite(m);
            m.once(e.COMPLETE, m.destroy, m);
            return m.play(n, q);
          },
          remove: function (m) {
            var n = this.sounds.indexOf(m);
            return -1 !== n ? (m.destroy(), this.sounds.splice(n, 1), !0) : !1;
          },
          removeAll: function () {
            this.sounds.forEach(function (m) {
              m.destroy();
            });
            this.sounds.length = 0;
          },
          removeByKey: function (m) {
            for (var n = 0, q = this.sounds.length - 1; 0 <= q; q--) {
              var r = this.sounds[q];
              r.key === m && (r.destroy(), this.sounds.splice(q, 1), n++);
            }
            return n;
          },
          pauseAll: function () {
            this.forEachActiveSound(function (m) {
              m.pause();
            });
            this.emit(e.PAUSE_ALL, this);
          },
          resumeAll: function () {
            this.forEachActiveSound(function (m) {
              m.resume();
            });
            this.emit(e.RESUME_ALL, this);
          },
          stopAll: function () {
            this.forEachActiveSound(function (m) {
              m.stop();
            });
            this.emit(e.STOP_ALL, this);
          },
          stopByKey: function (m) {
            var n = 0;
            this.getAll(m).forEach(function (q) {
              q.stop() && n++;
            });
            return n;
          },
          unlock: c,
          onBlur: c,
          onFocus: c,
          onGameBlur: function () {
            if (this.pauseOnBlur) this.onBlur();
          },
          onGameFocus: function () {
            if (this.pauseOnBlur) this.onFocus();
          },
          update: function (m, n) {
            this.unlocked &&
              ((this.locked = this.unlocked = !1), this.emit(e.UNLOCKED, this));
            for (var q = this.sounds.length - 1; 0 <= q; q--)
              this.sounds[q].pendingRemove && this.sounds.splice(q, 1);
            this.sounds.forEach(function (r) {
              r.update(m, n);
            });
          },
          destroy: function () {
            this.game.events.off(b.BLUR, this.onGameBlur, this);
            this.game.events.off(b.FOCUS, this.onGameFocus, this);
            this.game.events.off(b.PRE_STEP, this.update, this);
            this.removeAllListeners();
            this.removeAll();
            this.sounds.length = 0;
            this.game = this.sounds = null;
          },
          forEachActiveSound: function (m, n) {
            var q = this;
            this.sounds.forEach(function (r, u) {
              r && !r.pendingRemove && m.call(n || q, r, u, q.sounds);
            });
          },
          setRate: function (m) {
            this.rate = m;
            return this;
          },
          rate: {
            get: function () {
              return this._rate;
            },
            set: function (m) {
              this._rate = m;
              this.forEachActiveSound(function (n) {
                n.calculateRate();
              });
              this.emit(e.GLOBAL_RATE, this, m);
            },
          },
          setDetune: function (m) {
            this.detune = m;
            return this;
          },
          detune: {
            get: function () {
              return this._detune;
            },
            set: function (m) {
              this._detune = m;
              this.forEachActiveSound(function (n) {
                n.calculateRate();
              });
              this.emit(e.GLOBAL_DETUNE, this, m);
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(9),
          k = a(70),
          e = a(17);
        a = a(1);
        a = new t({
          Extends: d,
          initialize: function (b, c, f) {
            d.call(this);
            this.manager = b;
            this.key = c;
            this.isPaused = this.isPlaying = !1;
            this.totalRate = 1;
            this.duration = this.duration || 0;
            this.totalDuration = this.totalDuration || 0;
            this.currentConfig = this.config = {
              mute: !1,
              volume: 1,
              rate: 1,
              detune: 0,
              seek: 0,
              loop: !1,
              delay: 0,
              pan: 0,
            };
            this.config = e(this.config, f);
            this.markers = {};
            this.currentMarker = null;
            this.pendingRemove = !1;
          },
          addMarker: function (b) {
            if (!b || !b.name || "string" !== typeof b.name) return !1;
            if (this.markers[b.name])
              return (
                console.error(
                  "addMarker " + b.name + " already exists in Sound"
                ),
                !1
              );
            b = e(
              !0,
              {
                name: "",
                start: 0,
                duration: this.totalDuration - (b.start || 0),
                config: {
                  mute: !1,
                  volume: 1,
                  rate: 1,
                  detune: 0,
                  seek: 0,
                  loop: !1,
                  delay: 0,
                  pan: 0,
                },
              },
              b
            );
            this.markers[b.name] = b;
            return !0;
          },
          updateMarker: function (b) {
            if (!b || !b.name || "string" !== typeof b.name) return !1;
            if (!this.markers[b.name])
              return (
                console.warn(
                  "Audio Marker: " + b.name + " missing in Sound: " + this.key
                ),
                !1
              );
            this.markers[b.name] = e(!0, this.markers[b.name], b);
            return !0;
          },
          removeMarker: function (b) {
            var c = this.markers[b];
            if (!c) return null;
            this.markers[b] = null;
            return c;
          },
          play: function (b, c) {
            void 0 === b && (b = "");
            "object" === typeof b && ((c = b), (b = ""));
            if ("string" !== typeof b) return !1;
            if (b) {
              if (!this.markers[b])
                return (
                  console.warn(
                    "Marker: " + b + " missing in Sound: " + this.key
                  ),
                  !1
                );
              this.currentMarker = this.markers[b];
              this.currentConfig = this.currentMarker.config;
              this.duration = this.currentMarker.duration;
            } else
              (this.currentMarker = null),
                (this.currentConfig = this.config),
                (this.duration = this.totalDuration);
            this.resetConfig();
            this.currentConfig = e(this.currentConfig, c);
            this.isPlaying = !0;
            this.isPaused = !1;
            return !0;
          },
          pause: function () {
            if (this.isPaused || !this.isPlaying) return !1;
            this.isPlaying = !1;
            return (this.isPaused = !0);
          },
          resume: function () {
            if (!this.isPaused || this.isPlaying) return !1;
            this.isPlaying = !0;
            this.isPaused = !1;
            return !0;
          },
          stop: function () {
            if (!this.isPaused && !this.isPlaying) return !1;
            this.isPaused = this.isPlaying = !1;
            this.resetConfig();
            return !0;
          },
          applyConfig: function () {
            this.mute = this.currentConfig.mute;
            this.volume = this.currentConfig.volume;
            this.rate = this.currentConfig.rate;
            this.detune = this.currentConfig.detune;
            this.loop = this.currentConfig.loop;
            this.pan = this.currentConfig.pan;
          },
          resetConfig: function () {
            this.currentConfig.seek = 0;
            this.currentConfig.delay = 0;
          },
          update: a,
          calculateRate: function () {
            this.totalRate =
              this.currentConfig.rate *
              this.manager.rate *
              Math.pow(
                1.0005777895065548,
                this.currentConfig.detune + this.manager.detune
              );
          },
          destroy: function () {
            this.pendingRemove ||
              (this.emit(k.DESTROY, this),
              (this.pendingRemove = !0),
              (this.manager = null),
              (this.key = ""),
              this.removeAllListeners(),
              (this.isPaused = this.isPlaying = !1),
              (this.currentMarker =
                this.markers =
                this.currentConfig =
                this.config =
                  null));
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(209),
          k = a(435);
        h.exports = function (e, b) {
          void 0 === b && (b = 90);
          if (!d(e)) return null;
          "string" !== typeof b && (b = ((b % 360) + 360) % 360);
          if (90 === b || -270 === b || "rotateLeft" === b)
            (e = k(e)), e.reverse();
          else if (-90 === b || 270 === b || "rotateRight" === b)
            e.reverse(), (e = k(e));
          else if (180 === Math.abs(b) || "rotate180" === b) {
            for (b = 0; b < e.length; b++) e[b].reverse();
            e.reverse();
          }
          return e;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(18),
          k = a(11),
          e = a(15),
          b = a(1043),
          c = a(1044),
          f = a(212),
          g = a(10);
        a = a(1045);
        var m = new t({
          Extends: e,
          Mixins: [
            k.Alpha,
            k.BlendMode,
            k.Depth,
            k.Mask,
            k.Origin,
            k.Pipeline,
            k.ScrollFactor,
            k.Texture,
            k.Tint,
            k.Transform,
            k.Visible,
            a,
          ],
          initialize: function (n, q, r, u, v, x, y) {
            void 0 === v && (v = "");
            void 0 === y && (y = 0);
            e.call(this, n, "BitmapText");
            this.font = u;
            (n = this.scene.sys.cache.bitmapFont.get(u)) ||
              console.warn("Invalid BitmapText key: " + u);
            this.fontData = n.data;
            this._text = "";
            this._fontSize = x || this.fontData.size;
            this._letterSpacing = 0;
            this._align = y;
            this._bounds = b();
            this._dirty = !0;
            this._maxWidth = 0;
            this.wordWrapCharCode = 32;
            this.charColors = [];
            this.dropShadowColor = this.dropShadowY = this.dropShadowX = 0;
            this.dropShadowAlpha = 0.5;
            this.fromAtlas = n.fromAtlas;
            this.setTexture(n.texture, n.frame);
            this.setPosition(q, r);
            this.setOrigin(0, 0);
            this.initPipeline();
            this.setText(v);
          },
          setLeftAlign: function () {
            this._align = m.ALIGN_LEFT;
            this._dirty = !0;
            return this;
          },
          setCenterAlign: function () {
            this._align = m.ALIGN_CENTER;
            this._dirty = !0;
            return this;
          },
          setRightAlign: function () {
            this._align = m.ALIGN_RIGHT;
            this._dirty = !0;
            return this;
          },
          setFontSize: function (n) {
            this._fontSize = n;
            this._dirty = !0;
            return this;
          },
          setLetterSpacing: function (n) {
            void 0 === n && (n = 0);
            this._letterSpacing = n;
            this._dirty = !0;
            return this;
          },
          setText: function (n) {
            n || 0 === n || (n = "");
            Array.isArray(n) && (n = n.join("\n"));
            n !== this.text &&
              ((this._text = n.toString()),
              (this._dirty = !0),
              this.updateDisplayOrigin());
            return this;
          },
          setDropShadow: function (n, q, r, u) {
            void 0 === n && (n = 0);
            void 0 === q && (q = 0);
            void 0 === r && (r = 0);
            void 0 === u && (u = 0.5);
            this.dropShadowX = n;
            this.dropShadowY = q;
            this.dropShadowColor = r;
            this.dropShadowAlpha = u;
            return this;
          },
          setCharacterTint: function (n, q, r, u, v, x, y) {
            void 0 === n && (n = 0);
            void 0 === q && (q = 1);
            void 0 === r && (r = !1);
            void 0 === u && (u = -1);
            void 0 === v && (y = x = v = u);
            var z = this.text.length;
            -1 === q && (q = z);
            0 > n && (n = z + n);
            n = d(n, 0, z - 1);
            q = d(n + q, n, z);
            for (z = this.charColors; n < q; n++) {
              var A = z[n];
              if (-1 === u) z[n] = null;
              else {
                var B = r ? 1 : 0;
                A
                  ? ((A.tintEffect = B),
                    (A.tintTL = u),
                    (A.tintTR = v),
                    (A.tintBL = x),
                    (A.tintBR = y))
                  : (z[n] = {
                      tintEffect: B,
                      tintTL: u,
                      tintTR: v,
                      tintBL: x,
                      tintBR: y,
                    });
              }
            }
            return this;
          },
          setWordTint: function (n, q, r, u, v, x, y) {
            void 0 === q && (q = 1);
            for (
              var z = this.getTextBounds().words,
                A = "number" === typeof n,
                B = 0,
                D = 0;
              D < z.length;
              D++
            ) {
              var E = z[D];
              if ((A && D === n) || (!A && E.word === n))
                if (
                  (this.setCharacterTint(E.i, E.word.length, r, u, v, x, y),
                  B++,
                  B === q)
                )
                  break;
            }
            return this;
          },
          getTextBounds: function (n) {
            var q = this._bounds;
            if (
              this._dirty ||
              n ||
              this.scaleX !== q.scaleX ||
              this.scaleY !== q.scaleY
            )
              b(this, n, !0, q), (this._dirty = !1);
            return q;
          },
          getCharacterAt: function (n, q, r) {
            n = this.getLocalPoint(n, q, null, r);
            q = this.getTextBounds().characters;
            r = new g();
            for (var u = 0; u < q.length; u++) {
              var v = q[u];
              r.setTo(v.x, v.t, v.r - v.x, v.b);
              if (r.contains(n.x, n.y)) return v;
            }
            return null;
          },
          updateDisplayOrigin: function () {
            this._dirty = !0;
            this.getTextBounds(!1);
            return this;
          },
          setFont: function (n, q, r) {
            void 0 === q && (q = this._fontSize);
            void 0 === r && (r = this._align);
            if (n !== this.font) {
              var u = this.scene.sys.cache.bitmapFont.get(n);
              u &&
                ((this.font = n),
                (this.fontData = u.data),
                (this._fontSize = q),
                (this._align = r),
                (this.fromAtlas = !0 === u.fromAtlas),
                this.setTexture(u.texture, u.frame),
                b(this, !1, !0, this._bounds));
            }
            return this;
          },
          setMaxWidth: function (n, q) {
            this._maxWidth = n;
            this._dirty = !0;
            void 0 !== q && (this.wordWrapCharCode = q);
            return this;
          },
          align: {
            set: function (n) {
              this._align = n;
              this._dirty = !0;
            },
            get: function () {
              return this._align;
            },
          },
          text: {
            set: function (n) {
              this.setText(n);
            },
            get: function () {
              return this._text;
            },
          },
          fontSize: {
            set: function (n) {
              this._fontSize = n;
              this._dirty = !0;
            },
            get: function () {
              return this._fontSize;
            },
          },
          letterSpacing: {
            set: function (n) {
              this._letterSpacing = n;
              this._dirty = !0;
            },
            get: function () {
              return this._letterSpacing;
            },
          },
          maxWidth: {
            set: function (n) {
              this._maxWidth = n;
              this._dirty = !0;
            },
            get: function () {
              return this._maxWidth;
            },
          },
          width: {
            get: function () {
              this.getTextBounds(!1);
              return this._bounds.global.width;
            },
          },
          height: {
            get: function () {
              this.getTextBounds(!1);
              return this._bounds.global.height;
            },
          },
          toJSON: function () {
            var n = k.ToJSON(this);
            n.data = {
              font: this.font,
              text: this.text,
              fontSize: this.fontSize,
              letterSpacing: this.letterSpacing,
              align: this.align,
            };
            return n;
          },
          preDestroy: function () {
            this.charColors.length = 0;
            this.fontData = this._bounds = null;
          },
        });
        m.ALIGN_LEFT = 0;
        m.ALIGN_CENTER = 1;
        m.ALIGN_RIGHT = 2;
        m.ParseFromAtlas = c;
        m.ParseXMLBitmapFont = f;
        h.exports = m;
      },
      function (h, t, a) {
        var d = new (a(0))({
          initialize: function (k) {
            this.entries = [];
            if (Array.isArray(k))
              for (var e = 0; e < k.length; e++) this.set(k[e]);
          },
          set: function (k) {
            -1 === this.entries.indexOf(k) && this.entries.push(k);
            return this;
          },
          get: function (k, e) {
            for (var b = 0; b < this.entries.length; b++) {
              var c = this.entries[b];
              if (c[k] === e) return c;
            }
          },
          getArray: function () {
            return this.entries.slice(0);
          },
          delete: function (k) {
            k = this.entries.indexOf(k);
            -1 < k && this.entries.splice(k, 1);
            return this;
          },
          dump: function () {
            console.group("Set");
            for (var k = 0; k < this.entries.length; k++);
            console.groupEnd();
          },
          each: function (k, e) {
            var b,
              c = this.entries.slice(),
              f = c.length;
            if (e) for (b = 0; b < f && !1 !== k.call(e, c[b], b); b++);
            else for (b = 0; b < f && !1 !== k(c[b], b); b++);
            return this;
          },
          iterate: function (k, e) {
            var b,
              c = this.entries.length;
            if (e)
              for (b = 0; b < c && !1 !== k.call(e, this.entries[b], b); b++);
            else for (b = 0; b < c && !1 !== k(this.entries[b], b); b++);
            return this;
          },
          iterateLocal: function (k) {
            var e,
              b = [];
            for (e = 1; e < arguments.length; e++) b.push(arguments[e]);
            var c = this.entries.length;
            for (e = 0; e < c; e++) {
              var f = this.entries[e];
              f[k].apply(f, b);
            }
            return this;
          },
          clear: function () {
            this.entries.length = 0;
            return this;
          },
          contains: function (k) {
            return -1 < this.entries.indexOf(k);
          },
          union: function (k) {
            var e = new d();
            k.entries.forEach(function (b) {
              e.set(b);
            });
            this.entries.forEach(function (b) {
              e.set(b);
            });
            return e;
          },
          intersect: function (k) {
            var e = new d();
            this.entries.forEach(function (b) {
              k.contains(b) && e.set(b);
            });
            return e;
          },
          difference: function (k) {
            var e = new d();
            this.entries.forEach(function (b) {
              k.contains(b) || e.set(b);
            });
            return e;
          },
          size: {
            get: function () {
              return this.entries.length;
            },
            set: function (k) {
              return k < this.entries.length
                ? (this.entries.length = k)
                : this.entries.length;
            },
          },
        });
        h.exports = d;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(11),
          k = a(15),
          e = a(189),
          b = a(92);
        a = a(1182);
        a = new t({
          Extends: k,
          Mixins: [
            d.AlphaSingle,
            d.BlendMode,
            d.Depth,
            d.GetBounds,
            d.Mask,
            d.Pipeline,
            d.ScrollFactor,
            d.Transform,
            d.Visible,
            a,
          ],
          initialize: function (c, f, g, m, n, q, r) {
            void 0 === m && (m = 16777215);
            void 0 === n && (n = 128);
            void 0 === q && (q = 1);
            void 0 === r && (r = 0.1);
            k.call(this, c, "PointLight");
            this.initPipeline(b.POINTLIGHT_PIPELINE);
            this.setPosition(f, g);
            this.color = e(m);
            this.intensity = q;
            this.attenuation = r;
            this.width = 2 * n;
            this.height = 2 * n;
            this._radius = n;
          },
          radius: {
            get: function () {
              return this._radius;
            },
            set: function (c) {
              this._radius = c;
              this.width = 2 * c;
              this.height = 2 * c;
            },
          },
          originX: {
            get: function () {
              return 0.5;
            },
          },
          originY: {
            get: function () {
              return 0.5;
            },
          },
          displayOriginX: {
            get: function () {
              return this._radius;
            },
          },
          displayOriginY: {
            get: function () {
              return this._radius;
            },
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d) {
          var k = d.width / 2,
            e = d.height / 2,
            b = Math.abs(a.x - d.x - k);
          d = Math.abs(a.y - d.y - e);
          var c = e + a.radius;
          if (b > k + a.radius || d > c) return !1;
          if (b <= k || d <= e) return !0;
          k = b - k;
          e = d - e;
          return k * k + e * e <= a.radius * a.radius;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return 0 >= a.width || 0 >= a.height || 0 >= d.width || 0 >= d.height
            ? !1
            : !(
                a.right < d.x ||
                a.bottom < d.y ||
                a.x > d.right ||
                a.y > d.bottom
              );
        };
      },
      function (h, t, a) {
        var d = a(6),
          k = {};
        h.exports = {
          register: function (e, b, c, f, g) {
            k[e] = {
              plugin: b,
              mapping: c,
              settingsKey: f,
              configKey: g,
            };
          },
          getPlugin: function (e) {
            return k[e];
          },
          install: function (e) {
            var b = e.scene.sys,
              c = b.settings.input;
            b = b.game.config;
            for (var f in k) {
              var g = k[f].plugin,
                m = k[f].mapping;
              d(c, k[f].settingsKey, b[k[f].configKey]) && (e[m] = new g(e));
            }
          },
          remove: function (e) {
            k.hasOwnProperty(e) && delete k[e];
          },
        };
      },
      function (h, t, a) {
        h.exports = {
          ANY_KEY_DOWN: a(1323),
          ANY_KEY_UP: a(1324),
          COMBO_MATCH: a(1325),
          DOWN: a(1326),
          KEY_DOWN: a(1327),
          KEY_UP: a(1328),
          UP: a(1329),
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return a.url
            ? a.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/)
              ? a.url
              : d + a.url
            : !1;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b, c) {
          void 0 === a && (a = "");
          void 0 === d && (d = !0);
          void 0 === k && (k = "");
          void 0 === e && (e = "");
          void 0 === b && (b = 0);
          void 0 === c && (c = !1);
          return {
            responseType: a,
            async: d,
            user: k,
            password: e,
            timeout: b,
            headers: void 0,
            header: void 0,
            headerValue: void 0,
            requestedWith: !1,
            overrideMimeType: void 0,
            withCredentials: c,
          };
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(243),
          k = a(73);
        a = new t({
          Extends: k,
          Mixins: [
            d.Acceleration,
            d.Angular,
            d.Bounce,
            d.Debug,
            d.Drag,
            d.Enable,
            d.Friction,
            d.Gravity,
            d.Immovable,
            d.Mass,
            d.Pushable,
            d.Size,
            d.Velocity,
          ],
          initialize: function (e, b, c, f, g) {
            k.call(this, e, b, c, f, g);
            this.body = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(119);
        h.exports = function (k, e, b, c) {
          void 0 === b && (b = !1);
          return d(k, e, c)
            ? (k = c.data[e][k] || null)
              ? -1 === k.index
                ? b
                  ? k
                  : null
                : k
              : null
            : null;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          var b = a.data,
            c = a.width,
            f = a.height;
          a = a.tilemapLayer;
          var g = Math.max(0, d.left),
            m = Math.min(c, d.right),
            n = Math.max(0, d.top);
          d = Math.min(f, d.bottom);
          var q, r;
          if (0 === k)
            for (q = n; q < d; q++)
              for (k = g; b[q] && k < m; k++)
                (r = b[q][k]) &&
                  -1 !== r.index &&
                  r.visible &&
                  0 !== r.alpha &&
                  e.push(r);
          else if (1 === k)
            for (q = n; q < d; q++)
              for (k = m; b[q] && k >= g; k--)
                (r = b[q][k]) &&
                  -1 !== r.index &&
                  r.visible &&
                  0 !== r.alpha &&
                  e.push(r);
          else if (2 === k)
            for (q = d; q >= n; q--)
              for (k = g; b[q] && k < m; k++)
                (r = b[q][k]) &&
                  -1 !== r.index &&
                  r.visible &&
                  0 !== r.alpha &&
                  e.push(r);
          else if (3 === k)
            for (q = d; q >= n; q--)
              for (k = m; b[q] && k >= g; k--)
                (r = b[q][k]) &&
                  -1 !== r.index &&
                  r.visible &&
                  0 !== r.alpha &&
                  e.push(r);
          a.tilesDrawn = e.length;
          a.tilesTotal = c * f;
          return e;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          var e = k.collideIndexes.indexOf(a);
          d && -1 === e
            ? k.collideIndexes.push(a)
            : d || -1 === e || k.collideIndexes.splice(e, 1);
        };
      },
      function (h, t, a) {
        var d = a(2);
        h.exports = function (k, e, b) {
          if (!e)
            return {
              i: 0,
              layers: k.layers,
              name: "",
              opacity: 1,
              visible: !0,
              x: 0,
              y: 0,
            };
          var c = e.x + d(e, "startx", 0) * k.tilewidth + d(e, "offsetx", 0);
          k = e.y + d(e, "starty", 0) * k.tileheight + d(e, "offsety", 0);
          return {
            i: 0,
            layers: e.layers,
            name: b.name + e.name + "/",
            opacity: b.opacity * e.opacity,
            visible: b.visible && e.visible,
            x: b.x + c,
            y: b.y + k,
          };
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          return a.hasOwnProperty(d)
            ? "function" === typeof a[d]
              ? function (e, b, c, f, g, m) {
                  return a[d](e, b, c, f, g, m);
                }
              : function () {
                  return a[d];
                }
            : "function" === typeof k
            ? k
            : function () {
                return k;
              };
        };
      },
      function (h, t, a) {
        var d = a(265),
          k = a(13),
          e = a(99),
          b = a(80),
          c = a(162),
          f = a(583),
          g = a(263),
          m = a(6),
          n = a(264),
          q = a(266),
          r = a(268);
        h.exports = function (u, v, x) {
          void 0 === x && (x = d);
          var y = x.targets ? x.targets : g(v),
            z = f(v),
            A = c(v, "delay", x.delay),
            B = c(v, "duration", x.duration),
            D = m(v, "easeParams", x.easeParams),
            E = b(m(v, "ease", x.ease), D),
            C = c(v, "hold", x.hold),
            F = c(v, "repeat", x.repeat),
            G = c(v, "repeatDelay", x.repeatDelay),
            H = e(v, "yoyo", x.yoyo),
            K = e(v, "flipX", x.flipX);
          x = e(v, "flipY", x.flipY);
          for (var I = [], M = 0; M < z.length; M++)
            for (var N = z[M].key, P = z[M].value, J = 0; J < y.length; J++) {
              var L = n(N, P);
              L = r(
                y[J],
                J,
                N,
                L.getEnd,
                L.getStart,
                L.getActive,
                b(m(P, "ease", E), m(P, "easeParams", D)),
                c(P, "delay", A),
                c(P, "duration", B),
                e(P, "yoyo", H),
                c(P, "hold", C),
                c(P, "repeat", F),
                c(P, "repeatDelay", G),
                e(P, "flipX", K),
                e(P, "flipY", x)
              );
              I.push(L);
            }
          u = new q(u, I, y);
          u.offset = k(v, "offset", null);
          u.completeDelay = k(v, "completeDelay", 0);
          u.loop = Math.round(k(v, "loop", 0));
          u.loopDelay = Math.round(k(v, "loopDelay", 0));
          u.paused = e(v, "paused", !1);
          u.useFrames = e(v, "useFrames", !1);
          y = m(v, "callbackScope", u);
          z = [u, null];
          A = q.TYPES;
          for (B = 0; B < A.length; B++)
            if (((D = A[B]), (E = m(v, D, !1))))
              (C = m(v, D + "Scope", y)),
                (F = m(v, D + "Params", [])),
                u.setCallback(D, E, z.concat(F), C);
          return u;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(102),
          k = a(2),
          e = a(132),
          b = a(185);
        a = new t({
          initialize: function (c) {
            this.parent = c;
            this.animationManager = c.scene.sys.anims;
            this.animationManager.on(
              e.REMOVE_ANIMATION,
              this.globalRemove,
              this
            );
            this.textureManager = this.animationManager.textureManager;
            this.anims = null;
            this.hasStarted = this.isPlaying = !1;
            this.nextAnim = this.currentFrame = this.currentAnim = null;
            this.nextAnimsQueue = [];
            this.timeScale = 1;
            this.msPerFrame = this.duration = this.frameRate = 0;
            this.skipMissedFrames = !0;
            this.repeatDelay = this.repeat = this.delay = 0;
            this.hideOnComplete = this.showOnStart = this.yoyo = !1;
            this.forward = !0;
            this.inReverse = !1;
            this.repeatCounter =
              this.delayCounter =
              this.nextTick =
              this.accumulator =
                0;
            this._wasPlaying = this._paused = this.pendingRepeat = !1;
            this._pendingStop = 0;
            this._pendingStopValue;
          },
          chain: function (c) {
            var f = this.parent;
            if (void 0 === c)
              return (
                (this.nextAnimsQueue.length = 0), (this.nextAnim = null), f
              );
            Array.isArray(c) || (c = [c]);
            for (f = 0; f < c.length; f++) {
              var g = c[f];
              null === this.nextAnim
                ? (this.nextAnim = g)
                : this.nextAnimsQueue.push(g);
            }
            return this.parent;
          },
          getName: function () {
            return this.currentAnim ? this.currentAnim.key : "";
          },
          getFrameName: function () {
            return this.currentFrame ? this.currentFrame.textureFrame : "";
          },
          load: function (c) {
            this.isPlaying && this.stop();
            var f = this.animationManager,
              g = "string" === typeof c ? c : k(c, "key", null);
            if ((f = this.exists(g) ? this.get(g) : f.get(g))) {
              this.currentAnim = f;
              g = f.getTotalFrames();
              var m = k(c, "frameRate", f.frameRate),
                n = k(c, "duration", f.duration);
              f.calculateDuration(this, g, n, m);
              this.delay = k(c, "delay", f.delay);
              this.repeat = k(c, "repeat", f.repeat);
              this.repeatDelay = k(c, "repeatDelay", f.repeatDelay);
              this.yoyo = k(c, "yoyo", f.yoyo);
              this.showOnStart = k(c, "showOnStart", f.showOnStart);
              this.hideOnComplete = k(c, "hideOnComplete", f.hideOnComplete);
              this.skipMissedFrames = k(
                c,
                "skipMissedFrames",
                f.skipMissedFrames
              );
              this.timeScale = k(c, "timeScale", this.timeScale);
              c = k(c, "startFrame", 0);
              c > f.getTotalFrames() && (c = 0);
              g = f.frames[c];
              0 !== c || this.forward || (g = f.getLastFrame());
              this.currentFrame = g;
            } else console.warn("Missing animation: " + g);
            return this.parent;
          },
          pause: function (c) {
            this._paused ||
              ((this._paused = !0),
              (this._wasPlaying = this.isPlaying),
              (this.isPlaying = !1));
            void 0 !== c && this.setCurrentFrame(c);
            return this.parent;
          },
          resume: function (c) {
            this._paused &&
              ((this._paused = !1), (this.isPlaying = this._wasPlaying));
            void 0 !== c && this.setCurrentFrame(c);
            return this.parent;
          },
          playAfterDelay: function (c, f) {
            if (this.isPlaying) {
              var g = this.nextAnim,
                m = this.nextAnimsQueue;
              g && m.unshift(g);
              this.nextAnim = c;
              this._pendingStop = 1;
              this._pendingStopValue = f;
            } else (this.delayCounter = f), this.play(c, !0);
            return this.parent;
          },
          playAfterRepeat: function (c, f) {
            void 0 === f && (f = 1);
            if (this.isPlaying) {
              var g = this.nextAnim,
                m = this.nextAnimsQueue;
              g && m.unshift(g);
              -1 !== this.repeatCounter &&
                f > this.repeatCounter &&
                (f = this.repeatCounter);
              this.nextAnim = c;
              this._pendingStop = 2;
              this._pendingStopValue = f;
            } else this.play(c);
            return this.parent;
          },
          play: function (c, f) {
            void 0 === f && (f = !1);
            var g = this.currentAnim,
              m = this.parent,
              n = "string" === typeof c ? c : c.key;
            if (f && this.isPlaying && g.key === n) return m;
            if (
              g &&
              this.isPlaying &&
              ((f = this.animationManager.getMix(g.key, c)), 0 < f)
            )
              return this.playAfterDelay(c, f);
            this.forward = !0;
            this._paused = this.inReverse = !1;
            this._wasPlaying = !0;
            return this.startAnimation(c);
          },
          playReverse: function (c, f) {
            void 0 === f && (f = !1);
            var g = "string" === typeof c ? c : c.key;
            if (f && this.isPlaying && this.currentAnim.key === g)
              return this.parent;
            this.forward = !1;
            this.inReverse = !0;
            this._paused = !1;
            this._wasPlaying = !0;
            return this.startAnimation(c);
          },
          startAnimation: function (c) {
            this.load(c);
            c = this.currentAnim;
            var f = this.parent;
            if (!c) return f;
            this.repeatCounter =
              -1 === this.repeat ? Number.MAX_VALUE : this.repeat;
            c.getFirstTick(this);
            this.isPlaying = !0;
            this.hasStarted = this.pendingRepeat = !1;
            this._pendingStopValue = this._pendingStop = 0;
            this._paused = !1;
            this.delayCounter += this.delay;
            0 === this.delayCounter && this.handleStart();
            return f;
          },
          handleStart: function () {
            this.showOnStart && this.parent.setVisible(!0);
            this.setCurrentFrame(this.currentFrame);
            this.hasStarted = !0;
            this.emitEvents(e.ANIMATION_START);
          },
          handleRepeat: function () {
            this.pendingRepeat = !1;
            this.emitEvents(e.ANIMATION_REPEAT);
          },
          handleStop: function () {
            this._pendingStop = 0;
            this.isPlaying = !1;
            this.emitEvents(e.ANIMATION_STOP);
          },
          handleComplete: function () {
            this._pendingStop = 0;
            this.isPlaying = !1;
            this.hideOnComplete && this.parent.setVisible(!1);
            this.emitEvents(e.ANIMATION_COMPLETE, e.ANIMATION_COMPLETE_KEY);
          },
          emitEvents: function (c, f) {
            var g = this.currentAnim,
              m = this.currentFrame,
              n = this.parent,
              q = m.textureFrame;
            n.emit(c, g, m, n, q);
            f && n.emit(f + g.key, g, m, n, q);
          },
          reverse: function () {
            this.isPlaying &&
              ((this.inReverse = !this.inReverse),
              (this.forward = !this.forward));
            return this.parent;
          },
          getProgress: function () {
            var c = this.currentFrame;
            if (!c) return 0;
            c = c.progress;
            this.inReverse && (c *= -1);
            return c;
          },
          setProgress: function (c) {
            this.forward || (c = 1 - c);
            this.setCurrentFrame(this.currentAnim.getFrameByProgress(c));
            return this.parent;
          },
          setRepeat: function (c) {
            this.repeatCounter = -1 === c ? Number.MAX_VALUE : c;
            return this.parent;
          },
          globalRemove: function (c, f) {
            void 0 === f && (f = this.currentAnim);
            this.isPlaying &&
              f.key === this.currentAnim.key &&
              (this.stop(), this.setCurrentFrame(this.currentAnim.frames[0]));
          },
          restart: function (c, f) {
            void 0 === c && (c = !1);
            void 0 === f && (f = !1);
            var g = this.currentAnim,
              m = this.parent;
            if (!g) return m;
            f &&
              (this.repeatCounter =
                -1 === this.repeat ? Number.MAX_VALUE : this.repeat);
            g.getFirstTick(this);
            this.emitEvents(e.ANIMATION_RESTART);
            this.isPlaying = !0;
            this.pendingRepeat = !1;
            this.hasStarted = !c;
            this._pendingStopValue = this._pendingStop = 0;
            this._paused = !1;
            this.setCurrentFrame(g.frames[0]);
            return this.parent;
          },
          complete: function () {
            this._pendingStop = 0;
            this.isPlaying = !1;
            this.currentAnim && this.handleComplete();
            if (this.nextAnim) {
              var c = this.nextAnim;
              this.nextAnim =
                0 < this.nextAnimsQueue.length
                  ? this.nextAnimsQueue.shift()
                  : null;
              this.play(c);
            }
            return this.parent;
          },
          stop: function () {
            this._pendingStop = 0;
            this.isPlaying = !1;
            this.currentAnim && this.handleStop();
            if (this.nextAnim) {
              var c = this.nextAnim;
              this.nextAnim = this.nextAnimsQueue.shift();
              this.play(c);
            }
            return this.parent;
          },
          stopAfterDelay: function (c) {
            this._pendingStop = 1;
            this._pendingStopValue = c;
            return this.parent;
          },
          stopAfterRepeat: function (c) {
            void 0 === c && (c = 1);
            -1 !== this.repeatCounter &&
              c > this.repeatCounter &&
              (c = this.repeatCounter);
            this._pendingStop = 2;
            this._pendingStopValue = c;
            return this.parent;
          },
          stopOnFrame: function (c) {
            this._pendingStop = 3;
            this._pendingStopValue = c;
            return this.parent;
          },
          getTotalFrames: function () {
            return this.currentAnim ? this.currentAnim.getTotalFrames() : 0;
          },
          update: function (c, f) {
            c = this.currentAnim;
            if (this.isPlaying && c && !c.paused) {
              this.accumulator += f * this.timeScale;
              if (
                1 === this._pendingStop &&
                ((this._pendingStopValue -= f), 0 >= this._pendingStopValue)
              )
                return this.stop();
              if (!this.hasStarted)
                this.accumulator >= this.delayCounter &&
                  ((this.accumulator -= this.delayCounter), this.handleStart());
              else if (
                this.accumulator >= this.nextTick &&
                (this.forward ? c.nextFrame(this) : c.previousFrame(this),
                this.isPlaying &&
                  0 === this._pendingStop &&
                  this.skipMissedFrames &&
                  this.accumulator > this.nextTick)
              ) {
                f = 0;
                do
                  this.forward ? c.nextFrame(this) : c.previousFrame(this), f++;
                while (
                  this.isPlaying &&
                  this.accumulator > this.nextTick &&
                  60 > f
                );
              }
            }
          },
          setCurrentFrame: function (c) {
            var f = this.parent;
            this.currentFrame = c;
            f.texture = c.frame.texture;
            f.frame = c.frame;
            f.isCropped && f.frame.updateCropUVs(f._crop, f.flipX, f.flipY);
            c.setAlpha && (f.alpha = c.alpha);
            f.setSizeToFrame();
            f._originComponent &&
              (c.frame.customPivot
                ? f.setOrigin(c.frame.pivotX, c.frame.pivotY)
                : f.updateDisplayOrigin());
            this.isPlaying &&
              this.hasStarted &&
              (this.emitEvents(e.ANIMATION_UPDATE),
              3 === this._pendingStop &&
                this._pendingStopValue === c &&
                this.stop());
            return f;
          },
          nextFrame: function () {
            this.currentAnim && this.currentAnim.nextFrame(this);
            return this.parent;
          },
          previousFrame: function () {
            this.currentAnim && this.currentAnim.previousFrame(this);
            return this.parent;
          },
          get: function (c) {
            return this.anims ? this.anims.get(c) : null;
          },
          exists: function (c) {
            return this.anims ? this.anims.has(c) : !1;
          },
          create: function (c) {
            var f = c.key,
              g = !1;
            f &&
              ((g = this.get(f)),
              g ||
                ((g = new b(this, f, c)),
                this.anims || (this.anims = new d()),
                this.anims.set(f, g)));
            return g;
          },
          generateFrameNames: function (c, f) {
            return this.animationManager.generateFrameNames(c, f);
          },
          generateFrameNumbers: function (c, f) {
            return this.animationManager.generateFrameNumbers(c, f);
          },
          remove: function (c) {
            var f = this.get(c);
            f && (this.currentAnim === f && this.stop(), this.anims.delete(c));
            return f;
          },
          destroy: function () {
            this.animationManager.off(
              e.REMOVE_ANIMATION,
              this.globalRemove,
              this
            );
            this.anims && this.anims.clear();
            this.nextAnim = this.parent = this.animationManager = null;
            this.nextAnimsQueue.length = 0;
            this.currentFrame = this.currentAnim = null;
          },
          isPaused: {
            get: function () {
              return this._paused;
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(166);
        (function () {
          d._motionWakeThreshold = 0.18;
          d._motionSleepThreshold = 0.08;
          d._minBias = 0.9;
          d.update = function (e, b) {
            b *= b * b;
            for (var c = 0; c < e.length; c++) {
              var f = e[c],
                g = f.speed * f.speed + f.angularSpeed * f.angularSpeed;
              0 !== f.force.x || 0 !== f.force.y
                ? d.set(f, !1)
                : ((f.motion =
                    d._minBias * Math.min(f.motion, g) +
                    (1 - d._minBias) * Math.max(f.motion, g)),
                  0 < f.sleepThreshold && f.motion < d._motionSleepThreshold * b
                    ? ((f.sleepCounter += 1),
                      f.sleepCounter >= f.sleepThreshold && d.set(f, !0))
                    : 0 < f.sleepCounter && --f.sleepCounter);
            }
          };
          d.afterCollisions = function (e, b) {
            b *= b * b;
            for (var c = 0; c < e.length; c++) {
              var f = e[c];
              if (f.isActive) {
                var g = f.collision;
                f = g.bodyA.parent;
                var m = g.bodyB.parent;
                (f.isSleeping && m.isSleeping) ||
                  f.isStatic ||
                  m.isStatic ||
                  (!f.isSleeping && !m.isSleeping) ||
                  ((g = f.isSleeping && !f.isStatic ? f : m),
                  (f = g === f ? m : f),
                  !g.isStatic &&
                    f.motion > d._motionWakeThreshold * b &&
                    d.set(g, !1));
              }
            }
          };
          d.set = function (e, b) {
            var c = e.isSleeping;
            b
              ? ((e.isSleeping = !0),
                (e.sleepCounter = e.sleepThreshold),
                (e.positionImpulse.x = 0),
                (e.positionImpulse.y = 0),
                (e.positionPrev.x = e.position.x),
                (e.positionPrev.y = e.position.y),
                (e.anglePrev = e.angle),
                (e.speed = 0),
                (e.angularSpeed = 0),
                (e.motion = 0),
                c || k.trigger(e, "sleepStart"))
              : ((e.isSleeping = !1),
                (e.sleepCounter = 0),
                c && k.trigger(e, "sleepEnd"));
          };
        })();
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(32);
        (function () {
          d.on = function (e, b, c) {
            b = b.split(" ");
            for (var f, g = 0; g < b.length; g++)
              (f = b[g]),
                (e.events = e.events || {}),
                (e.events[f] = e.events[f] || []),
                e.events[f].push(c);
            return c;
          };
          d.off = function (e, b, c) {
            if (b) {
              "function" === typeof b &&
                ((c = b), (b = k.keys(e.events).join(" ")));
              b = b.split(" ");
              for (var f = 0; f < b.length; f++) {
                var g = e.events[b[f]],
                  m = [];
                if (c && g)
                  for (var n = 0; n < g.length; n++) g[n] !== c && m.push(g[n]);
                e.events[b[f]] = m;
              }
            } else e.events = {};
          };
          d.trigger = function (e, b, c) {
            var f,
              g = e.events;
            if (g && 0 < k.keys(g).length) {
              c || (c = {});
              b = b.split(" ");
              for (var m = 0; m < b.length; m++) {
                var n = b[m];
                if ((f = g[n])) {
                  var q = k.clone(c, !1);
                  q.name = n;
                  q.source = e;
                  for (n = 0; n < f.length; n++) f[n].apply(e, [q]);
                }
              }
            }
          };
        })();
      },
      function (h, t, a) {
        var d = a(175),
          k = a(92),
          e = a(74);
        h.exports = {
          defaultPipeline: null,
          pipeline: null,
          hasPostPipeline: !1,
          postPipelines: null,
          pipelineData: null,
          initPipeline: function (b) {
            void 0 === b && (b = k.MULTI_PIPELINE);
            var c = this.scene.sys.renderer;
            if (!c) return !1;
            c = c.pipelines;
            this.postPipelines = [];
            this.pipelineData = {};
            return c && (b = c.get(b))
              ? ((this.pipeline = this.defaultPipeline = b), !0)
              : !1;
          },
          setPipeline: function (b, c, f) {
            var g = this.scene.sys.renderer;
            if (!g) return this;
            if ((g = g.pipelines)) {
              if ((b = g.get(b))) this.pipeline = b;
              c && (this.pipelineData = f ? d(c) : c);
            }
            return this;
          },
          setPostPipeline: function (b, c, f) {
            var g = this.scene.sys.renderer;
            if (!g) return this;
            if ((g = g.pipelines)) {
              Array.isArray(b) || (b = [b]);
              for (var m = 0; m < b.length; m++) {
                var n = g.getPostPipeline(b[m], this);
                n && this.postPipelines.push(n);
              }
              c && (this.pipelineData = f ? d(c) : c);
            }
            this.hasPostPipeline = 0 < this.postPipelines.length;
            return this;
          },
          setPipelineData: function (b, c) {
            var f = this.pipelineData;
            void 0 === c ? delete f[b] : (f[b] = c);
            return this;
          },
          getPostPipeline: function (b) {
            for (var c = this.postPipelines, f = [], g = 0; g < c.length; g++) {
              var m = c[g];
              (("string" === typeof b && m.name === b) || m instanceof b) &&
                f.push(m);
            }
            return 1 === f.length ? f[0] : f;
          },
          resetPipeline: function (b, c) {
            void 0 === b && (b = !1);
            void 0 === c && (c = !1);
            this.pipeline = this.defaultPipeline;
            b && ((this.postPipelines = []), (this.hasPostPipeline = !1));
            c && (this.pipelineData = {});
            return null !== this.pipeline;
          },
          resetPostPipeline: function (b) {
            void 0 === b && (b = !1);
            for (var c = this.postPipelines, f = 0; f < c.length; f++)
              c[f].destroy();
            this.postPipelines = [];
            this.hasPostPipeline = !1;
            b && (this.pipelineData = {});
          },
          removePostPipeline: function (b) {
            for (var c = this.postPipelines, f = c.length - 1; 0 <= f; f--) {
              var g = c[f];
              if (
                ("string" === typeof b && g.name === b) ||
                ("string" !== typeof b && g instanceof b)
              )
                g.destroy(), e(c, f);
            }
            this.hasPostPipeline = 0 < this.postPipelines.length;
            return this;
          },
          getPipelineName: function () {
            return this.pipeline.name;
          },
        };
      },
      function (h, t) {
        h.exports = {
          DEFAULT: 0,
          LINEAR: 0,
          NEAREST: 1,
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e, b) {
          void 0 === b && (b = new d());
          b.x = k.x + k.radius * Math.cos(e);
          b.y = k.y + k.radius * Math.sin(e);
          return b;
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          var b = 2 * Math.PI * Math.random(),
            c = Math.random() + Math.random();
          c = 1 < c ? 2 - c : c;
          var f = c * Math.sin(b);
          e.x = k.x + c * Math.cos(b) * k.radius;
          e.y = k.y + f * k.radius;
          return e;
        };
      },
      function (h, t, a) {
        var d = a(130),
          k = a(4);
        h.exports = function (e, b, c) {
          void 0 === c && (c = new k());
          if (0 >= b || 1 <= b) return (c.x = e.x), (c.y = e.y), c;
          var f = d(e) * b;
          0.5 < b
            ? ((f -= e.width + e.height),
              f <= e.width
                ? ((c.x = e.right - f), (c.y = e.bottom))
                : ((c.x = e.x), (c.y = e.bottom - (f - e.width))))
            : f <= e.width
            ? ((c.x = e.x + f), (c.y = e.y))
            : ((c.x = e.right), (c.y = e.y + (f - e.width)));
          return c;
        };
      },
      function (h, t, a) {
        var d = a(67),
          k = a(4);
        h.exports = function (e, b, c, f) {
          void 0 === f && (f = []);
          !b && 0 < c && (b = d(e) / c);
          c = e.x1;
          var g = e.y1,
            m = e.x2;
          e = e.y2;
          for (var n = 0; n < b; n++) {
            var q = n / b;
            f.push(new k(c + (m - c) * q, g + (e - g) * q));
          }
          return f;
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          var b = Math.random();
          e.x = k.x1 + b * (k.x2 - k.x1);
          e.y = k.y1 + b * (k.y2 - k.y1);
          return e;
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          e.x = k.x + Math.random() * k.width;
          e.y = k.y + Math.random() * k.height;
          return e;
        };
      },
      function (h, t) {
        var a = function (d) {
          var k;
          if ("object" !== typeof d || null === d) return d;
          var e = Array.isArray(d) ? [] : {};
          for (k in d) {
            var b = d[k];
            e[k] = a(b);
          }
          return e;
        };
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a) {
          var d = {
            name: a.name,
            type: a.type,
            x: a.x,
            y: a.y,
            depth: a.depth,
            scale: {
              x: a.scaleX,
              y: a.scaleY,
            },
            origin: {
              x: a.originX,
              y: a.originY,
            },
            flipX: a.flipX,
            flipY: a.flipY,
            rotation: a.rotation,
            alpha: a.alpha,
            visible: a.visible,
            blendMode: a.blendMode,
            textureKey: "",
            frameKey: "",
            data: {},
          };
          a.texture &&
            ((d.textureKey = a.texture.key), (d.frameKey = a.frame.name));
          return d;
        };
      },
      function (h, t, a) {
        var d = a(3);
        h.exports = function (k, e, b, c, f, g, m, n) {
          void 0 === n && (n = new d());
          var q = Math.sin(f),
            r = Math.cos(f);
          f = r * g;
          g *= q;
          q = -q * m;
          m *= r;
          r = 1 / (f * m + q * -g);
          n.x = m * r * k + -q * r * e + (c * q - b * m) * r;
          n.y = f * r * e + -g * r * k + (-c * f + b * g) * r;
          return n;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = 1);
          for (var k = null, e = 0; e < d; e++) (k = a.shift()), a.push(k);
          return k;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = 1);
          for (var k = null, e = 0; e < d; e++) (k = a.pop()), a.unshift(k);
          return k;
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          var b = Math.random() * Math.PI * 2,
            c = Math.sqrt(Math.random());
          e.x = k.x + (c * Math.cos(b) * k.width) / 2;
          e.y = k.y + (c * Math.sin(b) * k.height) / 2;
          return e;
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          var b = k.x2 - k.x1,
            c = k.y2 - k.y1,
            f = k.x3 - k.x1,
            g = k.y3 - k.y1,
            m = Math.random(),
            n = Math.random();
          1 <= m + n && ((m = 1 - m), (n = 1 - n));
          e.x = k.x1 + (b * m + f * n);
          e.y = k.y1 + (c * m + g * n);
          return e;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b) {
          e += Math.atan2(a.y - k, a.x - d);
          a.x = d + b * Math.cos(e);
          a.y = k + b * Math.sin(e);
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          a = Math.max(0, Math.min(1, (a - d) / (k - d)));
          return a * a * a * (a * (6 * a - 15) + 10);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          if (a <= d) return 0;
          if (a >= k) return 1;
          a = (a - d) / (k - d);
          return a * a * (3 - 2 * a);
        };
      },
      function (h, t, a) {
        var d = a(18);
        t = a(0);
        var k = a(132),
          e = a(318),
          b = a(319),
          c = a(6),
          f = a(320);
        a = new t({
          initialize: function (g, m, n) {
            this.manager = g;
            this.key = m;
            this.type = "frame";
            this.frames = this.getFrames(
              g.textureManager,
              c(n, "frames", []),
              c(n, "defaultTextureKey", null),
              c(n, "sortFrames", !0)
            );
            this.frameRate = c(n, "frameRate", null);
            this.duration = c(n, "duration", null);
            this.msPerFrame;
            this.skipMissedFrames = c(n, "skipMissedFrames", !0);
            this.delay = c(n, "delay", 0);
            this.repeat = c(n, "repeat", 0);
            this.repeatDelay = c(n, "repeatDelay", 0);
            this.yoyo = c(n, "yoyo", !1);
            this.showOnStart = c(n, "showOnStart", !1);
            this.hideOnComplete = c(n, "hideOnComplete", !1);
            this.paused = !1;
            this.calculateDuration(
              this,
              this.getTotalFrames(),
              this.duration,
              this.frameRate
            );
            this.manager.on &&
              (this.manager.on(k.PAUSE_ALL, this.pause, this),
              this.manager.on(k.RESUME_ALL, this.resume, this));
          },
          getTotalFrames: function () {
            return this.frames.length;
          },
          calculateDuration: function (g, m, n, q) {
            null === n && null === q
              ? ((g.frameRate = 24), (g.duration = (24 / m) * 1e3))
              : n && null === q
              ? ((g.duration = n), (g.frameRate = m / (n / 1e3)))
              : ((g.frameRate = q), (g.duration = (m / q) * 1e3));
            g.msPerFrame = 1e3 / g.frameRate;
          },
          addFrame: function (g) {
            return this.addFrameAt(this.frames.length, g);
          },
          addFrameAt: function (g, m) {
            m = this.getFrames(this.manager.textureManager, m);
            if (0 < m.length) {
              if (0 === g) this.frames = m.concat(this.frames);
              else if (g === this.frames.length)
                this.frames = this.frames.concat(m);
              else {
                var n = this.frames.slice(0, g);
                g = this.frames.slice(g);
                this.frames = n.concat(m, g);
              }
              this.updateFrameSequence();
            }
            return this;
          },
          checkFrame: function (g) {
            return 0 <= g && g < this.frames.length;
          },
          getFirstTick: function (g) {
            g.accumulator = 0;
            g.nextTick = g.msPerFrame + g.currentFrame.duration;
          },
          getFrameAt: function (g) {
            return this.frames[g];
          },
          getFrames: function (g, m, n, q) {
            void 0 === q && (q = !0);
            var r = [],
              u = 1;
            if ("string" === typeof m) {
              var v = m;
              var x = g.get(v).getFrameNames();
              q && f(x);
              m = [];
              x.forEach(function (D) {
                m.push({
                  key: v,
                  frame: D,
                });
              });
            }
            if (!Array.isArray(m) || 0 === m.length) return r;
            for (q = 0; q < m.length; q++) {
              x = m[q];
              var y = c(x, "key", n);
              if (y) {
                var z = c(x, "frame", 0);
                var A = g.getFrame(y, z);
                z = new b(y, z, u, A);
                z.duration = c(x, "duration", 0);
                z.isFirst = !B;
                B && ((B.nextFrame = z), (z.prevFrame = B));
                r.push(z);
                var B = z;
                u++;
              }
            }
            if (0 < r.length)
              for (
                z.isLast = !0,
                  z.nextFrame = r[0],
                  r[0].prevFrame = z,
                  g = 1 / (r.length - 1),
                  q = 0;
                q < r.length;
                q++
              )
                r[q].progress = q * g;
            return r;
          },
          getNextTick: function (g) {
            g.accumulator -= g.nextTick;
            g.nextTick = g.msPerFrame + g.currentFrame.duration;
          },
          getFrameByProgress: function (g) {
            g = d(g, 0, 1);
            return e(g, this.frames, "progress");
          },
          nextFrame: function (g) {
            var m = g.currentFrame;
            m.isLast
              ? g.yoyo
                ? this.handleYoyoFrame(g, !1)
                : 0 < g.repeatCounter
                ? g.inReverse && g.forward
                  ? (g.forward = !1)
                  : this.repeatAnimation(g)
                : g.complete()
              : this.updateAndGetNextTick(g, m.nextFrame);
          },
          handleYoyoFrame: function (g, m) {
            m || (m = !1);
            if (g.inReverse === !m && 0 < g.repeatCounter) {
              if (0 === g.repeatDelay || g.pendingRepeat) g.forward = m;
              this.repeatAnimation(g);
            } else
              g.inReverse !== m && 0 === g.repeatCounter
                ? g.complete()
                : ((g.forward = m),
                  this.updateAndGetNextTick(
                    g,
                    m ? g.currentFrame.nextFrame : g.currentFrame.prevFrame
                  ));
          },
          getLastFrame: function () {
            return this.frames[this.frames.length - 1];
          },
          previousFrame: function (g) {
            var m = g.currentFrame;
            if (m.isFirst)
              if (g.yoyo) this.handleYoyoFrame(g, !0);
              else if (0 < g.repeatCounter) {
                if (!g.inReverse || g.forward) g.forward = !0;
                this.repeatAnimation(g);
              } else g.complete();
            else this.updateAndGetNextTick(g, m.prevFrame);
          },
          updateAndGetNextTick: function (g, m) {
            g.setCurrentFrame(m);
            this.getNextTick(g);
          },
          removeFrame: function (g) {
            g = this.frames.indexOf(g);
            -1 !== g && this.removeFrameAt(g);
            return this;
          },
          removeFrameAt: function (g) {
            this.frames.splice(g, 1);
            this.updateFrameSequence();
            return this;
          },
          repeatAnimation: function (g) {
            if (2 === g._pendingStop) {
              if (0 === g._pendingStopValue) return g.stop();
              g._pendingStopValue--;
            }
            0 < g.repeatDelay && !g.pendingRepeat
              ? ((g.pendingRepeat = !0),
                (g.accumulator -= g.nextTick),
                (g.nextTick += g.repeatDelay))
              : (g.repeatCounter--,
                g.forward
                  ? g.setCurrentFrame(g.currentFrame.nextFrame)
                  : g.setCurrentFrame(g.currentFrame.prevFrame),
                g.isPlaying && (this.getNextTick(g), g.handleRepeat()));
          },
          toJSON: function () {
            var g = {
              key: this.key,
              type: this.type,
              frames: [],
              frameRate: this.frameRate,
              duration: this.duration,
              skipMissedFrames: this.skipMissedFrames,
              delay: this.delay,
              repeat: this.repeat,
              repeatDelay: this.repeatDelay,
              yoyo: this.yoyo,
              showOnStart: this.showOnStart,
              hideOnComplete: this.hideOnComplete,
            };
            this.frames.forEach(function (m) {
              g.frames.push(m.toJSON());
            });
            return g;
          },
          updateFrameSequence: function () {
            for (
              var g = this.frames.length, m = 1 / (g - 1), n, q = 0;
              q < g;
              q++
            )
              (n = this.frames[q]),
                (n.index = q + 1),
                (n.isFirst = !1),
                (n.isLast = !1),
                (n.progress = q * m),
                0 === q
                  ? ((n.isFirst = !0),
                    1 === g
                      ? ((n.isLast = !0), (n.nextFrame = n), (n.prevFrame = n))
                      : ((n.isLast = !1),
                        (n.prevFrame = this.frames[g - 1]),
                        (n.nextFrame = this.frames[q + 1])))
                  : q === g - 1 && 1 < g
                  ? ((n.isLast = !0),
                    (n.prevFrame = this.frames[g - 2]),
                    (n.nextFrame = this.frames[0]))
                  : 1 < g &&
                    ((n.prevFrame = this.frames[q - 1]),
                    (n.nextFrame = this.frames[q + 1]));
            return this;
          },
          pause: function () {
            this.paused = !0;
            return this;
          },
          resume: function () {
            this.paused = !1;
            return this;
          },
          destroy: function () {
            this.manager.off &&
              (this.manager.off(k.PAUSE_ALL, this.pause, this),
              this.manager.off(k.RESUME_ALL, this.resume, this));
            this.manager.remove(this.key);
            for (var g = 0; g < this.frames.length; g++)
              this.frames[g].destroy();
            this.frames = [];
            this.manager = null;
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          void 0 === d && (d = 0);
          void 0 === k && (k = " ");
          void 0 === e && (e = 3);
          a = a.toString();
          if (d + 1 >= a.length)
            switch (e) {
              case 1:
                a = Array(d + 1 - a.length).join(k) + a;
                break;
              case 3:
                e = Math.ceil((d -= a.length) / 2);
                a = Array(d - e + 1).join(k) + a + Array(e + 1).join(k);
                break;
              default:
                a += Array(d + 1 - a.length).join(k);
            }
          return a;
        };
      },
      function (h, t, a) {
        var d = a(327),
          k = a(189),
          e = a(331),
          b = a(332);
        h.exports = function (c) {
          switch (typeof c) {
            case "string":
              return "rgb" === c.substr(0, 3).toLowerCase() ? b(c) : d(c);
            case "number":
              return k(c);
            case "object":
              return e(c);
          }
        };
      },
      function (h, t, a) {
        function d(e, b, c, f) {
          e = (e + 6 * b) % 6;
          return Math.round(
            255 * (f - f * c * Math.max(0, Math.min(e, 4 - e, 1)))
          );
        }
        var k = a(103);
        h.exports = function (e, b, c, f) {
          void 0 === b && (b = 1);
          void 0 === c && (c = 1);
          var g = d(5, e, b, c),
            m = d(3, e, b, c);
          e = d(1, e, b, c);
          if (f) {
            if (f.setTo) return f.setTo(g, m, e, f.alpha, !1);
            f.r = g;
            f.g = m;
            f.b = e;
            f.color = k(g, m, e);
            return f;
          }
          return {
            r: g,
            g: m,
            b: e,
            color: k(g, m, e),
          };
        };
      },
      function (h, t, a) {
        var d = a(38),
          k = a(330);
        h.exports = function (e) {
          e = k(e);
          return new d(e.r, e.g, e.b, e.a);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          a.x = d - a.width / 2;
          a.y = k - a.height / 2;
          return a;
        };
      },
      function (h, t, a) {
        function d() {
          var f = new ArrayBuffer(4),
            g = new Uint8Array(f);
          f = new Uint32Array(f);
          g[0] = 161;
          g[1] = 178;
          g[2] = 195;
          g[3] = 212;
          return 3569595041 === f[0] ? !0 : 2712847316 === f[0] ? !1 : null;
        }
        var k = a(105),
          e = a(136),
          b = a(31),
          c = {
            canvas: !1,
            canvasBitBltShift: null,
            file: !1,
            fileSystem: !1,
            getUserMedia: !0,
            littleEndian: !1,
            localStorage: !1,
            pointerLock: !1,
            support32bit: !1,
            vibration: !1,
            webGL: !1,
            worker: !1,
          };
        h.exports = (function () {
          if ("function" === typeof importScripts) return c;
          c.canvas = !!window.CanvasRenderingContext2D;
          try {
            c.localStorage = !!localStorage.getItem;
          } catch (g) {
            c.localStorage = !1;
          }
          c.file =
            !!window.File &&
            !!window.FileReader &&
            !!window.FileList &&
            !!window.Blob;
          c.fileSystem = !!window.requestFileSystem;
          var f = !1;
          c.webGL = (function () {
            if (window.WebGLRenderingContext)
              try {
                var g = b.createWebGL(this),
                  m =
                    g.getContext("webgl") || g.getContext("experimental-webgl"),
                  n = b.create2D(this);
                f =
                  n.getContext("2d").createImageData(1, 1).data instanceof
                  Uint8ClampedArray;
                b.remove(g);
                b.remove(n);
                return !!m;
              } catch (q) {}
            return !1;
          })();
          c.worker = !!window.Worker;
          c.pointerLock =
            "pointerLockElement" in document ||
            "mozPointerLockElement" in document ||
            "webkitPointerLockElement" in document;
          navigator.getUserMedia =
            navigator.getUserMedia ||
            navigator.webkitGetUserMedia ||
            navigator.mozGetUserMedia ||
            navigator.msGetUserMedia ||
            navigator.oGetUserMedia;
          window.URL =
            window.URL || window.webkitURL || window.mozURL || window.msURL;
          c.getUserMedia =
            c.getUserMedia && !!navigator.getUserMedia && !!window.URL;
          e.firefox && 21 > e.firefoxVersion && (c.getUserMedia = !1);
          !k.iOS &&
            (e.ie || e.firefox || e.chrome) &&
            (c.canvasBitBltShift = !0);
          if (e.safari || e.mobileSafari) c.canvasBitBltShift = !1;
          navigator.vibrate =
            navigator.vibrate ||
            navigator.webkitVibrate ||
            navigator.mozVibrate ||
            navigator.msVibrate;
          navigator.vibrate && (c.vibration = !0);
          "undefined" !== typeof ArrayBuffer &&
            "undefined" !== typeof Uint8Array &&
            "undefined" !== typeof Uint32Array &&
            (c.littleEndian = d());
          c.support32bit =
            "undefined" !== typeof ArrayBuffer &&
            "undefined" !== typeof Uint8ClampedArray &&
            "undefined" !== typeof Int32Array &&
            null !== c.littleEndian &&
            f;
          return c;
        })();
      },
      function (h, t) {
        var a = "";
        h.exports = (function () {
          var d = function (k) {
            for (
              var e = ["i", "webkitI", "msI", "mozI", "oI"], b = 0;
              b < e.length;
              b++
            ) {
              var c = e[b] + "mageSmoothingEnabled";
              if (c in k) return c;
            }
            return null;
          };
          return {
            disable: function (k) {
              "" === a && (a = d(k));
              a && (k[a] = !1);
              return k;
            },
            enable: function (k) {
              "" === a && (a = d(k));
              a && (k[a] = !0);
              return k;
            },
            getPrefix: d,
            isEnabled: function (k) {
              return null !== a ? k[a] : null;
            },
          };
        })();
      },
      function (h, t, a) {
        t = a(14);
        var d = a(17);
        a = {
          Angle: a(812),
          Distance: a(821),
          Easing: a(826),
          Fuzzy: a(827),
          Interpolation: a(830),
          Pow2: a(835),
          Snap: a(837),
          RandomDataGenerator: a(839),
          Average: a(840),
          Bernstein: a(356),
          Between: a(195),
          CatmullRom: a(194),
          CeilTo: a(841),
          Clamp: a(18),
          DegToRad: a(36),
          Difference: a(842),
          Euler: a(843),
          Factorial: a(357),
          FloatBetween: a(137),
          FloorTo: a(844),
          FromPercent: a(98),
          GetSpeed: a(845),
          IsEven: a(846),
          IsEvenStrict: a(847),
          Linear: a(135),
          MaxAdd: a(848),
          Median: a(849),
          MinSub: a(850),
          Percent: a(851),
          RadToDeg: a(196),
          RandomXY: a(852),
          RandomXYZ: a(853),
          RandomXYZW: a(854),
          Rotate: a(362),
          RotateAround: a(308),
          RotateAroundDistance: a(182),
          RotateTo: a(855),
          RoundAwayFromZero: a(363),
          RoundTo: a(856),
          SinCosTableGenerator: a(857),
          SmootherStep: a(183),
          SmoothStep: a(184),
          ToXY: a(858),
          TransformXY: a(177),
          Within: a(859),
          Wrap: a(68),
          Vector2: a(3),
          Vector3: a(39),
          Vector4: a(140),
          Matrix3: a(364),
          Matrix4: a(69),
          Quaternion: a(365),
          RotateVec3: a(860),
        };
        a = d(!1, a, t);
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b) {
          d = 0.5 * (e - d);
          b = 0.5 * (b - k);
          var c = a * a;
          return (
            (2 * k - 2 * e + d + b) * a * c +
            (-3 * k + 3 * e - 2 * d - b) * c +
            d * a +
            k
          );
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return Math.floor(Math.random() * (d - a + 1) + a);
        };
      },
      function (h, t, a) {
        var d = a(14);
        h.exports = function (k) {
          return k * d.RAD_TO_DEG;
        };
      },
      function (h, t, a) {
        h.exports = {
          Global:
            "game anims cache plugins registry scale sound textures renderer".split(
              " "
            ),
          CoreScene:
            "EventEmitter CameraManager GameObjectCreator GameObjectFactory ScenePlugin DisplayList UpdateList".split(
              " "
            ),
          DefaultScene:
            "Clock DataManagerPlugin InputPlugin Loader TweenManager LightsPlugin".split(
              " "
            ),
        };
      },
      function (h, t, a) {
        t = new (a(0))({
          initialize: function () {
            this._matrix = [
              1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0,
            ];
            this.alpha = 1;
            this._dirty = !0;
            this._data;
          },
          set: function (d) {
            this._matrix = d;
            this._dirty = !0;
            return this;
          },
          reset: function () {
            var d = this._matrix;
            d[0] = 1;
            d[1] = 0;
            d[2] = 0;
            d[3] = 0;
            d[4] = 0;
            d[5] = 0;
            d[6] = 1;
            d[7] = 0;
            d[8] = 0;
            d[9] = 0;
            d[10] = 0;
            d[11] = 0;
            d[12] = 1;
            d[13] = 0;
            d[14] = 0;
            d[15] = 0;
            d[16] = 0;
            d[17] = 0;
            d[18] = 1;
            d[19] = 0;
            this._dirty = !0;
            return this;
          },
          getData: function () {
            if (this._dirty) {
              var d = new Float32Array(this._matrix);
              d[4] /= 255;
              d[9] /= 255;
              d[14] /= 255;
              d[19] /= 255;
              this._data = d;
              this._dirty = !1;
            }
            return this._data;
          },
          brightness: function (d, k) {
            void 0 === d && (d = 0);
            void 0 === k && (k = !1);
            return this.multiply(
              [d, 0, 0, 0, 0, 0, d, 0, 0, 0, 0, 0, d, 0, 0, 0, 0, 0, 1, 0],
              k
            );
          },
          saturate: function (d, k) {
            void 0 === d && (d = 0);
            void 0 === k && (k = !1);
            d = (2 * d) / 3 + 1;
            var e = -0.5 * (d - 1);
            return this.multiply(
              [d, e, e, 0, 0, e, d, e, 0, 0, e, e, d, 0, 0, 0, 0, 0, 1, 0],
              k
            );
          },
          desaturate: function (d) {
            void 0 === d && (d = !1);
            return this.saturate(-1, d);
          },
          hue: function (d, k) {
            void 0 === d && (d = 0);
            void 0 === k && (k = !1);
            d = (d / 180) * Math.PI;
            var e = Math.cos(d);
            d = Math.sin(d);
            return this.multiply(
              [
                0.213 + 0.787 * e + -0.213 * d,
                0.715 + -0.715 * e + -0.715 * d,
                0.072 + -0.072 * e + 0.928 * d,
                0,
                0,
                0.213 + -0.213 * e + 0.143 * d,
                0.715 + e * (1 - 0.715) + 0.14 * d,
                0.072 + -0.072 * e + -0.283 * d,
                0,
                0,
                0.213 + -0.213 * e + -0.787 * d,
                0.715 + -0.715 * e + 0.715 * d,
                0.072 + 0.928 * e + 0.072 * d,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
              ],
              k
            );
          },
          grayscale: function (d, k) {
            void 0 === d && (d = 1);
            void 0 === k && (k = !1);
            return this.saturate(-d, k);
          },
          blackWhite: function (d) {
            void 0 === d && (d = !1);
            return this.multiply(
              [
                0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0,
                0, 0, 0, 1, 0,
              ],
              d
            );
          },
          contrast: function (d, k) {
            void 0 === d && (d = 0);
            void 0 === k && (k = !1);
            d += 1;
            var e = -0.5 * (d - 1);
            return this.multiply(
              [d, 0, 0, 0, e, 0, d, 0, 0, e, 0, 0, d, 0, e, 0, 0, 0, 1, 0],
              k
            );
          },
          negative: function (d) {
            void 0 === d && (d = !1);
            return this.multiply(
              [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0],
              d
            );
          },
          desaturateLuminance: function (d) {
            void 0 === d && (d = !1);
            return this.multiply(
              [
                0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708,
                0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1,
                0, 0, 0, 1, 0,
              ],
              d
            );
          },
          sepia: function (d) {
            void 0 === d && (d = !1);
            return this.multiply(
              [
                0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999,
                0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0,
                1, 0,
              ],
              d
            );
          },
          night: function (d, k) {
            void 0 === d && (d = 0.1);
            void 0 === k && (k = !1);
            return this.multiply(
              [
                -2 * d,
                -d,
                0,
                0,
                0,
                -d,
                0,
                d,
                0,
                0,
                0,
                d,
                2 * d,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
              ],
              k
            );
          },
          lsd: function (d) {
            void 0 === d && (d = !1);
            return this.multiply(
              [
                2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0,
                0, 0, 1, 0,
              ],
              d
            );
          },
          brown: function (d) {
            void 0 === d && (d = !1);
            return this.multiply(
              [
                0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0,
                47.43192855600873, -0.037703249837783157, 0.8609577587992641,
                0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335,
                -0.07441037908422492, 0.44972182064877153, 0,
                -7.562075277591283, 0, 0, 0, 1, 0,
              ],
              d
            );
          },
          vintagePinhole: function (d) {
            void 0 === d && (d = !1);
            return this.multiply(
              [
                0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0,
                9.651285835294123, 0.02578397704808868, 0.6441188644374771,
                0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719,
                -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296,
                0, 0, 0, 1, 0,
              ],
              d
            );
          },
          kodachrome: function (d) {
            void 0 === d && (d = !1);
            return this.multiply(
              [
                1.1285582396593525, -0.3967382283601348, -0.03992559172921793,
                0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304,
                -0.05498805115633132, 0, 24.732407896706203,
                -0.16786010706155763, -0.5603416277695248, 1.6014850761964943,
                0, 35.62982807460946, 0, 0, 0, 1, 0,
              ],
              d
            );
          },
          technicolor: function (d) {
            void 0 === d && (d = !1);
            return this.multiply(
              [
                1.9125277891456083, -0.8545344976951645, -0.09155508482755585,
                0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428,
                -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616,
                -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138,
                0, 0, 0, 1, 0,
              ],
              d
            );
          },
          polaroid: function (d) {
            void 0 === d && (d = !1);
            return this.multiply(
              [
                1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0,
                -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0,
              ],
              d
            );
          },
          shiftToBGR: function (d) {
            void 0 === d && (d = !1);
            return this.multiply(
              [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],
              d
            );
          },
          multiply: function (d, k) {
            k || this.reset();
            k = this._matrix;
            for (var e = [], b = 0; 20 > b; b++) e[b] = k[b];
            k[0] = e[0] * d[0] + e[1] * d[5] + e[2] * d[10] + e[3] * d[15];
            k[1] = e[0] * d[1] + e[1] * d[6] + e[2] * d[11] + e[3] * d[16];
            k[2] = e[0] * d[2] + e[1] * d[7] + e[2] * d[12] + e[3] * d[17];
            k[3] = e[0] * d[3] + e[1] * d[8] + e[2] * d[13] + e[3] * d[18];
            k[4] =
              e[0] * d[4] + e[1] * d[9] + e[2] * d[14] + e[3] * d[19] + e[4];
            k[5] = e[5] * d[0] + e[6] * d[5] + e[7] * d[10] + e[8] * d[15];
            k[6] = e[5] * d[1] + e[6] * d[6] + e[7] * d[11] + e[8] * d[16];
            k[7] = e[5] * d[2] + e[6] * d[7] + e[7] * d[12] + e[8] * d[17];
            k[8] = e[5] * d[3] + e[6] * d[8] + e[7] * d[13] + e[8] * d[18];
            k[9] =
              e[5] * d[4] + e[6] * d[9] + e[7] * d[14] + e[8] * d[19] + e[9];
            k[10] = e[10] * d[0] + e[11] * d[5] + e[12] * d[10] + e[13] * d[15];
            k[11] = e[10] * d[1] + e[11] * d[6] + e[12] * d[11] + e[13] * d[16];
            k[12] = e[10] * d[2] + e[11] * d[7] + e[12] * d[12] + e[13] * d[17];
            k[13] = e[10] * d[3] + e[11] * d[8] + e[12] * d[13] + e[13] * d[18];
            k[14] =
              e[10] * d[4] +
              e[11] * d[9] +
              e[12] * d[14] +
              e[13] * d[19] +
              e[14];
            k[15] = e[15] * d[0] + e[16] * d[5] + e[17] * d[10] + e[18] * d[15];
            k[16] = e[15] * d[1] + e[16] * d[6] + e[17] * d[11] + e[18] * d[16];
            k[17] = e[15] * d[2] + e[16] * d[7] + e[17] * d[12] + e[18] * d[17];
            k[18] = e[15] * d[3] + e[16] * d[8] + e[17] * d[13] + e[18] * d[18];
            k[19] =
              e[15] * d[4] +
              e[16] * d[9] +
              e[17] * d[14] +
              e[18] * d[19] +
              e[19];
            this._dirty = !0;
            return this;
          },
        });
        h.exports = t;
      },
      function (h, t, a) {
        var d = a(10),
          k = a(14);
        h.exports = function (e, b) {
          void 0 === b && (b = new d());
          if (0 === e.length) return b;
          for (
            var c = Number.MAX_VALUE,
              f = Number.MAX_VALUE,
              g = k.MIN_SAFE_INTEGER,
              m = k.MIN_SAFE_INTEGER,
              n,
              q,
              r = 0;
            r < e.length;
            r++
          )
            (n = e[r]),
              Array.isArray(n)
                ? ((q = n[0]), (n = n[1]))
                : ((q = n.x), (n = n.y)),
              (c = Math.min(c, q)),
              (f = Math.min(f, n)),
              (g = Math.max(g, q)),
              (m = Math.max(m, n));
          b.x = c;
          b.y = f;
          b.width = g - c;
          b.height = m - f;
          return b;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(1);
        a = new t({
          initialize: function (k, e, b) {
            this._rgb = [0, 0, 0];
            this.onChangeCallback = d;
            this.dirty = !1;
            this.set(k, e, b);
          },
          set: function (k, e, b) {
            void 0 === k && (k = 0);
            void 0 === e && (e = 0);
            void 0 === b && (b = 0);
            this._rgb = [k, e, b];
            this.onChange();
            return this;
          },
          equals: function (k, e, b) {
            var c = this._rgb;
            return c.r === k && c.g === e && c.b === b;
          },
          onChange: function () {
            this.dirty = !0;
            var k = this._rgb;
            this.onChangeCallback.call(this, k[0], k[1], k[2]);
          },
          r: {
            get: function () {
              return this._rgb[0];
            },
            set: function (k) {
              this._rgb[0] = k;
              this.onChange();
            },
          },
          g: {
            get: function () {
              return this._rgb[1];
            },
            set: function (k) {
              this._rgb[1] = k;
              this.onChange();
            },
          },
          b: {
            get: function () {
              return this._rgb[2];
            },
            set: function (k) {
              this._rgb[2] = k;
              this.onChange();
            },
          },
          destroy: function () {
            this.onChangeCallback = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = {
          CENTER: a(403),
          ORIENTATION: a(404),
          SCALE_MODE: a(405),
          ZOOM: a(406),
        };
        h.exports = t;
      },
      function (h, t) {
        h.exports = function (a) {
          a.parentNode && a.parentNode.removeChild(a);
        };
      },
      function (h, t) {
        h.exports = {
          MOUSE_DOWN: 0,
          MOUSE_MOVE: 1,
          MOUSE_UP: 2,
          TOUCH_START: 3,
          TOUCH_MOVE: 4,
          TOUCH_END: 5,
          POINTER_LOCK_CHANGE: 6,
          TOUCH_CANCEL: 7,
          MOUSE_WHEEL: 8,
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(144),
          k = a(197),
          e = a(20),
          b = a(419),
          c = a(420),
          f = a(33),
          g = a(1),
          m = a(421);
        a = new t({
          initialize: function (n, q) {
            this.scene = n;
            this.game;
            this.renderer;
            this.config = q;
            this.settings = m.create(q);
            this.canvas;
            this.context;
            this.anims;
            this.cache;
            this.plugins;
            this.registry;
            this.scale;
            this.sound;
            this.textures;
            this.add;
            this.cameras;
            this.displayList;
            this.events;
            this.make;
            this.scenePlugin;
            this.updateList;
            this.sceneUpdate = g;
          },
          init: function (n) {
            this.settings.status = d.INIT;
            this.sceneUpdate = g;
            this.game = n;
            this.renderer = n.renderer;
            this.canvas = n.canvas;
            this.context = n.context;
            this.plugins = n = n.plugins;
            n.addToScene(this, k.Global, [k.CoreScene, c(this), b(this)]);
            this.events.emit(e.BOOT, this);
            this.settings.isBooted = !0;
          },
          step: function (n, q) {
            var r = this.events;
            r.emit(e.PRE_UPDATE, n, q);
            r.emit(e.UPDATE, n, q);
            this.sceneUpdate.call(this.scene, n, q);
            r.emit(e.POST_UPDATE, n, q);
          },
          render: function (n) {
            var q = this.displayList;
            q.depthSort();
            this.events.emit(e.PRE_RENDER, n);
            this.cameras.render(n, q);
            this.events.emit(e.RENDER, n);
          },
          queueDepthSort: function () {
            this.displayList.queueDepthSort();
          },
          depthSort: function () {
            this.displayList.depthSort();
          },
          pause: function (n) {
            var q = this.events,
              r = this.settings;
            this.settings.active &&
              ((r.status = d.PAUSED),
              (r.active = !1),
              q.emit(e.PAUSE, this, n));
            return this;
          },
          resume: function (n) {
            var q = this.events,
              r = this.settings;
            this.settings.active ||
              ((r.status = d.RUNNING),
              (r.active = !0),
              q.emit(e.RESUME, this, n));
            return this;
          },
          sleep: function (n) {
            var q = this.events,
              r = this.settings;
            r.status = d.SLEEPING;
            r.active = !1;
            r.visible = !1;
            q.emit(e.SLEEP, this, n);
            return this;
          },
          wake: function (n) {
            var q = this.events,
              r = this.settings;
            r.status = d.RUNNING;
            r.active = !0;
            r.visible = !0;
            q.emit(e.WAKE, this, n);
            r.isTransition &&
              q.emit(e.TRANSITION_WAKE, r.transitionFrom, r.transitionDuration);
            return this;
          },
          getData: function () {
            return this.settings.data;
          },
          isSleeping: function () {
            return this.settings.status === d.SLEEPING;
          },
          isActive: function () {
            return this.settings.status === d.RUNNING;
          },
          isPaused: function () {
            return this.settings.status === d.PAUSED;
          },
          isTransitioning: function () {
            return (
              this.settings.isTransition || null !== this.scenePlugin._target
            );
          },
          isTransitionOut: function () {
            return (
              null !== this.scenePlugin._target &&
              0 < this.scenePlugin._duration
            );
          },
          isTransitionIn: function () {
            return this.settings.isTransition;
          },
          isVisible: function () {
            return this.settings.visible;
          },
          setVisible: function (n) {
            this.settings.visible = n;
            return this;
          },
          setActive: function (n, q) {
            return n ? this.resume(q) : this.pause(q);
          },
          start: function (n) {
            var q = this.events,
              r = this.settings;
            n && (r.data = n);
            r.status = d.START;
            r.active = !0;
            r.visible = !0;
            q.emit(e.START, this);
            q.emit(e.READY, this, n);
          },
          shutdown: function (n) {
            var q = this.events,
              r = this.settings;
            q.off(e.TRANSITION_INIT);
            q.off(e.TRANSITION_START);
            q.off(e.TRANSITION_COMPLETE);
            q.off(e.TRANSITION_OUT);
            r.status = d.SHUTDOWN;
            r.active = !1;
            r.visible = !1;
            this.renderer === f.WEBGL && this.renderer.resetTextures(!0);
            q.emit(e.SHUTDOWN, this, n);
          },
          destroy: function () {
            var n = this.events,
              q = this.settings;
            q.status = d.DESTROYED;
            q.active = !1;
            q.visible = !1;
            n.emit(e.DESTROY, this);
            n.removeAllListeners();
            n =
              "scene game anims cache plugins registry sound textures add camera displayList events make scenePlugin updateList".split(
                " "
              );
            for (q = 0; q < n.length; q++) this[n[q]] = null;
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a) {
          return a && a[0].toUpperCase() + a.slice(1);
        };
      },
      function (h, t, a) {
        var d = a(33);
        t = a(0);
        var k = a(109),
          e = a(424);
        a = new t({
          initialize: function (b, c, f, g, m) {
            Array.isArray(f) || (f = [f]);
            this.manager = b;
            this.key = c;
            this.source = [];
            this.dataSource = [];
            this.frames = {};
            this.customData = {};
            this.firstFrame = "__BASE";
            for (b = this.frameTotal = 0; b < f.length; b++)
              this.source.push(new e(this, f[b], g, m));
          },
          add: function (b, c, f, g, m, n) {
            if (this.has(b)) return null;
            c = new k(this, b, c, f, g, m, n);
            this.frames[b] = c;
            "__BASE" === this.firstFrame && (this.firstFrame = b);
            this.frameTotal++;
            return c;
          },
          remove: function (b) {
            return this.has(b)
              ? (this.get(b).destroy(), delete this.frames[b], !0)
              : !1;
          },
          has: function (b) {
            return this.frames[b];
          },
          get: function (b) {
            b || (b = this.firstFrame);
            var c = this.frames[b];
            c ||
              (console.warn("Texture.frame missing: " + b),
              (c = this.frames[this.firstFrame]));
            return c;
          },
          getTextureSourceIndex: function (b) {
            for (var c = 0; c < this.source.length; c++)
              if (this.source[c] === b) return c;
            return -1;
          },
          getFramesFromTextureSource: function (b, c) {
            void 0 === c && (c = !1);
            var f = [],
              g;
            for (g in this.frames)
              if ("__BASE" !== g || c) {
                var m = this.frames[g];
                m.sourceIndex === b && f.push(m);
              }
            return f;
          },
          getFrameNames: function (b) {
            void 0 === b && (b = !1);
            var c = Object.keys(this.frames);
            b || ((b = c.indexOf("__BASE")), -1 !== b && c.splice(b, 1));
            return c;
          },
          getSourceImage: function (b) {
            if (void 0 === b || null === b || 1 === this.frameTotal)
              b = "__BASE";
            var c = this.frames[b];
            if (c) return c.source.image;
            console.warn("Texture.frame missing: " + b);
            return this.frames.__BASE.source.image;
          },
          getDataSourceImage: function (b) {
            if (void 0 === b || null === b || 1 === this.frameTotal)
              b = "__BASE";
            var c = this.frames[b];
            c
              ? (b = c.sourceIndex)
              : (console.warn("Texture.frame missing: " + b),
                (b = this.frames.__BASE.sourceIndex));
            return this.dataSource[b].image;
          },
          setDataSource: function (b) {
            Array.isArray(b) || (b = [b]);
            for (var c = 0; c < b.length; c++) {
              var f = this.source[c];
              this.dataSource.push(new e(this, b[c], f.width, f.height));
            }
          },
          setFilter: function (b) {
            var c;
            for (c = 0; c < this.source.length; c++)
              this.source[c].setFilter(b);
            for (c = 0; c < this.dataSource.length; c++)
              this.dataSource[c].setFilter(b);
          },
          destroy: function () {
            var b;
            for (b = 0; b < this.source.length; b++) this.source[b].destroy();
            for (b = 0; b < this.dataSource.length; b++)
              this.dataSource[b].destroy();
            for (var c in this.frames) this.frames[c].destroy();
            this.source = [];
            this.dataSource = [];
            this.frames = {};
            this.manager.removeKey(this.key);
            (b = this.manager.game.renderer) &&
              b.type === d.WEBGL &&
              b.resetTextures(!0);
            this.manager = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(78);
        h.exports = function (k, e, b, c, f) {
          void 0 === c && (c = 0);
          void 0 === f && (f = k.length);
          var g = [];
          if (d(k, c, f))
            for (; c < f; c++) {
              var m = k[c];
              (!e ||
                (e && void 0 === b && m.hasOwnProperty(e)) ||
                (e && void 0 !== b && m[e] === b)) &&
                g.push(m);
            }
          return g;
        };
      },
      function (h, t, a) {
        h.exports = {
          Matrix: a(1013),
          Add: a(1021),
          AddAt: a(1022),
          BringToTop: a(1023),
          CountAllMatching: a(1024),
          Each: a(1025),
          EachInRange: a(1026),
          FindClosestInSorted: a(318),
          GetAll: a(207),
          GetFirst: a(428),
          GetRandom: a(210),
          MoveDown: a(1027),
          MoveTo: a(1028),
          MoveUp: a(1029),
          MoveAbove: a(1030),
          MoveBelow: a(1031),
          NumberArray: a(322),
          NumberArrayStep: a(1032),
          QuickSelect: a(436),
          Range: a(437),
          Remove: a(93),
          RemoveAt: a(1033),
          RemoveBetween: a(1034),
          RemoveRandomElement: a(1035),
          Replace: a(1036),
          RotateLeft: a(178),
          RotateRight: a(179),
          SafeRange: a(78),
          SendToBack: a(1037),
          SetAll: a(1038),
          Shuffle: a(131),
          SortByDigits: a(320),
          SpliceOne: a(74),
          StableSort: a(79),
          Swap: a(1039),
        };
      },
      function (h, t) {
        h.exports = function (a) {
          if (!Array.isArray(a) || 2 > a.length || !Array.isArray(a[0]))
            return !1;
          for (var d = a[0].length, k = 1; k < a.length; k++)
            if (a[k].length !== d) return !1;
          return !0;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          void 0 === d && (d = 0);
          void 0 === k && (k = a.length);
          d += Math.floor(Math.random() * k);
          return void 0 === a[d] ? null : a[d];
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(9),
          k = a(438);
        a = new t({
          Extends: d,
          initialize: function () {
            d.call(this);
            this._pending = [];
            this._active = [];
            this._destroy = [];
            this._toProcess = 0;
            this.checkQueue = !1;
          },
          add: function (e) {
            this._pending.push(e);
            this._toProcess++;
            return e;
          },
          remove: function (e) {
            this._destroy.push(e);
            this._toProcess++;
            return e;
          },
          removeAll: function () {
            for (var e = this._active, b = this._destroy, c = e.length; c--; )
              b.push(e[c]), this._toProcess++;
            return this;
          },
          update: function () {
            if (0 === this._toProcess) return this._active;
            var e = this._destroy,
              b = this._active,
              c;
            for (c = 0; c < e.length; c++) {
              var f = e[c];
              var g = b.indexOf(f);
              -1 !== g &&
                (b.splice(g, 1), this.emit(k.PROCESS_QUEUE_REMOVE, f));
            }
            e.length = 0;
            e = this._pending;
            for (c = 0; c < e.length; c++)
              if (
                ((f = e[c]),
                !this.checkQueue || (this.checkQueue && -1 === b.indexOf(f)))
              )
                b.push(f), this.emit(k.PROCESS_QUEUE_ADD, f);
            this._toProcess = e.length = 0;
            return b;
          },
          getActive: function () {
            return this._active;
          },
          length: {
            get: function () {
              return this._active.length;
            },
          },
          destroy: function () {
            this._toProcess = 0;
            this._pending = [];
            this._active = [];
            this._destroy = [];
          },
        });
        h.exports = a;
      },
      function (h, t) {
        function a(d, k) {
          return parseInt(d.getAttribute(k), 10);
        }
        h.exports = function (d, k, e, b, c) {
          void 0 === e && (e = 0);
          void 0 === b && (b = 0);
          var f = k.cutX,
            g = k.cutY,
            m = k.source.width,
            n = k.source.height,
            q = k.sourceIndex,
            r = {},
            u = d.getElementsByTagName("info")[0],
            v = d.getElementsByTagName("common")[0];
          r.font = u.getAttribute("face");
          r.size = a(u, "size");
          r.lineHeight = a(v, "lineHeight") + b;
          r.chars = {};
          u = d.getElementsByTagName("char");
          if ((v = void 0 !== k && k.trimmed))
            var x = k.height,
              y = k.width;
          for (b = 0; b < u.length; b++) {
            var z = u[b],
              A = a(z, "id"),
              B = String.fromCharCode(A),
              D = a(z, "x"),
              E = a(z, "y"),
              C = a(z, "width"),
              F = a(z, "height");
            v && (D < y && (y = D), E < x && (x = E));
            v && 0 !== x && 0 !== y && ((D -= k.x), (E -= k.y));
            var G = (f + D) / m,
              H = (g + E) / n,
              K = (f + D + C) / m,
              I = (g + E + F) / n;
            r.chars[A] = {
              x: D,
              y: E,
              width: C,
              height: F,
              centerX: Math.floor(C / 2),
              centerY: Math.floor(F / 2),
              xOffset: a(z, "xoffset"),
              yOffset: a(z, "yoffset"),
              xAdvance: a(z, "xadvance") + e,
              data: {},
              kerning: {},
              u0: G,
              v0: H,
              u1: K,
              v1: I,
            };
            c &&
              0 !== C &&
              0 !== F &&
              (z = c.add(B, q, D, E, C, F)) &&
              z.setUVs(C, F, G, H, K, I);
          }
          d = d.getElementsByTagName("kerning");
          for (b = 0; b < d.length; b++)
            (c = d[b]),
              (k = a(c, "first")),
              (e = a(c, "second")),
              (c = a(c, "amount")),
              (r.chars[e].kerning[k] = c);
          return r;
        };
      },
      function (h, t, a) {
        t = a(1049);
        var d = a(440),
          k = a(0),
          e = a(11),
          b = a(109),
          c = a(15),
          f = a(110);
        a = new k({
          Extends: c,
          Mixins: [
            e.Alpha,
            e.BlendMode,
            e.Depth,
            e.Mask,
            e.Pipeline,
            e.ScrollFactor,
            e.Size,
            e.Texture,
            e.Transform,
            e.Visible,
            t,
          ],
          initialize: function (g, m, n, q, r) {
            c.call(this, g, "Blitter");
            this.setTexture(q, r);
            this.setPosition(m, n);
            this.initPipeline();
            this.children = new f();
            this.renderList = [];
            this.dirty = !1;
          },
          create: function (g, m, n, q, r) {
            void 0 === q && (q = !0);
            void 0 === r && (r = this.children.length);
            void 0 === n
              ? (n = this.frame)
              : n instanceof b || (n = this.texture.get(n));
            g = new d(this, g, m, n, q);
            this.children.addAt(g, r, !1);
            this.dirty = !0;
            return g;
          },
          createFromCallback: function (g, m, n, q) {
            m = this.createMultiple(m, n, q);
            for (n = 0; n < m.length; n++) g.call(this, m[n], n);
            return m;
          },
          createMultiple: function (g, m, n) {
            void 0 === m && (m = this.frame.name);
            void 0 === n && (n = !0);
            Array.isArray(m) || (m = [m]);
            var q = [],
              r = this;
            m.forEach(function (u) {
              for (var v = 0; v < g; v++) q.push(r.create(0, 0, u, n));
            });
            return q;
          },
          childCanRender: function (g) {
            return g.visible && 0 < g.alpha;
          },
          getRenderList: function () {
            this.dirty &&
              ((this.renderList = this.children.list.filter(
                this.childCanRender,
                this
              )),
              (this.dirty = !1));
            return this.renderList;
          },
          clear: function () {
            this.children.removeAll();
            this.dirty = !0;
          },
          preDestroy: function () {
            this.children.destroy();
            this.renderList = [];
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(208),
          k = a(35);
        t = a(0);
        var e = a(11),
          b = a(75),
          c = a(15),
          f = a(10),
          g = a(1052),
          m = a(441),
          n = a(3);
        a = new t({
          Extends: c,
          Mixins: [
            e.AlphaSingle,
            e.BlendMode,
            e.ComputedSize,
            e.Depth,
            e.Mask,
            e.Pipeline,
            e.Transform,
            e.Visible,
            g,
          ],
          initialize: function (q, r, u, v) {
            c.call(this, q, "Container");
            this.list = [];
            this.exclusive = !0;
            this.maxSize = -1;
            this.position = 0;
            this.localTransform = new e.TransformMatrix();
            this.tempTransformMatrix = new e.TransformMatrix();
            this._sortKey = "";
            this._sysEvents = q.sys.events;
            this.scrollFactorY = this.scrollFactorX = 1;
            this.initPipeline();
            this.setPosition(r, u);
            this.clearAlpha();
            this.setBlendMode(k.SKIP_CHECK);
            v && this.add(v);
          },
          originX: {
            get: function () {
              return 0.5;
            },
          },
          originY: {
            get: function () {
              return 0.5;
            },
          },
          displayOriginX: {
            get: function () {
              return 0.5 * this.width;
            },
          },
          displayOriginY: {
            get: function () {
              return 0.5 * this.height;
            },
          },
          setExclusive: function (q) {
            void 0 === q && (q = !0);
            this.exclusive = q;
            return this;
          },
          getBounds: function (q) {
            void 0 === q && (q = new f());
            q.setTo(this.x, this.y, 0, 0);
            if (this.parentContainer) {
              var r = this.parentContainer
                .getBoundsTransformMatrix()
                .transformPoint(this.x, this.y);
              q.setTo(r.x, r.y, 0, 0);
            }
            if (0 < this.list.length) {
              r = this.list;
              var u = new f(),
                v = !1;
              q.setEmpty();
              for (var x = 0; x < r.length; x++) {
                var y = r[x];
                y.getBounds &&
                  (y.getBounds(u),
                  v
                    ? m(u, q, q)
                    : (q.setTo(u.x, u.y, u.width, u.height), (v = !0)));
              }
            }
            return q;
          },
          addHandler: function (q) {
            q.once(b.DESTROY, this.remove, this);
            this.exclusive &&
              (q.parentContainer && q.parentContainer.remove(q),
              q.removeFromDisplayList(),
              (q.parentContainer = this));
          },
          removeHandler: function (q) {
            q.off(b.DESTROY, this.remove);
            this.exclusive &&
              ((q.parentContainer = null), q.addToDisplayList());
          },
          pointToContainer: function (q, r) {
            void 0 === r && (r = new n());
            this.parentContainer
              ? this.parentContainer.pointToContainer(q, r)
              : (r = new n(q.x, q.y));
            var u = this.tempTransformMatrix;
            u.applyITRS(
              this.x,
              this.y,
              this.rotation,
              this.scaleX,
              this.scaleY
            );
            u.invert();
            u.transformPoint(q.x, q.y, r);
            return r;
          },
          getBoundsTransformMatrix: function () {
            return this.getWorldTransformMatrix(
              this.tempTransformMatrix,
              this.localTransform
            );
          },
          add: function (q) {
            d.Add(this.list, q, this.maxSize, this.addHandler, this);
            return this;
          },
          addAt: function (q, r) {
            d.AddAt(this.list, q, r, this.maxSize, this.addHandler, this);
            return this;
          },
          getAt: function (q) {
            return this.list[q];
          },
          getIndex: function (q) {
            return this.list.indexOf(q);
          },
          sort: function (q, r) {
            if (!q) return this;
            void 0 === r &&
              (r = function (u, v) {
                return u[q] - v[q];
              });
            d.StableSort(this.list, r);
            return this;
          },
          getByName: function (q) {
            return d.GetFirst(this.list, "name", q);
          },
          getRandom: function (q, r) {
            return d.GetRandom(this.list, q, r);
          },
          getFirst: function (q, r, u, v) {
            return d.GetFirst(this.list, q, r, u, v);
          },
          getAll: function (q, r, u, v) {
            return d.GetAll(this.list, q, r, u, v);
          },
          count: function (q, r, u, v) {
            return d.CountAllMatching(this.list, q, r, u, v);
          },
          swap: function (q, r) {
            d.Swap(this.list, q, r);
            return this;
          },
          moveTo: function (q, r) {
            d.MoveTo(this.list, q, r);
            return this;
          },
          moveAbove: function (q, r) {
            d.MoveAbove(this.list, q, r);
            return this;
          },
          moveBelow: function (q, r) {
            d.MoveBelow(this.list, q, r);
            return this;
          },
          remove: function (q, r) {
            q = d.Remove(this.list, q, this.removeHandler, this);
            if (r && q)
              for (Array.isArray(q) || (q = [q]), r = 0; r < q.length; r++)
                q[r].destroy();
            return this;
          },
          removeAt: function (q, r) {
            q = d.RemoveAt(this.list, q, this.removeHandler, this);
            r && q && q.destroy();
            return this;
          },
          removeBetween: function (q, r, u) {
            q = d.RemoveBetween(this.list, q, r, this.removeHandler, this);
            if (u) for (u = 0; u < q.length; u++) q[u].destroy();
            return this;
          },
          removeAll: function (q) {
            var r = d.RemoveBetween(
              this.list,
              0,
              this.list.length,
              this.removeHandler,
              this
            );
            if (q) for (q = 0; q < r.length; q++) r[q].destroy();
            return this;
          },
          bringToTop: function (q) {
            d.BringToTop(this.list, q);
            return this;
          },
          sendToBack: function (q) {
            d.SendToBack(this.list, q);
            return this;
          },
          moveUp: function (q) {
            d.MoveUp(this.list, q);
            return this;
          },
          moveDown: function (q) {
            d.MoveDown(this.list, q);
            return this;
          },
          reverse: function () {
            this.list.reverse();
            return this;
          },
          shuffle: function () {
            d.Shuffle(this.list);
            return this;
          },
          replace: function (q, r, u) {
            d.Replace(this.list, q, r) &&
              (this.addHandler(r), this.removeHandler(q), u && q.destroy());
            return this;
          },
          exists: function (q) {
            return -1 < this.list.indexOf(q);
          },
          setAll: function (q, r, u, v) {
            d.SetAll(this.list, q, r, u, v);
            return this;
          },
          each: function (q, r) {
            var u = [null],
              v,
              x = this.list.slice(),
              y = x.length;
            for (v = 2; v < arguments.length; v++) u.push(arguments[v]);
            for (v = 0; v < y; v++) (u[0] = x[v]), q.apply(r, u);
            return this;
          },
          iterate: function (q, r) {
            var u = [null],
              v;
            for (v = 2; v < arguments.length; v++) u.push(arguments[v]);
            for (v = 0; v < this.list.length; v++)
              (u[0] = this.list[v]), q.apply(r, u);
            return this;
          },
          setScrollFactor: function (q, r, u) {
            void 0 === r && (r = q);
            void 0 === u && (u = !1);
            this.scrollFactorX = q;
            this.scrollFactorY = r;
            u &&
              (d.SetAll(this.list, "scrollFactorX", q),
              d.SetAll(this.list, "scrollFactorY", r));
            return this;
          },
          length: {
            get: function () {
              return this.list.length;
            },
          },
          first: {
            get: function () {
              this.position = 0;
              return 0 < this.list.length ? this.list[0] : null;
            },
          },
          last: {
            get: function () {
              return 0 < this.list.length
                ? ((this.position = this.list.length - 1),
                  this.list[this.position])
                : null;
            },
          },
          next: {
            get: function () {
              return this.position < this.list.length
                ? (this.position++, this.list[this.position])
                : null;
            },
          },
          previous: {
            get: function () {
              return 0 < this.position
                ? (this.position--, this.list[this.position])
                : null;
            },
          },
          preDestroy: function () {
            this.removeAll(!!this.exclusive);
            this.localTransform.destroy();
            this.tempTransformMatrix.destroy();
            this.list = [];
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(148);
        t = a(0);
        a = a(1057);
        a = new t({
          Extends: d,
          Mixins: [a],
          initialize: function (k, e, b, c, f, g, m) {
            d.call(this, k, e, b, c, f, g, m);
            this.type = "DynamicBitmapText";
            this.cropHeight = this.cropWidth = this.scrollY = this.scrollX = 0;
            this.displayCallback;
            this.callbackData = {
              parent: this,
              color: 0,
              tint: {
                topLeft: 0,
                topRight: 0,
                bottomLeft: 0,
                bottomRight: 0,
              },
              index: 0,
              charCode: 0,
              x: 0,
              y: 0,
              scale: 0,
              rotation: 0,
              data: 0,
            };
          },
          setSize: function (k, e) {
            this.cropWidth = k;
            this.cropHeight = e;
            return this;
          },
          setDisplayCallback: function (k) {
            this.displayCallback = k;
            return this;
          },
          setScrollX: function (k) {
            this.scrollX = k;
            return this;
          },
          setScrollY: function (k) {
            this.scrollY = k;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(133);
        var d = a(0),
          k = a(217),
          e = a(303),
          b = a(304),
          c = a(305),
          f = a(309),
          g = a(167),
          m = a(312),
          n = a(313),
          q = a(314),
          r = a(111),
          u = a(15),
          v = a(2),
          x = a(6),
          y = a(14);
        a = a(1063);
        var z = new d({
          Extends: u,
          Mixins: [e, b, c, f, g, n, q, m, a],
          initialize: function (A, B) {
            var D = x(B, "x", 0),
              E = x(B, "y", 0);
            u.call(this, A, "Graphics");
            this.setPosition(D, E);
            this.initPipeline();
            this.displayOriginY = this.displayOriginX = 0;
            this.commandBuffer = [];
            this.defaultFillColor = -1;
            this.defaultStrokeWidth = this.defaultFillAlpha = 1;
            this.defaultStrokeColor = -1;
            this._lineWidth = this.defaultStrokeAlpha = 1;
            this.setDefaultStyles(B);
          },
          setDefaultStyles: function (A) {
            x(A, "lineStyle", null) &&
              ((this.defaultStrokeWidth = x(A, "lineStyle.width", 1)),
              (this.defaultStrokeColor = x(A, "lineStyle.color", 16777215)),
              (this.defaultStrokeAlpha = x(A, "lineStyle.alpha", 1)),
              this.lineStyle(
                this.defaultStrokeWidth,
                this.defaultStrokeColor,
                this.defaultStrokeAlpha
              ));
            x(A, "fillStyle", null) &&
              ((this.defaultFillColor = x(A, "fillStyle.color", 16777215)),
              (this.defaultFillAlpha = x(A, "fillStyle.alpha", 1)),
              this.fillStyle(this.defaultFillColor, this.defaultFillAlpha));
            return this;
          },
          lineStyle: function (A, B, D) {
            void 0 === D && (D = 1);
            this.commandBuffer.push(k.LINE_STYLE, A, B, D);
            this._lineWidth = A;
            return this;
          },
          fillStyle: function (A, B) {
            void 0 === B && (B = 1);
            this.commandBuffer.push(k.FILL_STYLE, A, B);
            return this;
          },
          fillGradientStyle: function (A, B, D, E, C, F, G, H) {
            void 0 === C && (C = 1);
            void 0 === F && (F = C);
            void 0 === G && (G = C);
            void 0 === H && (H = C);
            this.commandBuffer.push(
              k.GRADIENT_FILL_STYLE,
              C,
              F,
              G,
              H,
              A,
              B,
              D,
              E
            );
            return this;
          },
          lineGradientStyle: function (A, B, D, E, C, F) {
            void 0 === F && (F = 1);
            this.commandBuffer.push(k.GRADIENT_LINE_STYLE, A, F, B, D, E, C);
            return this;
          },
          beginPath: function () {
            this.commandBuffer.push(k.BEGIN_PATH);
            return this;
          },
          closePath: function () {
            this.commandBuffer.push(k.CLOSE_PATH);
            return this;
          },
          fillPath: function () {
            this.commandBuffer.push(k.FILL_PATH);
            return this;
          },
          fill: function () {
            this.commandBuffer.push(k.FILL_PATH);
            return this;
          },
          strokePath: function () {
            this.commandBuffer.push(k.STROKE_PATH);
            return this;
          },
          stroke: function () {
            this.commandBuffer.push(k.STROKE_PATH);
            return this;
          },
          fillCircleShape: function (A) {
            return this.fillCircle(A.x, A.y, A.radius);
          },
          strokeCircleShape: function (A) {
            return this.strokeCircle(A.x, A.y, A.radius);
          },
          fillCircle: function (A, B, D) {
            this.beginPath();
            this.arc(A, B, D, 0, y.PI2);
            this.fillPath();
            return this;
          },
          strokeCircle: function (A, B, D) {
            this.beginPath();
            this.arc(A, B, D, 0, y.PI2);
            this.strokePath();
            return this;
          },
          fillRectShape: function (A) {
            return this.fillRect(A.x, A.y, A.width, A.height);
          },
          strokeRectShape: function (A) {
            return this.strokeRect(A.x, A.y, A.width, A.height);
          },
          fillRect: function (A, B, D, E) {
            this.commandBuffer.push(k.FILL_RECT, A, B, D, E);
            return this;
          },
          strokeRect: function (A, B, D, E) {
            var C = this._lineWidth / 2,
              F = A - C;
            C = A + C;
            this.beginPath();
            this.moveTo(A, B);
            this.lineTo(A, B + E);
            this.strokePath();
            this.beginPath();
            this.moveTo(A + D, B);
            this.lineTo(A + D, B + E);
            this.strokePath();
            this.beginPath();
            this.moveTo(F, B);
            this.lineTo(C + D, B);
            this.strokePath();
            this.beginPath();
            this.moveTo(F, B + E);
            this.lineTo(C + D, B + E);
            this.strokePath();
            return this;
          },
          fillRoundedRect: function (A, B, D, E, C) {
            void 0 === C && (C = 20);
            var F = C,
              G = C,
              H = C,
              K = C;
            "number" !== typeof C &&
              ((F = v(C, "tl", 20)),
              (G = v(C, "tr", 20)),
              (H = v(C, "bl", 20)),
              (K = v(C, "br", 20)));
            this.beginPath();
            this.moveTo(A + F, B);
            this.lineTo(A + D - G, B);
            this.arc(A + D - G, B + G, G, -y.TAU, 0);
            this.lineTo(A + D, B + E - K);
            this.arc(A + D - K, B + E - K, K, 0, y.TAU);
            this.lineTo(A + H, B + E);
            this.arc(A + H, B + E - H, H, y.TAU, Math.PI);
            this.lineTo(A, B + F);
            this.arc(A + F, B + F, F, -Math.PI, -y.TAU);
            this.fillPath();
            return this;
          },
          strokeRoundedRect: function (A, B, D, E, C) {
            void 0 === C && (C = 20);
            var F = C,
              G = C,
              H = C,
              K = C;
            "number" !== typeof C &&
              ((F = v(C, "tl", 20)),
              (G = v(C, "tr", 20)),
              (H = v(C, "bl", 20)),
              (K = v(C, "br", 20)));
            this.beginPath();
            this.moveTo(A + F, B);
            this.lineTo(A + D - G, B);
            this.moveTo(A + D - G, B);
            this.arc(A + D - G, B + G, G, -y.TAU, 0);
            this.lineTo(A + D, B + E - K);
            this.moveTo(A + D, B + E - K);
            this.arc(A + D - K, B + E - K, K, 0, y.TAU);
            this.lineTo(A + H, B + E);
            this.moveTo(A + H, B + E);
            this.arc(A + H, B + E - H, H, y.TAU, Math.PI);
            this.lineTo(A, B + F);
            this.moveTo(A, B + F);
            this.arc(A + F, B + F, F, -Math.PI, -y.TAU);
            this.strokePath();
            return this;
          },
          fillPointShape: function (A, B) {
            return this.fillPoint(A.x, A.y, B);
          },
          fillPoint: function (A, B, D) {
            !D || 1 > D ? (D = 1) : ((A -= D / 2), (B -= D / 2));
            this.commandBuffer.push(k.FILL_RECT, A, B, D, D);
            return this;
          },
          fillTriangleShape: function (A) {
            return this.fillTriangle(A.x1, A.y1, A.x2, A.y2, A.x3, A.y3);
          },
          strokeTriangleShape: function (A) {
            return this.strokeTriangle(A.x1, A.y1, A.x2, A.y2, A.x3, A.y3);
          },
          fillTriangle: function (A, B, D, E, C, F) {
            this.commandBuffer.push(k.FILL_TRIANGLE, A, B, D, E, C, F);
            return this;
          },
          strokeTriangle: function (A, B, D, E, C, F) {
            this.commandBuffer.push(k.STROKE_TRIANGLE, A, B, D, E, C, F);
            return this;
          },
          strokeLineShape: function (A) {
            return this.lineBetween(A.x1, A.y1, A.x2, A.y2);
          },
          lineBetween: function (A, B, D, E) {
            this.beginPath();
            this.moveTo(A, B);
            this.lineTo(D, E);
            this.strokePath();
            return this;
          },
          lineTo: function (A, B) {
            this.commandBuffer.push(k.LINE_TO, A, B);
            return this;
          },
          moveTo: function (A, B) {
            this.commandBuffer.push(k.MOVE_TO, A, B);
            return this;
          },
          strokePoints: function (A, B, D, E) {
            void 0 === B && (B = !1);
            void 0 === D && (D = !1);
            void 0 === E && (E = A.length);
            this.beginPath();
            this.moveTo(A[0].x, A[0].y);
            for (var C = 1; C < E; C++) this.lineTo(A[C].x, A[C].y);
            B && this.lineTo(A[0].x, A[0].y);
            D && this.closePath();
            this.strokePath();
            return this;
          },
          fillPoints: function (A, B, D, E) {
            void 0 === B && (B = !1);
            void 0 === D && (D = !1);
            void 0 === E && (E = A.length);
            this.beginPath();
            this.moveTo(A[0].x, A[0].y);
            for (var C = 1; C < E; C++) this.lineTo(A[C].x, A[C].y);
            B && this.lineTo(A[0].x, A[0].y);
            D && this.closePath();
            this.fillPath();
            return this;
          },
          strokeEllipseShape: function (A, B) {
            void 0 === B && (B = 32);
            A = A.getPoints(B);
            return this.strokePoints(A, !0);
          },
          strokeEllipse: function (A, B, D, E, C) {
            void 0 === C && (C = 32);
            A = new r(A, B, D, E).getPoints(C);
            return this.strokePoints(A, !0);
          },
          fillEllipseShape: function (A, B) {
            void 0 === B && (B = 32);
            A = A.getPoints(B);
            return this.fillPoints(A, !0);
          },
          fillEllipse: function (A, B, D, E, C) {
            void 0 === C && (C = 32);
            A = new r(A, B, D, E).getPoints(C);
            return this.fillPoints(A, !0);
          },
          arc: function (A, B, D, E, C, F, G) {
            void 0 === F && (F = !1);
            void 0 === G && (G = 0);
            this.commandBuffer.push(k.ARC, A, B, D, E, C, F, G);
            return this;
          },
          slice: function (A, B, D, E, C, F, G) {
            void 0 === F && (F = !1);
            void 0 === G && (G = 0);
            this.commandBuffer.push(k.BEGIN_PATH);
            this.commandBuffer.push(k.MOVE_TO, A, B);
            this.commandBuffer.push(k.ARC, A, B, D, E, C, F, G);
            this.commandBuffer.push(k.CLOSE_PATH);
            return this;
          },
          save: function () {
            this.commandBuffer.push(k.SAVE);
            return this;
          },
          restore: function () {
            this.commandBuffer.push(k.RESTORE);
            return this;
          },
          translateCanvas: function (A, B) {
            this.commandBuffer.push(k.TRANSLATE, A, B);
            return this;
          },
          scaleCanvas: function (A, B) {
            this.commandBuffer.push(k.SCALE, A, B);
            return this;
          },
          rotateCanvas: function (A) {
            this.commandBuffer.push(k.ROTATE, A);
            return this;
          },
          clear: function () {
            this.commandBuffer.length = 0;
            -1 < this.defaultFillColor &&
              this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
            -1 < this.defaultStrokeColor &&
              this.lineStyle(
                this.defaultStrokeWidth,
                this.defaultStrokeColor,
                this.defaultStrokeAlpha
              );
            return this;
          },
          generateTexture: function (A, B, D) {
            var E = this.scene.sys,
              C = E.game.renderer;
            void 0 === B && (B = E.scale.width);
            void 0 === D && (D = E.scale.height);
            z.TargetCamera.setScene(this.scene);
            z.TargetCamera.setViewport(0, 0, B, D);
            z.TargetCamera.scrollX = this.x;
            z.TargetCamera.scrollY = this.y;
            var F;
            if ("string" === typeof A)
              if (E.textures.exists(A)) {
                var G = E.textures.get(A);
                A = G.getSourceImage();
                A instanceof HTMLCanvasElement && (F = A.getContext("2d"));
              } else
                (G = E.textures.createCanvas(A, B, D)),
                  (F = G.getSourceImage().getContext("2d"));
            else A instanceof HTMLCanvasElement && (F = A.getContext("2d"));
            F &&
              (this.renderCanvas(C, this, z.TargetCamera, null, F, !1),
              G && G.refresh());
            return this;
          },
          preDestroy: function () {
            this.commandBuffer = [];
          },
        });
        z.TargetCamera = new t();
        h.exports = z;
      },
      function (h, t) {
        h.exports = {
          ARC: 0,
          BEGIN_PATH: 1,
          CLOSE_PATH: 2,
          FILL_RECT: 3,
          LINE_TO: 4,
          MOVE_TO: 5,
          LINE_STYLE: 6,
          FILL_STYLE: 7,
          FILL_PATH: 8,
          STROKE_PATH: 9,
          FILL_TRIANGLE: 10,
          STROKE_TRIANGLE: 11,
          SAVE: 14,
          RESTORE: 15,
          TRANSLATE: 16,
          SCALE: 17,
          ROTATE: 18,
          GRADIENT_FILL_STYLE: 21,
          GRADIENT_LINE_STYLE: 22,
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e, b) {
          void 0 === b && (b = new d());
          var c = k.height / 2;
          b.x = k.x + (k.width / 2) * Math.cos(e);
          b.y = k.y + c * Math.sin(e);
          return b;
        };
      },
      function (h, t, a) {
        var d = a(35);
        t = a(0);
        var k = a(11),
          e = a(176),
          b = a(101),
          c = a(9),
          f = a(75),
          g = a(110),
          m = a(1071),
          n = a(20),
          q = a(79);
        a = new t({
          Extends: g,
          Mixins: [
            k.AlphaSingle,
            k.BlendMode,
            k.Depth,
            k.Mask,
            k.Pipeline,
            k.Visible,
            c,
            m,
          ],
          initialize: function (r, u) {
            g.call(this, r);
            c.call(this);
            this.scene = r;
            this.displayList = null;
            this.type = "Layer";
            this.state = 0;
            this.parentContainer = null;
            this.name = "";
            this.active = !0;
            this.tabIndex = -1;
            this.data = null;
            this.renderFlags = 15;
            this.cameraFilter = 0;
            this.body = this.input = null;
            this.ignoreDestroy = !1;
            this.systems = r.sys;
            this.events = r.sys.events;
            this.sortChildrenFlag = !1;
            this.addCallback = this.addChildCallback;
            this.removeCallback = this.removeChildCallback;
            this.initPipeline();
            this.clearAlpha();
            this.setBlendMode(d.SKIP_CHECK);
            u && this.add(u);
            r.sys.queueDepthSort();
          },
          setActive: function (r) {
            this.active = r;
            return this;
          },
          setName: function (r) {
            this.name = r;
            return this;
          },
          setState: function (r) {
            this.state = r;
            return this;
          },
          setDataEnabled: function () {
            this.data || (this.data = new b(this));
            return this;
          },
          setData: function (r, u) {
            this.data || (this.data = new b(this));
            this.data.set(r, u);
            return this;
          },
          incData: function (r, u) {
            this.data || (this.data = new b(this));
            this.data.inc(r, u);
            return this;
          },
          toggleData: function (r) {
            this.data || (this.data = new b(this));
            this.data.toggle(r);
            return this;
          },
          getData: function (r) {
            this.data || (this.data = new b(this));
            return this.data.get(r);
          },
          setInteractive: function () {
            return this;
          },
          disableInteractive: function () {
            return this;
          },
          removeInteractive: function () {
            return this;
          },
          addedToScene: function () {},
          removedFromScene: function () {},
          update: function () {},
          toJSON: function () {
            return e(this);
          },
          willRender: function (r) {
            return !(
              15 !== this.renderFlags ||
              0 === this.list.length ||
              (0 !== this.cameraFilter && this.cameraFilter & r.id)
            );
          },
          getIndexList: function () {
            for (var r = this, u = this.parentContainer, v = []; u; )
              if ((v.unshift(u.getIndex(r)), (r = u), u.parentContainer))
                u = u.parentContainer;
              else break;
            v.unshift(this.displayList.getIndex(r));
            return v;
          },
          addChildCallback: function (r) {
            r.displayList &&
              r.displayList !== this &&
              r.removeFromDisplayList();
            r.displayList ||
              (this.queueDepthSort(),
              (r.displayList = this),
              r.emit(f.ADDED_TO_SCENE, r, this.scene),
              this.events.emit(n.ADDED_TO_SCENE, r, this.scene));
          },
          removeChildCallback: function (r) {
            this.queueDepthSort();
            r.displayList = null;
            r.emit(f.REMOVED_FROM_SCENE, r, this.scene);
            this.events.emit(n.REMOVED_FROM_SCENE, r, this.scene);
          },
          queueDepthSort: function () {
            this.sortChildrenFlag = !0;
          },
          depthSort: function () {
            this.sortChildrenFlag &&
              (q(this.list, this.sortByDepth), (this.sortChildrenFlag = !1));
          },
          sortByDepth: function (r, u) {
            return r._depth - u._depth;
          },
          getChildren: function () {
            return this.list;
          },
          destroy: function () {
            if (this.scene && !this.ignoreDestroy) {
              this.emit(f.DESTROY, this);
              for (var r = this.list.length; r--; ) this.list[r].destroy();
              this.removeAllListeners();
              this.resetPostPipeline(!0);
              this.displayList &&
                (this.displayList.remove(this, !0),
                this.displayList.queueDepthSort());
              this.data && (this.data.destroy(), (this.data = void 0));
              this.visible = this.active = !1;
              this.events =
                this.systems =
                this.displayList =
                this.scene =
                this.list =
                  void 0;
            }
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(11),
          k = a(15),
          e = a(450),
          b = a(110),
          c = a(452);
        a = a(1075);
        a = new t({
          Extends: k,
          Mixins: [d.Depth, d.Mask, d.Pipeline, d.Transform, d.Visible, a],
          initialize: function (f, g, m, n) {
            k.call(this, f, "ParticleEmitterManager");
            this.blendMode = -1;
            this.timeScale = 1;
            this.frame = this.texture = null;
            this.frameNames = [];
            null === m ||
              ("object" !== typeof m && !Array.isArray(m)) ||
              ((n = m), (m = null));
            this.setTexture(g, m);
            this.initPipeline();
            this.emitters = new b(this);
            this.wells = new b(this);
            if (n)
              for (Array.isArray(n) || (n = [n]), f = 0; f < n.length; f++)
                this.createEmitter(n[f]);
          },
          addedToScene: function () {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function () {
            this.scene.sys.updateList.remove(this);
          },
          setTexture: function (f, g) {
            this.texture = this.scene.sys.textures.get(f);
            return this.setFrame(g);
          },
          setFrame: function (f) {
            this.frame = this.texture.get(f);
            var g = [];
            this.texture
              .getFramesFromTextureSource(this.frame.sourceIndex)
              .forEach(function (m) {
                g.push(m.name);
              });
            this.frameNames = g;
            this.defaultFrame = this.frame;
            return this;
          },
          setEmitterFrames: function (f, g) {
            Array.isArray(f) || (f = [f]);
            for (var m = g.frames, n = (m.length = 0); n < f.length; n++) {
              var q = f[n];
              -1 !== this.frameNames.indexOf(q) && m.push(this.texture.get(q));
            }
            g.defaultFrame = 0 < m.length ? m[0] : this.defaultFrame;
            return this;
          },
          addEmitter: function (f) {
            return this.emitters.add(f);
          },
          createEmitter: function (f) {
            return this.addEmitter(new c(this, f));
          },
          removeEmitter: function (f) {
            return this.emitters.remove(f, !0);
          },
          addGravityWell: function (f) {
            return this.wells.add(f);
          },
          createGravityWell: function (f) {
            return this.addGravityWell(new e(f));
          },
          emitParticle: function (f, g, m) {
            for (var n = this.emitters.list, q = 0; q < n.length; q++) {
              var r = n[q];
              r.active && r.emitParticle(f, g, m);
            }
            return this;
          },
          emitParticleAt: function (f, g, m) {
            return this.emitParticle(m, f, g);
          },
          pause: function () {
            this.active = !1;
            return this;
          },
          resume: function () {
            this.active = !0;
            return this;
          },
          getProcessors: function () {
            return this.wells.getAll("active", !0);
          },
          preUpdate: function (f, g) {
            g *= this.timeScale;
            for (var m = this.emitters.list, n = 0; n < m.length; n++) {
              var q = m[n];
              q.active && q.preUpdate(f, g);
            }
          },
          setAlpha: function () {},
          setScrollFactor: function () {},
          setBlendMode: function () {},
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(35),
          k = a(133),
          e = a(31);
        t = a(0);
        var b = a(11),
          c = a(33),
          f = a(109),
          g = a(15),
          m = a(1),
          n = a(92),
          q = a(1079),
          r = a(141),
          u = a(12),
          v = a(222);
        a = new t({
          Extends: g,
          Mixins: [
            b.Alpha,
            b.BlendMode,
            b.ComputedSize,
            b.Crop,
            b.Depth,
            b.Flip,
            b.GetBounds,
            b.Mask,
            b.Origin,
            b.Pipeline,
            b.ScrollFactor,
            b.Tint,
            b.Transform,
            b.Visible,
            q,
          ],
          initialize: function (x, y, z, A, B, D, E) {
            void 0 === y && (y = 0);
            void 0 === z && (z = 0);
            void 0 === A && (A = 32);
            void 0 === B && (B = 32);
            g.call(this, x, "RenderTexture");
            this.renderer = x.sys.renderer;
            this.textureManager = x.sys.textures;
            this.globalTint = 16777215;
            this.globalAlpha = 1;
            this.canvas = null;
            this.dirty = !1;
            this._crop = this.resetCropObject();
            this.frame = this.texture = null;
            this._saved = !1;
            void 0 === D
              ? ((this.canvas = e.create2D(this, A, B)),
                (this.texture = x.sys.textures.addCanvas(v(), this.canvas)),
                (this.frame = this.texture.get()))
              : ((this.texture = x.sys.textures.get(D)),
                (this.frame = this.texture.get(E)),
                (this.canvas = this.frame.source.image),
                (this.dirty = this._saved = !0),
                (this.width = this.frame.cutWidth),
                (this.height = this.frame.cutHeight));
            this.context = this.canvas.getContext("2d");
            this._eraseMode = !1;
            this.camera = new k(0, 0, A, B);
            this.renderTarget = null;
            E = this.renderer;
            E
              ? E.type === c.WEBGL
                ? ((this.drawGameObject = this.batchGameObjectWebGL),
                  (this.renderTarget = new r(E, A, B, 1, 0, !1)))
                : E.type === c.CANVAS &&
                  (this.drawGameObject = this.batchGameObjectCanvas)
              : (this.drawGameObject = m);
            this.camera.setScene(x);
            this.setPosition(y, z);
            void 0 === D && this.setSize(A, B);
            this.setOrigin(0, 0);
            this.initPipeline(n.SINGLE_PIPELINE);
          },
          setSize: function (x, y) {
            return this.resize(x, y);
          },
          resize: function (x, y) {
            void 0 === y && (y = x);
            var z = this.frame;
            if (x !== this.width || y !== this.height) {
              if ("__BASE" === z.name) {
                this.canvas.width = x;
                this.canvas.height = y;
                this.texture.width = x;
                this.texture.height = y;
                var A = this.renderTarget;
                A &&
                  (A.resize(x, y),
                  (z.glTexture = A.texture),
                  (z.source.isRenderTexture = !0),
                  (z.source.isGLTexture = !0),
                  (z.source.glTexture = A.texture));
                this.camera.setSize(x, y);
                z.source.width = x;
                z.source.height = y;
                z.setSize(x, y);
                this.width = x;
                this.height = y;
              }
            } else
              (A = this.texture.getSourceImage()),
                z.cutX + x > A.width && (x = A.width - z.cutX),
                z.cutY + y > A.height && (y = A.height - z.cutY),
                z.setSize(x, y, z.cutX, z.cutY);
            this.updateDisplayOrigin();
            (z = this.input) &&
              !z.customHitArea &&
              ((z.hitArea.width = x), (z.hitArea.height = y));
            return this;
          },
          setGlobalTint: function (x) {
            this.globalTint = x;
            return this;
          },
          setGlobalAlpha: function (x) {
            this.globalAlpha = x;
            return this;
          },
          saveTexture: function (x) {
            this.textureManager.renameTexture(this.texture.key, x);
            this._saved = !0;
            return this.texture;
          },
          fill: function (x, y, z, A, B, D) {
            var E = this.frame,
              C = this.camera,
              F = this.renderer;
            void 0 === y && (y = 1);
            void 0 === z && (z = 0);
            void 0 === A && (A = 0);
            void 0 === B && (B = E.cutWidth);
            void 0 === D && (D = E.cutHeight);
            var G = ((x >> 16) & 255) / 255,
              H = ((x >> 8) & 255) / 255;
            x = (x & 255) / 255;
            var K = this.renderTarget;
            C.preRender();
            K
              ? (K.bind(!0),
                (E = this.pipeline),
                E.manager.set(E),
                (C = F.width / K.width),
                (F = F.height / K.height),
                E.drawFillRect(
                  z * C,
                  A * F,
                  B * C,
                  D * F,
                  u.getTintFromFloats(x, H, G, 1),
                  y
                ),
                K.unbind(!0))
              : ((K = this.context),
                F.setContext(K),
                (K.fillStyle = "rgba(" + G + "," + H + "," + x + "," + y + ")"),
                K.fillRect(z + E.cutX, A + E.cutY, B, D),
                F.setContext());
            this.dirty = !0;
            return this;
          },
          clear: function () {
            if (this.dirty) {
              var x = this.renderTarget;
              x
                ? x.clear()
                : ((x = this.context),
                  x.save(),
                  x.setTransform(1, 0, 0, 1, 0, 0),
                  x.clearRect(
                    this.frame.cutX,
                    this.frame.cutY,
                    this.frame.cutWidth,
                    this.frame.cutHeight
                  ),
                  x.restore());
              this.dirty = !1;
            }
            return this;
          },
          erase: function (x, y, z) {
            this._eraseMode = !0;
            this.draw(x, y, z, 1, 16777215);
            this._eraseMode = !1;
            return this;
          },
          draw: function (x, y, z, A, B) {
            this.beginDraw();
            this.batchDraw(x, y, z, A, B);
            this.endDraw();
            return this;
          },
          drawFrame: function (x, y, z, A, B, D) {
            this.beginDraw();
            this.batchDrawFrame(x, y, z, A, B, D);
            this.endDraw();
            return this;
          },
          beginDraw: function () {
            var x = this.renderer,
              y = this.renderTarget;
            this.camera.preRender();
            y ? x.beginCapture(y.width, y.height) : x.setContext(this.context);
            return this;
          },
          batchDraw: function (x, y, z, A, B) {
            void 0 === A && (A = this.globalAlpha);
            B =
              void 0 === B
                ? (this.globalTint >> 16) +
                  (this.globalTint & 65280) +
                  ((this.globalTint & 255) << 16)
                : (B >> 16) + (B & 65280) + ((B & 255) << 16);
            Array.isArray(x) || (x = [x]);
            this.batchList(x, y, z, A, B);
            return this;
          },
          batchDrawFrame: function (x, y, z, A, B, D) {
            void 0 === z && (z = 0);
            void 0 === A && (A = 0);
            void 0 === B && (B = this.globalAlpha);
            D =
              void 0 === D
                ? (this.globalTint >> 16) +
                  (this.globalTint & 65280) +
                  ((this.globalTint & 255) << 16)
                : (D >> 16) + (D & 65280) + ((D & 255) << 16);
            (x = this.textureManager.getFrame(x, y)) &&
              (this.renderTarget
                ? this.pipeline.batchTextureFrame(
                    x,
                    z,
                    A,
                    D,
                    B,
                    this.camera.matrix,
                    null
                  )
                : this.batchTextureFrame(
                    x,
                    z + this.frame.cutX,
                    A + this.frame.cutY,
                    B,
                    D
                  ));
            return this;
          },
          endDraw: function (x) {
            void 0 === x && (x = this._eraseMode);
            var y = this.renderer,
              z = this.renderTarget;
            if (z) {
              var A = y.endCapture();
              y.pipelines.setUtility().blitFrame(A, z, 1, !1, !1, x);
              y.resetScissor();
              y.resetViewport();
            } else y.setContext();
            this.dirty = !0;
            return this;
          },
          batchList: function (x, y, z, A, B) {
            for (var D = 0; D < x.length; D++) {
              var E = x[D];
              E &&
                E !== this &&
                (E.renderWebGL || E.renderCanvas
                  ? this.drawGameObject(E, y, z)
                  : E.isParent || E.list
                  ? this.batchGroup(E.getChildren(), y, z)
                  : "string" === typeof E
                  ? this.batchTextureFrameKey(E, null, y, z, A, B)
                  : E instanceof f
                  ? this.batchTextureFrame(E, y, z, A, B)
                  : Array.isArray(E) && this.batchList(E, y, z, A, B));
            }
          },
          batchGroup: function (x, y, z) {
            void 0 === y && (y = 0);
            void 0 === z && (z = 0);
            y += this.frame.cutX;
            z += this.frame.cutY;
            for (var A = 0; A < x.length; A++) {
              var B = x[A];
              B.willRender(this.camera) &&
                this.drawGameObject(B, B.x + y, B.y + z);
            }
          },
          batchGameObjectWebGL: function (x, y, z) {
            void 0 === y && (y = x.x);
            void 0 === z && (z = x.y);
            var A = x.x,
              B = x.y;
            x.setPosition(y + this.frame.cutX, z + this.frame.cutY);
            x.renderDirect
              ? x.renderDirect(this.renderer, x, this.camera)
              : x.renderWebGL(this.renderer, x, this.camera);
            x.setPosition(A, B);
          },
          batchGameObjectCanvas: function (x, y, z) {
            void 0 === y && (y = x.x);
            void 0 === z && (z = x.y);
            var A = x.x,
              B = x.y;
            if (this._eraseMode) {
              var D = x.blendMode;
              x.blendMode = d.ERASE;
            }
            x.setPosition(y + this.frame.cutX, z + this.frame.cutY);
            x.renderCanvas(this.renderer, x, this.camera, null);
            x.setPosition(A, B);
            this._eraseMode && (x.blendMode = D);
          },
          batchTextureFrameKey: function (x, y, z, A, B, D) {
            (x = this.textureManager.getFrame(x, y)) &&
              this.batchTextureFrame(x, z, A, B, D);
          },
          batchTextureFrame: function (x, y, z, A, B) {
            void 0 === y && (y = 0);
            void 0 === z && (z = 0);
            y += this.frame.cutX;
            z += this.frame.cutY;
            if (this.renderTarget)
              this.pipeline.batchTextureFrame(
                x,
                y,
                z,
                B,
                A,
                this.camera.matrix,
                null
              );
            else {
              B = this.context;
              var D = x.canvasData;
              x = x.source.image;
              var E = this.camera.matrix;
              B.save();
              B.globalCompositeOperation = this._eraseMode
                ? "destination-out"
                : "source-over";
              B.globalAlpha = A;
              E.setToContext(B);
              B.drawImage(
                x,
                D.x,
                D.y,
                D.width,
                D.height,
                y,
                z,
                D.width,
                D.height
              );
              B.restore();
            }
          },
          snapshotArea: function (x, y, z, A, B, D, E) {
            this.renderTarget
              ? this.renderer.snapshotFramebuffer(
                  this.renderTarget.framebuffer,
                  this.width,
                  this.height,
                  B,
                  !1,
                  x,
                  y,
                  z,
                  A,
                  D,
                  E
                )
              : this.renderer.snapshotCanvas(
                  this.canvas,
                  B,
                  !1,
                  x,
                  y,
                  z,
                  A,
                  D,
                  E
                );
            return this;
          },
          snapshot: function (x, y, z) {
            this.renderTarget
              ? this.renderer.snapshotFramebuffer(
                  this.renderTarget.framebuffer,
                  this.width,
                  this.height,
                  x,
                  !1,
                  0,
                  0,
                  this.width,
                  this.height,
                  y,
                  z
                )
              : this.renderer.snapshotCanvas(
                  this.canvas,
                  x,
                  !1,
                  0,
                  0,
                  this.width,
                  this.height,
                  y,
                  z
                );
            return this;
          },
          snapshotPixel: function (x, y, z) {
            this.renderTarget
              ? this.renderer.snapshotFramebuffer(
                  this.renderTarget.framebuffer,
                  this.width,
                  this.height,
                  z,
                  !0,
                  x,
                  y
                )
              : this.renderer.snapshotCanvas(this.canvas, z, !0, x, y);
            return this;
          },
          preDestroy: function () {
            this._saved ||
              (e.remove(this.canvas),
              this.renderTarget && this.renderTarget.destroy(),
              this.texture.destroy(),
              this.camera.destroy(),
              (this.texture = this.context = this.canvas = null));
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function () {
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
            /[xy]/g,
            function (a) {
              var d = (16 * Math.random()) | 0;
              return ("x" === a ? d : (d & 3) | 8).toString(16);
            }
          );
        };
      },
      function (h, t, a) {
        var d = a(164);
        t = a(0);
        var k = a(11),
          e = a(15),
          b = a(92),
          c = a(1085),
          f = a(3);
        a = new t({
          Extends: e,
          Mixins: [
            k.AlphaSingle,
            k.BlendMode,
            k.Depth,
            k.Flip,
            k.Mask,
            k.Pipeline,
            k.Size,
            k.Texture,
            k.Transform,
            k.Visible,
            k.ScrollFactor,
            c,
          ],
          initialize: function (g, m, n, q, r, u, v, x, y) {
            void 0 === q && (q = "__DEFAULT");
            void 0 === u && (u = 2);
            void 0 === v && (v = !0);
            e.call(this, g, "Rope");
            this.anims = new d(this);
            this.points = u;
            this.vertices;
            this.uv;
            this.colors;
            this.alphas;
            this.tintFill = "__DEFAULT" === q ? !0 : !1;
            this.dirty = !1;
            this.horizontal = v;
            this._flipY = this._flipX = !1;
            this._perp = new f();
            this.debugGraphic = this.debugCallback = null;
            this.setTexture(q, r);
            this.setPosition(m, n);
            this.setSizeToFrame();
            this.initPipeline(b.ROPE_PIPELINE);
            Array.isArray(u) && this.resizeArrays(u.length);
            this.setPoints(u, x, y);
            this.updateVertices();
          },
          addedToScene: function () {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function () {
            this.scene.sys.updateList.remove(this);
          },
          preUpdate: function (g, m) {
            var n = this.anims.currentFrame;
            this.anims.update(g, m);
            this.anims.currentFrame !== n &&
              (this.updateUVs(), this.updateVertices());
          },
          play: function (g, m, n) {
            this.anims.play(g, m, n);
            return this;
          },
          setDirty: function () {
            this.dirty = !0;
            return this;
          },
          setHorizontal: function (g, m, n) {
            void 0 === g && (g = this.points.length);
            if (this.horizontal) return this;
            this.horizontal = !0;
            return this.setPoints(g, m, n);
          },
          setVertical: function (g, m, n) {
            void 0 === g && (g = this.points.length);
            if (!this.horizontal) return this;
            this.horizontal = !1;
            return this.setPoints(g, m, n);
          },
          setTintFill: function (g) {
            void 0 === g && (g = !1);
            this.tintFill = g;
            return this;
          },
          setAlphas: function (g, m) {
            var n = this.points.length;
            if (1 > n) return this;
            var q = this.alphas;
            void 0 === g
              ? (g = [1])
              : Array.isArray(g) || void 0 !== m || (g = [g]);
            var r;
            if (void 0 !== m)
              for (r = 0; r < n; r++) {
                var u = 2 * r;
                q[u] = g;
                q[u + 1] = m;
              }
            else if (g.length === n)
              for (r = 0; r < n; r++)
                (u = 2 * r), (q[u] = g[r]), (q[u + 1] = g[r]);
            else
              for (m = g[0], r = 0; r < n; r++)
                (u = 2 * r),
                  g.length > u && (m = g[u]),
                  (q[u] = m),
                  g.length > u + 1 && (m = g[u + 1]),
                  (q[u + 1] = m);
            return this;
          },
          setColors: function (g) {
            var m = this.points.length;
            if (1 > m) return this;
            var n = this.colors;
            void 0 === g ? (g = [16777215]) : Array.isArray(g) || (g = [g]);
            var q;
            if (g.length === m)
              for (q = 0; q < m; q++) {
                var r = 2 * q;
                n[r] = g[q];
                n[r + 1] = g[q];
              }
            else {
              var u = g[0];
              for (q = 0; q < m; q++)
                (r = 2 * q),
                  g.length > r && (u = g[r]),
                  (n[r] = u),
                  g.length > r + 1 && (u = g[r + 1]),
                  (n[r + 1] = u);
            }
            return this;
          },
          setPoints: function (g, m, n) {
            void 0 === g && (g = 2);
            if ("number" === typeof g) {
              var q = g;
              2 > q && (q = 2);
              g = [];
              var r;
              if (this.horizontal) {
                var u = -this.frame.halfWidth;
                var v = this.frame.width / (q - 1);
                for (r = 0; r < q; r++)
                  g.push({
                    x: u + r * v,
                    y: 0,
                  });
              } else
                for (
                  u = -this.frame.halfHeight,
                    v = this.frame.height / (q - 1),
                    r = 0;
                  r < q;
                  r++
                )
                  g.push({
                    x: 0,
                    y: u + r * v,
                  });
            }
            q = g.length;
            r = this.points.length;
            if (1 > q)
              return console.warn("Rope: Not enough points given"), this;
            1 === q &&
              (g.unshift({
                x: 0,
                y: 0,
              }),
              q++);
            r !== q && this.resizeArrays(q);
            this.points = g;
            this.updateUVs();
            void 0 !== m && null !== m && this.setColors(m);
            void 0 !== n && null !== n && this.setAlphas(n);
            return this;
          },
          updateUVs: function () {
            for (
              var g = this.uv,
                m = this.points.length,
                n = this.frame.u0,
                q = this.frame.v0,
                r = this.frame.u1,
                u = this.frame.v1,
                v = (r - n) / (m - 1),
                x = (u - q) / (m - 1),
                y = 0;
              y < m;
              y++
            ) {
              var z = 4 * y;
              if (this.horizontal) {
                if (this._flipX) {
                  var A = r - y * v;
                  var B = r - y * v;
                } else (A = n + y * v), (B = n + y * v);
                if (this._flipY) {
                  var D = u;
                  var E = q;
                } else (D = q), (E = u);
              } else
                this._flipX ? ((A = n), (B = r)) : ((A = r), (B = n)),
                  this._flipY
                    ? ((D = u - y * x), (E = u - y * x))
                    : ((D = q + y * x), (E = q + y * x));
              g[z + 0] = A;
              g[z + 1] = D;
              g[z + 2] = B;
              g[z + 3] = E;
            }
            return this;
          },
          resizeArrays: function (g) {
            this.vertices = new Float32Array(4 * g);
            this.uv = new Float32Array(4 * g);
            var m = new Uint32Array(2 * g);
            var n = new Float32Array(2 * g);
            for (var q = 0; q < 2 * g; q++) (m[q] = 16777215), (n[q] = 1);
            this.colors = m;
            this.alphas = n;
            this.dirty = !0;
            return this;
          },
          updateVertices: function () {
            var g = this._perp,
              m = this.points,
              n = this.vertices,
              q = m.length;
            this.dirty = !1;
            if (!(1 > q)) {
              for (
                var r,
                  u = m[0],
                  v = this.horizontal
                    ? this.frame.halfHeight
                    : this.frame.halfWidth,
                  x = 0;
                x < q;
                x++
              ) {
                var y = m[x],
                  z = 4 * x;
                r = x < q - 1 ? m[x + 1] : y;
                g.x = r.y - u.y;
                g.y = -(r.x - u.x);
                r = g.length();
                g.x /= r;
                g.y /= r;
                g.x *= v;
                g.y *= v;
                n[z] = y.x + g.x;
                n[z + 1] = y.y + g.y;
                n[z + 2] = y.x - g.x;
                n[z + 3] = y.y - g.y;
                u = y;
              }
              return this;
            }
          },
          setDebug: function (g, m) {
            this.debugCallback =
              (this.debugGraphic = g) || m
                ? m
                  ? m
                  : this.renderDebugVerts
                : null;
            return this;
          },
          renderDebugVerts: function (g, m, n) {
            g = g.debugGraphic;
            var q = n[0],
              r = n[1],
              u = n[2],
              v = n[3];
            g.lineBetween(q, r, u, v);
            for (var x = 4; x < m; x += 4) {
              var y = n[x + 0],
                z = n[x + 1],
                A = n[x + 2],
                B = n[x + 3];
              g.lineBetween(q, r, y, z);
              g.lineBetween(u, v, A, B);
              g.lineBetween(u, v, y, z);
              g.lineBetween(y, z, A, B);
              q = y;
              r = z;
              u = A;
              v = B;
            }
          },
          preDestroy: function () {
            this.anims.destroy();
            this.anims = void 0;
            this.debugGraphic =
              this.debugCallback =
              this.alphas =
              this.colors =
              this.uv =
              this.vertices =
              this.points =
                null;
          },
          flipX: {
            get: function () {
              return this._flipX;
            },
            set: function (g) {
              this._flipX = g;
              return this.updateUVs();
            },
          },
          flipY: {
            get: function () {
              return this._flipY;
            },
            set: function (g) {
              this._flipY = g;
              return this.updateUVs();
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(142),
          k = a(31);
        t = a(0);
        var e = a(11),
          b = a(22),
          c = a(15),
          f = a(458),
          g = a(6),
          m = a(202),
          n = a(1088),
          q = a(459);
        a = new t({
          Extends: c,
          Mixins: [
            e.Alpha,
            e.BlendMode,
            e.ComputedSize,
            e.Crop,
            e.Depth,
            e.Flip,
            e.GetBounds,
            e.Mask,
            e.Origin,
            e.Pipeline,
            e.ScrollFactor,
            e.Tint,
            e.Transform,
            e.Visible,
            n,
          ],
          initialize: function (r, u, v, x, y) {
            void 0 === u && (u = 0);
            void 0 === v && (v = 0);
            c.call(this, r, "Text");
            this.renderer = r.sys.renderer;
            this.setPosition(u, v);
            this.setOrigin(0, 0);
            this.initPipeline();
            this.canvas = k.create(this);
            this.context = this.canvas.getContext("2d");
            this.style = new q(this, y);
            this.autoRound = !0;
            this.splitRegExp = /(?:\r\n|\r|\n)/;
            this._text = void 0;
            this.padding = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
            };
            this.height = this.width = 1;
            this.lineSpacing = 0;
            this.dirty = !1;
            0 === this.style.resolution && (this.style.resolution = 1);
            this._crop = this.resetCropObject();
            this.texture = r.sys.textures.addCanvas(null, this.canvas, !0);
            this.frame = this.texture.get();
            this.frame.source.resolution = this.style.resolution;
            this.renderer &&
              this.renderer.gl &&
              (this.renderer.deleteTexture(this.frame.source.glTexture),
              (this.frame.source.glTexture = null));
            this.initRTL();
            this.setText(x);
            y && y.padding && this.setPadding(y.padding);
            y && y.lineSpacing && this.setLineSpacing(y.lineSpacing);
            r.sys.game.events.on(
              b.CONTEXT_RESTORED,
              function () {
                this.dirty = !0;
              },
              this
            );
          },
          initRTL: function () {
            this.style.rtl &&
              ((this.canvas.dir = "rtl"),
              (this.context.direction = "rtl"),
              (this.canvas.style.display = "none"),
              d(this.canvas, this.scene.sys.canvas),
              (this.originX = 1));
          },
          runWordWrap: function (r) {
            var u = this.style;
            return u.wordWrapCallback
              ? ((r = u.wordWrapCallback.call(
                  u.wordWrapCallbackScope,
                  r,
                  this
                )),
                Array.isArray(r) && (r = r.join("\n")),
                r)
              : u.wordWrapWidth
              ? u.wordWrapUseAdvanced
                ? this.advancedWordWrap(
                    r,
                    this.context,
                    this.style.wordWrapWidth
                  )
                : this.basicWordWrap(r, this.context, this.style.wordWrapWidth)
              : r;
          },
          advancedWordWrap: function (r, u, v) {
            var x = "";
            r = r.replace(/ +/gi, " ").split(this.splitRegExp);
            for (var y = r.length, z = 0; z < y; z++) {
              var A = r[z],
                B = "";
              A = A.replace(/^ *|\s*$/gi, "");
              if (u.measureText(A).width < v) x += A + "\n";
              else {
                var D = v;
                A = A.split(" ");
                for (var E = 0; E < A.length; E++) {
                  var C = A[E],
                    F = C + " ",
                    G = u.measureText(F).width;
                  if (G > D) {
                    if (0 === E) {
                      for (
                        y = F;
                        y.length &&
                        !((y = y.slice(0, -1)),
                        (G = u.measureText(y).width),
                        G <= D);

                      );
                      if (!y.length)
                        throw Error(
                          "This text's wordWrapWidth setting is less than a single character!"
                        );
                      D = C.substr(y.length);
                      A[E] = D;
                      B += y;
                    }
                    D = A.slice(A[E].length ? E : E + 1)
                      .join(" ")
                      .replace(/[ \n]*$/gi, "");
                    r[z + 1] = D + " " + (r[z + 1] || "");
                    y = r.length;
                    break;
                  } else (B += F), (D -= G);
                }
                x += B.replace(/[ \n]*$/gi, "") + "\n";
              }
            }
            return (x = x.replace(/[\s|\n]*$/gi, ""));
          },
          basicWordWrap: function (r, u, v) {
            var x = "";
            r = r.split(this.splitRegExp);
            for (
              var y = r.length - 1, z = u.measureText(" ").width, A = 0;
              A <= y;
              A++
            ) {
              for (
                var B = v, D = r[A].split(" "), E = D.length - 1, C = 0;
                C <= E;
                C++
              ) {
                var F = D[C],
                  G = u.measureText(F).width,
                  H = G;
                C < E && (H += z);
                H > B && 0 < C && ((x += "\n"), (B = v));
                x += F;
                C < E ? ((x += " "), (B -= H)) : (B -= G);
              }
              A < y && (x += "\n");
            }
            return x;
          },
          getWrappedText: function (r) {
            void 0 === r && (r = this._text);
            this.style.syncFont(this.canvas, this.context);
            return this.runWordWrap(r).split(this.splitRegExp);
          },
          setText: function (r) {
            r || 0 === r || (r = "");
            Array.isArray(r) && (r = r.join("\n"));
            r !== this._text &&
              ((this._text = r.toString()), this.updateText());
            return this;
          },
          setStyle: function (r) {
            return this.style.setStyle(r);
          },
          setFont: function (r) {
            return this.style.setFont(r);
          },
          setFontFamily: function (r) {
            return this.style.setFontFamily(r);
          },
          setFontSize: function (r) {
            return this.style.setFontSize(r);
          },
          setFontStyle: function (r) {
            return this.style.setFontStyle(r);
          },
          setFixedSize: function (r, u) {
            return this.style.setFixedSize(r, u);
          },
          setBackgroundColor: function (r) {
            return this.style.setBackgroundColor(r);
          },
          setFill: function (r) {
            return this.style.setFill(r);
          },
          setColor: function (r) {
            return this.style.setColor(r);
          },
          setStroke: function (r, u) {
            return this.style.setStroke(r, u);
          },
          setShadow: function (r, u, v, x, y, z) {
            return this.style.setShadow(r, u, v, x, y, z);
          },
          setShadowOffset: function (r, u) {
            return this.style.setShadowOffset(r, u);
          },
          setShadowColor: function (r) {
            return this.style.setShadowColor(r);
          },
          setShadowBlur: function (r) {
            return this.style.setShadowBlur(r);
          },
          setShadowStroke: function (r) {
            return this.style.setShadowStroke(r);
          },
          setShadowFill: function (r) {
            return this.style.setShadowFill(r);
          },
          setWordWrapWidth: function (r, u) {
            return this.style.setWordWrapWidth(r, u);
          },
          setWordWrapCallback: function (r, u) {
            return this.style.setWordWrapCallback(r, u);
          },
          setAlign: function (r) {
            return this.style.setAlign(r);
          },
          setResolution: function (r) {
            return this.style.setResolution(r);
          },
          setLineSpacing: function (r) {
            this.lineSpacing = r;
            return this.updateText();
          },
          setPadding: function (r, u, v, x) {
            if ("object" === typeof r) {
              x = r;
              u = g(x, "x", null);
              null !== u
                ? (v = r = u)
                : ((r = g(x, "left", 0)), (v = g(x, "right", r)));
              var y = g(x, "y", null);
              null !== y
                ? (x = u = y)
                : ((u = g(x, "top", 0)), (x = g(x, "bottom", u)));
            } else
              void 0 === r && (r = 0),
                void 0 === u && (u = r),
                void 0 === v && (v = r),
                void 0 === x && (x = u);
            this.padding.left = r;
            this.padding.top = u;
            this.padding.right = v;
            this.padding.bottom = x;
            return this.updateText();
          },
          setMaxLines: function (r) {
            return this.style.setMaxLines(r);
          },
          updateText: function () {
            var r = this.canvas,
              u = this.context,
              v = this.style,
              x = v.resolution,
              y = v.metrics;
            v.syncFont(r, u);
            var z = this._text;
            if (v.wordWrapWidth || v.wordWrapCallback)
              z = this.runWordWrap(this._text);
            z = z.split(this.splitRegExp);
            var A = f(this, y, z),
              B = this.padding;
            if (0 === v.fixedWidth) {
              this.width = A.width + B.left + B.right;
              var D = A.width;
            } else
              (this.width = v.fixedWidth),
                (D = this.width - B.left - B.right),
                D < A.width && (D = A.width);
            this.height =
              0 === v.fixedHeight ? A.height + B.top + B.bottom : v.fixedHeight;
            var E = this.width,
              C = this.height;
            this.updateDisplayOrigin();
            E = Math.max(E * x, 1);
            C = Math.max(C * x, 1);
            r.width !== E || r.height !== C
              ? ((r.width = E),
                (r.height = C),
                this.frame.setSize(E, C),
                v.syncFont(r, u))
              : u.clearRect(0, 0, E, C);
            u.save();
            u.scale(x, x);
            v.backgroundColor &&
              ((u.fillStyle = v.backgroundColor), u.fillRect(0, 0, E, C));
            v.syncStyle(r, u);
            u.textBaseline = "alphabetic";
            u.translate(B.left, B.top);
            for (C = 0; C < A.lines; C++) {
              x = v.strokeThickness / 2;
              B = v.strokeThickness / 2 + C * A.lineHeight + y.ascent;
              0 < C && (B += A.lineSpacing * C);
              if (v.rtl) x = E - x;
              else if ("right" === v.align) x += D - A.lineWidths[C];
              else if ("center" === v.align) x += (D - A.lineWidths[C]) / 2;
              else if (
                "justify" === v.align &&
                0.85 <= A.lineWidths[C] / A.width
              ) {
                var F = A.width - A.lineWidths[C],
                  G = u.measureText(" ").width,
                  H = z[C].trim(),
                  K = H.split(" ");
                F += (z[C].length - H.length) * G;
                F = Math.floor(F / G);
                for (G = 0; 0 < F; )
                  (K[G] += " "), (G = (G + 1) % (K.length - 1 || 1)), --F;
                z[C] = K.join(" ");
              }
              this.autoRound && ((x = Math.round(x)), (B = Math.round(B)));
              v.strokeThickness &&
                (this.style.syncShadow(u, v.shadowStroke),
                u.strokeText(z[C], x, B));
              v.color &&
                (this.style.syncShadow(u, v.shadowFill),
                u.fillText(z[C], x, B));
            }
            u.restore();
            this.renderer &&
              this.renderer.gl &&
              ((this.frame.source.glTexture = this.renderer.canvasToTexture(
                r,
                this.frame.source.glTexture,
                !0
              )),
              (this.frame.glTexture = this.frame.source.glTexture));
            this.dirty = !0;
            (r = this.input) &&
              !r.customHitArea &&
              ((r.hitArea.width = this.width),
              (r.hitArea.height = this.height));
            return this;
          },
          getTextMetrics: function () {
            return this.style.getTextMetrics();
          },
          text: {
            get: function () {
              return this._text;
            },
            set: function (r) {
              this.setText(r);
            },
          },
          toJSON: function () {
            var r = e.ToJSON(this),
              u = {
                autoRound: this.autoRound,
                text: this._text,
                style: this.style.toJSON(),
                padding: {
                  left: this.padding.left,
                  right: this.padding.right,
                  top: this.padding.top,
                  bottom: this.padding.bottom,
                },
              };
            r.data = u;
            return r;
          },
          preDestroy: function () {
            this.style.rtl && m(this.canvas);
            k.remove(this.canvas);
            this.texture.destroy();
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(31);
        t = a(0);
        var k = a(11),
          e = a(22),
          b = a(15),
          c = a(361),
          f = a(192),
          g = a(1091),
          m = a(3);
        a = new t({
          Extends: b,
          Mixins: [
            k.Alpha,
            k.BlendMode,
            k.ComputedSize,
            k.Crop,
            k.Depth,
            k.Flip,
            k.GetBounds,
            k.Mask,
            k.Origin,
            k.Pipeline,
            k.ScrollFactor,
            k.Tint,
            k.Transform,
            k.Visible,
            g,
          ],
          initialize: function (n, q, r, u, v, x, y) {
            var z = n.sys.renderer;
            b.call(this, n, "TileSprite");
            x = n.sys.textures.get(x);
            var A = x.get(y);
            u && v
              ? ((u = Math.floor(u)), (v = Math.floor(v)))
              : ((u = A.width), (v = A.height));
            this._tilePosition = new m();
            this._tileScale = new m(1, 1);
            this.dirty = !1;
            this.renderer = z;
            this.canvas = d.create(this, u, v);
            this.context = this.canvas.getContext("2d");
            this.displayTexture = x;
            this.displayFrame = A;
            this._crop = this.resetCropObject();
            this.texture = n.sys.textures.addCanvas(null, this.canvas, !0);
            this.frame = this.texture.get();
            this.potWidth = c(A.width);
            this.potHeight = c(A.height);
            this.fillCanvas = d.create2D(this, this.potWidth, this.potHeight);
            this.fillContext = this.fillCanvas.getContext("2d");
            this.fillPattern = null;
            this.setPosition(q, r);
            this.setSize(u, v);
            this.setFrame(y);
            this.setOriginFromFrame();
            this.initPipeline();
            n.sys.game.events.on(
              e.CONTEXT_RESTORED,
              function (B) {
                if (B) {
                  var D = B.gl;
                  this.dirty = !0;
                  this.fillPattern = null;
                  this.fillPattern = B.createTexture2D(
                    0,
                    D.LINEAR,
                    D.LINEAR,
                    D.REPEAT,
                    D.REPEAT,
                    D.RGBA,
                    this.fillCanvas,
                    this.potWidth,
                    this.potHeight
                  );
                }
              },
              this
            );
          },
          setTexture: function (n, q) {
            this.displayTexture = this.scene.sys.textures.get(n);
            return this.setFrame(q);
          },
          setFrame: function (n) {
            n = this.displayTexture.get(n);
            this.potWidth = c(n.width);
            this.potHeight = c(n.height);
            this.canvas.width = 0;
            this.renderFlags =
              n.cutWidth && n.cutHeight
                ? this.renderFlags | 8
                : this.renderFlags & -9;
            this.displayFrame = n;
            this.dirty = !0;
            this.updateTileTexture();
            return this;
          },
          setTilePosition: function (n, q) {
            void 0 !== n && (this.tilePositionX = n);
            void 0 !== q && (this.tilePositionY = q);
            return this;
          },
          setTileScale: function (n, q) {
            void 0 === n && (n = this.tileScaleX);
            void 0 === q && (q = n);
            this.tileScaleX = n;
            this.tileScaleY = q;
            return this;
          },
          updateTileTexture: function () {
            if (this.dirty && this.renderer) {
              var n = this.displayFrame;
              if (n.source.isRenderTexture || n.source.isGLTexture)
                console.warn(
                  "TileSprites can only use Image or Canvas based textures"
                );
              else {
                var q = this.fillContext,
                  r = this.fillCanvas,
                  u = this.potWidth,
                  v = this.potHeight;
                (this.renderer && this.renderer.gl) ||
                  ((u = n.cutWidth), (v = n.cutHeight));
                q.clearRect(0, 0, u, v);
                r.width = u;
                r.height = v;
                q.drawImage(
                  n.source.image,
                  n.cutX,
                  n.cutY,
                  n.cutWidth,
                  n.cutHeight,
                  0,
                  0,
                  u,
                  v
                );
                this.fillPattern =
                  this.renderer && this.renderer.gl
                    ? this.renderer.canvasToTexture(r, this.fillPattern)
                    : q.createPattern(r, "repeat");
                this.updateCanvas();
              }
              this.dirty = !1;
            }
          },
          updateCanvas: function () {
            var n = this.canvas;
            if (n.width !== this.width || n.height !== this.height)
              (n.width = this.width),
                (n.height = this.height),
                this.frame.setSize(this.width, this.height),
                this.updateDisplayOrigin(),
                (this.dirty = !0);
            if (!(!this.dirty || (this.renderer && this.renderer.gl))) {
              n = this.context;
              this.scene.sys.game.config.antialias || f.disable(n);
              var q = this._tileScale.x,
                r = this._tileScale.y,
                u = this._tilePosition.x,
                v = this._tilePosition.y;
              n.clearRect(0, 0, this.width, this.height);
              n.save();
              n.scale(q, r);
              n.translate(-u, -v);
              n.fillStyle = this.fillPattern;
              n.fillRect(u, v, this.width / q, this.height / r);
              n.restore();
            }
            this.dirty = !1;
          },
          preDestroy: function () {
            this.renderer &&
              this.renderer.gl &&
              this.renderer.deleteTexture(this.fillPattern);
            d.remove(this.canvas);
            d.remove(this.fillCanvas);
            this.displayFrame =
              this.displayTexture =
              this.fillCanvas =
              this.fillContext =
              this.fillPattern =
                null;
            this.texture.destroy();
            this.renderer = null;
          },
          tilePositionX: {
            get: function () {
              return this._tilePosition.x;
            },
            set: function (n) {
              this._tilePosition.x = n;
              this.dirty = !0;
            },
          },
          tilePositionY: {
            get: function () {
              return this._tilePosition.y;
            },
            set: function (n) {
              this._tilePosition.y = n;
              this.dirty = !0;
            },
          },
          tileScaleX: {
            get: function () {
              return this._tileScale.x;
            },
            set: function (n) {
              this._tileScale.x = n;
              this.dirty = !0;
            },
          },
          tileScaleY: {
            get: function () {
              return this._tileScale.y;
            },
            set: function (n) {
              this._tileScale.y = n;
              this.dirty = !0;
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(18),
          k = a(11),
          e = a(75),
          b = a(22),
          c = a(51),
          f = a(15),
          g = a(70),
          m = a(222),
          n = a(1094),
          q = a(14);
        a = new t({
          Extends: f,
          Mixins: [
            k.Alpha,
            k.BlendMode,
            k.Depth,
            k.Flip,
            k.GetBounds,
            k.Mask,
            k.Origin,
            k.Pipeline,
            k.ScrollFactor,
            k.Size,
            k.TextureCrop,
            k.Tint,
            k.Transform,
            k.Visible,
            n,
          ],
          initialize: function (r, u, v, x) {
            f.call(this, r, "Video");
            this.snapshotTexture =
              this.videoTextureSource =
              this.videoTexture =
              this.video =
                null;
            this.flipY = !1;
            this._key = m();
            this.touchLocked = !0;
            this.playWhenUnlocked = !1;
            this.retryLimit = 20;
            this.retry = 0;
            this.retryInterval = 500;
            this._retryID = null;
            this._codePaused =
              this._systemPaused =
              this._codeMuted =
              this._systemMuted =
                !1;
            this._callbacks = {
              play: this.playHandler.bind(this),
              error: this.loadErrorHandler.bind(this),
              end: this.completeHandler.bind(this),
              time: this.timeUpdateHandler.bind(this),
              seeking: this.seekingHandler.bind(this),
              seeked: this.seekedHandler.bind(this),
            };
            this._crop = this.resetCropObject();
            this.markers = {};
            this._markerIn = -1;
            this._markerOut = q.MAX_SAFE_INTEGER;
            this._lastUpdate = 0;
            this._cacheKey = "";
            this.removeVideoElementOnDestroy = this._isSeeking = !1;
            this.setPosition(u, v);
            this.initPipeline();
            x && this.changeSource(x, !1);
            u = r.sys.game.events;
            u.on(b.PAUSE, this.globalPause, this);
            u.on(b.RESUME, this.globalResume, this);
            if ((r = r.sys.sound)) r.on(g.GLOBAL_MUTE, this.globalMute, this);
          },
          addedToScene: function () {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function () {
            this.scene.sys.updateList.remove(this);
          },
          play: function (r, u, v) {
            if ((this.touchLocked && this.playWhenUnlocked) || this.isPlaying())
              return this;
            var x = this.video;
            if (!x) return console.warn("Video not loaded"), this;
            void 0 === r && (r = x.loop);
            var y = this.scene.sys.sound;
            y && y.mute && this.setMute(!0);
            isNaN(u) || (this._markerIn = u);
            !isNaN(v) && v > u && (this._markerOut = v);
            x.loop = r;
            r = this._callbacks;
            u = x.play();
            void 0 !== u
              ? u
                  .then(this.playPromiseSuccessHandler.bind(this))
                  .catch(this.playPromiseErrorHandler.bind(this))
              : (x.addEventListener("playing", r.play, !0),
                2 > x.readyState &&
                  ((this.retry = this.retryLimit),
                  (this._retryID = window.setTimeout(
                    this.checkVideoProgress.bind(this),
                    this.retryInterval
                  ))));
            x.addEventListener("ended", r.end, !0);
            x.addEventListener("timeupdate", r.time, !0);
            x.addEventListener("seeking", r.seeking, !0);
            x.addEventListener("seeked", r.seeked, !0);
            return this;
          },
          changeSource: function (r, u, v, x, y) {
            void 0 === u && (u = !0);
            this.video && this.stop();
            var z = this.scene.sys.cache.video.get(r);
            z
              ? ((this.video = z),
                (this._cacheKey = r),
                (this._codePaused = z.paused),
                (this._codeMuted = z.muted),
                this.videoTexture
                  ? (this.scene.sys.textures.remove(this._key),
                    (this.videoTexture = this.scene.sys.textures.create(
                      this._key,
                      z,
                      z.videoWidth,
                      z.videoHeight
                    )),
                    (this.videoTextureSource = this.videoTexture.source[0]),
                    this.videoTexture.add(
                      "__BASE",
                      0,
                      0,
                      0,
                      z.videoWidth,
                      z.videoHeight
                    ),
                    this.setTexture(this.videoTexture),
                    this.setSizeToFrame(),
                    this.updateDisplayOrigin(),
                    this.emit(
                      e.VIDEO_CREATED,
                      this,
                      z.videoWidth,
                      z.videoHeight
                    ))
                  : this.updateTexture(),
                (this._lastUpdate = z.currentTime = 0),
                u && this.play(v, x, y))
              : (this.video = null);
            return this;
          },
          addMarker: function (r, u, v) {
            !isNaN(u) && 0 <= u && !isNaN(v) && (this.markers[r] = [u, v]);
            return this;
          },
          playMarker: function (r, u) {
            (r = this.markers[r]) && this.play(u, r[0], r[1]);
            return this;
          },
          removeMarker: function (r) {
            delete this.markers[r];
            return this;
          },
          snapshot: function (r, u) {
            void 0 === r && (r = this.width);
            void 0 === u && (u = this.height);
            return this.snapshotArea(0, 0, this.width, this.height, r, u);
          },
          snapshotArea: function (r, u, v, x, y, z) {
            void 0 === r && (r = 0);
            void 0 === u && (u = 0);
            void 0 === v && (v = this.width);
            void 0 === x && (x = this.height);
            void 0 === y && (y = v);
            void 0 === z && (z = x);
            var A = this.video,
              B = this.snapshotTexture;
            B
              ? B.setSize(y, z)
              : (this.snapshotTexture = B =
                  this.scene.sys.textures.createCanvas(m(), y, z));
            A && B.context.drawImage(A, r, u, v, x, 0, 0, y, z);
            return B.update();
          },
          saveSnapshotTexture: function (r) {
            this.snapshotTexture
              ? this.scene.sys.textures.renameTexture(
                  this.snapshotTexture.key,
                  r
                )
              : (this.snapshotTexture = this.scene.sys.textures.createCanvas(
                  r,
                  this.width,
                  this.height
                ));
            return this.snapshotTexture;
          },
          loadURL: function (r, u, v) {
            void 0 === v && (v = !1);
            this.video && this.stop();
            this.videoTexture && this.scene.sys.textures.remove(this._key);
            u = document.createElement("video");
            u.controls = !1;
            v &&
              ((u.muted = !0),
              (u.defaultMuted = !0),
              u.setAttribute("autoplay", "autoplay"));
            u.setAttribute("playsinline", "playsinline");
            u.setAttribute("preload", "auto");
            u.addEventListener("error", this._callbacks.error, !0);
            u.src = r;
            u.load();
            this.video = u;
            return this;
          },
          loadMediaStream: function (r, u, v) {
            void 0 === v && (v = !1);
            this.video && this.stop();
            this.videoTexture && this.scene.sys.textures.remove(this._key);
            u = document.createElement("video");
            u.controls = !1;
            v &&
              ((u.muted = !0),
              (u.defaultMuted = !0),
              u.setAttribute("autoplay", "autoplay"));
            u.setAttribute("playsinline", "playsinline");
            u.setAttribute("preload", "auto");
            u.addEventListener("error", this._callbacks.error, !0);
            try {
              u.srcObject = r;
            } catch (x) {
              u.src = window.URL.createObjectURL(r);
            }
            u.load();
            this.video = u;
            return this;
          },
          playPromiseSuccessHandler: function () {
            this.touchLocked = this._codePaused = !1;
            this.emit(e.VIDEO_PLAY, this);
            -1 < this._markerIn && (this.video.currentTime = this._markerIn);
          },
          playPromiseErrorHandler: function (r) {
            this.scene.sys.input.once(c.POINTER_DOWN, this.unlockHandler, this);
            this.playWhenUnlocked = this.touchLocked = !0;
            this.emit(e.VIDEO_ERROR, this, r);
          },
          playHandler: function () {
            this.touchLocked = this._codePaused = !1;
            this.emit(e.VIDEO_PLAY, this);
            this.video.removeEventListener("playing", this._callbacks.play, !0);
          },
          loadErrorHandler: function (r) {
            this.stop();
            this.emit(e.VIDEO_ERROR, this, r);
          },
          unlockHandler: function () {
            this.playWhenUnlocked = this.touchLocked = !1;
            this.emit(e.VIDEO_UNLOCKED, this);
            -1 < this._markerIn && (this.video.currentTime = this._markerIn);
            this.video.play();
            this.emit(e.VIDEO_PLAY, this);
          },
          completeHandler: function () {
            this.emit(e.VIDEO_COMPLETE, this);
          },
          timeUpdateHandler: function () {
            this.video &&
              this.video.currentTime < this._lastUpdate &&
              (this.emit(e.VIDEO_LOOP, this), (this._lastUpdate = 0));
          },
          preUpdate: function () {
            var r = this.video;
            if (r) {
              var u = r.currentTime;
              u !== this._lastUpdate &&
                ((this._lastUpdate = u),
                this.updateTexture(),
                u >= this._markerOut &&
                  (r.loop
                    ? ((r.currentTime = this._markerIn),
                      this.updateTexture(),
                      (this._lastUpdate = u),
                      this.emit(e.VIDEO_LOOP, this))
                    : (this.emit(e.VIDEO_COMPLETE, this), this.stop())));
            }
          },
          checkVideoProgress: function () {
            2 <= this.video.readyState
              ? this.updateTexture()
              : (this.retry--,
                0 < this.retry
                  ? (this._retryID = window.setTimeout(
                      this.checkVideoProgress.bind(this),
                      this.retryInterval
                    ))
                  : this.emit(e.VIDEO_TIMEOUT, this));
          },
          updateTexture: function () {
            var r = this.video,
              u = r.videoWidth,
              v = r.videoHeight;
            if (this.videoTexture) {
              var x = this.videoTextureSource;
              x.source !== r && ((x.source = r), (x.width = u), (x.height = v));
              x.update();
            } else
              (this.videoTexture = this.scene.sys.textures.create(
                this._key,
                r,
                u,
                v
              )),
                (this.videoTextureSource = this.videoTexture.source[0]),
                this.videoTexture.add("__BASE", 0, 0, 0, u, v),
                this.setTexture(this.videoTexture),
                this.setSizeToFrame(),
                this.updateDisplayOrigin(),
                this.emit(e.VIDEO_CREATED, this, u, v);
          },
          getVideoKey: function () {
            return this._cacheKey;
          },
          seekTo: function (r) {
            var u = this.video;
            u &&
              ((u = u.duration),
              Infinity === u || isNaN(u) || this.setCurrentTime(u * r));
            return this;
          },
          getCurrentTime: function () {
            return this.video ? this.video.currentTime : 0;
          },
          setCurrentTime: function (r) {
            var u = this.video;
            if (u) {
              if ("string" === typeof r) {
                var v = r[0],
                  x = parseFloat(r.substr(1));
                "+" === v
                  ? (r = u.currentTime + x)
                  : "-" === v && (r = u.currentTime - x);
              }
              this._lastUpdate = u.currentTime = r;
            }
            return this;
          },
          isSeeking: function () {
            return this._isSeeking;
          },
          seekingHandler: function () {
            this._isSeeking = !0;
            this.emit(e.VIDEO_SEEKING, this);
          },
          seekedHandler: function () {
            this._isSeeking = !1;
            this.emit(e.VIDEO_SEEKED, this);
            this.video && this.updateTexture();
          },
          getProgress: function () {
            var r = this.video;
            if (r) {
              var u = r.currentTime;
              r = r.duration;
              if (Infinity !== r && !isNaN(r)) return u / r;
            }
            return 0;
          },
          getDuration: function () {
            return this.video ? this.video.duration : 0;
          },
          setMute: function (r) {
            void 0 === r && (r = !0);
            this._codeMuted = r;
            var u = this.video;
            u && (u.muted = this._systemMuted ? !0 : r);
            return this;
          },
          isMuted: function () {
            return this._codeMuted;
          },
          globalMute: function (r, u) {
            this._systemMuted = u;
            if ((r = this.video)) r.muted = this._codeMuted ? !0 : u;
          },
          globalPause: function () {
            this._systemPaused = !0;
            this.video && this.video.pause();
          },
          globalResume: function () {
            this._systemPaused = !1;
            this.video && !this._codePaused && this.video.play();
          },
          setPaused: function (r) {
            void 0 === r && (r = !0);
            var u = this.video;
            this._codePaused = r;
            u &&
              (r
                ? u.paused || u.pause()
                : r || (u.paused && !this._systemPaused && u.play()));
            return this;
          },
          getVolume: function () {
            return this.video ? this.video.volume : 1;
          },
          setVolume: function (r) {
            void 0 === r && (r = 1);
            this.video && (this.video.volume = d(r, 0, 1));
            return this;
          },
          getPlaybackRate: function () {
            return this.video ? this.video.playbackRate : 1;
          },
          setPlaybackRate: function (r) {
            this.video && (this.video.playbackRate = r);
            return this;
          },
          getLoop: function () {
            return this.video ? this.video.loop : !1;
          },
          setLoop: function (r) {
            void 0 === r && (r = !0);
            this.video && (this.video.loop = r);
            return this;
          },
          isPlaying: function () {
            return this.video ? !(this.video.paused || this.video.ended) : !1;
          },
          isPaused: function () {
            return (
              (this.video && this.video.paused) ||
              this._codePaused ||
              this._systemPaused
            );
          },
          saveTexture: function (r, u) {
            void 0 === u && (u = !1);
            this.videoTexture &&
              this.scene.sys.textures.renameTexture(this._key, r);
            this._key = r;
            this.flipY = u;
            this.videoTextureSource && this.videoTextureSource.setFlipY(u);
            return this.videoTexture;
          },
          stop: function () {
            var r = this.video;
            if (r) {
              var u = this._callbacks,
                v;
              for (v in u) r.removeEventListener(v, u[v], !0);
              r.pause();
            }
            this._retryID && window.clearTimeout(this._retryID);
            this.emit(e.VIDEO_STOP, this);
            return this;
          },
          removeVideoElement: function () {
            var r = this.video;
            if (r) {
              for (
                r.parentNode && r.parentNode.removeChild(r);
                r.hasChildNodes();

              )
                r.removeChild(r.firstChild);
              r.removeAttribute("autoplay");
              r.removeAttribute("src");
              this.video = null;
            }
          },
          preDestroy: function () {
            this.stop();
            this.removeVideoElementOnDestroy && this.removeVideoElement();
            var r = this.scene.sys.game.events;
            r.off(b.PAUSE, this.globalPause, this);
            r.off(b.RESUME, this.globalResume, this);
            (r = this.scene.sys.sound) &&
              r.off(g.GLOBAL_MUTE, this.globalMute, this);
            this._retryID && window.clearTimeout(this._retryID);
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(228),
          k = a(470),
          e = a(56);
        a = new t({
          initialize: function (b) {
            this.type = e.POLYGON;
            this.area = 0;
            this.points = [];
            b && this.setTo(b);
          },
          contains: function (b, c) {
            return d(this, b, c);
          },
          setTo: function (b) {
            this.area = 0;
            this.points = [];
            "string" === typeof b && (b = b.split(" "));
            if (!Array.isArray(b)) return this;
            for (var c, f = Number.MAX_VALUE, g = 0; g < b.length; g++)
              (c = {
                x: 0,
                y: 0,
              }),
                "number" === typeof b[g] || "string" === typeof b[g]
                  ? ((c.x = parseFloat(b[g])),
                    (c.y = parseFloat(b[g + 1])),
                    g++)
                  : Array.isArray(b[g])
                  ? ((c.x = b[g][0]), (c.y = b[g][1]))
                  : ((c.x = b[g].x), (c.y = b[g].y)),
                this.points.push(c),
                c.y < f && (f = c.y);
            this.calculateArea(f);
            return this;
          },
          calculateArea: function () {
            if (3 > this.points.length) return (this.area = 0);
            for (var b = 0, c, f, g = 0; g < this.points.length - 1; g++)
              (c = this.points[g]),
                (f = this.points[g + 1]),
                (b += (f.x - c.x) * (c.y + f.y));
            c = this.points[0];
            f = this.points[this.points.length - 1];
            b += (c.x - f.x) * (f.y + c.y);
            return (this.area = 0.5 * -b);
          },
          getPoints: function (b, c, f) {
            return k(this, b, c, f);
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          for (
            var e = !1, b = -1, c = a.points.length - 1;
            ++b < a.points.length;
            c = b
          ) {
            var f = a.points[b].x,
              g = a.points[b].y,
              m = a.points[c].x;
            c = a.points[c].y;
            ((g <= k && k < c) || (c <= k && k < g)) &&
              d < ((m - f) * (k - g)) / (c - g) + f &&
              (e = !e);
          }
          return e;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(11),
          k = a(15),
          e = a(2),
          b = a(17),
          c = a(478),
          f = a(1176),
          g = a(25);
        a = new t({
          Extends: k,
          Mixins: [
            d.ComputedSize,
            d.Depth,
            d.GetBounds,
            d.Mask,
            d.Origin,
            d.ScrollFactor,
            d.Transform,
            d.Visible,
            f,
          ],
          initialize: function (m, n, q, r, u, v, x, y) {
            void 0 === q && (q = 0);
            void 0 === r && (r = 0);
            void 0 === u && (u = 128);
            void 0 === v && (v = 128);
            k.call(this, m, "Shader");
            this.blendMode = -1;
            this.shader;
            this.renderer = m = m.sys.renderer;
            this.gl = m.gl;
            this.vertexData = new ArrayBuffer(
              12 * Float32Array.BYTES_PER_ELEMENT
            );
            this.vertexBuffer = m.createVertexBuffer(
              this.vertexData.byteLength,
              this.gl.STREAM_DRAW
            );
            this.program = null;
            this.bytes = new Uint8Array(this.vertexData);
            this.vertexViewF32 = new Float32Array(this.vertexData);
            this._tempMatrix1 = new g();
            this._tempMatrix2 = new g();
            this._tempMatrix3 = new g();
            this.viewMatrix = new Float32Array([
              1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
            ]);
            this.projectionMatrix = new Float32Array([
              1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
            ]);
            this.uniforms = {};
            this.pointer = null;
            this._rendererWidth = m.width;
            this._rendererHeight = m.height;
            this._textureCount = 0;
            this.glTexture = this.framebuffer = null;
            this.renderToTexture = !1;
            this.texture = null;
            this.setPosition(q, r);
            this.setSize(u, v);
            this.setOrigin(0.5, 0.5);
            this.setShader(n, x, y);
          },
          willRender: function (m) {
            return this.renderToTexture
              ? !0
              : !(
                  k.RENDER_MASK !== this.renderFlags ||
                  (0 !== this.cameraFilter && this.cameraFilter & m.id)
                );
          },
          setRenderToTexture: function (m, n) {
            void 0 === n && (n = !1);
            if (!this.renderToTexture) {
              var q = this.width,
                r = this.height,
                u = this.renderer;
              this.glTexture = u.createTextureFromSource(null, q, r, 0);
              this.glTexture.flipY = n;
              this.framebuffer = u.createFramebuffer(q, r, this.glTexture, !1);
              this._rendererWidth = q;
              this._rendererHeight = r;
              this.renderToTexture = !0;
              this.projOrtho(0, this.width, this.height, 0);
              m &&
                (this.texture = this.scene.sys.textures.addGLTexture(
                  m,
                  this.glTexture,
                  q,
                  r
                ));
            }
            this.shader &&
              (u.pipelines.clear(),
              this.load(),
              this.flush(),
              u.pipelines.rebind());
            return this;
          },
          setShader: function (m, n, q) {
            void 0 === n && (n = []);
            if ("string" === typeof m) {
              var r = this.scene.sys.cache.shader;
              if (!r.has(m)) return console.warn("Shader missing: " + m), this;
              this.shader = r.get(m);
            } else this.shader = m;
            m = this.gl;
            r = this.renderer;
            this.program && m.deleteProgram(this.program);
            r = r.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);
            m.uniformMatrix4fv(
              m.getUniformLocation(r, "uViewMatrix"),
              !1,
              this.viewMatrix
            );
            m.uniformMatrix4fv(
              m.getUniformLocation(r, "uProjectionMatrix"),
              !1,
              this.projectionMatrix
            );
            m.uniform2f(
              m.getUniformLocation(r, "uResolution"),
              this.width,
              this.height
            );
            this.program = r;
            m = new Date();
            m = {
              resolution: {
                type: "2f",
                value: {
                  x: this.width,
                  y: this.height,
                },
              },
              time: {
                type: "1f",
                value: 0,
              },
              mouse: {
                type: "2f",
                value: {
                  x: this.width / 2,
                  y: this.height / 2,
                },
              },
              date: {
                type: "4fv",
                value: [
                  m.getFullYear(),
                  m.getMonth(),
                  m.getDate(),
                  3600 * m.getHours() + 60 * m.getMinutes() + m.getSeconds(),
                ],
              },
              sampleRate: {
                type: "1f",
                value: 44100,
              },
              iChannel0: {
                type: "sampler2D",
                value: null,
                textureData: {
                  repeat: !0,
                },
              },
              iChannel1: {
                type: "sampler2D",
                value: null,
                textureData: {
                  repeat: !0,
                },
              },
              iChannel2: {
                type: "sampler2D",
                value: null,
                textureData: {
                  repeat: !0,
                },
              },
              iChannel3: {
                type: "sampler2D",
                value: null,
                textureData: {
                  repeat: !0,
                },
              },
            };
            this.uniforms = this.shader.uniforms
              ? b(!0, {}, this.shader.uniforms, m)
              : m;
            for (m = 0; 4 > m; m++)
              n[m] && this.setSampler2D("iChannel" + m, n[m], m, q);
            this.initUniforms();
            this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0);
            return this;
          },
          setPointer: function (m) {
            this.pointer = m;
            return this;
          },
          projOrtho: function (m, n, q, r) {
            var u = 1 / (m - n),
              v = 1 / (q - r),
              x = this.projectionMatrix;
            x[0] = -2 * u;
            x[5] = -2 * v;
            x[10] = -0.001;
            x[12] = (m + n) * u;
            x[13] = (r + q) * v;
            x[14] = -0;
            m = this.program;
            r = this.gl;
            this.renderer.setProgram(m);
            r.uniformMatrix4fv(
              r.getUniformLocation(m, "uProjectionMatrix"),
              !1,
              this.projectionMatrix
            );
            this._rendererWidth = n;
            this._rendererHeight = q;
          },
          initUniforms: function () {
            var m = this.gl,
              n = this.renderer.glFuncMap,
              q = this.program;
            this._textureCount = 0;
            for (var r in this.uniforms) {
              var u = this.uniforms[r],
                v = u.type,
                x = n[v];
              u.uniformLocation = m.getUniformLocation(q, r);
              "sampler2D" !== v &&
                ((u.glMatrix = x.matrix),
                (u.glValueLength = x.length),
                (u.glFunc = x.func));
            }
          },
          setSampler2DBuffer: function (m, n, q, r, u, v) {
            void 0 === u && (u = 0);
            void 0 === v && (v = {});
            m = this.uniforms[m];
            m.value = n;
            v.width = q;
            v.height = r;
            m.textureData = v;
            this._textureCount = u;
            this.initSampler2D(m);
            return this;
          },
          setSampler2D: function (m, n, q, r) {
            void 0 === q && (q = 0);
            var u = this.scene.sys.textures;
            if (u.exists(n)) {
              u = u.getFrame(n);
              if (u.glTexture && u.glTexture.isRenderTexture)
                return this.setSampler2DBuffer(
                  m,
                  u.glTexture,
                  u.width,
                  u.height,
                  q,
                  r
                );
              m = this.uniforms[m];
              var v = u.source;
              m.textureKey = n;
              m.source = v.image;
              m.value = u.glTexture;
              v.isGLTexture &&
                (r || (r = {}), (r.width = v.width), (r.height = v.height));
              r && (m.textureData = r);
              this._textureCount = q;
              this.initSampler2D(m);
            }
            return this;
          },
          setUniform: function (m, n) {
            c(this.uniforms, m, n);
            return this;
          },
          getUniform: function (m) {
            return e(this.uniforms, m, null);
          },
          setChannel0: function (m, n) {
            return this.setSampler2D("iChannel0", m, 0, n);
          },
          setChannel1: function (m, n) {
            return this.setSampler2D("iChannel1", m, 1, n);
          },
          setChannel2: function (m, n) {
            return this.setSampler2D("iChannel2", m, 2, n);
          },
          setChannel3: function (m, n) {
            return this.setSampler2D("iChannel3", m, 3, n);
          },
          initSampler2D: function (m) {
            if (m.value) {
              var n = this.gl;
              n.activeTexture(n.TEXTURE0 + this._textureCount);
              n.bindTexture(n.TEXTURE_2D, m.value);
              var q = m.textureData;
              if (q && !m.value.isRenderTexture) {
                var r = n[e(q, "magFilter", "linear").toUpperCase()],
                  u = n[e(q, "minFilter", "linear").toUpperCase()],
                  v = n[e(q, "wrapS", "repeat").toUpperCase()],
                  x = n[e(q, "wrapT", "repeat").toUpperCase()],
                  y = n[e(q, "format", "rgba").toUpperCase()];
                q.repeat && (x = v = n.REPEAT);
                n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !!q.flipY);
                if (q.width) {
                  var z = e(q, "width", 512),
                    A = e(q, "height", 2);
                  q = e(q, "border", 0);
                  n.texImage2D(
                    n.TEXTURE_2D,
                    0,
                    y,
                    z,
                    A,
                    q,
                    y,
                    n.UNSIGNED_BYTE,
                    null
                  );
                } else
                  n.texImage2D(
                    n.TEXTURE_2D,
                    0,
                    y,
                    n.RGBA,
                    n.UNSIGNED_BYTE,
                    m.source
                  );
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, r);
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, u);
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, v);
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, x);
              }
              this.renderer.setProgram(this.program);
              n.uniform1i(m.uniformLocation, this._textureCount);
              this._textureCount++;
            }
          },
          syncUniforms: function () {
            var m = this.gl,
              n = this.uniforms,
              q = 0,
              r;
            for (r in n) {
              var u = n[r];
              var v = u.glFunc;
              var x = u.glValueLength;
              var y = u.uniformLocation;
              var z = u.value;
              null !== z &&
                (1 === x
                  ? u.glMatrix
                    ? v.call(m, y, u.transpose, z)
                    : v.call(m, y, z)
                  : 2 === x
                  ? v.call(m, y, z.x, z.y)
                  : 3 === x
                  ? v.call(m, y, z.x, z.y, z.z)
                  : 4 === x
                  ? v.call(m, y, z.x, z.y, z.z, z.w)
                  : "sampler2D" === u.type &&
                    (m.activeTexture(m.TEXTURE0 + q),
                    m.bindTexture(m.TEXTURE_2D, z),
                    m.uniform1i(y, q),
                    q++));
            }
          },
          load: function (m) {
            var n = this.gl,
              q = this.width,
              r = this.height,
              u = this.renderer,
              v = this.program,
              x = this.viewMatrix;
            if (!this.renderToTexture) {
              var y = -this._displayOriginX,
                z = -this._displayOriginY;
              x[0] = m[0];
              x[1] = m[1];
              x[4] = m[2];
              x[5] = m[3];
              x[8] = m[4];
              x[9] = m[5];
              x[12] = x[0] * y + x[4] * z;
              x[13] = x[1] * y + x[5] * z;
            }
            n.useProgram(v);
            n.uniformMatrix4fv(n.getUniformLocation(v, "uViewMatrix"), !1, x);
            n.uniform2f(
              n.getUniformLocation(v, "uResolution"),
              this.width,
              this.height
            );
            m = this.uniforms;
            n = m.resolution;
            n.value.x = q;
            n.value.y = r;
            m.time.value = u.game.loop.getDuration();
            if ((u = this.pointer))
              (m = m.mouse),
                (r = 1 - u.y / r),
                (m.value.x = (u.x / q).toFixed(2)),
                (m.value.y = r.toFixed(2));
            this.syncUniforms();
          },
          flush: function () {
            var m = this.width,
              n = this.height,
              q = this.program,
              r = this.gl,
              u = this.vertexBuffer,
              v = this.renderer,
              x = 2 * Float32Array.BYTES_PER_ELEMENT;
            this.renderToTexture &&
              (v.setFramebuffer(this.framebuffer),
              r.clearColor(0, 0, 0, 0),
              r.clear(r.COLOR_BUFFER_BIT));
            r.bindBuffer(r.ARRAY_BUFFER, u);
            q = r.getAttribLocation(q, "inPosition");
            -1 !== q &&
              (r.enableVertexAttribArray(q),
              r.vertexAttribPointer(q, 2, r.FLOAT, !1, x, 0));
            q = this.vertexViewF32;
            q[3] = n;
            q[4] = m;
            q[5] = n;
            q[8] = m;
            q[9] = n;
            q[10] = m;
            r.bufferSubData(r.ARRAY_BUFFER, 0, this.bytes.subarray(0, 6 * x));
            r.drawArrays(r.TRIANGLES, 0, 6);
            this.renderToTexture && v.setFramebuffer(null, !1);
          },
          setAlpha: function () {},
          setBlendMode: function () {},
          preDestroy: function () {
            var m = this.gl;
            m.deleteProgram(this.program);
            m.deleteBuffer(this.vertexBuffer);
            this.renderToTexture &&
              (this.renderer.deleteFramebuffer(this.framebuffer),
              this.texture.destroy(),
              (this.texture = this.glTexture = this.framebuffer = null));
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(11),
          k = a(36),
          e = a(116),
          b = a(15),
          c = a(479),
          f = a(480),
          g = a(19),
          m = a(69),
          n = a(1179),
          q = a(79),
          r = a(39),
          u = a(117);
        a = new t({
          Extends: b,
          Mixins: [
            d.AlphaSingle,
            d.BlendMode,
            d.Depth,
            d.Mask,
            d.Pipeline,
            d.Size,
            d.Texture,
            d.Transform,
            d.Visible,
            d.ScrollFactor,
            n,
          ],
          initialize: function (v, x, y, z, A, B, D, E, C, F, G, H) {
            void 0 === x && (x = 0);
            void 0 === y && (y = 0);
            void 0 === z && (z = "__WHITE");
            b.call(this, v, "Mesh");
            this.faces = [];
            this.vertices = [];
            this.tintFill = !1;
            this.debugGraphic = this.debugCallback = null;
            this.hideCCW = !0;
            this.modelPosition = new r();
            this.modelScale = new r(1, 1, 1);
            this.modelRotation = new r();
            this.dirtyCache = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            this.transformMatrix = new m();
            this.viewPosition = new r();
            this.viewMatrix = new m();
            this.projectionMatrix = new m();
            this.totalFrame = this.totalRendered = 0;
            this.ignoreDirtyCache = !1;
            v = v.sys.renderer;
            this.setPosition(x, y);
            this.setTexture(z, A);
            this.setSize(v.width, v.height);
            this.initPipeline();
            this.setPerspective(v.width, v.height);
            B && this.addVertices(B, D, E, C, F, G, H);
          },
          addedToScene: function () {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function () {
            this.scene.sys.updateList.remove(this);
          },
          panX: function (v) {
            this.viewPosition.addScale(r.LEFT, v);
            this.dirtyCache[10] = 1;
            return this;
          },
          panY: function (v) {
            this.viewPosition.y += r.DOWN.y * v;
            this.dirtyCache[10] = 1;
            return this;
          },
          panZ: function (v) {
            this.viewPosition.z += v;
            this.dirtyCache[10] = 1;
            return this;
          },
          setPerspective: function (v, x, y, z, A) {
            void 0 === y && (y = 45);
            void 0 === z && (z = 0.01);
            void 0 === A && (A = 1e3);
            this.projectionMatrix.perspective(k(y), v / x, z, A);
            this.dirtyCache[10] = 1;
            this.dirtyCache[11] = 0;
            return this;
          },
          setOrtho: function (v, x, y, z) {
            void 0 === v && (v = this.scene.sys.renderer.getAspectRatio());
            void 0 === x && (x = 1);
            void 0 === y && (y = -1e3);
            void 0 === z && (z = 1e3);
            this.projectionMatrix.ortho(-v, v, -x, x, y, z);
            this.dirtyCache[10] = 1;
            this.dirtyCache[11] = 1;
            return this;
          },
          clear: function () {
            this.faces.forEach(function (v) {
              v.destroy();
            });
            this.faces = [];
            this.vertices = [];
            return this;
          },
          addVerticesFromObj: function (v, x, y, z, A, B, D, E, C) {
            (v = this.scene.sys.cache.obj.get(v)) &&
              f(v, this, x, y, z, A, B, D, E, C);
            return this;
          },
          sortByDepth: function (v, x) {
            return v.depth - x.depth;
          },
          depthSort: function () {
            q(this.faces, this.sortByDepth);
            return this;
          },
          addVertex: function (v, x, y, z, A, B, D) {
            v = new u(v, x, y, z, A, B, D);
            this.vertices.push(v);
            return v;
          },
          addFace: function (v, x, y) {
            v = new e(v, x, y);
            this.faces.push(v);
            this.dirtyCache[9] = -1;
            return v;
          },
          addVertices: function (v, x, y, z, A, B, D) {
            if ((v = c(v, x, y, z, A, B, D)))
              (this.faces = this.faces.concat(v.faces)),
                (this.vertices = this.vertices.concat(v.vertices));
            this.dirtyCache[9] = -1;
            return this;
          },
          getFaceCount: function () {
            return this.faces.length;
          },
          getVertexCount: function () {
            return this.vertices.length;
          },
          getFace: function (v) {
            return this.faces[v];
          },
          getFaceAt: function (v, x, y) {
            void 0 === y && (y = this.scene.sys.cameras.main);
            y = g(this, y).calc;
            for (var z = this.faces, A = [], B = 0; B < z.length; B++) {
              var D = z[B];
              D.contains(v, x, y) && A.push(D);
            }
            return q(A, this.sortByDepth);
          },
          setDebug: function (v, x) {
            this.debugCallback =
              (this.debugGraphic = v) || x ? (x ? x : this.renderDebug) : null;
            return this;
          },
          isDirty: function () {
            var v = this.modelPosition,
              x = this.modelRotation,
              y = this.modelScale,
              z = this.dirtyCache,
              A = v.x,
              B = v.y;
            v = v.z;
            var D = x.x,
              E = x.y;
            x = x.z;
            var C = y.x,
              F = y.y;
            y = y.z;
            var G = this.getFaceCount(),
              H = z[0],
              K = z[1],
              I = z[2],
              M = z[3],
              N = z[4],
              P = z[5],
              J = z[6],
              L = z[7],
              O = z[8],
              Q = z[9];
            z[0] = A;
            z[1] = B;
            z[2] = v;
            z[3] = D;
            z[4] = E;
            z[5] = x;
            z[6] = C;
            z[7] = F;
            z[8] = y;
            z[9] = G;
            return (
              H !== A ||
              K !== B ||
              I !== v ||
              M !== D ||
              N !== E ||
              P !== x ||
              J !== C ||
              L !== F ||
              O !== y ||
              Q !== G
            );
          },
          preUpdate: function () {
            this.totalRendered = this.totalFrame;
            this.totalFrame = 0;
            var v = this.dirtyCache;
            if (this.ignoreDirtyCache || v[10] || this.isDirty()) {
              var x = this.width,
                y = this.height,
                z = this.viewMatrix,
                A = this.viewPosition;
              v[10] && (z.identity(), z.translate(A), z.invert(), (v[10] = 0));
              v = this.transformMatrix;
              v.setWorldMatrix(
                this.modelRotation,
                this.modelPosition,
                this.modelScale,
                this.viewMatrix,
                this.projectionMatrix
              );
              A = A.z;
              z = this.faces;
              for (var B = 0; B < z.length; B++)
                z[B].transformCoordinatesLocal(v, x, y, A);
              this.depthSort();
            }
          },
          renderDebug: function (v, x) {
            v = v.debugGraphic;
            for (var y = 0; y < x.length; y++) {
              var z = x[y];
              v.strokeTriangle(
                z.vertex1.tx,
                z.vertex1.ty,
                z.vertex2.tx,
                z.vertex2.ty,
                z.vertex3.tx,
                z.vertex3.ty
              );
            }
          },
          preDestroy: function () {
            this.clear();
            this.debugGraphic = this.debugCallback = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(50);
        h.exports = function (k, e) {
          return d(k.x, k.y, e.x, e.y) <= k.radius + e.radius;
        };
      },
      function (h, t, a) {
        var d = a(4),
          k = a(233);
        h.exports = function (e, b, c) {
          void 0 === c && (c = []);
          if (k(e, b)) {
            var f = e.x1,
              g = e.y1,
              m = b.radius,
              n = e.x2 - f;
            e = e.y2 - g;
            var q = f - b.x,
              r = g - b.y;
            b = n * n + e * e;
            var u = 2 * (n * q + e * r);
            m = u * u - 4 * b * (q * q + r * r - m * m);
            0 === m
              ? ((m = -u / (2 * b)),
                0 <= m && 1 >= m && c.push(new d(f + m * n, g + m * e)))
              : 0 < m &&
                ((q = (-u - Math.sqrt(m)) / (2 * b)),
                0 <= q && 1 >= q && c.push(new d(f + q * n, g + q * e)),
                (m = (-u + Math.sqrt(m)) / (2 * b)),
                0 <= m && 1 >= m && c.push(new d(f + m * n, g + m * e)));
          }
          return c;
        };
      },
      function (h, t, a) {
        var d = a(66),
          k = new (a(4))();
        h.exports = function (e, b, c) {
          void 0 === c && (c = k);
          if (d(b, e.x1, e.y1)) return (c.x = e.x1), (c.y = e.y1), !0;
          if (d(b, e.x2, e.y2)) return (c.x = e.x2), (c.y = e.y2), !0;
          var f = e.x2 - e.x1,
            g = e.y2 - e.y1,
            m = b.x - e.x1,
            n = b.y - e.y1,
            q = f * f + g * g,
            r = f,
            u = g;
          0 < q && ((m = (m * f + n * g) / q), (r *= m), (u *= m));
          c.x = e.x1 + r;
          c.y = e.y1 + u;
          return r * r + u * u <= q && 0 <= r * f + u * g && d(b, c.x, c.y);
        };
      },
      function (h, t, a) {
        var d = a(4),
          k = a(96),
          e = a(488);
        h.exports = function (b, c, f) {
          void 0 === f && (f = []);
          if (e(b, c)) {
            var g = c.getLineA(),
              m = c.getLineB(),
              n = c.getLineC(),
              q = c.getLineD();
            c = [new d(), new d(), new d(), new d()];
            b = [k(g, b, c[0]), k(m, b, c[1]), k(n, b, c[2]), k(q, b, c[3])];
            for (g = 0; 4 > g; g++) b[g] && f.push(c[g]);
          }
          return f;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          void 0 === k && (k = !1);
          void 0 === e && (e = []);
          var b = a.x3 - a.x1,
            c = a.y3 - a.y1,
            f = a.x2 - a.x1,
            g = a.y2 - a.y1,
            m = b * b + c * c,
            n = b * f + c * g,
            q = f * f + g * g,
            r = m * q - n * n;
          r = 0 === r ? 0 : 1 / r;
          var u = a.x1;
          a = a.y1;
          for (var v = 0; v < d.length; v++) {
            var x = d[v].x - u;
            var y = d[v].y - a;
            var z = b * x + c * y;
            y = f * x + g * y;
            x = (q * z - n * y) * r;
            z = (m * y - n * z) * r;
            if (
              0 <= x &&
              0 <= z &&
              1 > x + z &&
              (e.push({
                x: d[v].x,
                y: d[v].y,
              }),
              k)
            )
              break;
          }
          return e;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          var b = Math.cos(e);
          e = Math.sin(e);
          var c = a.x1 - d,
            f = a.y1 - k;
          a.x1 = c * b - f * e + d;
          a.y1 = c * e + f * b + k;
          c = a.x2 - d;
          f = a.y2 - k;
          a.x2 = c * b - f * e + d;
          a.y2 = c * e + f * b + k;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 0 === a.height ? NaN : a.width / a.height;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          var b = Math.cos(e);
          e = Math.sin(e);
          var c = a.x1 - d,
            f = a.y1 - k;
          a.x1 = c * b - f * e + d;
          a.y1 = c * e + f * b + k;
          c = a.x2 - d;
          f = a.y2 - k;
          a.x2 = c * b - f * e + d;
          a.y2 = c * e + f * b + k;
          c = a.x3 - d;
          f = a.y3 - k;
          a.x3 = c * b - f * e + d;
          a.y3 = c * e + f * b + k;
          return a;
        };
      },
      function (h, t, a) {
        h.exports = {
          BUTTON_DOWN: a(1310),
          BUTTON_UP: a(1311),
          CONNECTED: a(1312),
          DISCONNECTED: a(1313),
          GAMEPAD_BUTTON_DOWN: a(1314),
          GAMEPAD_BUTTON_UP: a(1315),
        };
      },
      function (h, t, a) {
        var d = a(17),
          k = a(156);
        h.exports = function (e, b) {
          e = void 0 === e ? k() : d({}, e);
          if (b) for (var c in b) void 0 !== b[c] && (e[c] = b[c]);
          return e;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(7),
          f = a(408),
          g = new t({
            Extends: k,
            initialize: function (m, n, q, r) {
              var u = "xml";
              if (c(n)) {
                var v = n;
                n = b(v, "key");
                q = b(v, "url");
                r = b(v, "xhrSettings");
                u = b(v, "extension", u);
              }
              k.call(this, m, {
                type: "xml",
                cache: m.cacheManager.xml,
                extension: u,
                responseType: "text",
                key: n,
                url: q,
                xhrSettings: r,
              });
            },
            onProcess: function () {
              this.state = d.FILE_PROCESSING;
              if ((this.data = f(this.xhrLoader.responseText)))
                this.onProcessComplete();
              else
                console.warn("Invalid XMLFile: " + this.key),
                  this.onProcessError();
            },
          });
        e.register("xml", function (m, n, q) {
          if (Array.isArray(m))
            for (n = 0; n < m.length; n++) this.addFile(new g(this, m[n]));
          else this.addFile(new g(this, m, n, q));
          return this;
        });
        h.exports = g;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(7),
          f = new t({
            Extends: k,
            initialize: function (g, m, n, q) {
              var r = "text",
                u = "txt",
                v = g.cacheManager.text;
              if (c(m)) {
                var x = m;
                m = b(x, "key");
                n = b(x, "url");
                q = b(x, "xhrSettings");
                u = b(x, "extension", u);
                r = b(x, "type", r);
                v = b(x, "cache", v);
              }
              k.call(this, g, {
                type: r,
                cache: v,
                extension: u,
                responseType: "text",
                key: m,
                url: n,
                xhrSettings: q,
              });
            },
            onProcess: function () {
              this.state = d.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            },
          });
        e.register("text", function (g, m, n) {
          if (Array.isArray(g))
            for (m = 0; m < g.length; m++) this.addFile(new f(this, g[m]));
          else this.addFile(new f(this, g, m, n));
          return this;
        });
        h.exports = f;
      },
      function (h, t, a) {
        h.exports = {
          Acceleration: a(1368),
          Angular: a(1369),
          Bounce: a(1370),
          Debug: a(1371),
          Drag: a(1372),
          Enable: a(1373),
          Friction: a(1374),
          Gravity: a(1375),
          Immovable: a(1376),
          Mass: a(1377),
          OverlapCirc: a(523),
          OverlapRect: a(244),
          Pushable: a(1378),
          Size: a(1379),
          Velocity: a(1380),
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b, c, f) {
          void 0 === c && (c = !0);
          void 0 === f && (f = !1);
          var g = [],
            m = [],
            n = a.treeMinMax;
          n.minX = d;
          n.minY = k;
          n.maxX = d + e;
          n.maxY = k + b;
          f && (m = a.staticTree.search(n));
          if (c && a.useTree) g = a.tree.search(n);
          else if (c) {
            var q = {
                position: {
                  x: d,
                  y: k,
                },
                left: d,
                top: k,
                right: d + e,
                bottom: k + b,
                isCircle: !1,
              },
              r = a.intersects;
            a.bodies.iterate(function (u) {
              r(u, q) && g.push(u);
            });
          }
          return m.concat(g);
        };
      },
      function (h, t, a) {
        h.exports = {
          COLLIDE: a(1381),
          OVERLAP: a(1382),
          PAUSE: a(1383),
          RESUME: a(1384),
          TILE_COLLIDE: a(1385),
          TILE_OVERLAP: a(1386),
          WORLD_BOUNDS: a(1387),
          WORLD_STEP: a(1388),
        };
      },
      function (h, t, a) {
        var d = a(62);
        h.exports = function (k, e, b, c) {
          var f = 0;
          c = k.deltaAbsX() + e.deltaAbsX() + c;
          0 === k._dx && 0 === e._dx
            ? ((k.embedded = !0), (e.embedded = !0))
            : k._dx > e._dx
            ? ((f = k.right - e.x),
              (f > c && !b) ||
              !1 === k.checkCollision.right ||
              !1 === e.checkCollision.left
                ? (f = 0)
                : ((k.touching.none = !1),
                  (k.touching.right = !0),
                  (e.touching.none = !1),
                  (e.touching.left = !0),
                  e.physicsType !== d.STATIC_BODY ||
                    b ||
                    ((k.blocked.none = !1), (k.blocked.right = !0)),
                  k.physicsType !== d.STATIC_BODY ||
                    b ||
                    ((e.blocked.none = !1), (e.blocked.left = !0))))
            : k._dx < e._dx &&
              ((f = k.x - e.width - e.x),
              (-f > c && !b) ||
              !1 === k.checkCollision.left ||
              !1 === e.checkCollision.right
                ? (f = 0)
                : ((k.touching.none = !1),
                  (k.touching.left = !0),
                  (e.touching.none = !1),
                  (e.touching.right = !0),
                  e.physicsType !== d.STATIC_BODY ||
                    b ||
                    ((k.blocked.none = !1), (k.blocked.left = !0)),
                  k.physicsType !== d.STATIC_BODY ||
                    b ||
                    ((e.blocked.none = !1), (e.blocked.right = !0))));
          k.overlapX = f;
          return (e.overlapX = f);
        };
      },
      function (h, t, a) {
        var d = a(62);
        h.exports = function (k, e, b, c) {
          var f = 0;
          c = k.deltaAbsY() + e.deltaAbsY() + c;
          0 === k._dy && 0 === e._dy
            ? ((k.embedded = !0), (e.embedded = !0))
            : k._dy > e._dy
            ? ((f = k.bottom - e.y),
              (f > c && !b) ||
              !1 === k.checkCollision.down ||
              !1 === e.checkCollision.up
                ? (f = 0)
                : ((k.touching.none = !1),
                  (k.touching.down = !0),
                  (e.touching.none = !1),
                  (e.touching.up = !0),
                  e.physicsType !== d.STATIC_BODY ||
                    b ||
                    ((k.blocked.none = !1), (k.blocked.down = !0)),
                  k.physicsType !== d.STATIC_BODY ||
                    b ||
                    ((e.blocked.none = !1), (e.blocked.up = !0))))
            : k._dy < e._dy &&
              ((f = k.y - e.bottom),
              (-f > c && !b) ||
              !1 === k.checkCollision.up ||
              !1 === e.checkCollision.down
                ? (f = 0)
                : ((k.touching.none = !1),
                  (k.touching.up = !0),
                  (e.touching.none = !1),
                  (e.touching.down = !0),
                  e.physicsType !== d.STATIC_BODY ||
                    b ||
                    ((k.blocked.none = !1), (k.blocked.up = !0)),
                  k.physicsType !== d.STATIC_BODY ||
                    b ||
                    ((e.blocked.none = !1), (e.blocked.down = !0))));
          k.overlapY = f;
          return (e.overlapY = f);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return !(
            d.right <= a.left ||
            d.bottom <= a.top ||
            d.position.x >= a.right ||
            d.position.y >= a.bottom
          );
        };
      },
      function (h, t, a) {
        h.exports = {
          Bounce: a(1495),
          Collision: a(1496),
          Force: a(1497),
          Friction: a(1498),
          Gravity: a(1499),
          Mass: a(1500),
          Sensor: a(1501),
          SetBody: a(1502),
          Sleep: a(1503),
          Static: a(1520),
          Transform: a(1521),
          Velocity: a(1522),
        };
      },
      function (h, t) {
        var a = {};
        h.exports = a;
        (function () {
          a.create = function (d, k) {
            var e = d.bodyA,
              b = d.bodyB;
            e = {
              id: a.id(e, b),
              bodyA: e,
              bodyB: b,
              activeContacts: [],
              separation: 0,
              isActive: !0,
              confirmedActive: !0,
              isSensor: e.isSensor || b.isSensor,
              timeCreated: k,
              timeUpdated: k,
              collision: null,
              inverseMass: 0,
              friction: 0,
              frictionStatic: 0,
              restitution: 0,
              slop: 0,
            };
            a.update(e, d, k);
            return e;
          };
          a.update = function (d, k, e) {
            d.collision = k;
            if (k.collided) {
              var b = k.supports,
                c = d.activeContacts,
                f = k.parentA,
                g = k.parentB;
              d.inverseMass = f.inverseMass + g.inverseMass;
              d.friction = Math.min(f.friction, g.friction);
              d.frictionStatic = Math.max(f.frictionStatic, g.frictionStatic);
              d.restitution = Math.max(f.restitution, g.restitution);
              d.slop = Math.max(f.slop, g.slop);
              for (f = 0; f < b.length; f++) c[f] = b[f].contact;
              b = b.length;
              b < c.length && (c.length = b);
              d.separation = k.depth;
              a.setActive(d, !0, e);
            } else !0 === d.isActive && a.setActive(d, !1, e);
          };
          a.setActive = function (d, k, e) {
            k
              ? ((d.isActive = !0), (d.timeUpdated = e))
              : ((d.isActive = !1), (d.activeContacts.length = 0));
          };
          a.id = function (d, k) {
            return d.id < k.id
              ? "A" + d.id + "B" + k.id
              : "A" + k.id + "B" + d.id;
          };
        })();
      },
      function (h, t, a) {
        h.exports = {
          CalculateFacesAt: a(252),
          CalculateFacesWithin: a(63),
          CheckIsoBounds: a(541),
          Copy: a(1420),
          CreateFromTiles: a(1421),
          CullBounds: a(543),
          CullTiles: a(544),
          Fill: a(1422),
          FilterTiles: a(1423),
          FindByIndex: a(1424),
          FindTile: a(1425),
          ForEachTile: a(1426),
          GetCullTilesFunction: a(1427),
          GetTileAt: a(158),
          GetTileAtWorldXY: a(1428),
          GetTilesWithin: a(26),
          GetTilesWithinShape: a(1429),
          GetTilesWithinWorldXY: a(529),
          GetTileToWorldXFunction: a(1430),
          GetTileToWorldXYFunction: a(1431),
          GetTileToWorldYFunction: a(1432),
          GetWorldToTileXFunction: a(1433),
          GetWorldToTileXYFunction: a(1434),
          GetWorldToTileYFunction: a(1435),
          HasTileAt: a(562),
          HasTileAtWorldXY: a(1436),
          HexagonalCullBounds: a(546),
          HexagonalCullTiles: a(545),
          HexagonalTileToWorldXY: a(550),
          HexagonalTileToWorldY: a(554),
          HexagonalWorldToTileXY: a(556),
          HexagonalWorldToTileY: a(560),
          IsInLayerBounds: a(119),
          IsometricCullTiles: a(547),
          IsometricTileToWorldXY: a(551),
          IsometricWorldToTileXY: a(557),
          PutTileAt: a(257),
          PutTileAtWorldXY: a(1437),
          PutTilesAt: a(1438),
          Randomize: a(1439),
          RemoveTileAt: a(563),
          RemoveTileAtWorldXY: a(1440),
          RenderDebug: a(1441),
          ReplaceByIndex: a(542),
          RunCull: a(159),
          SetCollision: a(1442),
          SetCollisionBetween: a(1443),
          SetCollisionByExclusion: a(1444),
          SetCollisionByProperty: a(1445),
          SetCollisionFromCollisionGroup: a(1446),
          SetLayerCollisionIndex: a(160),
          SetTileCollision: a(72),
          SetTileIndexCallback: a(1447),
          SetTileLocationCallback: a(1448),
          Shuffle: a(1449),
          StaggeredCullBounds: a(549),
          StaggeredCullTiles: a(548),
          StaggeredTileToWorldXY: a(552),
          StaggeredTileToWorldY: a(555),
          StaggeredWorldToTileXY: a(558),
          StaggeredWorldToTileY: a(561),
          SwapByIndex: a(1450),
          TileToWorldX: a(253),
          TileToWorldXY: a(553),
          TileToWorldY: a(254),
          WeightedRandomize: a(1451),
          WorldToTileX: a(255),
          WorldToTileXY: a(559),
          WorldToTileY: a(256),
        };
      },
      function (h, t, a) {
        var d = a(158);
        h.exports = function (k, e, b) {
          var c = d(k, e, !0, b),
            f = d(k, e - 1, !0, b),
            g = d(k, e + 1, !0, b),
            m = d(k - 1, e, !0, b);
          k = d(k + 1, e, !0, b);
          if ((e = c && c.collides))
            (c.faceTop = !0),
              (c.faceBottom = !0),
              (c.faceLeft = !0),
              (c.faceRight = !0);
          f && f.collides && (e && (c.faceTop = !1), (f.faceBottom = !e));
          g && g.collides && (e && (c.faceBottom = !1), (g.faceTop = !e));
          m && m.collides && (e && (c.faceLeft = !1), (m.faceRight = !e));
          k && k.collides && (e && (c.faceRight = !1), (k.faceLeft = !e));
          c && !c.collides && c.resetFaces();
          return c;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          var e = k.baseTileWidth;
          k = k.tilemapLayer;
          var b = 0;
          k &&
            (d || (d = k.scene.cameras.main),
            (b = k.x + d.scrollX * (1 - k.scrollFactorX)),
            (e *= k.scaleX));
          return b + a * e;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          var e = k.baseTileHeight;
          k = k.tilemapLayer;
          var b = 0;
          k &&
            (d || (d = k.scene.cameras.main),
            (b = k.y + d.scrollY * (1 - k.scrollFactorY)),
            (e *= k.scaleY));
          return b + a * e;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          void 0 === d && (d = !0);
          var b = e.baseTileWidth;
          if ((e = e.tilemapLayer))
            k || (k = e.scene.cameras.main),
              (a -= e.x + k.scrollX * (1 - e.scrollFactorX)),
              (b *= e.scaleX);
          return d ? Math.floor(a / b) : a / b;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          void 0 === d && (d = !0);
          var b = e.baseTileHeight;
          if ((e = e.tilemapLayer))
            k || (k = e.scene.cameras.main),
              (a -= e.y + k.scrollY * (1 - e.scrollFactorY)),
              (b *= e.scaleY);
          return d ? Math.floor(a / b) : a / b;
        };
      },
      function (h, t, a) {
        var d = a(85),
          k = a(119),
          e = a(252),
          b = a(72);
        h.exports = function (c, f, g, m, n) {
          void 0 === m && (m = !0);
          if (!k(f, g, n)) return null;
          var q = n.data[g][f];
          q = q && q.collides;
          c instanceof d
            ? (null === n.data[g][f] &&
                (n.data[g][f] = new d(
                  n,
                  c.index,
                  f,
                  g,
                  n.tileWidth,
                  n.tileHeight
                )),
              n.data[g][f].copy(c))
            : null === n.data[g][f]
            ? (n.data[g][f] = new d(n, c, f, g, n.tileWidth, n.tileHeight))
            : (n.data[g][f].index = c);
          c = n.data[g][f];
          var r = -1 !== n.collideIndexes.indexOf(c.index);
          b(c, r);
          m && q !== c.collides && e(f, g, n);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(29);
        h.exports = function (k) {
          k = k.toLowerCase();
          return "isometric" === k
            ? d.ISOMETRIC
            : "staggered" === k
            ? d.STAGGERED
            : "hexagonal" === k
            ? d.HEXAGONAL
            : d.ORTHOGONAL;
        };
      },
      function (h, t, a) {
        var d = a(40),
          k = a(120),
          e = a(121),
          b = a(85);
        h.exports = function (c, f, g, m, n) {
          var q = new k({
            tileWidth: g,
            tileHeight: m,
          });
          c = new e({
            name: c,
            tileWidth: g,
            tileHeight: m,
            format: d.ARRAY_2D,
            layers: [q],
          });
          for (var r = [], u = f.length, v = 0, x = 0; x < f.length; x++) {
            r[x] = [];
            for (var y = f[x], z = 0; z < y.length; z++) {
              var A = parseInt(y[z], 10);
              isNaN(A) || -1 === A
                ? (r[x][z] = n ? null : new b(q, -1, z, x, g, m))
                : (r[x][z] = new b(q, A, z, x, g, m));
            }
            0 === v && (v = y.length);
          }
          c.width = q.width = v;
          c.height = q.height = u;
          c.widthInPixels = q.widthInPixels = v * g;
          c.heightInPixels = q.heightInPixels = u * m;
          q.data = r;
          return c;
        };
      },
      function (h, t, a) {
        var d = a(571),
          k = a(261),
          e = function (c) {
            return {
              x: c.x,
              y: c.y,
            };
          },
          b = "id name type rotation properties visible x y width height".split(
            " "
          );
        h.exports = function (c, f, g) {
          void 0 === f && (f = 0);
          void 0 === g && (g = 0);
          var m = d(c, b);
          m.x += f;
          m.y += g;
          c.gid
            ? ((c = k(c.gid)),
              (m.gid = c.gid),
              (m.flippedHorizontal = c.flippedHorizontal),
              (m.flippedVertical = c.flippedVertical),
              (m.flippedAntiDiagonal = c.flippedAntiDiagonal))
            : c.polyline
            ? (m.polyline = c.polyline.map(e))
            : c.polygon
            ? (m.polygon = c.polygon.map(e))
            : c.ellipse
            ? (m.ellipse = c.ellipse)
            : c.text
            ? (m.text = c.text)
            : c.point
            ? (m.point = !0)
            : (m.rectangle = !0);
          return m;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          var d = !!(a & 2147483648),
            k = !!(a & 1073741824),
            e = !!(a & 536870912),
            b = 0,
            c = !1;
          d && k && e
            ? ((b = Math.PI / 2), (c = !0))
            : d && k && !e
            ? ((b = Math.PI), (c = !1))
            : d && !k && e
            ? ((b = Math.PI / 2), (c = !1))
            : !d || k || e
            ? !d && k && e
              ? ((b = (3 * Math.PI) / 2), (c = !1))
              : d || !k || e
              ? d || k || !e
                ? d || k || e || ((b = 0), (c = !1))
                : ((b = (3 * Math.PI) / 2), (c = !0))
              : ((b = Math.PI), (c = !0))
            : ((b = 0), (c = !0));
          return {
            gid: a & 536870911,
            flippedHorizontal: d,
            flippedVertical: k,
            flippedAntiDiagonal: e,
            rotation: b,
            flipped: c,
          };
        };
      },
      function (h, t, a) {
        var d = a(40),
          k = a(121),
          e = a(564),
          b = a(580);
        h.exports = function (c, f, g, m, n, q, r, u) {
          void 0 === g && (g = 32);
          void 0 === m && (m = 32);
          void 0 === n && (n = 10);
          void 0 === q && (q = 10);
          void 0 === u && (u = !1);
          var v = null;
          Array.isArray(r)
            ? (v = e(void 0 !== f ? f : "map", d.ARRAY_2D, r, g, m, u))
            : void 0 !== f &&
              ((r = c.cache.tilemap.get(f))
                ? (v = e(f, r.format, r.data, g, m, u))
                : console.warn("No map data found for key " + f));
          null === v &&
            (v = new k({
              tileWidth: g,
              tileHeight: m,
              width: n,
              height: q,
            }));
          return new b(c, v);
        };
      },
      function (h, t, a) {
        var d = a(6);
        h.exports = function (k) {
          k = d(k, "targets", null);
          if (null === k) return k;
          "function" === typeof k && (k = k.call());
          Array.isArray(k) || (k = [k]);
          return k;
        };
      },
      function (h, t) {
        var a = function (d, k) {
          var e = function (r, u, v) {
              return v;
            },
            b = function (r, u, v) {
              return v;
            },
            c = null,
            f = typeof k;
          if ("number" === f)
            e = function () {
              return k;
            };
          else if ("string" === f) {
            e = k[0];
            var g = parseFloat(k.substr(2));
            switch (e) {
              case "+":
                e = function (r, u, v) {
                  return v + g;
                };
                break;
              case "-":
                e = function (r, u, v) {
                  return v - g;
                };
                break;
              case "*":
                e = function (r, u, v) {
                  return v * g;
                };
                break;
              case "/":
                e = function (r, u, v) {
                  return v / g;
                };
                break;
              default:
                e = function () {
                  return parseFloat(k);
                };
            }
          } else if ("function" === f) e = k;
          else if ("object" === f)
            if (
              (k.getStart && "function" === typeof k.getStart) ||
              (k.getEnd && "function" === typeof k.getEnd) ||
              (k.getActive && "function" === typeof k.getActive)
            )
              k.getActive &&
                "function" === typeof k.getActive &&
                (c = k.getActive),
                k.getEnd && "function" === typeof k.getEnd && (e = k.getEnd),
                k.getStart &&
                  "function" === typeof k.getStart &&
                  (b = k.getStart);
            else if (k.hasOwnProperty("value")) var m = a(d, k.value);
            else {
              var n = k.hasOwnProperty("to");
              f = k.hasOwnProperty("from");
              var q = k.hasOwnProperty("start");
              n &&
                (f || q) &&
                ((m = a(d, k.to)),
                q && ((n = a(d, k.start)), (m.getActive = n.getEnd)),
                f && ((d = a(d, k.from)), (m.getStart = d.getEnd)));
            }
          m ||
            (m = {
              getActive: c,
              getEnd: e,
              getStart: b,
            });
          return m;
        };
        h.exports = a;
      },
      function (h, t) {
        h.exports = {
          targets: null,
          delay: 0,
          duration: 1e3,
          ease: "Power0",
          easeParams: null,
          hold: 0,
          repeat: 0,
          repeatDelay: 0,
          yoyo: !1,
          flipX: !1,
          flipY: !1,
        };
      },
      function (h, t, a) {
        var d = a(0),
          k = a(9),
          e = a(267);
        t = a(16);
        var b = a(5),
          c = a(100),
          f = a(14);
        a = new d({
          Extends: k,
          initialize: function (g, m, n) {
            k.call(this);
            this.parent = g;
            this.parentIsTimeline = g.hasOwnProperty("isTimeline");
            this.data = m;
            this.totalData = m.length;
            this.targets = n;
            this.totalTargets = n.length;
            this.useFrames = !1;
            this.timeScale = 1;
            this.startDelay = this.loopCounter = this.loopDelay = this.loop = 0;
            this.isSeeking = this.hasStarted = !1;
            this.calculatedOffset =
              this.offset =
              this.countdown =
              this.completeDelay =
                0;
            this.state = c.PENDING_ADD;
            this._pausedState = c.INIT;
            this.paused = !1;
            this.totalProgress =
              this.totalDuration =
              this.progress =
              this.duration =
              this.totalElapsed =
              this.elapsed =
                0;
            this.callbacks = {
              onActive: null,
              onComplete: null,
              onLoop: null,
              onRepeat: null,
              onStart: null,
              onStop: null,
              onUpdate: null,
              onYoyo: null,
            };
            this.callbackScope;
          },
          getValue: function (g) {
            void 0 === g && (g = 0);
            return this.data[g].current;
          },
          setTimeScale: function (g) {
            this.timeScale = g;
            return this;
          },
          getTimeScale: function () {
            return this.timeScale;
          },
          isPlaying: function () {
            return this.state === c.ACTIVE;
          },
          isPaused: function () {
            return this.state === c.PAUSED;
          },
          hasTarget: function (g) {
            return -1 !== this.targets.indexOf(g);
          },
          updateTo: function (g, m, n) {
            void 0 === n && (n = !1);
            for (var q = 0; q < this.totalData; q++) {
              var r = this.data[q];
              r.key === g && ((r.end = m), n && (r.start = r.current));
            }
            return this;
          },
          restart: function () {
            this.totalProgress =
              this.totalElapsed =
              this.progress =
              this.elapsed =
                0;
            return this.state === c.ACTIVE
              ? this.seek(0)
              : this.state === c.REMOVED
              ? (this.seek(0), this.parent.makeActive(this), this)
              : this.state === c.PENDING_ADD
              ? this
              : this.play();
          },
          calcDuration: function () {
            for (
              var g = 0, m = f.MAX_SAFE_INTEGER, n = this.data, q = 0;
              q < this.totalData;
              q++
            ) {
              var r = n[q];
              r.t1 = r.duration + r.hold;
              r.yoyo && (r.t1 += r.duration);
              r.t2 = r.t1 + r.repeatDelay;
              r.totalDuration = r.delay + r.t1;
              -1 === r.repeat
                ? (r.totalDuration += 999999999999 * r.t2)
                : 0 < r.repeat && (r.totalDuration += r.t2 * r.repeat);
              r.totalDuration > g && (g = r.totalDuration);
              r.delay < m && (m = r.delay);
            }
            this.duration = Math.max(g, 0.001);
            this.loopCounter = -1 === this.loop ? 999999999999 : this.loop;
            this.totalDuration =
              0 < this.loopCounter
                ? this.duration +
                  this.completeDelay +
                  (this.duration + this.loopDelay) * this.loopCounter
                : this.duration + this.completeDelay;
            this.startDelay = m;
          },
          init: function () {
            if (this.paused && !this.parentIsTimeline)
              return (
                (this.state = c.PENDING_ADD), (this._pausedState = c.INIT), !1
              );
            for (
              var g = this.data, m = this.totalTargets, n = 0;
              n < this.totalData;
              n++
            ) {
              var q = g[n],
                r = q.target,
                u = q.gen,
                v = q.key,
                x = q.index;
              q.delay = u.delay(r, v, 0, x, m, this);
              q.duration = Math.max(u.duration(r, v, 0, x, m, this), 0.001);
              q.hold = u.hold(r, v, 0, x, m, this);
              q.repeat = u.repeat(r, v, 0, x, m, this);
              q.repeatDelay = u.repeatDelay(r, v, 0, x, m, this);
            }
            this.calcDuration();
            this.totalElapsed =
              this.elapsed =
              this.totalProgress =
              this.progress =
                0;
            this.state = c.INIT;
            return !0;
          },
          makeActive: function () {
            this.parent.makeActive(this);
            this.dispatchTweenEvent(e.TWEEN_ACTIVE, this.callbacks.onActive);
          },
          nextState: function () {
            0 < this.loopCounter
              ? ((this.progress = this.elapsed = 0),
                this.loopCounter--,
                this.resetTweenData(!0),
                0 < this.loopDelay
                  ? ((this.countdown = this.loopDelay),
                    (this.state = c.LOOP_DELAY))
                  : ((this.state = c.ACTIVE),
                    this.dispatchTweenEvent(
                      e.TWEEN_LOOP,
                      this.callbacks.onLoop
                    )))
              : 0 < this.completeDelay
              ? ((this.state = c.COMPLETE_DELAY),
                (this.countdown = this.completeDelay))
              : ((this.state = c.PENDING_REMOVE),
                this.dispatchTweenEvent(
                  e.TWEEN_COMPLETE,
                  this.callbacks.onComplete
                ));
          },
          pause: function () {
            if (this.state === c.PAUSED) return this;
            this.paused = !0;
            this._pausedState = this.state;
            this.state = c.PAUSED;
            return this;
          },
          play: function (g) {
            void 0 === g && (g = !1);
            var m = this.state;
            if (m !== c.INIT || this.parentIsTimeline) {
              if (
                m === c.ACTIVE ||
                (m === c.PENDING_ADD && this._pausedState === c.PENDING_ADD)
              )
                return this;
              if (
                !this.parentIsTimeline &&
                (m === c.PENDING_REMOVE || m === c.REMOVED)
              )
                return this.seek(0), this.parent.makeActive(this), this;
            } else
              return this.resetTweenData(!1), (this.state = c.ACTIVE), this;
            this.parentIsTimeline
              ? (this.resetTweenData(g),
                0 === this.calculatedOffset
                  ? (this.state = c.ACTIVE)
                  : ((this.countdown = this.calculatedOffset),
                    (this.state = c.OFFSET_DELAY)))
              : (this.paused
                  ? (this.paused = !1)
                  : (this.resetTweenData(g), (this.state = c.ACTIVE)),
                this.makeActive());
            return this;
          },
          resetTweenData: function (g) {
            for (
              var m = this.data,
                n = this.totalData,
                q = this.totalTargets,
                r = 0;
              r < n;
              r++
            ) {
              var u = m[r],
                v = u.target,
                x = u.key,
                y = u.index;
              u.progress = 0;
              u.elapsed = 0;
              u.repeatCounter = -1 === u.repeat ? 999999999999 : u.repeat;
              g
                ? ((u.start = u.getStartValue(v, x, u.start, y, q, this)),
                  (u.end = u.getEndValue(v, x, u.end, y, q, this)),
                  (u.current = u.start),
                  (u.state = c.PLAYING_FORWARD))
                : (u.state = c.PENDING_RENDER);
              0 < u.delay && ((u.elapsed = u.delay), (u.state = c.DELAY));
              u.getActiveValue &&
                (v[x] = u.getActiveValue(u.target, u.key, u.start));
            }
          },
          resume: function () {
            this.state === c.PAUSED
              ? ((this.paused = !1), (this.state = this._pausedState))
              : this.play();
            return this;
          },
          seek: function (g, m) {
            void 0 === m && (m = 16.6);
            this.state === c.REMOVED && this.makeActive();
            this.totalProgress =
              this.totalElapsed =
              this.progress =
              this.elapsed =
                0;
            for (
              var n = this.data, q = this.totalTargets, r = 0;
              r < this.totalData;
              r++
            ) {
              var u = n[r],
                v = u.target,
                x = u.gen,
                y = u.key,
                z = u.index;
              u.progress = 0;
              u.elapsed = 0;
              u.repeatCounter = -1 === u.repeat ? 999999999999 : u.repeat;
              u.delay = x.delay(v, y, 0, z, q, this);
              u.duration = Math.max(x.duration(v, y, 0, z, q, this), 0.001);
              u.hold = x.hold(v, y, 0, z, q, this);
              u.repeat = x.repeat(v, y, 0, z, q, this);
              u.repeatDelay = x.repeatDelay(v, y, 0, z, q, this);
              u.current = u.start;
              u.state = c.PLAYING_FORWARD;
              this.updateTweenData(this, u, 0, z, q);
              0 < u.delay && ((u.elapsed = u.delay), (u.state = c.DELAY));
            }
            this.calcDuration();
            n = !1;
            this.state === c.PAUSED && ((n = !0), (this.state = c.ACTIVE));
            this.isSeeking = !0;
            do this.update(0, m);
            while (this.totalProgress < g);
            this.isSeeking = !1;
            n && (this.state = c.PAUSED);
            return this;
          },
          setCallback: function (g, m, n, q) {
            this.callbacks[g] = {
              func: m,
              scope: q,
              params: n,
            };
            return this;
          },
          complete: function (g) {
            void 0 === g && (g = 0);
            g
              ? ((this.state = c.COMPLETE_DELAY), (this.countdown = g))
              : ((this.state = c.PENDING_REMOVE),
                this.dispatchTweenEvent(
                  e.TWEEN_COMPLETE,
                  this.callbacks.onComplete
                ));
            return this;
          },
          remove: function () {
            this.parent.remove(this);
            return this;
          },
          stop: function (g) {
            this.state === c.ACTIVE && void 0 !== g && this.seek(g);
            if (this.state !== c.REMOVED) {
              if (this.state === c.PAUSED || this.state === c.PENDING_ADD)
                this.parentIsTimeline
                  ? (this.parent.manager._destroy.push(this),
                    this.parent.manager._toProcess++)
                  : (this.parent._destroy.push(this), this.parent._toProcess++);
              this.dispatchTweenEvent(e.TWEEN_STOP, this.callbacks.onStop);
              this.removeAllListeners();
              this.state = c.PENDING_REMOVE;
            }
            return this;
          },
          update: function (g, m) {
            if (this.state === c.PAUSED) return !1;
            this.useFrames && (m = 1 * this.parent.timeScale);
            m *= this.timeScale;
            this.elapsed += m;
            this.progress = Math.min(this.elapsed / this.duration, 1);
            this.totalElapsed += m;
            this.totalProgress = Math.min(
              this.totalElapsed / this.totalDuration,
              1
            );
            switch (this.state) {
              case c.ACTIVE:
                this.hasStarted ||
                  this.isSeeking ||
                  ((this.startDelay -= m),
                  0 >= this.startDelay &&
                    ((this.hasStarted = !0),
                    this.dispatchTweenEvent(
                      e.TWEEN_START,
                      this.callbacks.onStart
                    )));
                g = !1;
                for (var n = 0; n < this.totalData; n++)
                  this.updateTweenData(this, this.data[n], m) && (g = !0);
                g || this.nextState();
                break;
              case c.LOOP_DELAY:
                this.countdown -= m;
                0 >= this.countdown &&
                  ((this.state = c.ACTIVE),
                  this.dispatchTweenEvent(e.TWEEN_LOOP, this.callbacks.onLoop));
                break;
              case c.OFFSET_DELAY:
                this.countdown -= m;
                0 >= this.countdown && (this.state = c.ACTIVE);
                break;
              case c.COMPLETE_DELAY:
                (this.countdown -= m),
                  0 >= this.countdown &&
                    ((this.state = c.PENDING_REMOVE),
                    this.dispatchTweenEvent(
                      e.TWEEN_COMPLETE,
                      this.callbacks.onComplete
                    ));
            }
            return this.state === c.PENDING_REMOVE;
          },
          dispatchTweenDataEvent: function (g, m, n) {
            this.isSeeking ||
              (this.emit(g, this, n.key, n.target, n.current, n.previous),
              m && ((m.params[1] = n.target), m.func.apply(m.scope, m.params)));
          },
          dispatchTweenEvent: function (g, m) {
            this.isSeeking ||
              (this.emit(g, this, this.targets),
              m &&
                ((m.params[1] = this.targets),
                m.func.apply(m.scope, m.params)));
          },
          setStateFromEnd: function (g, m, n) {
            if (m.yoyo)
              return (
                (m.elapsed = n),
                (m.progress = n / m.duration),
                m.flipX && m.target.toggleFlipX(),
                m.flipY && m.target.toggleFlipY(),
                this.dispatchTweenDataEvent(
                  e.TWEEN_YOYO,
                  g.callbacks.onYoyo,
                  m
                ),
                (m.start = m.getStartValue(
                  m.target,
                  m.key,
                  m.start,
                  m.index,
                  g.totalTargets,
                  g
                )),
                c.PLAYING_BACKWARD
              );
            if (0 < m.repeatCounter) {
              m.repeatCounter--;
              m.elapsed = n;
              m.progress = n / m.duration;
              m.flipX && m.target.toggleFlipX();
              m.flipY && m.target.toggleFlipY();
              m.start = m.getStartValue(
                m.target,
                m.key,
                m.start,
                m.index,
                g.totalTargets,
                g
              );
              m.end = m.getEndValue(
                m.target,
                m.key,
                m.start,
                m.index,
                g.totalTargets,
                g
              );
              if (0 < m.repeatDelay)
                return (
                  (m.elapsed = m.repeatDelay - n),
                  (m.current = m.start),
                  (m.target[m.key] = m.current),
                  c.REPEAT_DELAY
                );
              this.dispatchTweenDataEvent(
                e.TWEEN_REPEAT,
                g.callbacks.onRepeat,
                m
              );
              return c.PLAYING_FORWARD;
            }
            return c.COMPLETE;
          },
          setStateFromStart: function (g, m, n) {
            if (0 < m.repeatCounter) {
              m.repeatCounter--;
              m.elapsed = n;
              m.progress = n / m.duration;
              m.flipX && m.target.toggleFlipX();
              m.flipY && m.target.toggleFlipY();
              m.end = m.getEndValue(
                m.target,
                m.key,
                m.start,
                m.index,
                g.totalTargets,
                g
              );
              if (0 < m.repeatDelay)
                return (
                  (m.elapsed = m.repeatDelay - n),
                  (m.current = m.start),
                  (m.target[m.key] = m.current),
                  c.REPEAT_DELAY
                );
              this.dispatchTweenDataEvent(
                e.TWEEN_REPEAT,
                g.callbacks.onRepeat,
                m
              );
              return c.PLAYING_FORWARD;
            }
            return c.COMPLETE;
          },
          updateTweenData: function (g, m, n) {
            var q = m.target;
            switch (m.state) {
              case c.PLAYING_FORWARD:
              case c.PLAYING_BACKWARD:
                if (!q) {
                  m.state = c.COMPLETE;
                  break;
                }
                var r = m.elapsed,
                  u = m.duration,
                  v = 0;
                r += n;
                r > u && ((v = r - u), (r = u));
                n = m.state === c.PLAYING_FORWARD;
                u = r / u;
                m.elapsed = r;
                m.progress = u;
                m.previous = m.current;
                1 === u
                  ? n
                    ? ((m.current = m.end),
                      (q[m.key] = m.end),
                      0 < m.hold
                        ? ((m.elapsed = m.hold - v), (m.state = c.HOLD_DELAY))
                        : (m.state = this.setStateFromEnd(g, m, v)))
                    : ((m.current = m.start),
                      (q[m.key] = m.start),
                      (m.state = this.setStateFromStart(g, m, v)))
                  : ((r = n ? m.ease(u) : m.ease(1 - u)),
                    (m.current = m.start + (m.end - m.start) * r),
                    (q[m.key] = m.current));
                this.dispatchTweenDataEvent(
                  e.TWEEN_UPDATE,
                  g.callbacks.onUpdate,
                  m
                );
                break;
              case c.DELAY:
                m.elapsed -= n;
                0 >= m.elapsed &&
                  ((m.elapsed = Math.abs(m.elapsed)),
                  (m.state = c.PENDING_RENDER));
                break;
              case c.REPEAT_DELAY:
                m.elapsed -= n;
                0 >= m.elapsed &&
                  ((m.elapsed = Math.abs(m.elapsed)),
                  (m.state = c.PLAYING_FORWARD),
                  this.dispatchTweenDataEvent(
                    e.TWEEN_REPEAT,
                    g.callbacks.onRepeat,
                    m
                  ));
                break;
              case c.HOLD_DELAY:
                m.elapsed -= n;
                0 >= m.elapsed &&
                  (m.state = this.setStateFromEnd(g, m, Math.abs(m.elapsed)));
                break;
              case c.PENDING_RENDER:
                q
                  ? ((m.start = m.getStartValue(
                      q,
                      m.key,
                      q[m.key],
                      m.index,
                      g.totalTargets,
                      g
                    )),
                    (m.end = m.getEndValue(
                      q,
                      m.key,
                      m.start,
                      m.index,
                      g.totalTargets,
                      g
                    )),
                    (m.current = m.start),
                    (q[m.key] = m.start),
                    (m.state = c.PLAYING_FORWARD))
                  : (m.state = c.COMPLETE);
            }
            return m.state !== c.COMPLETE;
          },
        });
        a.TYPES =
          "onActive onComplete onLoop onRepeat onStart onStop onUpdate onYoyo".split(
            " "
          );
        b.register("tween", function (g) {
          return this.scene.sys.tweens.add(g);
        });
        t.register("tween", function (g) {
          return this.scene.sys.tweens.create(g);
        });
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          TIMELINE_COMPLETE: a(1466),
          TIMELINE_LOOP: a(1467),
          TIMELINE_PAUSE: a(1468),
          TIMELINE_RESUME: a(1469),
          TIMELINE_START: a(1470),
          TIMELINE_UPDATE: a(1471),
          TWEEN_ACTIVE: a(1472),
          TWEEN_COMPLETE: a(1473),
          TWEEN_LOOP: a(1474),
          TWEEN_REPEAT: a(1475),
          TWEEN_START: a(1476),
          TWEEN_STOP: a(1477),
          TWEEN_UPDATE: a(1478),
          TWEEN_YOYO: a(1479),
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b, c, f, g, m, n, q, r, u, v, x) {
          return {
            target: a,
            index: d,
            key: k,
            getActiveValue: c,
            getEndValue: e,
            getStartValue: b,
            ease: f,
            duration: 0,
            totalDuration: 0,
            delay: 0,
            yoyo: n,
            hold: 0,
            repeat: 0,
            repeatDelay: 0,
            flipX: v,
            flipY: x,
            progress: 0,
            elapsed: 0,
            repeatCounter: 0,
            start: 0,
            previous: 0,
            current: 0,
            end: 0,
            t1: 0,
            t2: 0,
            gen: {
              delay: g,
              duration: m,
              hold: q,
              repeat: r,
              repeatDelay: u,
            },
            state: 0,
          };
        };
      },
      function (h, t, a) {
        var d = a(68);
        h.exports = function (k) {
          return d(k, -Math.PI, Math.PI);
        };
      },
      function (h, t, a) {
        var d = a(68);
        h.exports = function (k) {
          return d(k, -180, 180);
        };
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(83),
          e = a(32);
        (function () {
          d.fromVertices = function (b) {
            for (var c = {}, f = 0; f < b.length; f++) {
              var g = (f + 1) % b.length;
              g = k.normalise({
                x: b[g].y - b[f].y,
                y: b[f].x - b[g].x,
              });
              var m = 0 === g.y ? Infinity : g.x / g.y;
              m = m.toFixed(3).toString();
              c[m] = g;
            }
            return e.values(c);
          };
          d.rotate = function (b, c) {
            if (0 !== c) {
              var f = Math.cos(c);
              c = Math.sin(c);
              for (var g = 0; g < b.length; g++) {
                var m = b[g];
                var n = m.x * f - m.y * c;
                m.y = m.x * c + m.y * f;
                m.x = n;
              }
            }
          };
        })();
      },
      function (h, t, a) {
        h.exports = {
          AFTER_ADD: a(1504),
          AFTER_REMOVE: a(1505),
          AFTER_UPDATE: a(1506),
          BEFORE_ADD: a(1507),
          BEFORE_REMOVE: a(1508),
          BEFORE_UPDATE: a(1509),
          COLLISION_ACTIVE: a(1510),
          COLLISION_END: a(1511),
          COLLISION_START: a(1512),
          DRAG_END: a(1513),
          DRAG: a(1514),
          DRAG_START: a(1515),
          PAUSE: a(1516),
          RESUME: a(1517),
          SLEEP_END: a(1518),
          SLEEP_START: a(1519),
        };
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(274),
          e = a(250),
          b = a(84);
        (function () {
          d.collisions = function (c, f) {
            var g = [],
              m = f.pairs.table;
            f = f.metrics;
            for (var n = 0; n < c.length; n++) {
              var q = c[n][0],
                r = c[n][1];
              if (
                ((!q.isStatic && !q.isSleeping) ||
                  (!r.isStatic && !r.isSleeping)) &&
                d.canCollide(q.collisionFilter, r.collisionFilter) &&
                ((f.midphaseTests += 1), b.overlaps(q.bounds, r.bounds))
              )
                for (
                  var u = 1 < q.parts.length ? 1 : 0;
                  u < q.parts.length;
                  u++
                )
                  for (
                    var v = q.parts[u], x = 1 < r.parts.length ? 1 : 0;
                    x < r.parts.length;
                    x++
                  ) {
                    var y = r.parts[x];
                    if (
                      (v === q && y === r) ||
                      b.overlaps(v.bounds, y.bounds)
                    ) {
                      var z = e.id(v, y);
                      z = m[z];
                      y = k.collides(
                        v,
                        y,
                        z && z.isActive ? z.collision : null
                      );
                      f.narrowphaseTests += 1;
                      y.reused && (f.narrowReuseCount += 1);
                      y.collided && (g.push(y), (f.narrowDetections += 1));
                    }
                  }
            }
            return g;
          };
          d.canCollide = function (c, f) {
            return c.group === f.group && 0 !== c.group
              ? 0 < c.group
              : 0 !== (c.mask & f.category) && 0 !== (f.mask & c.category);
          };
        })();
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(64),
          e = a(83);
        (function () {
          d.collides = function (b, c, f) {
            var g = !1;
            if (f) {
              var m = b.parent;
              g = c.parent;
              m =
                m.speed * m.speed +
                m.angularSpeed * m.angularSpeed +
                g.speed * g.speed +
                g.angularSpeed * g.angularSpeed;
              g = f && f.collided && 0.2 > m;
              m = f;
            } else
              m = {
                collided: !1,
                bodyA: b,
                bodyB: c,
              };
            if (f && g) {
              if (
                ((g = m.axisBody),
                (f = d._overlapAxes(g.vertices, (g === b ? c : b).vertices, [
                  g.axes[f.axisNumber],
                ])),
                (m.reused = !0),
                0 >= f.overlap)
              )
                return (m.collided = !1), m;
            } else {
              f = d._overlapAxes(b.vertices, c.vertices, b.axes);
              if (0 >= f.overlap) return (m.collided = !1), m;
              g = d._overlapAxes(c.vertices, b.vertices, c.axes);
              if (0 >= g.overlap) return (m.collided = !1), m;
              f.overlap < g.overlap
                ? (m.axisBody = b)
                : ((f = g), (m.axisBody = c));
              m.axisNumber = f.axisNumber;
            }
            m.bodyA = b.id < c.id ? b : c;
            m.bodyB = b.id < c.id ? c : b;
            m.collided = !0;
            m.depth = f.overlap;
            m.parentA = m.bodyA.parent;
            m.parentB = m.bodyB.parent;
            b = m.bodyA;
            c = m.bodyB;
            0 > e.dot(f.axis, e.sub(c.position, b.position))
              ? (m.normal = {
                  x: f.axis.x,
                  y: f.axis.y,
                })
              : (m.normal = {
                  x: -f.axis.x,
                  y: -f.axis.y,
                });
            m.tangent = e.perp(m.normal);
            m.penetration = m.penetration || {};
            m.penetration.x = m.normal.x * m.depth;
            m.penetration.y = m.normal.y * m.depth;
            f = d._findSupports(b, c, m.normal);
            g = [];
            k.contains(b.vertices, f[0]) && g.push(f[0]);
            k.contains(b.vertices, f[1]) && g.push(f[1]);
            2 > g.length &&
              ((b = d._findSupports(c, b, e.neg(m.normal))),
              k.contains(c.vertices, b[0]) && g.push(b[0]),
              2 > g.length && k.contains(c.vertices, b[1]) && g.push(b[1]));
            1 > g.length && (g = [f[0]]);
            m.supports = g;
            return m;
          };
          d._overlapAxes = function (b, c, f) {
            for (
              var g = e._temp[0],
                m = e._temp[1],
                n = {
                  overlap: Number.MAX_VALUE,
                },
                q,
                r,
                u = 0;
              u < f.length;
              u++
            ) {
              r = f[u];
              d._projectToAxis(g, b, r);
              d._projectToAxis(m, c, r);
              q = Math.min(g.max - m.min, m.max - g.min);
              if (0 >= q) {
                n.overlap = q;
                break;
              }
              q < n.overlap &&
                ((n.overlap = q), (n.axis = r), (n.axisNumber = u));
            }
            return n;
          };
          d._projectToAxis = function (b, c, f) {
            for (var g = e.dot(c[0], f), m = g, n = 1; n < c.length; n += 1) {
              var q = e.dot(c[n], f);
              q > m ? (m = q) : q < g && (g = q);
            }
            b.min = g;
            b.max = m;
          };
          d._findSupports = function (b, c, f) {
            var g = Number.MAX_VALUE,
              m = e._temp[0];
            c = c.vertices;
            b = b.position;
            var n;
            for (n = 0; n < c.length; n++) {
              var q = c[n];
              m.x = q.x - b.x;
              m.y = q.y - b.y;
              var r = -e.dot(f, m);
              if (r < g) {
                g = r;
                var u = q;
              }
            }
            q = c[0 <= u.index - 1 ? u.index - 1 : c.length - 1];
            m.x = q.x - b.x;
            m.y = q.y - b.y;
            g = -e.dot(f, m);
            n = q;
            q = c[(u.index + 1) % c.length];
            m.x = q.x - b.x;
            m.y = q.y - b.y;
            r = -e.dot(f, m);
            r < g && (n = q);
            return [u, n];
          };
        })();
      },
      function (h, t, a) {
        h.exports = {
          AlignTo: a(601),
          Angle: a(602),
          Call: a(603),
          GetFirst: a(604),
          GetLast: a(605),
          GridAlign: a(606),
          IncAlpha: a(678),
          IncX: a(679),
          IncXY: a(680),
          IncY: a(681),
          PlaceOnCircle: a(682),
          PlaceOnEllipse: a(683),
          PlaceOnLine: a(684),
          PlaceOnRectangle: a(685),
          PlaceOnTriangle: a(686),
          PlayAnimation: a(687),
          PropertyValueInc: a(46),
          PropertyValueSet: a(27),
          RandomCircle: a(688),
          RandomEllipse: a(689),
          RandomLine: a(690),
          RandomRectangle: a(691),
          RandomTriangle: a(692),
          Rotate: a(693),
          RotateAround: a(694),
          RotateAroundDistance: a(695),
          ScaleX: a(696),
          ScaleXY: a(697),
          ScaleY: a(698),
          SetAlpha: a(699),
          SetBlendMode: a(700),
          SetDepth: a(701),
          SetHitArea: a(702),
          SetOrigin: a(703),
          SetRotation: a(704),
          SetScale: a(705),
          SetScaleX: a(706),
          SetScaleY: a(707),
          SetScrollFactor: a(708),
          SetScrollFactorX: a(709),
          SetScrollFactorY: a(710),
          SetTint: a(711),
          SetVisible: a(712),
          SetX: a(713),
          SetXY: a(714),
          SetY: a(715),
          ShiftPosition: a(716),
          Shuffle: a(717),
          SmootherStep: a(718),
          SmoothStep: a(719),
          Spread: a(720),
          ToggleVisible: a(721),
          WrapInRectangle: a(722),
        };
      },
      function (h, t, a) {
        t = a(123);
        var d = [];
        d[t.BOTTOM_CENTER] = a(277);
        d[t.BOTTOM_LEFT] = a(278);
        d[t.BOTTOM_RIGHT] = a(279);
        d[t.LEFT_BOTTOM] = a(280);
        d[t.LEFT_CENTER] = a(281);
        d[t.LEFT_TOP] = a(282);
        d[t.RIGHT_BOTTOM] = a(283);
        d[t.RIGHT_CENTER] = a(284);
        d[t.RIGHT_TOP] = a(285);
        d[t.TOP_CENTER] = a(286);
        d[t.TOP_LEFT] = a(287);
        d[t.TOP_RIGHT] = a(288);
        h.exports = function (k, e, b, c, f) {
          return d[b](k, e, c, f);
        };
      },
      function (h, t, a) {
        var d = a(42),
          k = a(87),
          e = a(88),
          b = a(52);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          e(c, k(f) + g);
          b(c, d(f) + m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(42),
          k = a(43),
          e = a(53),
          b = a(52);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          e(c, k(f) - g);
          b(c, d(f) + m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(42),
          k = a(44),
          e = a(54),
          b = a(52);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          e(c, k(f) + g);
          b(c, d(f) + m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(42),
          k = a(43),
          e = a(55),
          b = a(54);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          b(c, k(f) - g);
          e(c, d(f) + m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(89),
          k = a(43),
          e = a(90),
          b = a(54);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          b(c, k(f) - g);
          e(c, d(f) + m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(43),
          k = a(45),
          e = a(54),
          b = a(52);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          e(c, d(f) - g);
          b(c, k(f) - m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(42),
          k = a(44),
          e = a(55),
          b = a(53);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          b(c, k(f) + g);
          e(c, d(f) + m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(89),
          k = a(44),
          e = a(90),
          b = a(53);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          b(c, k(f) + g);
          e(c, d(f) + m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(44),
          k = a(45),
          e = a(53),
          b = a(52);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          e(c, d(f) + g);
          b(c, k(f) - m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(87),
          k = a(45),
          e = a(55),
          b = a(88);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          b(c, d(f) + g);
          e(c, k(f) - m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(43),
          k = a(45),
          e = a(55),
          b = a(53);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          b(c, d(f) - g);
          e(c, k(f) - m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(44),
          k = a(45),
          e = a(55),
          b = a(54);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          b(c, d(f) + g);
          e(c, k(f) - m);
          return c;
        };
      },
      function (h, t, a) {
        t = a(123);
        var d = [];
        d[t.BOTTOM_CENTER] = a(290);
        d[t.BOTTOM_LEFT] = a(291);
        d[t.BOTTOM_RIGHT] = a(292);
        d[t.CENTER] = a(293);
        d[t.LEFT_CENTER] = a(295);
        d[t.RIGHT_CENTER] = a(296);
        d[t.TOP_CENTER] = a(297);
        d[t.TOP_LEFT] = a(298);
        d[t.TOP_RIGHT] = a(299);
        d[t.LEFT_BOTTOM] = d[t.BOTTOM_LEFT];
        d[t.LEFT_TOP] = d[t.TOP_LEFT];
        d[t.RIGHT_BOTTOM] = d[t.BOTTOM_RIGHT];
        d[t.RIGHT_TOP] = d[t.TOP_RIGHT];
        h.exports = function (k, e, b, c, f) {
          return d[b](k, e, c, f);
        };
      },
      function (h, t, a) {
        var d = a(42),
          k = a(87),
          e = a(55),
          b = a(88);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          b(c, k(f) + g);
          e(c, d(f) + m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(42),
          k = a(43),
          e = a(55),
          b = a(53);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          b(c, k(f) - g);
          e(c, d(f) + m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(42),
          k = a(44),
          e = a(55),
          b = a(54);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          b(c, k(f) + g);
          e(c, d(f) + m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(294),
          k = a(87),
          e = a(89);
        h.exports = function (b, c, f, g) {
          void 0 === f && (f = 0);
          void 0 === g && (g = 0);
          d(b, k(c) + f, e(c) + g);
          return b;
        };
      },
      function (h, t, a) {
        var d = a(88),
          k = a(90);
        h.exports = function (e, b, c) {
          d(e, b);
          return k(e, c);
        };
      },
      function (h, t, a) {
        var d = a(89),
          k = a(43),
          e = a(90),
          b = a(53);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          b(c, k(f) - g);
          e(c, d(f) + m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(89),
          k = a(44),
          e = a(90),
          b = a(54);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          b(c, k(f) + g);
          e(c, d(f) + m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(87),
          k = a(45),
          e = a(88),
          b = a(52);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          e(c, d(f) + g);
          b(c, k(f) - m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(43),
          k = a(45),
          e = a(53),
          b = a(52);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          e(c, d(f) - g);
          b(c, k(f) - m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(44),
          k = a(45),
          e = a(54),
          b = a(52);
        h.exports = function (c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = 0);
          e(c, d(f) + g);
          b(c, k(f) - m);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(169),
          k = a(98),
          e = a(14),
          b = a(4);
        h.exports = function (c, f, g) {
          void 0 === g && (g = new b());
          f = k(f, 0, e.PI2);
          return d(c, f, g);
        };
      },
      function (h, t, a) {
        var d = a(302),
          k = a(169),
          e = a(98),
          b = a(14);
        h.exports = function (c, f, g, m) {
          void 0 === m && (m = []);
          !f && 0 < g && (f = d(c) / g);
          for (g = 0; g < f; g++) {
            var n = e(g / f, 0, b.PI2);
            m.push(k(c, n));
          }
          return m;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 2 * Math.PI * a.radius;
        };
      },
      function (h, t, a) {
        var d = a(18);
        h.exports = {
          _alpha: 1,
          clearAlpha: function () {
            return this.setAlpha(1);
          },
          setAlpha: function (k) {
            void 0 === k && (k = 1);
            this.alpha = k;
            return this;
          },
          alpha: {
            get: function () {
              return this._alpha;
            },
            set: function (k) {
              this._alpha = k = d(k, 0, 1);
              this.renderFlags =
                0 === k ? this.renderFlags & -3 : this.renderFlags | 2;
            },
          },
        };
      },
      function (h, t, a) {
        var d = a(35);
        h.exports = {
          _blendMode: d.NORMAL,
          blendMode: {
            get: function () {
              return this._blendMode;
            },
            set: function (k) {
              "string" === typeof k && (k = d[k]);
              k |= 0;
              -1 <= k && (this._blendMode = k);
            },
          },
          setBlendMode: function (k) {
            this.blendMode = k;
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          _depth: 0,
          depth: {
            get: function () {
              return this._depth;
            },
            set: function (a) {
              this.displayList && this.displayList.queueDepthSort();
              this._depth = a;
            },
          },
          setDepth: function (a) {
            void 0 === a && (a = 0);
            this.depth = a;
            return this;
          },
        };
      },
      function (h, t, a) {
        var d = a(171),
          k = a(130);
        h.exports = function (e, b, c, f) {
          void 0 === f && (f = []);
          !b && 0 < c && (b = k(e) / c);
          for (c = 0; c < b; c++) f.push(d(e, c / b));
          return f;
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e, b) {
          void 0 === b && (b = new d());
          b.x = k.x1 + (k.x2 - k.x1) * e;
          b.y = k.y1 + (k.y2 - k.y1) * e;
          return b;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          var b = Math.cos(e);
          e = Math.sin(e);
          var c = a.x - d,
            f = a.y - k;
          a.x = c * b - f * e + d;
          a.y = c * e + f * b + k;
          return a;
        };
      },
      function (h, t, a) {
        var d = a(310),
          k = a(311);
        h.exports = {
          mask: null,
          setMask: function (e) {
            this.mask = e;
            return this;
          },
          clearMask: function (e) {
            void 0 === e && (e = !1);
            e && this.mask && this.mask.destroy();
            this.mask = null;
            return this;
          },
          createBitmapMask: function (e) {
            void 0 === e && (this.texture || this.shader) && (e = this);
            return new d(this.scene, e);
          },
          createGeometryMask: function (e) {
            void 0 === e && "Graphics" === this.type && (e = this);
            return new k(this.scene, e);
          },
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(22),
          k = a(91);
        a = new t({
          initialize: function (e, b) {
            var c = e.sys.renderer;
            this.renderer = c;
            this.bitmapMask = b;
            this.mainTexture = this.maskTexture = null;
            this.dirty = !0;
            this.maskFramebuffer = this.mainFramebuffer = null;
            this.isStencil = this.invertAlpha = !1;
            this.createMask();
            e.sys.game.events.on(d.CONTEXT_RESTORED, this.createMask, this);
            if (c) c.on(k.RESIZE, this.createMask, this);
          },
          createMask: function () {
            var e = this.renderer;
            if (e && e.gl) {
              this.mainTexture && this.clearMask();
              var b = e.width,
                c = e.height,
                f = e.gl,
                g =
                  0 === (b & (b - 1)) && 0 === (c & (c - 1))
                    ? f.REPEAT
                    : f.CLAMP_TO_EDGE,
                m = f.LINEAR;
              this.mainTexture = e.createTexture2D(
                0,
                m,
                m,
                g,
                g,
                f.RGBA,
                null,
                b,
                c
              );
              this.maskTexture = e.createTexture2D(
                0,
                m,
                m,
                g,
                g,
                f.RGBA,
                null,
                b,
                c
              );
              this.mainFramebuffer = e.createFramebuffer(
                b,
                c,
                this.mainTexture,
                !0
              );
              this.maskFramebuffer = e.createFramebuffer(
                b,
                c,
                this.maskTexture,
                !0
              );
            }
          },
          clearMask: function () {
            var e = this.renderer;
            e &&
              e.gl &&
              this.mainTexture &&
              (e.deleteTexture(this.mainTexture),
              e.deleteTexture(this.maskTexture),
              e.deleteFramebuffer(this.mainFramebuffer),
              e.deleteFramebuffer(this.maskFramebuffer),
              (this.maskFramebuffer =
                this.mainFramebuffer =
                this.maskTexture =
                this.mainTexture =
                  null));
          },
          setBitmap: function (e) {
            this.bitmapMask = e;
          },
          preRenderWebGL: function (e, b, c) {
            e.pipelines.BITMAPMASK_PIPELINE.beginMask(this, b, c);
          },
          postRenderWebGL: function (e, b) {
            e.pipelines.BITMAPMASK_PIPELINE.endMask(this, b);
          },
          preRenderCanvas: function () {},
          postRenderCanvas: function () {},
          destroy: function () {
            this.clearMask();
            this.renderer && this.renderer.off(k.RESIZE, this.createMask, this);
            this.renderer = this.prevFramebuffer = this.bitmapMask = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = new (a(0))({
          initialize: function (d, k) {
            this.geometryMask = k;
            this.invertAlpha = !1;
            this.isStencil = !0;
            this.level = 0;
          },
          setShape: function (d) {
            this.geometryMask = d;
            return this;
          },
          setInvertAlpha: function (d) {
            void 0 === d && (d = !0);
            this.invertAlpha = d;
            return this;
          },
          preRenderWebGL: function (d, k, e) {
            k = d.gl;
            d.flush();
            0 === d.maskStack.length &&
              (k.enable(k.STENCIL_TEST),
              k.clear(k.STENCIL_BUFFER_BIT),
              (d.maskCount = 0));
            d.currentCameraMask.mask !== this && (d.currentMask.mask = this);
            d.maskStack.push({
              mask: this,
              camera: e,
            });
            this.applyStencil(d, e, !0);
            d.maskCount++;
          },
          applyStencil: function (d, k, e) {
            var b = d.gl,
              c = this.geometryMask,
              f = d.maskCount;
            b.colorMask(!1, !1, !1, !1);
            e
              ? (b.stencilFunc(b.EQUAL, f, 255),
                b.stencilOp(b.KEEP, b.KEEP, b.INCR))
              : (b.stencilFunc(b.EQUAL, f + 1, 255),
                b.stencilOp(b.KEEP, b.KEEP, b.DECR));
            c.renderWebGL(d, c, k);
            d.flush();
            b.colorMask(!0, !0, !0, !0);
            b.stencilOp(b.KEEP, b.KEEP, b.KEEP);
            e
              ? this.invertAlpha
                ? b.stencilFunc(b.NOTEQUAL, f + 1, 255)
                : b.stencilFunc(b.EQUAL, f + 1, 255)
              : this.invertAlpha
              ? b.stencilFunc(b.NOTEQUAL, f, 255)
              : b.stencilFunc(b.EQUAL, f, 255);
          },
          postRenderWebGL: function (d) {
            var k = d.gl;
            d.maskStack.pop();
            d.maskCount--;
            d.flush();
            var e = d.currentMask;
            0 === d.maskStack.length
              ? ((e.mask = null), k.disable(k.STENCIL_TEST))
              : ((k = d.maskStack[d.maskStack.length - 1]),
                k.mask.applyStencil(d, k.camera, !1),
                d.currentCameraMask.mask !== k.mask
                  ? ((e.mask = k.mask), (e.camera = k.camera))
                  : (e.mask = null));
          },
          preRenderCanvas: function (d, k, e) {
            k = this.geometryMask;
            d.currentContext.save();
            k.renderCanvas(d, k, e, null, null, !0);
            d.currentContext.clip();
          },
          postRenderCanvas: function (d) {
            d.currentContext.restore();
          },
          destroy: function () {
            this.geometryMask = null;
          },
        });
        h.exports = t;
      },
      function (h, t) {
        h.exports = {
          scrollFactorX: 1,
          scrollFactorY: 1,
          setScrollFactor: function (a, d) {
            void 0 === d && (d = a);
            this.scrollFactorX = a;
            this.scrollFactorY = d;
            return this;
          },
        };
      },
      function (h, t, a) {
        var d = a(14),
          k = a(25),
          e = a(177),
          b = a(269),
          c = a(270),
          f = a(3);
        h.exports = {
          _scaleX: 1,
          _scaleY: 1,
          _rotation: 0,
          x: 0,
          y: 0,
          z: 0,
          w: 0,
          scale: {
            get: function () {
              return (this._scaleX + this._scaleY) / 2;
            },
            set: function (g) {
              this._scaleY = this._scaleX = g;
              this.renderFlags =
                0 === g ? this.renderFlags & -5 : this.renderFlags | 4;
            },
          },
          scaleX: {
            get: function () {
              return this._scaleX;
            },
            set: function (g) {
              this._scaleX = g;
              this.renderFlags =
                0 === g ? this.renderFlags & -5 : this.renderFlags | 4;
            },
          },
          scaleY: {
            get: function () {
              return this._scaleY;
            },
            set: function (g) {
              this._scaleY = g;
              this.renderFlags =
                0 === g ? this.renderFlags & -5 : this.renderFlags | 4;
            },
          },
          angle: {
            get: function () {
              return c(this._rotation * d.RAD_TO_DEG);
            },
            set: function (g) {
              this.rotation = c(g) * d.DEG_TO_RAD;
            },
          },
          rotation: {
            get: function () {
              return this._rotation;
            },
            set: function (g) {
              this._rotation = b(g);
            },
          },
          setPosition: function (g, m, n, q) {
            void 0 === g && (g = 0);
            void 0 === m && (m = g);
            void 0 === n && (n = 0);
            void 0 === q && (q = 0);
            this.x = g;
            this.y = m;
            this.z = n;
            this.w = q;
            return this;
          },
          copyPosition: function (g) {
            void 0 !== g.x && (this.x = g.x);
            void 0 !== g.y && (this.y = g.y);
            void 0 !== g.z && (this.z = g.z);
            void 0 !== g.w && (this.w = g.w);
            return this;
          },
          setRandomPosition: function (g, m, n, q) {
            void 0 === g && (g = 0);
            void 0 === m && (m = 0);
            void 0 === n && (n = this.scene.sys.scale.width);
            void 0 === q && (q = this.scene.sys.scale.height);
            this.x = g + Math.random() * n;
            this.y = m + Math.random() * q;
            return this;
          },
          setRotation: function (g) {
            void 0 === g && (g = 0);
            this.rotation = g;
            return this;
          },
          setAngle: function (g) {
            void 0 === g && (g = 0);
            this.angle = g;
            return this;
          },
          setScale: function (g, m) {
            void 0 === g && (g = 1);
            void 0 === m && (m = g);
            this.scaleX = g;
            this.scaleY = m;
            return this;
          },
          setX: function (g) {
            void 0 === g && (g = 0);
            this.x = g;
            return this;
          },
          setY: function (g) {
            void 0 === g && (g = 0);
            this.y = g;
            return this;
          },
          setZ: function (g) {
            void 0 === g && (g = 0);
            this.z = g;
            return this;
          },
          setW: function (g) {
            void 0 === g && (g = 0);
            this.w = g;
            return this;
          },
          getLocalTransformMatrix: function (g) {
            void 0 === g && (g = new k());
            return g.applyITRS(
              this.x,
              this.y,
              this._rotation,
              this._scaleX,
              this._scaleY
            );
          },
          getWorldTransformMatrix: function (g, m) {
            void 0 === g && (g = new k());
            void 0 === m && (m = new k());
            var n = this.parentContainer;
            if (!n) return this.getLocalTransformMatrix(g);
            for (
              g.applyITRS(
                this.x,
                this.y,
                this._rotation,
                this._scaleX,
                this._scaleY
              );
              n;

            )
              m.applyITRS(n.x, n.y, n._rotation, n._scaleX, n._scaleY),
                m.multiply(g, g),
                (n = n.parentContainer);
            return g;
          },
          getLocalPoint: function (g, m, n, q) {
            n || (n = new f());
            q || (q = this.scene.sys.cameras.main);
            var r = q.scrollX;
            q = q.scrollY;
            g = g + r * this.scrollFactorX - r;
            m = m + q * this.scrollFactorY - q;
            this.parentContainer
              ? this.getWorldTransformMatrix().applyInverse(g, m, n)
              : e(
                  g,
                  m,
                  this.x,
                  this.y,
                  this.rotation,
                  this.scaleX,
                  this.scaleY,
                  n
                );
            this._originComponent &&
              ((n.x += this._displayOriginX), (n.y += this._displayOriginY));
            return n;
          },
          getParentRotation: function () {
            for (var g = 0, m = this.parentContainer; m; )
              (g += m.rotation), (m = m.parentContainer);
            return g;
          },
        };
      },
      function (h, t) {
        h.exports = {
          _visible: !0,
          visible: {
            get: function () {
              return this._visible;
            },
            set: function (a) {
              a
                ? ((this._visible = !0), (this.renderFlags |= 1))
                : ((this._visible = !1), (this.renderFlags &= -2));
            },
          },
          setVisible: function (a) {
            this.visible = a;
            return this;
          },
        };
      },
      function (h, t, a) {
        h.exports = {
          CHANGE_DATA: a(638),
          CHANGE_DATA_KEY: a(639),
          DESTROY: a(640),
          REMOVE_DATA: a(641),
          SET_DATA: a(642),
        };
      },
      function (h, t, a) {
        var d = a(130),
          k = a(4);
        h.exports = function (e, b, c, f) {
          void 0 === f && (f = []);
          if (!b && !c) return f;
          b ? (c = Math.round(d(e) / b)) : (b = d(e) / c);
          for (var g = e.x, m = e.y, n = 0, q = 0; q < c; q++)
            switch ((f.push(new k(g, m)), n)) {
              case 0:
                g += b;
                g >= e.right && ((n = 1), (m += g - e.right), (g = e.right));
                break;
              case 1:
                m += b;
                m >= e.bottom && ((n = 2), (g -= m - e.bottom), (m = e.bottom));
                break;
              case 2:
                g -= b;
                g <= e.left && ((n = 3), (m -= e.left - g), (g = e.left));
                break;
              case 3:
                (m -= b), m <= e.top && ((n = 0), (m = e.top));
            }
          return f;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          void 0 === d && (d = 1);
          void 0 === k && (k = []);
          var e = Math.round(a.x1),
            b = Math.round(a.y1),
            c = Math.round(a.x2);
          a = Math.round(a.y2);
          var f = Math.abs(c - e),
            g = Math.abs(a - b),
            m = e < c ? 1 : -1,
            n = b < a ? 1 : -1,
            q = f - g;
          k.push({
            x: e,
            y: b,
          });
          for (var r = 1; e !== c || b !== a; ) {
            var u = q << 1;
            u > -g && ((q -= g), (e += m));
            u < f && ((q += f), (b += n));
            0 === r % d &&
              k.push({
                x: e,
                y: b,
              });
            r++;
          }
          return k;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          if (!d.length) return NaN;
          if (1 === d.length) return d[0];
          var e = 1;
          if (k) {
            if (a < d[0][k]) return d[0];
            for (; d[e][k] < a; ) e++;
          } else for (; d[e] < a; ) e++;
          e > d.length && (e = d.length);
          if (k) {
            var b = d[e - 1][k];
            k = d[e][k];
            return k - a <= a - b ? d[e] : d[e - 1];
          }
          b = d[e - 1];
          k = d[e];
          return k - a <= a - b ? k : b;
        };
      },
      function (h, t, a) {
        t = new (a(0))({
          initialize: function (d, k, e, b, c) {
            void 0 === c && (c = !1);
            this.textureKey = d;
            this.textureFrame = k;
            this.index = e;
            this.frame = b;
            this.isLast = this.isFirst = !1;
            this.nextFrame = this.prevFrame = null;
            this.progress = this.duration = 0;
            this.isKeyFrame = c;
          },
          toJSON: function () {
            return {
              key: this.textureKey,
              frame: this.textureFrame,
              duration: this.duration,
              keyframe: this.isKeyFrame,
            };
          },
          destroy: function () {
            this.frame = void 0;
          },
        });
        h.exports = t;
      },
      function (h, t) {
        h.exports = function (a) {
          var d = /\D/g;
          a.sort(function (k, e) {
            return (
              parseInt(k.replace(d, ""), 10) - parseInt(e.replace(d, ""), 10)
            );
          });
          return a;
        };
      },
      function (h, t, a) {
        var d = a(185);
        t = a(0);
        var k = a(102),
          e = a(9),
          b = a(132),
          c = a(22),
          f = a(2),
          g = a(6),
          m = a(186),
          n = a(322);
        a = new t({
          Extends: e,
          initialize: function (q) {
            e.call(this);
            this.game = q;
            this.textureManager = null;
            this.globalTimeScale = 1;
            this.anims = new k();
            this.mixes = new k();
            this.paused = !1;
            this.name = "AnimationManager";
            q.events.once(c.BOOT, this.boot, this);
          },
          boot: function () {
            this.textureManager = this.game.textures;
            this.game.events.once(c.DESTROY, this.destroy, this);
          },
          addMix: function (q, r, u) {
            var v = this.anims,
              x = this.mixes;
            q = "string" === typeof q ? q : q.key;
            r = "string" === typeof r ? r : r.key;
            v.has(q) &&
              v.has(r) &&
              ((v = x.get(q)) || (v = {}), (v[r] = u), x.set(q, v));
            return this;
          },
          removeMix: function (q, r) {
            var u = this.mixes,
              v = "string" === typeof q ? q : q.key;
            if ((q = u.get(v)))
              r
                ? ((r = "string" === typeof r ? r : r.key),
                  q.hasOwnProperty(r) && delete q[r])
                : r || u.delete(v);
            return this;
          },
          getMix: function (q, r) {
            r = "string" === typeof r ? r : r.key;
            return (q = this.mixes.get("string" === typeof q ? q : q.key)) &&
              q.hasOwnProperty(r)
              ? q[r]
              : 0;
          },
          add: function (q, r) {
            if (this.anims.has(q))
              return console.warn("Animation key exists: " + q), this;
            r.key = q;
            this.anims.set(q, r);
            this.emit(b.ADD_ANIMATION, q, r);
            return this;
          },
          exists: function (q) {
            return this.anims.has(q);
          },
          createFromAseprite: function (q, r) {
            var u = [],
              v = this.game.cache.json.get(q);
            if (!v) return u;
            var x = this,
              y = g(v, "meta", null),
              z = g(v, "frames", null);
            y &&
              z &&
              g(y, "frameTags", []).forEach(function (A) {
                var B = [],
                  D = f(A, "name", null),
                  E = f(A, "from", 0),
                  C = f(A, "to", 0);
                A = f(A, "direction", "forward");
                if (D && (!r || (r && -1 < r.indexOf(D)))) {
                  for (var F = [], G = Number.MAX_SAFE_INTEGER; E <= C; E++) {
                    var H = E.toString(),
                      K = z[H];
                    K &&
                      ((K = f(K, "duration", Number.MAX_SAFE_INTEGER)),
                      K < G && (G = K),
                      F.push({
                        frame: H,
                        duration: K,
                      }));
                  }
                  F.forEach(function (I) {
                    B.push({
                      key: q,
                      frame: I.frame,
                      duration: G - I.duration,
                    });
                  });
                  C = G * B.length;
                  "reverse" === A && (B = B.reverse());
                  (D = x.create({
                    key: D,
                    frames: B,
                    duration: C,
                    yoyo: "pingpong" === A,
                  })) && u.push(D);
                }
              });
            return u;
          },
          create: function (q) {
            var r = q.key,
              u = !1;
            r &&
              ((u = this.get(r)),
              u ||
                ((u = new d(this, r, q)),
                this.anims.set(r, u),
                this.emit(b.ADD_ANIMATION, r, u)));
            return u;
          },
          fromJSON: function (q, r) {
            void 0 === r && (r = !1);
            r && this.anims.clear();
            "string" === typeof q && (q = JSON.parse(q));
            r = [];
            if (q.hasOwnProperty("anims") && Array.isArray(q.anims)) {
              for (var u = 0; u < q.anims.length; u++)
                r.push(this.create(q.anims[u]));
              q.hasOwnProperty("globalTimeScale") &&
                (this.globalTimeScale = q.globalTimeScale);
            } else
              q.hasOwnProperty("key") &&
                "frame" === q.type &&
                r.push(this.create(q));
            return r;
          },
          generateFrameNames: function (q, r) {
            var u = g(r, "prefix", ""),
              v = g(r, "start", 0),
              x = g(r, "end", 0),
              y = g(r, "suffix", ""),
              z = g(r, "zeroPad", 0),
              A = g(r, "outputArray", []),
              B = g(r, "frames", !1),
              D = this.textureManager.get(q);
            if (!D) return A;
            if (r)
              for (B || (B = n(v, x)), r = 0; r < B.length; r++)
                (v = u + m(B[r], z, "0", 1) + y),
                  D.has(v)
                    ? A.push({
                        key: q,
                        frame: v,
                      })
                    : console.warn(
                        "generateFrameNames: Frame missing: " +
                          v +
                          " from texture: " +
                          q
                      );
            else
              for (B = D.getFrameNames(), r = 0; r < B.length; r++)
                A.push({
                  key: q,
                  frame: B[r],
                });
            return A;
          },
          generateFrameNumbers: function (q, r) {
            var u = g(r, "start", 0),
              v = g(r, "end", -1),
              x = g(r, "first", !1),
              y = g(r, "outputArray", []);
            r = g(r, "frames", !1);
            var z = this.textureManager.get(q);
            if (!z) return y;
            x &&
              z.has(x) &&
              y.push({
                key: q,
                frame: x,
              });
            r || (-1 === v && (v = z.frameTotal - 2), (r = n(u, v)));
            for (u = 0; u < r.length; u++)
              z.has(r[u])
                ? y.push({
                    key: q,
                    frame: r[u],
                  })
                : console.warn(
                    "generateFrameNumbers: Frame " +
                      u +
                      " missing from texture: " +
                      q
                  );
            return y;
          },
          get: function (q) {
            return this.anims.get(q);
          },
          pauseAll: function () {
            this.paused || ((this.paused = !0), this.emit(b.PAUSE_ALL));
            return this;
          },
          play: function (q, r) {
            Array.isArray(r) || (r = [r]);
            for (var u = 0; u < r.length; u++) r[u].anims.play(q);
            return this;
          },
          staggerPlay: function (q, r, u, v) {
            void 0 === u && (u = 0);
            void 0 === v && (v = !0);
            Array.isArray(r) || (r = [r]);
            var x = r.length;
            v || x--;
            for (v = 0; v < r.length; v++)
              r[v].anims.playAfterDelay(
                q,
                0 > u ? Math.abs(u) * (x - v) : u * v
              );
            return this;
          },
          remove: function (q) {
            var r = this.get(q);
            r &&
              (this.emit(b.REMOVE_ANIMATION, q, r),
              this.anims.delete(q),
              this.removeMix(q));
            return r;
          },
          resumeAll: function () {
            this.paused && ((this.paused = !1), this.emit(b.RESUME_ALL));
            return this;
          },
          toJSON: function (q) {
            var r = {
              anims: [],
              globalTimeScale: this.globalTimeScale,
            };
            void 0 !== q && "" !== q
              ? r.anims.push(this.anims.get(q).toJSON())
              : this.anims.each(function (u, v) {
                  r.anims.push(v.toJSON());
                });
            return r;
          },
          destroy: function () {
            this.anims.clear();
            this.mixes.clear();
            this.game = this.textureManager = null;
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          var b = [],
            c = !1;
          if (k || e) (c = !0), k || (k = ""), e || (e = "");
          if (d < a)
            for (; a >= d; a--) c ? b.push(k + a.toString() + e) : b.push(a);
          else for (; a <= d; a++) c ? b.push(k + a.toString() + e) : b.push(a);
          return b;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(102),
          k = a(9),
          e = a(324);
        a = new t({
          initialize: function () {
            this.entries = new d();
            this.events = new k();
          },
          add: function (b, c) {
            this.entries.set(b, c);
            this.events.emit(e.ADD, this, b, c);
            return this;
          },
          has: function (b) {
            return this.entries.has(b);
          },
          exists: function (b) {
            return this.entries.has(b);
          },
          get: function (b) {
            return this.entries.get(b);
          },
          remove: function (b) {
            var c = this.get(b);
            c &&
              (this.entries.delete(b),
              this.events.emit(e.REMOVE, this, b, c.data));
            return this;
          },
          getKeys: function () {
            return this.entries.keys();
          },
          destroy: function () {
            this.entries.clear();
            this.events.removeAllListeners();
            this.events = this.entries = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          ADD: a(736),
          REMOVE: a(737),
        };
      },
      function (h, t, a) {
        var d = a(323);
        t = a(0);
        var k = a(22);
        a = new t({
          initialize: function (e) {
            this.game = e;
            this.binary = new d();
            this.bitmapFont = new d();
            this.json = new d();
            this.physics = new d();
            this.shader = new d();
            this.audio = new d();
            this.video = new d();
            this.text = new d();
            this.html = new d();
            this.obj = new d();
            this.tilemap = new d();
            this.xml = new d();
            this.custom = {};
            this.game.events.once(k.DESTROY, this.destroy, this);
          },
          addCustom: function (e) {
            this.custom.hasOwnProperty(e) || (this.custom[e] = new d());
            return this.custom[e];
          },
          destroy: function () {
            for (
              var e =
                  "binary bitmapFont json physics shader audio video text html obj tilemap xml".split(
                    " "
                  ),
                b = 0;
              b < e.length;
              b++
            )
              this[e[b]].destroy(), (this[e[b]] = null);
            for (var c in this.custom) this.custom[c].destroy();
            this.game = this.custom = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(133),
          k = a(190),
          e = a(18);
        t = a(0);
        var b = a(11),
          c = a(333),
          f = a(37),
          g = a(135),
          m = a(10),
          n = a(3);
        a = new t({
          Extends: d,
          Mixins: [b.Flip, b.Tint, b.Pipeline],
          initialize: function (q, r, u, v) {
            d.call(this, q, r, u, v);
            this.postPipelines = [];
            this.pipelineData = {};
            this.inputEnabled = !0;
            this.fadeEffect = new c.Fade(this);
            this.flashEffect = new c.Flash(this);
            this.shakeEffect = new c.Shake(this);
            this.panEffect = new c.Pan(this);
            this.rotateToEffect = new c.RotateTo(this);
            this.zoomEffect = new c.Zoom(this);
            this.lerp = new n(1, 1);
            this.followOffset = new n();
            this._follow = this.deadzone = null;
          },
          setDeadzone: function (q, r) {
            if (void 0 === q) this.deadzone = null;
            else {
              this.deadzone
                ? ((this.deadzone.width = q), (this.deadzone.height = r))
                : (this.deadzone = new m(0, 0, q, r));
              if (this._follow) {
                q = this.width / 2;
                r = this.height / 2;
                var u = this._follow.x - this.followOffset.x,
                  v = this._follow.y - this.followOffset.y;
                this.midPoint.set(u, v);
                this.scrollX = u - q;
                this.scrollY = v - r;
              }
              k(this.deadzone, this.midPoint.x, this.midPoint.y);
            }
            return this;
          },
          fadeIn: function (q, r, u, v, x, y) {
            return this.fadeEffect.start(!1, q, r, u, v, !0, x, y);
          },
          fadeOut: function (q, r, u, v, x, y) {
            return this.fadeEffect.start(!0, q, r, u, v, !0, x, y);
          },
          fadeFrom: function (q, r, u, v, x, y, z) {
            return this.fadeEffect.start(!1, q, r, u, v, x, y, z);
          },
          fade: function (q, r, u, v, x, y, z) {
            return this.fadeEffect.start(!0, q, r, u, v, x, y, z);
          },
          flash: function (q, r, u, v, x, y, z) {
            return this.flashEffect.start(q, r, u, v, x, y, z);
          },
          shake: function (q, r, u, v, x) {
            return this.shakeEffect.start(q, r, u, v, x);
          },
          pan: function (q, r, u, v, x, y, z) {
            return this.panEffect.start(q, r, u, v, x, y, z);
          },
          rotateTo: function (q, r, u, v, x, y, z) {
            return this.rotateToEffect.start(q, r, u, v, x, y, z);
          },
          zoomTo: function (q, r, u, v, x, y) {
            return this.zoomEffect.start(q, r, u, v, x, y);
          },
          preRender: function () {
            this.renderList.length = 0;
            var q = this.width,
              r = this.height,
              u = 0.5 * q,
              v = 0.5 * r,
              x = this.zoom,
              y = this.matrix,
              z = q * this.originX,
              A = r * this.originY,
              B = this._follow,
              D = this.deadzone,
              E = this.scrollX,
              C = this.scrollY;
            D && k(D, this.midPoint.x, this.midPoint.y);
            var F = !1;
            if (B && !this.panEffect.isRunning) {
              F = B.x - this.followOffset.x;
              var G = B.y - this.followOffset.y;
              D
                ? (F < D.x
                    ? (E = g(E, E - (D.x - F), this.lerp.x))
                    : F > D.right && (E = g(E, E + (F - D.right), this.lerp.x)),
                  G < D.y
                    ? (C = g(C, C - (D.y - G), this.lerp.y))
                    : G > D.bottom &&
                      (C = g(C, C + (G - D.bottom), this.lerp.y)))
                : ((E = g(E, F - z, this.lerp.x)),
                  (C = g(C, G - A, this.lerp.y)));
              F = !0;
            }
            this.useBounds && ((E = this.clampX(E)), (C = this.clampY(C)));
            this.roundPixels &&
              ((z = Math.round(z)),
              (A = Math.round(A)),
              (E = Math.round(E)),
              (C = Math.round(C)));
            this.scrollX = E;
            this.scrollY = C;
            u = E + u;
            v = C + v;
            this.midPoint.set(u, v);
            q /= x;
            r /= x;
            C = u - q / 2;
            v -= r / 2;
            this.roundPixels && ((C = Math.round(C)), (v = Math.round(v)));
            this.worldView.setTo(C, v, q, r);
            y.applyITRS(this.x + z, this.y + A, this.rotation, x, x);
            y.translate(-z, -A);
            this.shakeEffect.preRender();
            F && this.emit(f.FOLLOW_UPDATE, this, B);
          },
          setLerp: function (q, r) {
            void 0 === q && (q = 1);
            void 0 === r && (r = q);
            this.lerp.set(q, r);
            return this;
          },
          setFollowOffset: function (q, r) {
            void 0 === q && (q = 0);
            void 0 === r && (r = 0);
            this.followOffset.set(q, r);
            return this;
          },
          startFollow: function (q, r, u, v, x, y) {
            void 0 === r && (r = !1);
            void 0 === u && (u = 1);
            void 0 === v && (v = u);
            void 0 === x && (x = 0);
            void 0 === y && (y = x);
            this._follow = q;
            this.roundPixels = r;
            u = e(u, 0, 1);
            v = e(v, 0, 1);
            this.lerp.set(u, v);
            this.followOffset.set(x, y);
            r = this.width / 2;
            u = this.height / 2;
            x = q.x - x;
            q = q.y - y;
            this.midPoint.set(x, q);
            this.scrollX = x - r;
            this.scrollY = q - u;
            this.useBounds &&
              ((this.scrollX = this.clampX(this.scrollX)),
              (this.scrollY = this.clampY(this.scrollY)));
            return this;
          },
          stopFollow: function () {
            this._follow = null;
            return this;
          },
          resetFX: function () {
            this.rotateToEffect.reset();
            this.panEffect.reset();
            this.shakeEffect.reset();
            this.flashEffect.reset();
            this.fadeEffect.reset();
            return this;
          },
          update: function (q, r) {
            this.visible &&
              (this.rotateToEffect.update(q, r),
              this.panEffect.update(q, r),
              this.zoomEffect.update(q, r),
              this.shakeEffect.update(q, r),
              this.flashEffect.update(q, r),
              this.fadeEffect.update(q, r));
          },
          destroy: function () {
            this.resetFX();
            d.prototype.destroy.call(this);
            this.deadzone = this._follow = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(38);
        h.exports = function (k) {
          var e = new d();
          k = k.replace(
            /^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i,
            function (f, g, m, n) {
              return g + g + m + m + n + n;
            }
          );
          var b = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(k);
          if (b) {
            k = parseInt(b[1], 16);
            var c = parseInt(b[2], 16);
            b = parseInt(b[3], 16);
            e.setTo(k, c, b);
          }
          return e;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          return (e << 24) | (a << 16) | (d << 8) | k;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          void 0 === e &&
            (e = {
              h: 0,
              s: 0,
              v: 0,
            });
          a /= 255;
          d /= 255;
          k /= 255;
          var b = Math.min(a, d, k),
            c = Math.max(a, d, k),
            f = c - b,
            g = 0,
            m = 0 === c ? 0 : f / c;
          c !== b &&
            (c === a
              ? (g = (d - k) / f + (d < k ? 6 : 0))
              : c === d
              ? (g = (k - a) / f + 2)
              : c === k && (g = (a - d) / f + 4),
            (g /= 6));
          e.hasOwnProperty("_h")
            ? ((e._h = g), (e._s = m), (e._v = c))
            : ((e.h = g), (e.s = m), (e.v = c));
          return e;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 16777215 < a
            ? {
                a: a >>> 24,
                r: (a >> 16) & 255,
                g: (a >> 8) & 255,
                b: a & 255,
              }
            : {
                a: 255,
                r: (a >> 16) & 255,
                g: (a >> 8) & 255,
                b: a & 255,
              };
        };
      },
      function (h, t, a) {
        var d = a(38);
        h.exports = function (k) {
          return new d(k.r, k.g, k.b, k.a);
        };
      },
      function (h, t, a) {
        var d = a(38);
        h.exports = function (k) {
          var e = new d(),
            b =
              /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(
                k.toLowerCase()
              );
          if (b) {
            k = parseInt(b[1], 10);
            var c = parseInt(b[2], 10),
              f = parseInt(b[3], 10);
            b = void 0 !== b[4] ? parseFloat(b[4]) : 1;
            e.setTo(k, c, f, 255 * b);
          }
          return e;
        };
      },
      function (h, t, a) {
        h.exports = {
          Fade: a(761),
          Flash: a(762),
          Pan: a(763),
          Shake: a(796),
          RotateTo: a(797),
          Zoom: a(798),
        };
      },
      function (h, t, a) {
        h.exports = {
          In: a(764),
          Out: a(765),
          InOut: a(766),
        };
      },
      function (h, t, a) {
        h.exports = {
          In: a(767),
          Out: a(768),
          InOut: a(769),
        };
      },
      function (h, t, a) {
        h.exports = {
          In: a(770),
          Out: a(771),
          InOut: a(772),
        };
      },
      function (h, t, a) {
        h.exports = {
          In: a(773),
          Out: a(774),
          InOut: a(775),
        };
      },
      function (h, t, a) {
        h.exports = {
          In: a(776),
          Out: a(777),
          InOut: a(778),
        };
      },
      function (h, t, a) {
        h.exports = {
          In: a(779),
          Out: a(780),
          InOut: a(781),
        };
      },
      function (h, t, a) {
        h.exports = a(782);
      },
      function (h, t, a) {
        h.exports = {
          In: a(783),
          Out: a(784),
          InOut: a(785),
        };
      },
      function (h, t, a) {
        h.exports = {
          In: a(786),
          Out: a(787),
          InOut: a(788),
        };
      },
      function (h, t, a) {
        h.exports = {
          In: a(789),
          Out: a(790),
          InOut: a(791),
        };
      },
      function (h, t, a) {
        h.exports = {
          In: a(792),
          Out: a(793),
          InOut: a(794),
        };
      },
      function (h, t, a) {
        h.exports = a(795);
      },
      function (h, t, a) {
        t = a(0);
        var d = a(33),
          k = a(347),
          e = a(2),
          b = a(6),
          c = a(7),
          f = a(193),
          g = a(1),
          m = a(197),
          n = a(187);
        a = new t({
          initialize: function (q) {
            void 0 === q && (q = {});
            this.width = b(q, "width", 1024);
            this.height = b(q, "height", 768);
            this.zoom = b(q, "zoom", 1);
            this.parent = b(q, "parent", void 0);
            this.scaleMode = b(q, "scaleMode", 0);
            this.expandParent = b(q, "expandParent", !0);
            this.autoRound = b(q, "autoRound", !1);
            this.autoCenter = b(q, "autoCenter", 0);
            this.resizeInterval = b(q, "resizeInterval", 500);
            this.fullscreenTarget = b(q, "fullscreenTarget", null);
            this.minWidth = b(q, "minWidth", 0);
            this.maxWidth = b(q, "maxWidth", 0);
            this.minHeight = b(q, "minHeight", 0);
            this.maxHeight = b(q, "maxHeight", 0);
            var r = b(q, "scale", null);
            r &&
              ((this.width = b(r, "width", this.width)),
              (this.height = b(r, "height", this.height)),
              (this.zoom = b(r, "zoom", this.zoom)),
              (this.parent = b(r, "parent", this.parent)),
              (this.scaleMode = b(r, "mode", this.scaleMode)),
              (this.expandParent = b(r, "expandParent", this.expandParent)),
              (this.autoRound = b(r, "autoRound", this.autoRound)),
              (this.autoCenter = b(r, "autoCenter", this.autoCenter)),
              (this.resizeInterval = b(
                r,
                "resizeInterval",
                this.resizeInterval
              )),
              (this.fullscreenTarget = b(
                r,
                "fullscreenTarget",
                this.fullscreenTarget
              )),
              (this.minWidth = b(r, "min.width", this.minWidth)),
              (this.maxWidth = b(r, "max.width", this.maxWidth)),
              (this.minHeight = b(r, "min.height", this.minHeight)),
              (this.maxHeight = b(r, "max.height", this.maxHeight)));
            this.renderType = b(q, "type", d.AUTO);
            this.canvas = b(q, "canvas", null);
            this.context = b(q, "context", null);
            this.canvasStyle = b(q, "canvasStyle", null);
            this.customEnvironment = b(q, "customEnvironment", !1);
            this.sceneConfig = b(q, "scene", null);
            this.seed = b(q, "seed", [(Date.now() * Math.random()).toString()]);
            f.RND = new f.RandomDataGenerator(this.seed);
            this.gameTitle = b(q, "title", "");
            this.gameURL = b(q, "url", "https://phaser.io");
            this.gameVersion = b(q, "version", "");
            this.autoFocus = b(q, "autoFocus", !0);
            this.domCreateContainer = b(q, "dom.createContainer", !1);
            this.domBehindCanvas = b(q, "dom.behindCanvas", !1);
            this.domPointerEvents = b(q, "dom.pointerEvents", "none");
            this.inputKeyboard = b(q, "input.keyboard", !0);
            this.inputKeyboardEventTarget = b(
              q,
              "input.keyboard.target",
              window
            );
            this.inputKeyboardCapture = b(q, "input.keyboard.capture", []);
            this.inputMouse = b(q, "input.mouse", !0);
            this.inputMouseEventTarget = b(q, "input.mouse.target", null);
            this.inputMousePreventDefaultDown = b(
              q,
              "input.mouse.preventDefaultDown",
              !0
            );
            this.inputMousePreventDefaultUp = b(
              q,
              "input.mouse.preventDefaultUp",
              !0
            );
            this.inputMousePreventDefaultMove = b(
              q,
              "input.mouse.preventDefaultMove",
              !0
            );
            this.inputMousePreventDefaultWheel = b(
              q,
              "input.mouse.preventDefaultWheel",
              !0
            );
            this.inputTouch = b(q, "input.touch", k.input.touch);
            this.inputTouchEventTarget = b(q, "input.touch.target", null);
            this.inputTouchCapture = b(q, "input.touch.capture", !0);
            this.inputActivePointers = b(q, "input.activePointers", 1);
            this.inputSmoothFactor = b(q, "input.smoothFactor", 0);
            this.inputWindowEvents = b(q, "input.windowEvents", !0);
            this.inputGamepad = b(q, "input.gamepad", !1);
            this.inputGamepadEventTarget = b(q, "input.gamepad.target", window);
            this.disableContextMenu = b(q, "disableContextMenu", !1);
            this.audio = b(q, "audio", {});
            this.hideBanner = !1 === b(q, "banner", null);
            this.hidePhaser = b(q, "banner.hidePhaser", !1);
            this.bannerTextColor = b(q, "banner.text", "#ffffff");
            this.bannerBackgroundColor = b(q, "banner.background", [
              "#ff0000",
              "#ffff00",
              "#00ff00",
              "#00ffff",
              "#000000",
            ]);
            "" === this.gameTitle && this.hidePhaser && (this.hideBanner = !0);
            this.fps = b(q, "fps", null);
            r = b(q, "render", q);
            this.pipeline = b(r, "pipeline", null);
            this.antialias = b(r, "antialias", !0);
            this.antialiasGL = b(r, "antialiasGL", !0);
            this.mipmapFilter = b(r, "mipmapFilter", "LINEAR");
            this.desynchronized = b(r, "desynchronized", !1);
            this.roundPixels = b(r, "roundPixels", !1);
            if ((this.pixelArt = b(r, "pixelArt", 1 !== this.zoom)))
              (this.antialiasGL = this.antialias = !1), (this.roundPixels = !0);
            this.transparent = b(r, "transparent", !1);
            this.clearBeforeRender = b(r, "clearBeforeRender", !0);
            this.preserveDrawingBuffer = b(r, "preserveDrawingBuffer", !1);
            this.premultipliedAlpha = b(r, "premultipliedAlpha", !0);
            this.failIfMajorPerformanceCaveat = b(
              r,
              "failIfMajorPerformanceCaveat",
              !1
            );
            this.powerPreference = b(r, "powerPreference", "default");
            this.batchSize = b(r, "batchSize", 4096);
            this.maxTextures = b(r, "maxTextures", -1);
            this.maxLights = b(r, "maxLights", 10);
            r = b(q, "backgroundColor", 0);
            this.backgroundColor = n(r);
            this.transparent &&
              ((this.backgroundColor = n(0)), (this.backgroundColor.alpha = 0));
            this.preBoot = b(q, "callbacks.preBoot", g);
            this.postBoot = b(q, "callbacks.postBoot", g);
            this.physics = b(q, "physics", {});
            this.defaultPhysicsSystem = b(this.physics, "default", !1);
            this.loaderBaseURL = b(q, "loader.baseURL", "");
            this.loaderPath = b(q, "loader.path", "");
            this.loaderMaxParallelDownloads = b(
              q,
              "loader.maxParallelDownloads",
              k.os.android ? 6 : 32
            );
            this.loaderCrossOrigin = b(q, "loader.crossOrigin", void 0);
            this.loaderResponseType = b(q, "loader.responseType", "");
            this.loaderAsync = b(q, "loader.async", !0);
            this.loaderUser = b(q, "loader.user", "");
            this.loaderPassword = b(q, "loader.password", "");
            this.loaderTimeout = b(q, "loader.timeout", 0);
            this.loaderWithCredentials = b(q, "loader.withCredentials", !1);
            this.installGlobalPlugins = [];
            this.installScenePlugins = [];
            r = b(q, "plugins", null);
            var u = m.DefaultScene;
            r &&
              (Array.isArray(r)
                ? (this.defaultPlugins = r)
                : c(r) &&
                  ((this.installGlobalPlugins = e(r, "global", [])),
                  (this.installScenePlugins = e(r, "scene", [])),
                  Array.isArray(r.default)
                    ? (u = r.default)
                    : Array.isArray(r.defaultMerge) &&
                      (u = u.concat(r.defaultMerge))));
            this.defaultPlugins = u;
            this.defaultImage = b(
              q,
              "images.default",
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg=="
            );
            this.missingImage = b(
              q,
              "images.missing",
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg=="
            );
            this.whiteImage = b(
              q,
              "images.white",
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABdJREFUeNpi/P//PwMMMDEgAdwcgAADAJZuAwXJYZOzAAAAAElFTkSuQmCC"
            );
            window &&
              (window.FORCE_WEBGL
                ? (this.renderType = d.WEBGL)
                : window.FORCE_CANVAS && (this.renderType = d.CANVAS));
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          os: a(105),
          browser: a(136),
          features: a(191),
          input: a(808),
          audio: a(809),
          video: a(810),
          fullscreen: a(811),
          canvasFeatures: a(348),
        };
      },
      function (h, t, a) {
        function d() {
          var c = new Image();
          c.onload = function () {
            var f = new Image();
            f.onload = function () {
              var g = e.create(f, 6, 1).getContext("2d");
              g.globalCompositeOperation = "multiply";
              g.drawImage(c, 0, 0);
              g.drawImage(f, 2, 0);
              if (!g.getImageData(2, 0, 1, 1)) return !1;
              g = g.getImageData(2, 0, 1, 1).data;
              e.remove(f);
              b.supportNewBlendModes = 255 === g[0] && 0 === g[1] && 0 === g[2];
            };
            f.src =
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX//wCKxvRFAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==";
          };
          c.src =
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/AP804Oa6AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==";
          return !1;
        }

        function k() {
          var c = e.create(this, 2, 1).getContext("2d");
          c.fillStyle = "rgba(10, 20, 30, 0.5)";
          c.fillRect(0, 0, 1, 1);
          var f = c.getImageData(0, 0, 1, 1);
          if (null === f) return !1;
          c.putImageData(f, 1, 0);
          c = c.getImageData(1, 0, 1, 1);
          return (
            c.data[0] === f.data[0] &&
            c.data[1] === f.data[1] &&
            c.data[2] === f.data[2] &&
            c.data[3] === f.data[3]
          );
        }
        var e = a(31),
          b = {
            supportInverseAlpha: !1,
            supportNewBlendModes: !1,
          };
        "function" !== typeof importScripts &&
          void 0 !== document &&
          ((b.supportNewBlendModes = d()), (b.supportInverseAlpha = k()));
        h.exports = b;
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          return Math.atan2(e - d, k - a);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return Math.atan2(d.y - a.y, d.x - a.x);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          a %= 2 * Math.PI;
          return 0 <= a ? a : a + 2 * Math.PI;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          var k = a.x - d.x;
          a = a.y - d.y;
          return Math.sqrt(k * k + a * a);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          a -= k;
          d -= e;
          return a * a + d * d;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          void 0 === k && (k = 1e-4);
          return a > d - k;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          void 0 === k && (k = 1e-4);
          return a < d + k;
        };
      },
      function (h, t, a) {
        var d = a(357);
        h.exports = function (k, e) {
          return d(k) / d(e) / d(k - e);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          if (0 === a) return 1;
          for (var d = a; --a; ) d *= a;
          return d;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b) {
          var c = 1 - a,
            f = 1 - a;
          return (
            c * c * c * d +
            3 * f * f * a * k +
            3 * (1 - a) * a * a * e +
            a * a * a * b
          );
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          var b = 1 - a;
          return b * b * d + 2 * (1 - a) * a * k + a * a * e;
        };
      },
      function (h, t, a) {
        var d = a(184);
        h.exports = function (k, e, b) {
          return e + (b - e) * d(k, 0, 1);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 1 << Math.ceil(Math.log(a) / 0.6931471805599453);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          var k = a.x,
            e = a.y;
          a.x = k * Math.cos(d) - e * Math.sin(d);
          a.y = k * Math.sin(d) + e * Math.cos(d);
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 0 < a ? Math.ceil(a) : Math.floor(a);
        };
      },
      function (h, t, a) {
        var d = new (a(0))({
          initialize: function (k) {
            this.val = new Float32Array(9);
            k ? this.copy(k) : this.identity();
          },
          clone: function () {
            return new d(this);
          },
          set: function (k) {
            return this.copy(k);
          },
          copy: function (k) {
            var e = this.val;
            k = k.val;
            e[0] = k[0];
            e[1] = k[1];
            e[2] = k[2];
            e[3] = k[3];
            e[4] = k[4];
            e[5] = k[5];
            e[6] = k[6];
            e[7] = k[7];
            e[8] = k[8];
            return this;
          },
          fromMat4: function (k) {
            k = k.val;
            var e = this.val;
            e[0] = k[0];
            e[1] = k[1];
            e[2] = k[2];
            e[3] = k[4];
            e[4] = k[5];
            e[5] = k[6];
            e[6] = k[8];
            e[7] = k[9];
            e[8] = k[10];
            return this;
          },
          fromArray: function (k) {
            var e = this.val;
            e[0] = k[0];
            e[1] = k[1];
            e[2] = k[2];
            e[3] = k[3];
            e[4] = k[4];
            e[5] = k[5];
            e[6] = k[6];
            e[7] = k[7];
            e[8] = k[8];
            return this;
          },
          identity: function () {
            var k = this.val;
            k[0] = 1;
            k[1] = 0;
            k[2] = 0;
            k[3] = 0;
            k[4] = 1;
            k[5] = 0;
            k[6] = 0;
            k[7] = 0;
            k[8] = 1;
            return this;
          },
          transpose: function () {
            var k = this.val,
              e = k[1],
              b = k[2],
              c = k[5];
            k[1] = k[3];
            k[2] = k[6];
            k[3] = e;
            k[5] = k[7];
            k[6] = b;
            k[7] = c;
            return this;
          },
          invert: function () {
            var k = this.val,
              e = k[0],
              b = k[1],
              c = k[2],
              f = k[3],
              g = k[4],
              m = k[5],
              n = k[6],
              q = k[7],
              r = k[8],
              u = r * g - m * q,
              v = -r * f + m * n,
              x = q * f - g * n,
              y = e * u + b * v + c * x;
            if (!y) return null;
            y = 1 / y;
            k[0] = u * y;
            k[1] = (-r * b + c * q) * y;
            k[2] = (m * b - c * g) * y;
            k[3] = v * y;
            k[4] = (r * e - c * n) * y;
            k[5] = (-m * e + c * f) * y;
            k[6] = x * y;
            k[7] = (-q * e + b * n) * y;
            k[8] = (g * e - b * f) * y;
            return this;
          },
          adjoint: function () {
            var k = this.val,
              e = k[0],
              b = k[1],
              c = k[2],
              f = k[3],
              g = k[4],
              m = k[5],
              n = k[6],
              q = k[7],
              r = k[8];
            k[0] = g * r - m * q;
            k[1] = c * q - b * r;
            k[2] = b * m - c * g;
            k[3] = m * n - f * r;
            k[4] = e * r - c * n;
            k[5] = c * f - e * m;
            k[6] = f * q - g * n;
            k[7] = b * n - e * q;
            k[8] = e * g - b * f;
            return this;
          },
          determinant: function () {
            var k = this.val,
              e = k[3],
              b = k[4],
              c = k[5],
              f = k[6],
              g = k[7],
              m = k[8];
            return (
              k[0] * (m * b - c * g) +
              k[1] * (-m * e + c * f) +
              k[2] * (g * e - b * f)
            );
          },
          multiply: function (k) {
            var e = this.val,
              b = e[0],
              c = e[1],
              f = e[2],
              g = e[3],
              m = e[4],
              n = e[5],
              q = e[6],
              r = e[7],
              u = e[8],
              v = k.val;
            k = v[0];
            var x = v[1],
              y = v[2],
              z = v[3],
              A = v[4],
              B = v[5],
              D = v[6],
              E = v[7];
            v = v[8];
            e[0] = k * b + x * g + y * q;
            e[1] = k * c + x * m + y * r;
            e[2] = k * f + x * n + y * u;
            e[3] = z * b + A * g + B * q;
            e[4] = z * c + A * m + B * r;
            e[5] = z * f + A * n + B * u;
            e[6] = D * b + E * g + v * q;
            e[7] = D * c + E * m + v * r;
            e[8] = D * f + E * n + v * u;
            return this;
          },
          translate: function (k) {
            var e = this.val,
              b = k.x;
            k = k.y;
            e[6] = b * e[0] + k * e[3] + e[6];
            e[7] = b * e[1] + k * e[4] + e[7];
            e[8] = b * e[2] + k * e[5] + e[8];
            return this;
          },
          rotate: function (k) {
            var e = this.val,
              b = e[0],
              c = e[1],
              f = e[2],
              g = e[3],
              m = e[4],
              n = e[5],
              q = Math.sin(k);
            k = Math.cos(k);
            e[0] = k * b + q * g;
            e[1] = k * c + q * m;
            e[2] = k * f + q * n;
            e[3] = k * g - q * b;
            e[4] = k * m - q * c;
            e[5] = k * n - q * f;
            return this;
          },
          scale: function (k) {
            var e = this.val,
              b = k.x;
            k = k.y;
            e[0] *= b;
            e[1] *= b;
            e[2] *= b;
            e[3] *= k;
            e[4] *= k;
            e[5] *= k;
            return this;
          },
          fromQuat: function (k) {
            var e = k.x,
              b = k.y,
              c = k.z,
              f = k.w,
              g = e + e,
              m = b + b,
              n = c + c;
            k = e * g;
            var q = e * m;
            e *= n;
            var r = b * m;
            b *= n;
            c *= n;
            g *= f;
            m *= f;
            f *= n;
            n = this.val;
            n[0] = 1 - (r + c);
            n[3] = q + f;
            n[6] = e - m;
            n[1] = q - f;
            n[4] = 1 - (k + c);
            n[7] = b + g;
            n[2] = e + m;
            n[5] = b - g;
            n[8] = 1 - (k + r);
            return this;
          },
          normalFromMat4: function (k) {
            var e = k.val;
            k = this.val;
            var b = e[0],
              c = e[1],
              f = e[2],
              g = e[3],
              m = e[4],
              n = e[5],
              q = e[6],
              r = e[7],
              u = e[8],
              v = e[9],
              x = e[10],
              y = e[11],
              z = e[12],
              A = e[13],
              B = e[14];
            e = e[15];
            var D = b * n - c * m,
              E = b * q - f * m,
              C = b * r - g * m,
              F = c * q - f * n,
              G = c * r - g * n,
              H = f * r - g * q,
              K = u * A - v * z,
              I = u * B - x * z;
            u = u * e - y * z;
            var M = v * B - x * A;
            v = v * e - y * A;
            x = x * e - y * B;
            y = D * x - E * v + C * M + F * u - G * I + H * K;
            if (!y) return null;
            y = 1 / y;
            k[0] = (n * x - q * v + r * M) * y;
            k[1] = (q * u - m * x - r * I) * y;
            k[2] = (m * v - n * u + r * K) * y;
            k[3] = (f * v - c * x - g * M) * y;
            k[4] = (b * x - f * u + g * I) * y;
            k[5] = (c * u - b * v - g * K) * y;
            k[6] = (A * H - B * G + e * F) * y;
            k[7] = (B * C - z * H - e * E) * y;
            k[8] = (z * G - A * C + e * D) * y;
            return this;
          },
        });
        h.exports = d;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(364),
          k = a(1);
        a = a(39);
        var e = new Int8Array([1, 2, 0]),
          b = new Float32Array([0, 0, 0]),
          c = new a(1, 0, 0),
          f = new a(0, 1, 0),
          g = new a(),
          m = new d();
        a = new t({
          initialize: function (n, q, r, u) {
            this.onChangeCallback = k;
            this.set(n, q, r, u);
          },
          x: {
            get: function () {
              return this._x;
            },
            set: function (n) {
              this._x = n;
              this.onChangeCallback(this);
            },
          },
          y: {
            get: function () {
              return this._y;
            },
            set: function (n) {
              this._y = n;
              this.onChangeCallback(this);
            },
          },
          z: {
            get: function () {
              return this._z;
            },
            set: function (n) {
              this._z = n;
              this.onChangeCallback(this);
            },
          },
          w: {
            get: function () {
              return this._w;
            },
            set: function (n) {
              this._w = n;
              this.onChangeCallback(this);
            },
          },
          copy: function (n) {
            return this.set(n);
          },
          set: function (n, q, r, u, v) {
            void 0 === v && (v = !0);
            "object" === typeof n
              ? ((this._x = n.x || 0),
                (this._y = n.y || 0),
                (this._z = n.z || 0),
                (this._w = n.w || 0))
              : ((this._x = n || 0),
                (this._y = q || 0),
                (this._z = r || 0),
                (this._w = u || 0));
            if (v) this.onChangeCallback(this);
            return this;
          },
          add: function (n) {
            this._x += n.x;
            this._y += n.y;
            this._z += n.z;
            this._w += n.w;
            this.onChangeCallback(this);
            return this;
          },
          subtract: function (n) {
            this._x -= n.x;
            this._y -= n.y;
            this._z -= n.z;
            this._w -= n.w;
            this.onChangeCallback(this);
            return this;
          },
          scale: function (n) {
            this._x *= n;
            this._y *= n;
            this._z *= n;
            this._w *= n;
            this.onChangeCallback(this);
            return this;
          },
          length: function () {
            var n = this.x,
              q = this.y,
              r = this.z,
              u = this.w;
            return Math.sqrt(n * n + q * q + r * r + u * u);
          },
          lengthSq: function () {
            var n = this.x,
              q = this.y,
              r = this.z,
              u = this.w;
            return n * n + q * q + r * r + u * u;
          },
          normalize: function () {
            var n = this.x,
              q = this.y,
              r = this.z,
              u = this.w,
              v = n * n + q * q + r * r + u * u;
            0 < v &&
              ((v = 1 / Math.sqrt(v)),
              (this._x = n * v),
              (this._y = q * v),
              (this._z = r * v),
              (this._w = u * v));
            this.onChangeCallback(this);
            return this;
          },
          dot: function (n) {
            return this.x * n.x + this.y * n.y + this.z * n.z + this.w * n.w;
          },
          lerp: function (n, q) {
            void 0 === q && (q = 0);
            var r = this.x,
              u = this.y,
              v = this.z,
              x = this.w;
            return this.set(
              r + q * (n.x - r),
              u + q * (n.y - u),
              v + q * (n.z - v),
              x + q * (n.w - x)
            );
          },
          rotationTo: function (n, q) {
            var r = n.x * q.x + n.y * q.y + n.z * q.z;
            if (-0.999999 > r)
              return (
                1e-6 > g.copy(c).cross(n).length() && g.copy(f).cross(n),
                g.normalize(),
                this.setAxisAngle(g, Math.PI)
              );
            if (0.999999 < r) return this.set(0, 0, 0, 1);
            g.copy(n).cross(q);
            this._x = g.x;
            this._y = g.y;
            this._z = g.z;
            this._w = 1 + r;
            return this.normalize();
          },
          setAxes: function (n, q, r) {
            var u = m.val;
            u[0] = q.x;
            u[3] = q.y;
            u[6] = q.z;
            u[1] = r.x;
            u[4] = r.y;
            u[7] = r.z;
            u[2] = -n.x;
            u[5] = -n.y;
            u[8] = -n.z;
            return this.fromMat3(m).normalize();
          },
          identity: function () {
            return this.set(0, 0, 0, 1);
          },
          setAxisAngle: function (n, q) {
            q *= 0.5;
            var r = Math.sin(q);
            return this.set(r * n.x, r * n.y, r * n.z, Math.cos(q));
          },
          multiply: function (n) {
            var q = this.x,
              r = this.y,
              u = this.z,
              v = this.w,
              x = n.x,
              y = n.y,
              z = n.z;
            n = n.w;
            return this.set(
              q * n + v * x + r * z - u * y,
              r * n + v * y + u * x - q * z,
              u * n + v * z + q * y - r * x,
              v * n - q * x - r * y - u * z
            );
          },
          slerp: function (n, q) {
            var r = this.x,
              u = this.y,
              v = this.z,
              x = this.w,
              y = n.x,
              z = n.y,
              A = n.z;
            n = n.w;
            var B = r * y + u * z + v * A + x * n;
            0 > B && ((B = -B), (y = -y), (z = -z), (A = -A), (n = -n));
            var D = 1 - q,
              E = q;
            1e-6 < 1 - B &&
              ((B = Math.acos(B)),
              (E = Math.sin(B)),
              (D = Math.sin((1 - q) * B) / E),
              (E = Math.sin(q * B) / E));
            return this.set(
              D * r + E * y,
              D * u + E * z,
              D * v + E * A,
              D * x + E * n
            );
          },
          invert: function () {
            var n = this.x,
              q = this.y,
              r = this.z,
              u = this.w,
              v = n * n + q * q + r * r + u * u;
            v = v ? 1 / v : 0;
            return this.set(-n * v, -q * v, -r * v, u * v);
          },
          conjugate: function () {
            this._x = -this.x;
            this._y = -this.y;
            this._z = -this.z;
            this.onChangeCallback(this);
            return this;
          },
          rotateX: function (n) {
            n *= 0.5;
            var q = this.x,
              r = this.y,
              u = this.z,
              v = this.w,
              x = Math.sin(n);
            n = Math.cos(n);
            return this.set(
              q * n + v * x,
              r * n + u * x,
              u * n - r * x,
              v * n - q * x
            );
          },
          rotateY: function (n) {
            n *= 0.5;
            var q = this.x,
              r = this.y,
              u = this.z,
              v = this.w,
              x = Math.sin(n);
            n = Math.cos(n);
            return this.set(
              q * n - u * x,
              r * n + v * x,
              u * n + q * x,
              v * n - r * x
            );
          },
          rotateZ: function (n) {
            n *= 0.5;
            var q = this.x,
              r = this.y,
              u = this.z,
              v = this.w,
              x = Math.sin(n);
            n = Math.cos(n);
            return this.set(
              q * n + r * x,
              r * n - q * x,
              u * n + v * x,
              v * n - u * x
            );
          },
          calculateW: function () {
            var n = this.x,
              q = this.y,
              r = this.z;
            this.w = -Math.sqrt(1 - n * n - q * q - r * r);
            return this;
          },
          setFromEuler: function (n, q) {
            var r = n.x / 2,
              u = n.y / 2,
              v = n.z / 2,
              x = Math.cos(r),
              y = Math.cos(u),
              z = Math.cos(v);
            r = Math.sin(r);
            u = Math.sin(u);
            v = Math.sin(v);
            switch (n.order) {
              case "XYZ":
                this.set(
                  r * y * z + x * u * v,
                  x * u * z - r * y * v,
                  x * y * v + r * u * z,
                  x * y * z - r * u * v,
                  q
                );
                break;
              case "YXZ":
                this.set(
                  r * y * z + x * u * v,
                  x * u * z - r * y * v,
                  x * y * v - r * u * z,
                  x * y * z + r * u * v,
                  q
                );
                break;
              case "ZXY":
                this.set(
                  r * y * z - x * u * v,
                  x * u * z + r * y * v,
                  x * y * v + r * u * z,
                  x * y * z - r * u * v,
                  q
                );
                break;
              case "ZYX":
                this.set(
                  r * y * z - x * u * v,
                  x * u * z + r * y * v,
                  x * y * v - r * u * z,
                  x * y * z + r * u * v,
                  q
                );
                break;
              case "YZX":
                this.set(
                  r * y * z + x * u * v,
                  x * u * z + r * y * v,
                  x * y * v - r * u * z,
                  x * y * z - r * u * v,
                  q
                );
                break;
              case "XZY":
                this.set(
                  r * y * z - x * u * v,
                  x * u * z - r * y * v,
                  x * y * v + r * u * z,
                  x * y * z + r * u * v,
                  q
                );
            }
            return this;
          },
          setFromRotationMatrix: function (n) {
            var q = n.val,
              r = q[0];
            n = q[4];
            var u = q[8],
              v = q[1],
              x = q[5],
              y = q[9],
              z = q[2],
              A = q[6];
            q = q[10];
            var B = r + x + q;
            0 < B
              ? ((r = 0.5 / Math.sqrt(B + 1)),
                this.set((A - y) * r, (u - z) * r, (v - n) * r, 0.25 / r))
              : r > x && r > q
              ? ((r = 2 * Math.sqrt(1 + r - x - q)),
                this.set(0.25 * r, (n + v) / r, (u + z) / r, (A - y) / r))
              : x > q
              ? ((r = 2 * Math.sqrt(1 + x - r - q)),
                this.set((n + v) / r, 0.25 * r, (y + A) / r, (u - z) / r))
              : ((r = 2 * Math.sqrt(1 + q - r - x)),
                this.set((u + z) / r, (y + A) / r, 0.25 * r, (v - n) / r));
            return this;
          },
          fromMat3: function (n) {
            n = n.val;
            var q = n[0] + n[4] + n[8];
            if (0 < q)
              (q = Math.sqrt(q + 1)),
                (this.w = 0.5 * q),
                (q = 0.5 / q),
                (this._x = (n[7] - n[5]) * q),
                (this._y = (n[2] - n[6]) * q),
                (this._z = (n[3] - n[1]) * q);
            else {
              var r = 0;
              n[4] > n[0] && (r = 1);
              n[8] > n[3 * r + r] && (r = 2);
              var u = e[r],
                v = e[u];
              q = Math.sqrt(n[3 * r + r] - n[3 * u + u] - n[3 * v + v] + 1);
              b[r] = 0.5 * q;
              q = 0.5 / q;
              b[u] = (n[3 * u + r] + n[3 * r + u]) * q;
              b[v] = (n[3 * v + r] + n[3 * r + v]) * q;
              this._x = b[0];
              this._y = b[1];
              this._z = b[2];
              this._w = (n[3 * v + u] - n[3 * u + v]) * q;
            }
            this.onChangeCallback(this);
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(367),
          k = a(31),
          e = a(33),
          b = a(191);
        h.exports = function (c) {
          var f = c.config;
          if ((f.customEnvironment || f.canvas) && f.renderType === e.AUTO)
            throw Error("Must set explicit renderType in custom environment");
          if (!f.customEnvironment && !f.canvas && f.renderType !== e.HEADLESS)
            if (
              f.renderType === e.CANVAS ||
              (f.renderType !== e.CANVAS && !b.webGL)
            )
              if (b.canvas) f.renderType = e.CANVAS;
              else
                throw Error("Cannot create Canvas or WebGL context, aborting.");
            else f.renderType = e.WEBGL;
          f.antialias || k.disableSmoothing();
          var g = c.scale.baseSize,
            m = g.width;
          g = g.height;
          f.canvas
            ? ((c.canvas = f.canvas),
              (c.canvas.width = m),
              (c.canvas.height = g))
            : (c.canvas = k.create(c, m, g, f.renderType));
          f.canvasStyle && (c.canvas.style = f.canvasStyle);
          f.antialias || d.setCrisp(c.canvas);
          f.renderType !== e.HEADLESS &&
            ((m = a(368)),
            (g = a(371)),
            f.renderType === e.WEBGL
              ? (c.renderer = new g(c))
              : ((c.renderer = new m(c)),
                (c.context = c.renderer.gameContext)));
        };
      },
      function (h, t) {
        h.exports = {
          setCrisp: function (a) {
            "optimizeSpeed -moz-crisp-edges -o-crisp-edges -webkit-optimize-contrast optimize-contrast crisp-edges pixelated"
              .split(" ")
              .forEach(function (d) {
                a.style["image-rendering"] = d;
              });
            a.style.msInterpolationMode = "nearest-neighbor";
            return a;
          },
          setBicubic: function (a) {
            a.style["image-rendering"] = "auto";
            a.style.msInterpolationMode = "bicubic";
            return a;
          },
        };
      },
      function (h, t, a) {
        var d = a(37),
          k = a(369);
        t = a(0);
        var e = a(33),
          b = a(9),
          c = a(91),
          f = a(370),
          g = a(104),
          m = a(106),
          n = a(25);
        a = new t({
          Extends: b,
          initialize: function (q) {
            b.call(this);
            var r = q.config;
            this.config = {
              clearBeforeRender: r.clearBeforeRender,
              backgroundColor: r.backgroundColor,
              antialias: r.antialias,
              roundPixels: r.roundPixels,
            };
            this.game = q;
            this.type = e.CANVAS;
            this.height = this.width = this.drawCount = 0;
            this.gameCanvas = q.canvas;
            var u = {
              alpha: q.config.transparent,
              desynchronized: q.config.desynchronized,
            };
            this.currentContext = this.gameContext = r.context
              ? r.context
              : this.gameCanvas.getContext("2d", u);
            this.antialias = q.config.antialias;
            this.blendModes = f();
            this.snapshotState = {
              x: 0,
              y: 0,
              width: 1,
              height: 1,
              getPixel: !1,
              callback: null,
              type: "image/png",
              encoder: 0.92,
            };
            this._tempMatrix1 = new n();
            this._tempMatrix2 = new n();
            this._tempMatrix3 = new n();
            this.isBooted = !1;
            this.init();
          },
          init: function () {
            this.game.textures.once(m.READY, this.boot, this);
          },
          boot: function () {
            var q = this.game,
              r = q.scale.baseSize;
            this.width = r.width;
            this.height = r.height;
            this.isBooted = !0;
            q.scale.on(g.RESIZE, this.onResize, this);
            this.resize(r.width, r.height);
          },
          onResize: function (q, r) {
            (r.width === this.width && r.height === this.height) ||
              this.resize(r.width, r.height);
          },
          resize: function (q, r) {
            this.width = q;
            this.height = r;
            this.emit(c.RESIZE, q, r);
          },
          resetTransform: function () {
            this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
          },
          setBlendMode: function (q) {
            this.currentContext.globalCompositeOperation = q;
            return this;
          },
          setContext: function (q) {
            this.currentContext = q ? q : this.gameContext;
            return this;
          },
          setAlpha: function (q) {
            this.currentContext.globalAlpha = q;
            return this;
          },
          preRender: function () {
            var q = this.gameContext,
              r = this.config,
              u = this.width,
              v = this.height;
            q.globalAlpha = 1;
            q.globalCompositeOperation = "source-over";
            q.setTransform(1, 0, 0, 1, 0, 0);
            r.clearBeforeRender &&
              (q.clearRect(0, 0, u, v),
              r.transparent ||
                ((q.fillStyle = r.backgroundColor.rgba),
                q.fillRect(0, 0, u, v)));
            q.save();
            this.drawCount = 0;
            this.emit(c.PRE_RENDER);
          },
          render: function (q, r, u) {
            var v = r.length;
            this.emit(c.RENDER, q, u);
            var x = u.x,
              y = u.y,
              z = u.width,
              A = u.height,
              B = u.renderToTexture ? u.context : q.sys.context;
            B.save();
            this.game.scene.customViewports &&
              (B.beginPath(), B.rect(x, y, z, A), B.clip());
            this.currentContext = B;
            var D = u.mask;
            D && D.preRenderCanvas(this, null, u._maskCamera);
            u.transparent ||
              ((B.fillStyle = u.backgroundColor.rgba), B.fillRect(x, y, z, A));
            B.globalAlpha = u.alpha;
            B.globalCompositeOperation = "source-over";
            this.drawCount += v;
            u.renderToTexture && u.emit(d.PRE_RENDER, u);
            u.matrix.copyToContext(B);
            for (z = 0; z < v; z++)
              (A = r[z]),
                A.mask && A.mask.preRenderCanvas(this, A, u),
                A.renderCanvas(this, A, u),
                A.mask && A.mask.postRenderCanvas(this, A, u);
            B.setTransform(1, 0, 0, 1, 0, 0);
            B.globalCompositeOperation = "source-over";
            B.globalAlpha = 1;
            u.flashEffect.postRenderCanvas(B);
            u.fadeEffect.postRenderCanvas(B);
            u.dirty = !1;
            D && D.postRenderCanvas(this);
            B.restore();
            u.renderToTexture &&
              (u.emit(d.POST_RENDER, u),
              u.renderToGame && q.sys.context.drawImage(u.canvas, x, y));
          },
          postRender: function () {
            this.gameContext.restore();
            this.emit(c.POST_RENDER);
            var q = this.snapshotState;
            q.callback && (k(this.gameCanvas, q), (q.callback = null));
          },
          snapshotCanvas: function (q, r, u, v, x, y, z, A, B) {
            void 0 === u && (u = !1);
            this.snapshotArea(v, x, y, z, r, A, B);
            q = this.snapshotState;
            q.getPixel = u;
            k(this.canvas, q);
            q.callback = null;
            return this;
          },
          snapshot: function (q, r, u) {
            return this.snapshotArea(
              0,
              0,
              this.gameCanvas.width,
              this.gameCanvas.height,
              q,
              r,
              u
            );
          },
          snapshotArea: function (q, r, u, v, x, y, z) {
            var A = this.snapshotState;
            A.callback = x;
            A.type = y;
            A.encoder = z;
            A.getPixel = !1;
            A.x = q;
            A.y = r;
            A.width = Math.min(u, this.gameCanvas.width);
            A.height = Math.min(v, this.gameCanvas.height);
            return this;
          },
          snapshotPixel: function (q, r, u) {
            this.snapshotArea(q, r, 1, 1, u);
            this.snapshotState.getPixel = !0;
            return this;
          },
          batchSprite: function (q, r, u, v) {
            var x = u.alpha * q.alpha;
            if (0 !== x) {
              var y = this.currentContext,
                z = this._tempMatrix1,
                A = this._tempMatrix2,
                B = r.canvasData,
                D = B.x;
              B = B.y;
              var E = r.cutWidth,
                C = r.cutHeight,
                F = r.customPivot,
                G = r.source.resolution,
                H = q.displayOriginX,
                K = q.displayOriginY,
                I = -H + r.x,
                M = -K + r.y;
              q.isCropped &&
                ((M = q._crop),
                (M.flipX === q.flipX && M.flipY === q.flipY) ||
                  r.updateCropUVs(M, q.flipX, q.flipY),
                (E = M.cw),
                (C = M.ch),
                (D = M.cx),
                (B = M.cy),
                (I = -H + M.x),
                (M = -K + M.y),
                q.flipX &&
                  (0 <= I ? (I = -(I + E)) : 0 > I && (I = Math.abs(I) - E)),
                q.flipY &&
                  (0 <= M ? (M = -(M + C)) : 0 > M && (M = Math.abs(M) - C)));
              var N = 1,
                P = 1;
              q.flipX && (F || (I += -r.realWidth + 2 * H), (N = -1));
              q.flipY && (F || (M += -r.realHeight + 2 * K), (P = -1));
              A.applyITRS(q.x, q.y, q.rotation, q.scaleX * N, q.scaleY * P);
              z.copyFrom(u.matrix);
              v
                ? (z.multiplyWithOffset(
                    v,
                    -u.scrollX * q.scrollFactorX,
                    -u.scrollY * q.scrollFactorY
                  ),
                  (A.e = q.x),
                  (A.f = q.y))
                : ((A.e -= u.scrollX * q.scrollFactorX),
                  (A.f -= u.scrollY * q.scrollFactorY));
              z.multiply(A);
              y.save();
              z.setToContext(y);
              y.globalCompositeOperation = this.blendModes[q.blendMode];
              y.globalAlpha = x;
              y.imageSmoothingEnabled = !(
                !this.antialias || r.source.scaleMode
              );
              q.mask && q.mask.preRenderCanvas(this, q, u);
              y.drawImage(r.source.image, D, B, E, C, I, M, E / G, C / G);
              q.mask && q.mask.postRenderCanvas(this, q, u);
              y.restore();
            }
          },
          destroy: function () {
            this.removeAllListeners();
            this.gameContext = this.gameCanvas = this.game = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(31),
          k = a(38),
          e = a(2);
        h.exports = function (b, c) {
          var f = e(c, "callback"),
            g = e(c, "type", "image/png"),
            m = e(c, "encoder", 0.92),
            n = Math.abs(Math.round(e(c, "x", 0))),
            q = Math.abs(Math.round(e(c, "y", 0))),
            r = e(c, "width", b.width),
            u = e(c, "height", b.height);
          if (e(c, "getPixel", !1))
            (b = b.getContext("2d").getImageData(n, q, 1, 1).data),
              f.call(null, new k(b[0], b[1], b[2], b[3] / 255));
          else if (0 !== n || 0 !== q || r !== b.width || u !== b.height) {
            var v = d.createWebGL(this, r, u);
            v.getContext("2d").drawImage(b, n, q, r, u, 0, 0, r, u);
            var x = new Image();
            x.onerror = function () {
              f.call(null);
              d.remove(v);
            };
            x.onload = function () {
              f.call(null, x);
              d.remove(v);
            };
            x.src = v.toDataURL(g, m);
          } else {
            var y = new Image();
            y.onerror = function () {
              f.call(null);
            };
            y.onload = function () {
              f.call(null, y);
            };
            y.src = b.toDataURL(g, m);
          }
        };
      },
      function (h, t, a) {
        var d = a(35),
          k = a(348);
        h.exports = function () {
          var e = [],
            b = k.supportNewBlendModes;
          e[d.NORMAL] = "source-over";
          e[d.ADD] = "lighter";
          e[d.MULTIPLY] = b ? "multiply" : "source-over";
          e[d.SCREEN] = b ? "screen" : "source-over";
          e[d.OVERLAY] = b ? "overlay" : "source-over";
          e[d.DARKEN] = b ? "darken" : "source-over";
          e[d.LIGHTEN] = b ? "lighten" : "source-over";
          e[d.COLOR_DODGE] = b ? "color-dodge" : "source-over";
          e[d.COLOR_BURN] = b ? "color-burn" : "source-over";
          e[d.HARD_LIGHT] = b ? "hard-light" : "source-over";
          e[d.SOFT_LIGHT] = b ? "soft-light" : "source-over";
          e[d.DIFFERENCE] = b ? "difference" : "source-over";
          e[d.EXCLUSION] = b ? "exclusion" : "source-over";
          e[d.HUE] = b ? "hue" : "source-over";
          e[d.SATURATION] = b ? "saturation" : "source-over";
          e[d.COLOR] = b ? "color" : "source-over";
          e[d.LUMINOSITY] = b ? "luminosity" : "source-over";
          e[d.ERASE] = "destination-out";
          e[d.SOURCE_IN] = "source-in";
          e[d.SOURCE_OUT] = "source-out";
          e[d.SOURCE_ATOP] = "source-atop";
          e[d.DESTINATION_OVER] = "destination-over";
          e[d.DESTINATION_IN] = "destination-in";
          e[d.DESTINATION_OUT] = "destination-out";
          e[d.DESTINATION_ATOP] = "destination-atop";
          e[d.LIGHTER] = "lighter";
          e[d.COPY] = "copy";
          e[d.XOR] = "xor";
          return e;
        };
      },
      function (h, t, a) {
        var d = a(93),
          k = a(37);
        t = a(0);
        var e = a(33),
          b = a(9),
          c = a(91),
          f = a(22),
          g = a(138),
          m = a(69),
          n = a(1),
          q = a(372),
          r = a(141),
          u = a(104),
          v = a(106),
          x = a(12),
          y = a(383);
        a = new t({
          Extends: b,
          initialize: function (z) {
            b.call(this);
            var A = z.config;
            this.config = {
              clearBeforeRender: A.clearBeforeRender,
              antialias: A.antialias,
              backgroundColor: A.backgroundColor,
              contextCreation: {
                alpha: A.transparent,
                desynchronized: A.desynchronized,
                depth: !1,
                antialias: A.antialiasGL,
                premultipliedAlpha: A.premultipliedAlpha,
                stencil: !0,
                failIfMajorPerformanceCaveat: A.failIfMajorPerformanceCaveat,
                powerPreference: A.powerPreference,
                preserveDrawingBuffer: A.preserveDrawingBuffer,
              },
              roundPixels: A.roundPixels,
              maxTextures: A.maxTextures,
              maxTextureSize: A.maxTextureSize,
              batchSize: A.batchSize,
              maxLights: A.maxLights,
              mipmapFilter: A.mipmapFilter,
            };
            this.game = z;
            this.type = e.WEBGL;
            this.pipelines = null;
            this.height = this.width = 0;
            this.canvas = z.canvas;
            this.blendModes = [];
            this.contextLost = !1;
            this.snapshotState = {
              x: 0,
              y: 0,
              width: 1,
              height: 1,
              getPixel: !1,
              callback: null,
              type: "image/png",
              encoder: 0.92,
              isFramebuffer: !1,
              bufferWidth: 0,
              bufferHeight: 0,
            };
            this.maxTextures =
              this.startActiveTexture =
              this.currentActiveTexture =
                0;
            this.textureIndexes;
            this.tempTextures;
            this.textureZero;
            this.normalTexture;
            this.currentFramebuffer = null;
            this.fboStack = [];
            this.currentProgram = null;
            this.currentBlendMode = Infinity;
            this.currentScissorEnabled = !1;
            this.currentScissor = null;
            this.scissorStack = [];
            this.contextRestoredHandler = this.contextLostHandler = n;
            this.vaoExtension =
              this.instancedArraysExtension =
              this.supportedExtensions =
              this.gl =
                null;
            this.extensions = {};
            this.glFormats = [];
            this.compression = {
              ETC1: !1,
              PVRTC: !1,
              S3TC: !1,
            };
            this.drawingBufferHeight = 0;
            this.whiteTexture = this.blankTexture = null;
            this.maskCount = 0;
            this.maskStack = [];
            this.currentMask = {
              mask: null,
              camera: null,
            };
            this.currentCameraMask = {
              mask: null,
              camera: null,
            };
            this.glFuncMap = null;
            this.currentType = "";
            this.finalType = this.nextTypeMatch = this.newType = !1;
            this.mipmapFilter = null;
            this.textureFlush = 0;
            this.isTextureClean = !1;
            this.defaultScissor = [0, 0, 0, 0];
            this.isBooted = !1;
            this.renderTarget = null;
            this.projectionMatrix;
            this.projectionHeight = this.projectionWidth = 0;
            this.init(this.config);
          },
          init: function (z) {
            var A = this.game,
              B = this.canvas,
              D = z.backgroundColor;
            var E = A.config.context
              ? A.config.context
              : B.getContext("webgl", z.contextCreation) ||
                B.getContext("experimental-webgl", z.contextCreation);
            if (!E || E.isContextLost())
              throw ((this.contextLost = !0), Error("WebGL unsupported"));
            this.gl = E;
            var C = this;
            this.contextLostHandler = function (G) {
              C.contextLost = !0;
              C.game.events.emit(f.CONTEXT_LOST, C);
              G.preventDefault();
            };
            this.contextRestoredHandler = function () {
              C.contextLost = !1;
              C.init(C.config);
              C.game.events.emit(f.CONTEXT_RESTORED, C);
            };
            B.addEventListener("webglcontextlost", this.contextLostHandler, !1);
            B.addEventListener(
              "webglcontextrestored",
              this.contextRestoredHandler,
              !1
            );
            A.context = E;
            for (B = 0; 27 >= B; B++)
              this.blendModes.push({
                func: [E.ONE, E.ONE_MINUS_SRC_ALPHA],
                equation: E.FUNC_ADD,
              });
            this.blendModes[1].func = [E.ONE, E.DST_ALPHA];
            this.blendModes[2].func = [E.DST_COLOR, E.ONE_MINUS_SRC_ALPHA];
            this.blendModes[3].func = [E.ONE, E.ONE_MINUS_SRC_COLOR];
            this.blendModes[17] = {
              func: [E.ZERO, E.ONE_MINUS_SRC_ALPHA],
              equation: E.FUNC_REVERSE_SUBTRACT,
            };
            this.glFormats[0] = E.BYTE;
            this.glFormats[1] = E.SHORT;
            this.glFormats[2] = E.UNSIGNED_BYTE;
            this.glFormats[3] = E.UNSIGNED_SHORT;
            this.glFormats[4] = E.FLOAT;
            this.glFuncMap = {
              mat2: {
                func: E.uniformMatrix2fv,
                length: 1,
                matrix: !0,
              },
              mat3: {
                func: E.uniformMatrix3fv,
                length: 1,
                matrix: !0,
              },
              mat4: {
                func: E.uniformMatrix4fv,
                length: 1,
                matrix: !0,
              },
              "1f": {
                func: E.uniform1f,
                length: 1,
              },
              "1fv": {
                func: E.uniform1fv,
                length: 1,
              },
              "1i": {
                func: E.uniform1i,
                length: 1,
              },
              "1iv": {
                func: E.uniform1iv,
                length: 1,
              },
              "2f": {
                func: E.uniform2f,
                length: 2,
              },
              "2fv": {
                func: E.uniform2fv,
                length: 1,
              },
              "2i": {
                func: E.uniform2i,
                length: 2,
              },
              "2iv": {
                func: E.uniform2iv,
                length: 1,
              },
              "3f": {
                func: E.uniform3f,
                length: 3,
              },
              "3fv": {
                func: E.uniform3fv,
                length: 1,
              },
              "3i": {
                func: E.uniform3i,
                length: 3,
              },
              "3iv": {
                func: E.uniform3iv,
                length: 1,
              },
              "4f": {
                func: E.uniform4f,
                length: 4,
              },
              "4fv": {
                func: E.uniform4fv,
                length: 1,
              },
              "4i": {
                func: E.uniform4i,
                length: 4,
              },
              "4iv": {
                func: E.uniform4iv,
                length: 1,
              },
            };
            var F = E.getSupportedExtensions();
            (z.maxTextures && -1 !== z.maxTextures) ||
              (z.maxTextures = E.getParameter(E.MAX_TEXTURE_IMAGE_UNITS));
            z.maxTextureSize ||
              (z.maxTextureSize = E.getParameter(E.MAX_TEXTURE_SIZE));
            this.compression.ETC1 =
              E.getExtension("WEBGL_compressed_texture_etc1") ||
              E.getExtension("WEBKIT_WEBGL_compressed_texture_etc1");
            this.compression.PVRTC =
              E.getExtension("WEBGL_compressed_texture_pvrtc") ||
              E.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            this.compression.S3TC =
              E.getExtension("WEBGL_compressed_texture_s3tc") ||
              E.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            this.supportedExtensions = F;
            this.instancedArraysExtension =
              -1 < F.indexOf("ANGLE_instanced_arrays")
                ? E.getExtension("ANGLE_instanced_arrays")
                : null;
            this.vaoExtension =
              -1 < F.indexOf("OES_vertex_array_object")
                ? E.getExtension("OES_vertex_array_object")
                : null;
            E.disable(E.DEPTH_TEST);
            E.disable(E.CULL_FACE);
            E.enable(E.BLEND);
            E.clearColor(D.redGL, D.greenGL, D.blueGL, D.alphaGL);
            this.mipmapFilter = E[z.mipmapFilter];
            this.maxTextures = x.checkShaderMax(E, z.maxTextures);
            this.textureIndexes = [];
            z = this.tempTextures;
            if (Array.isArray(z))
              for (D = 0; B < this.maxTextures; D++) E.deleteTexture(z[D]);
            else z = Array(this.maxTextures);
            for (B = 0; B < this.maxTextures; B++)
              (D = E.createTexture()),
                E.activeTexture(E.TEXTURE0 + B),
                E.bindTexture(E.TEXTURE_2D, D),
                E.texImage2D(
                  E.TEXTURE_2D,
                  0,
                  E.RGBA,
                  1,
                  1,
                  0,
                  E.RGBA,
                  E.UNSIGNED_BYTE,
                  new Uint8Array([0, 0, 255, 255])
                ),
                (z[B] = D),
                this.textureIndexes.push(B);
            this.tempTextures = z;
            this.currentActiveTexture = 1;
            this.startActiveTexture++;
            E.activeTexture(E.TEXTURE1);
            this.pipelines = new q(this);
            this.setBlendMode(e.BlendModes.NORMAL);
            this.projectionMatrix = new m().identity();
            A.textures.once(v.READY, this.boot, this);
            return this;
          },
          boot: function () {
            var z = this.game,
              A = this.pipelines,
              B = z.scale.baseSize;
            this.width = B.width;
            this.height = B.height;
            this.isBooted = !0;
            this.renderTarget = new r(
              this,
              this.width,
              this.height,
              1,
              0,
              !0,
              !0
            );
            A.boot(z.config.pipeline);
            this.blankTexture = z.textures.getFrame("__DEFAULT");
            this.whiteTexture = z.textures.getFrame("__WHITE");
            A = this.gl;
            A.bindFramebuffer(A.FRAMEBUFFER, null);
            A.enable(A.SCISSOR_TEST);
            z.scale.on(u.RESIZE, this.onResize, this);
            this.resize(B.width, B.height);
          },
          onResize: function (z, A) {
            (A.width === this.width && A.height === this.height) ||
              this.resize(A.width, A.height);
          },
          beginCapture: function (z, A) {
            void 0 === z && (z = this.width);
            void 0 === A && (A = this.height);
            this.renderTarget.bind(!0, z, A);
            this.setProjectionMatrix(z, A);
            this.resetTextures();
          },
          endCapture: function () {
            this.renderTarget.unbind(!0);
            this.resetProjectionMatrix();
            return this.renderTarget;
          },
          resize: function (z, A) {
            var B = this.gl;
            this.width = z;
            this.height = A;
            this.setProjectionMatrix(z, A);
            B.viewport(0, 0, z, A);
            this.drawingBufferHeight = B.drawingBufferHeight;
            B.scissor(0, B.drawingBufferHeight - A, z, A);
            this.defaultScissor[2] = z;
            this.defaultScissor[3] = A;
            this.emit(c.RESIZE, z, A);
            return this;
          },
          getAspectRatio: function () {
            return this.width / this.height;
          },
          setProjectionMatrix: function (z, A) {
            if (z !== this.projectionWidth || A !== this.projectionHeight)
              (this.projectionWidth = z),
                (this.projectionHeight = A),
                this.projectionMatrix.ortho(0, z, A, 0, -1e3, 1e3);
            return this;
          },
          resetProjectionMatrix: function () {
            this.projectionWidth = this.width;
            this.projectionHeight = this.height;
            this.projectionMatrix.ortho(
              0,
              this.width,
              this.height,
              0,
              -1e3,
              1e3
            );
          },
          hasExtension: function (z) {
            return this.supportedExtensions
              ? this.supportedExtensions.indexOf(z)
              : !1;
          },
          getExtension: function (z) {
            if (!this.hasExtension(z)) return null;
            z in this.extensions ||
              (this.extensions[z] = this.gl.getExtension(z));
            return this.extensions[z];
          },
          flush: function () {
            this.pipelines.flush();
          },
          pushScissor: function (z, A, B, D, E) {
            void 0 === E && (E = this.drawingBufferHeight);
            var C = [z, A, B, D];
            this.scissorStack.push(C);
            this.setScissor(z, A, B, D, E);
            return (this.currentScissor = C);
          },
          setScissor: function (z, A, B, D, E) {
            void 0 === E && (E = this.drawingBufferHeight);
            var C = this.gl,
              F = this.currentScissor,
              G = 0 < B && 0 < D;
            if (F && G) {
              G = F[1];
              var H = F[2],
                K = F[3];
              G = F[0] !== z || G !== A || H !== B || K !== D;
            }
            G && (this.flush(), C.scissor(z, E - A - D, B, D));
          },
          resetScissor: function () {
            var z = this.gl;
            z.enable(z.SCISSOR_TEST);
            var A = this.currentScissor;
            if (A) {
              var B = A[0],
                D = A[1],
                E = A[2];
              A = A[3];
              0 < E &&
                0 < A &&
                z.scissor(B, this.drawingBufferHeight - D - A, E, A);
            }
          },
          popScissor: function () {
            var z = this.scissorStack;
            z.pop();
            (z = z[z.length - 1]) && this.setScissor(z[0], z[1], z[2], z[3]);
            this.currentScissor = z;
          },
          hasActiveStencilMask: function () {
            var z = this.currentMask.mask,
              A = this.currentCameraMask.mask;
            return (z && z.isStencil) || (A && A.isStencil);
          },
          resetViewport: function () {
            var z = this.gl;
            z.viewport(0, 0, this.width, this.height);
            this.drawingBufferHeight = z.drawingBufferHeight;
          },
          setBlendMode: function (z, A) {
            void 0 === A && (A = !1);
            var B = this.gl,
              D = this.blendModes[z];
            return A ||
              (z !== e.BlendModes.SKIP_CHECK && this.currentBlendMode !== z)
              ? (this.flush(),
                B.enable(B.BLEND),
                B.blendEquation(D.equation),
                2 < D.func.length
                  ? B.blendFuncSeparate(
                      D.func[0],
                      D.func[1],
                      D.func[2],
                      D.func[3]
                    )
                  : B.blendFunc(D.func[0], D.func[1]),
                (this.currentBlendMode = z),
                !0)
              : !1;
          },
          addBlendMode: function (z, A) {
            return (
              this.blendModes.push({
                func: z,
                equation: A,
              }) - 1
            );
          },
          updateBlendMode: function (z, A, B) {
            this.blendModes[z] &&
              ((this.blendModes[z].func = A),
              B && (this.blendModes[z].equation = B));
            return this;
          },
          removeBlendMode: function (z) {
            17 < z && this.blendModes[z] && this.blendModes.splice(z, 1);
            return this;
          },
          setBlankTexture: function () {
            this.setTexture2D(this.blankTexture.glTexture);
          },
          setTextureSource: function (z) {
            if (this.pipelines.forceZero())
              return this.setTextureZero(z.glTexture, !0), 0;
            var A = this.gl,
              B = this.currentActiveTexture;
            z.glIndexCounter < this.startActiveTexture &&
              ((z.glIndexCounter = this.startActiveTexture),
              B < this.maxTextures
                ? ((z.glIndex = B),
                  A.activeTexture(A.TEXTURE0 + B),
                  A.bindTexture(A.TEXTURE_2D, z.glTexture),
                  this.currentActiveTexture++)
                : (this.flush(),
                  this.startActiveTexture++,
                  this.textureFlush++,
                  (z.glIndexCounter = this.startActiveTexture),
                  (z.glIndex = 1),
                  A.activeTexture(A.TEXTURE1),
                  A.bindTexture(A.TEXTURE_2D, z.glTexture),
                  (this.currentActiveTexture = 2)));
            this.isTextureClean = !1;
            return z.glIndex;
          },
          isNewNormalMap: function (z, A) {
            return this.textureZero !== z || this.normalTexture !== A;
          },
          setTextureZero: function (z, A) {
            this.textureZero !== z &&
              (A && this.flush(),
              (A = this.gl),
              A.activeTexture(A.TEXTURE0),
              A.bindTexture(A.TEXTURE_2D, z),
              (this.textureZero = z));
          },
          clearTextureZero: function () {
            this.textureZero = null;
          },
          setNormalMap: function (z) {
            if (this.normalTexture !== z) {
              var A = this.gl;
              A.activeTexture(A.TEXTURE1);
              A.bindTexture(A.TEXTURE_2D, z);
              this.normalTexture = z;
              1 === this.currentActiveTexture &&
                (this.currentActiveTexture = 2);
            }
          },
          clearNormalMap: function () {
            this.normalTexture = null;
            this.startActiveTexture++;
            this.currentActiveTexture = 1;
            this.textureFlush++;
          },
          unbindTextures: function () {
            for (
              var z = this.gl, A = this.tempTextures, B = 0;
              B < A.length;
              B++
            )
              z.activeTexture(z.TEXTURE0 + B),
                z.bindTexture(z.TEXTURE_2D, null);
            this.textureZero = this.normalTexture = null;
            this.currentActiveTexture = 1;
            this.startActiveTexture++;
            this.textureFlush++;
          },
          resetTextures: function (z) {
            void 0 === z && (z = !1);
            if (!this.isTextureClean) {
              this.flush();
              var A = this.gl,
                B = this.tempTextures;
              if (z) {
                for (z = 0; z < B.length; z++)
                  A.activeTexture(A.TEXTURE0 + z),
                    A.bindTexture(A.TEXTURE_2D, B[z]);
                A.activeTexture(A.TEXTURE1);
                A.bindTexture(A.TEXTURE_2D, B[1]);
                this.isTextureClean = !0;
              } else
                A.activeTexture(A.TEXTURE0),
                  A.bindTexture(A.TEXTURE_2D, B[0]),
                  A.activeTexture(A.TEXTURE1),
                  A.bindTexture(A.TEXTURE_2D, B[1]);
              this.textureZero = this.normalTexture = null;
              this.currentActiveTexture = 1;
              this.startActiveTexture++;
              this.textureFlush++;
            }
          },
          setTexture2D: function (z) {
            if (this.pipelines.forceZero())
              return this.setTextureZero(z, !0), 0;
            var A = this.gl,
              B = this.currentActiveTexture;
            z.glIndexCounter < this.startActiveTexture &&
              ((z.glIndexCounter = this.startActiveTexture),
              B < this.maxTextures
                ? ((z.glIndex = B),
                  A.activeTexture(A.TEXTURE0 + B),
                  A.bindTexture(A.TEXTURE_2D, z),
                  this.currentActiveTexture++)
                : (this.flush(),
                  this.startActiveTexture++,
                  this.textureFlush++,
                  (z.glIndexCounter = this.startActiveTexture),
                  (z.glIndex = 1),
                  A.activeTexture(A.TEXTURE1),
                  A.bindTexture(A.TEXTURE_2D, z),
                  (this.currentActiveTexture = 2)));
            this.isTextureClean = !1;
            return z.glIndex;
          },
          pushFramebuffer: function (z, A, B, D) {
            if (z === this.currentFramebuffer) return this;
            this.fboStack.push(z);
            return this.setFramebuffer(z, A, B, D);
          },
          setFramebuffer: function (z, A, B, D) {
            void 0 === A && (A = !1);
            void 0 === B && (B = !1);
            void 0 === D && (D = !0);
            if (z === this.currentFramebuffer) return this;
            var E = this.gl,
              C = this.width,
              F = this.height;
            z && z.renderTexture && D
              ? ((C = z.renderTexture.width), (F = z.renderTexture.height))
              : this.flush();
            E.bindFramebuffer(E.FRAMEBUFFER, z);
            D && E.viewport(0, 0, C, F);
            A &&
              (z
                ? ((this.drawingBufferHeight = F), this.pushScissor(0, 0, C, F))
                : ((this.drawingBufferHeight = this.height),
                  this.popScissor()));
            this.currentFramebuffer = z;
            B && this.resetTextures();
            return this;
          },
          popFramebuffer: function (z, A, B) {
            void 0 === z && (z = !1);
            void 0 === A && (A = !1);
            void 0 === B && (B = !0);
            var D = this.fboStack;
            D.pop();
            (D = D[D.length - 1]) || (D = null);
            this.setFramebuffer(D, z, A, B);
            return D;
          },
          setProgram: function (z) {
            return z !== this.currentProgram
              ? (this.flush(),
                this.gl.useProgram(z),
                (this.currentProgram = z),
                !0)
              : !1;
          },
          resetProgram: function () {
            this.gl.useProgram(this.currentProgram);
            return this;
          },
          createTextureFromSource: function (z, A, B, D) {
            var E = this.gl,
              C = E.NEAREST,
              F = E.NEAREST,
              G = E.CLAMP_TO_EDGE;
            A = z ? z.width : A;
            B = z ? z.height : B;
            var H = g(A, B);
            H && (G = E.REPEAT);
            D === e.ScaleModes.LINEAR &&
              this.config.antialias &&
              ((C = H ? this.mipmapFilter : E.LINEAR), (F = E.LINEAR));
            return z || "number" !== typeof A || "number" !== typeof B
              ? this.createTexture2D(0, C, F, G, G, E.RGBA, z)
              : this.createTexture2D(0, C, F, G, G, E.RGBA, null, A, B);
          },
          createTexture2D: function (z, A, B, D, E, C, F, G, H, K, I, M) {
            K = void 0 === K || null === K ? !0 : K;
            void 0 === I && (I = !1);
            void 0 === M && (M = !1);
            var N = this.gl,
              P = N.createTexture();
            N.activeTexture(N.TEXTURE0);
            var J = N.getParameter(N.TEXTURE_BINDING_2D);
            N.bindTexture(N.TEXTURE_2D, P);
            N.texParameteri(N.TEXTURE_2D, N.TEXTURE_MIN_FILTER, A);
            N.texParameteri(N.TEXTURE_2D, N.TEXTURE_MAG_FILTER, B);
            N.texParameteri(N.TEXTURE_2D, N.TEXTURE_WRAP_S, E);
            N.texParameteri(N.TEXTURE_2D, N.TEXTURE_WRAP_T, D);
            N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, K);
            N.pixelStorei(N.UNPACK_FLIP_Y_WEBGL, M);
            null === F || void 0 === F
              ? N.texImage2D(
                  N.TEXTURE_2D,
                  z,
                  C,
                  G,
                  H,
                  0,
                  C,
                  N.UNSIGNED_BYTE,
                  null
                )
              : (I || ((G = F.width), (H = F.height)),
                N.texImage2D(N.TEXTURE_2D, z, C, C, N.UNSIGNED_BYTE, F));
            g(G, H) && N.generateMipmap(N.TEXTURE_2D);
            J && N.bindTexture(N.TEXTURE_2D, J);
            P.isAlphaPremultiplied = K;
            P.isRenderTexture = !1;
            P.width = G;
            P.height = H;
            P.glIndex = 0;
            P.glIndexCounter = -1;
            return P;
          },
          createFramebuffer: function (z, A, B, D) {
            var E = this.gl,
              C = E.createFramebuffer();
            this.setFramebuffer(C);
            D &&
              ((D = E.createRenderbuffer()),
              E.bindRenderbuffer(E.RENDERBUFFER, D),
              E.renderbufferStorage(E.RENDERBUFFER, E.DEPTH_STENCIL, z, A),
              E.framebufferRenderbuffer(
                E.FRAMEBUFFER,
                E.DEPTH_STENCIL_ATTACHMENT,
                E.RENDERBUFFER,
                D
              ));
            B.isRenderTexture = !0;
            B.isAlphaPremultiplied = !1;
            E.framebufferTexture2D(
              E.FRAMEBUFFER,
              E.COLOR_ATTACHMENT0,
              E.TEXTURE_2D,
              B,
              0
            );
            z = E.checkFramebufferStatus(E.FRAMEBUFFER);
            if (z !== E.FRAMEBUFFER_COMPLETE)
              throw Error(
                "Framebuffer status: " +
                  {
                    36054: "Incomplete Attachment",
                    36055: "Missing Attachment",
                    36057: "Incomplete Dimensions",
                    36061: "Framebuffer Unsupported",
                  }[z]
              );
            C.renderTexture = B;
            this.setFramebuffer(null);
            this.resetTextures();
            return C;
          },
          createProgram: function (z, A) {
            var B = this.gl,
              D = B.createProgram(),
              E = B.createShader(B.VERTEX_SHADER),
              C = B.createShader(B.FRAGMENT_SHADER);
            B.shaderSource(E, z);
            B.shaderSource(C, A);
            B.compileShader(E);
            B.compileShader(C);
            if (!B.getShaderParameter(E, B.COMPILE_STATUS))
              throw Error("Vertex Shader failed:\n" + B.getShaderInfoLog(E));
            if (!B.getShaderParameter(C, B.COMPILE_STATUS))
              throw Error("Fragment Shader failed:\n" + B.getShaderInfoLog(C));
            B.attachShader(D, E);
            B.attachShader(D, C);
            B.linkProgram(D);
            if (!B.getProgramParameter(D, B.LINK_STATUS))
              throw Error("Link Program failed:\n" + B.getProgramInfoLog(D));
            B.useProgram(D);
            return D;
          },
          createVertexBuffer: function (z, A) {
            var B = this.gl,
              D = B.createBuffer();
            B.bindBuffer(B.ARRAY_BUFFER, D);
            B.bufferData(B.ARRAY_BUFFER, z, A);
            B.bindBuffer(B.ARRAY_BUFFER, null);
            return D;
          },
          createIndexBuffer: function (z, A) {
            var B = this.gl,
              D = B.createBuffer();
            B.bindBuffer(B.ELEMENT_ARRAY_BUFFER, D);
            B.bufferData(B.ELEMENT_ARRAY_BUFFER, z, A);
            B.bindBuffer(B.ELEMENT_ARRAY_BUFFER, null);
            return D;
          },
          deleteTexture: function (z, A) {
            A && this.resetTextures(!0);
            z && this.gl.deleteTexture(z);
            return this;
          },
          deleteFramebuffer: function (z) {
            z &&
              (this.gl.deleteFramebuffer(z),
              d(this.fboStack, z),
              this.currentFramebuffer === z &&
                (this.currentFramebuffer = null));
            return this;
          },
          deleteProgram: function (z) {
            z && this.gl.deleteProgram(z);
            return this;
          },
          deleteBuffer: function (z) {
            this.gl.deleteBuffer(z);
            return this;
          },
          preRenderCamera: function (z) {
            var A = z.x,
              B = z.y,
              D = z.width,
              E = z.height,
              C = z.backgroundColor;
            z.emit(k.PRE_RENDER, z);
            this.pipelines.preBatchCamera(z);
            this.pushScissor(A, B, D, E);
            z.mask &&
              ((this.currentCameraMask.mask = z.mask),
              (this.currentCameraMask.camera = z._maskCamera),
              z.mask.preRenderWebGL(this, z, z._maskCamera));
            0 < C.alphaGL &&
              this.pipelines
                .setMulti()
                .drawFillRect(
                  A,
                  B,
                  D,
                  E,
                  x.getTintFromFloats(C.blueGL, C.greenGL, C.redGL, 1),
                  C.alphaGL
                );
          },
          getCurrentStencilMask: function () {
            var z = null,
              A = this.maskStack,
              B = this.currentCameraMask;
            0 < A.length
              ? (z = A[A.length - 1])
              : B.mask && B.mask.isStencil && (z = B);
            return z;
          },
          postRenderCamera: function (z) {
            var A = z.flashEffect,
              B = z.fadeEffect;
            if (A.isRunning || B.isRunning || B.isComplete) {
              var D = this.pipelines.setMulti();
              A.postRenderWebGL(D, x.getTintFromFloats);
              B.postRenderWebGL(D, x.getTintFromFloats);
            }
            z.dirty = !1;
            this.popScissor();
            z.mask &&
              ((this.currentCameraMask.mask = null),
              z.mask.postRenderWebGL(this, z._maskCamera));
            this.pipelines.postBatchCamera(z);
            z.emit(k.POST_RENDER, z);
          },
          preRender: function () {
            if (!this.contextLost) {
              var z = this.gl;
              z.bindFramebuffer(z.FRAMEBUFFER, null);
              if (this.config.clearBeforeRender) {
                var A = this.config.backgroundColor;
                z.clearColor(A.redGL, A.greenGL, A.blueGL, A.alphaGL);
                z.clear(
                  z.COLOR_BUFFER_BIT | z.DEPTH_BUFFER_BIT | z.STENCIL_BUFFER_BIT
                );
              }
              z.enable(z.SCISSOR_TEST);
              this.currentScissor = this.defaultScissor;
              this.scissorStack.length = 0;
              this.scissorStack.push(this.currentScissor);
              this.game.scene.customViewports &&
                z.scissor(
                  0,
                  this.drawingBufferHeight - this.height,
                  this.width,
                  this.height
                );
              this.currentMask.mask = null;
              this.currentCameraMask.mask = null;
              this.textureFlush = this.maskStack.length = 0;
              this.emit(c.PRE_RENDER);
            }
          },
          render: function (z, A, B) {
            if (!this.contextLost) {
              var D = A.length;
              this.emit(c.RENDER, z, B);
              this.preRenderCamera(B);
              if (0 !== D) {
                this.currentType = "";
                for (z = 0; z < D; z++) {
                  this.finalType = z === D - 1;
                  var E = A[z],
                    C = E.mask;
                  var F = this.currentMask;
                  F.mask &&
                    F.mask !== C &&
                    F.mask.postRenderWebGL(this, F.camera);
                  C && F.mask !== C && C.preRenderWebGL(this, E, B);
                  E.blendMode !== this.currentBlendMode &&
                    this.setBlendMode(E.blendMode);
                  F = E.type;
                  F !== this.currentType &&
                    ((this.newType = !0), (this.currentType = F));
                  this.nextTypeMatch = this.finalType
                    ? !1
                    : A[z + 1].type === this.currentType;
                  E.renderWebGL(this, E, B);
                  this.newType = !1;
                }
                F = this.currentMask;
                F.mask && F.mask.postRenderWebGL(this, F.camera);
              }
              this.setBlendMode(e.BlendModes.NORMAL);
              this.postRenderCamera(B);
            }
          },
          postRender: function () {
            if (!this.contextLost) {
              this.flush();
              this.emit(c.POST_RENDER);
              var z = this.snapshotState;
              z.callback && (y(this.canvas, z), (z.callback = null));
              0 < this.textureFlush &&
                (this.startActiveTexture++, (this.currentActiveTexture = 1));
            }
          },
          snapshot: function (z, A, B) {
            return this.snapshotArea(
              0,
              0,
              this.gl.drawingBufferWidth,
              this.gl.drawingBufferHeight,
              z,
              A,
              B
            );
          },
          snapshotArea: function (z, A, B, D, E, C, F) {
            var G = this.snapshotState;
            G.callback = E;
            G.type = C;
            G.encoder = F;
            G.getPixel = !1;
            G.x = z;
            G.y = A;
            G.width = Math.min(B, this.gl.drawingBufferWidth);
            G.height = Math.min(D, this.gl.drawingBufferHeight);
            return this;
          },
          snapshotPixel: function (z, A, B) {
            this.snapshotArea(z, A, 1, 1, B);
            this.snapshotState.getPixel = !0;
            return this;
          },
          snapshotFramebuffer: function (z, A, B, D, E, C, F, G, H, K, I) {
            void 0 === E && (E = !1);
            void 0 === C && (C = 0);
            void 0 === F && (F = 0);
            void 0 === G && (G = A);
            void 0 === H && (H = B);
            var M = this.currentFramebuffer;
            this.snapshotArea(C, F, G, H, D, K, I);
            D = this.snapshotState;
            D.getPixel = E;
            D.isFramebuffer = !0;
            D.bufferWidth = A;
            D.bufferHeight = B;
            this.setFramebuffer(z);
            y(this.canvas, D);
            this.setFramebuffer(M);
            D.callback = null;
            D.isFramebuffer = !1;
            return this;
          },
          canvasToTexture: function (z, A, B, D) {
            void 0 === B && (B = !1);
            void 0 === D && (D = !1);
            return A
              ? this.updateCanvasTexture(z, A, D)
              : this.createCanvasTexture(z, B, D);
          },
          createCanvasTexture: function (z, A, B) {
            void 0 === A && (A = !1);
            void 0 === B && (B = !1);
            var D = this.gl,
              E = D.NEAREST,
              C = D.NEAREST,
              F = z.width,
              G = z.height,
              H = D.CLAMP_TO_EDGE,
              K = g(F, G);
            !A && K && (H = D.REPEAT);
            this.config.antialias &&
              ((E = K ? this.mipmapFilter : D.LINEAR), (C = D.LINEAR));
            return this.createTexture2D(
              0,
              E,
              C,
              H,
              H,
              D.RGBA,
              z,
              F,
              G,
              !0,
              !1,
              B
            );
          },
          updateCanvasTexture: function (z, A, B) {
            void 0 === B && (B = !1);
            var D = this.gl,
              E = z.width,
              C = z.height;
            if (0 < E && 0 < C) {
              D.activeTexture(D.TEXTURE0);
              var F = D.getParameter(D.TEXTURE_BINDING_2D);
              D.bindTexture(D.TEXTURE_2D, A);
              D.pixelStorei(D.UNPACK_FLIP_Y_WEBGL, B);
              D.pixelStorei(D.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0);
              D.texImage2D(D.TEXTURE_2D, 0, D.RGBA, D.RGBA, D.UNSIGNED_BYTE, z);
              A.width = E;
              A.height = C;
              F && D.bindTexture(D.TEXTURE_2D, F);
            }
            return A;
          },
          createVideoTexture: function (z, A, B) {
            void 0 === A && (A = !1);
            void 0 === B && (B = !1);
            var D = this.gl,
              E = D.NEAREST,
              C = D.NEAREST,
              F = z.videoWidth,
              G = z.videoHeight,
              H = D.CLAMP_TO_EDGE,
              K = g(F, G);
            !A && K && (H = D.REPEAT);
            this.config.antialias &&
              ((E = K ? this.mipmapFilter : D.LINEAR), (C = D.LINEAR));
            return this.createTexture2D(
              0,
              E,
              C,
              H,
              H,
              D.RGBA,
              z,
              F,
              G,
              !0,
              !0,
              B
            );
          },
          updateVideoTexture: function (z, A, B) {
            void 0 === B && (B = !1);
            var D = this.gl,
              E = z.videoWidth,
              C = z.videoHeight;
            if (0 < E && 0 < C) {
              D.activeTexture(D.TEXTURE0);
              var F = D.getParameter(D.TEXTURE_BINDING_2D);
              D.bindTexture(D.TEXTURE_2D, A);
              D.pixelStorei(D.UNPACK_FLIP_Y_WEBGL, B);
              D.texImage2D(D.TEXTURE_2D, 0, D.RGBA, D.RGBA, D.UNSIGNED_BYTE, z);
              A.width = E;
              A.height = C;
              F && D.bindTexture(D.TEXTURE_2D, F);
            }
            return A;
          },
          setTextureFilter: function (z, A) {
            var B = this.gl;
            A = [B.LINEAR, B.NEAREST][A];
            B.activeTexture(B.TEXTURE0);
            var D = B.getParameter(B.TEXTURE_BINDING_2D);
            B.bindTexture(B.TEXTURE_2D, z);
            B.texParameteri(B.TEXTURE_2D, B.TEXTURE_MIN_FILTER, A);
            B.texParameteri(B.TEXTURE_2D, B.TEXTURE_MAG_FILTER, A);
            D && B.bindTexture(B.TEXTURE_2D, D);
            return this;
          },
          getMaxTextureSize: function () {
            return this.config.maxTextureSize;
          },
          destroy: function () {
            this.canvas.removeEventListener(
              "webglcontextlost",
              this.contextLostHandler,
              !1
            );
            this.canvas.removeEventListener(
              "webglcontextrestored",
              this.contextRestoredHandler,
              !1
            );
            for (
              var z = this.gl, A = this.tempTextures, B = 0;
              B < A.length;
              B++
            )
              z.deleteTexture(A[B]);
            this.pipelines.destroy();
            this.removeAllListeners();
            this.fboStack = [];
            this.maskStack = [];
            this.extensions = {};
            this.textureIndexes = [];
            this.canvas = this.game = this.gl = null;
            this.contextLost = !0;
            this.currentCameraMask = this.currentMask = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(92),
          k = a(102),
          e = a(373),
          b = a(376),
          c = a(377),
          f = a(108),
          g = a(378),
          m = a(379),
          n = a(380),
          q = a(381);
        a = new t({
          initialize: function (r) {
            this.game = r.game;
            this.renderer = r;
            this.classes = new k([
              [d.UTILITY_PIPELINE, q],
              [d.MULTI_PIPELINE, f],
              [d.BITMAPMASK_PIPELINE, e],
              [d.SINGLE_PIPELINE, n],
              [d.ROPE_PIPELINE, m],
              [d.LIGHT_PIPELINE, c],
              [d.POINTLIGHT_PIPELINE, g],
              [d.GRAPHICS_PIPELINE, b],
            ]);
            this.postPipelineClasses = new k();
            this.pipelines = new k();
            this.UTILITY_PIPELINE =
              this.BITMAPMASK_PIPELINE =
              this.MULTI_PIPELINE =
              this.previous =
              this.current =
                null;
            this.fullFrame1;
            this.fullFrame2;
            this.halfFrame1;
            this.halfFrame2;
          },
          boot: function (r) {
            var u,
              v = this,
              x = this.game;
            this.classes.each(function (A, B) {
              z = v.add(
                A,
                new B({
                  game: x,
                })
              );
              A === d.UTILITY_PIPELINE &&
                ((v.UTILITY_PIPELINE = z),
                (v.fullFrame1 = z.fullFrame1),
                (v.fullFrame2 = z.fullFrame2),
                (v.halfFrame1 = z.halfFrame1),
                (v.halfFrame2 = z.halfFrame2));
            });
            this.MULTI_PIPELINE = this.get(d.MULTI_PIPELINE);
            this.BITMAPMASK_PIPELINE = this.get(d.BITMAPMASK_PIPELINE);
            if (r)
              for (u in r) {
                var y = r[u];
                var z = new y(x);
                z.isPostFX
                  ? this.postPipelineClasses.set(u, y)
                  : this.has(u) || (this.classes.set(u, y), this.add(u, z));
              }
          },
          add: function (r, u) {
            if (u.isPostFX)
              console.warn(
                r + " is a Post Pipeline. Use `addPostPipeline` instead"
              );
            else {
              var v = this.pipelines,
                x = this.renderer;
              v.has(r)
                ? console.warn("Pipeline exists: " + r)
                : ((u.name = r), (u.manager = this), v.set(r, u));
              u.hasBooted || u.boot();
              0 !== x.width && 0 !== x.height && u.resize(x.width, x.height);
              return u;
            }
          },
          addPostPipeline: function (r, u) {
            this.postPipelineClasses.has(r) ||
              this.postPipelineClasses.set(r, u);
          },
          flush: function () {
            this.current && this.current.flush();
          },
          has: function (r) {
            var u = this.pipelines;
            return "string" === typeof r ? u.has(r) : u.contains(r) ? !0 : !1;
          },
          get: function (r) {
            var u = this.pipelines;
            if ("string" === typeof r) return u.get(r);
            if (u.contains(r)) return r;
          },
          getPostPipeline: function (r, u) {
            var v = this.postPipelineClasses,
              x;
            "string" === typeof r
              ? (x = v.get(r))
              : "function" === typeof r
              ? v.contains(r) && (x = r)
              : "object" === typeof r && (x = v.get(r.name));
            if (x) return (r = new x(this.game)), u && (r.gameObject = u), r;
          },
          remove: function (r, u, v) {
            void 0 === u && (u = !0);
            void 0 === v && (v = !0);
            this.pipelines.delete(r);
            u && this.classes.delete(r);
            v && this.postPipelineClasses.delete(r);
          },
          set: function (r, u, v) {
            if (!r.isPostFX)
              return (
                this.isCurrent(r, v) ||
                  (this.flush(),
                  this.current && this.current.unbind(),
                  (this.current = r),
                  r.bind(v)),
                r.updateProjectionMatrix(),
                r.onBind(u),
                r
              );
          },
          preBatch: function (r) {
            if (r.hasPostPipeline) {
              this.flush();
              for (var u = r.postPipelines, v = u.length - 1; 0 <= v; v--) {
                var x = u[v];
                x.active && x.preBatch(r);
              }
            }
          },
          postBatch: function (r) {
            if (r.hasPostPipeline) {
              this.flush();
              for (var u = r.postPipelines, v = 0; v < u.length; v++) {
                var x = u[v];
                x.active && x.postBatch(r);
              }
            }
          },
          preBatchCamera: function (r) {
            if (r.hasPostPipeline) {
              this.flush();
              for (var u = r.postPipelines, v = u.length - 1; 0 <= v; v--) {
                var x = u[v];
                x.active && x.preBatch(r);
              }
            }
          },
          postBatchCamera: function (r) {
            if (r.hasPostPipeline) {
              this.flush();
              for (var u = r.postPipelines, v = 0; v < u.length; v++) {
                var x = u[v];
                x.active && x.postBatch(r);
              }
            }
          },
          isCurrent: function (r, u) {
            var v = this.renderer,
              x = this.current;
            x && !u && (u = x.currentShader);
            return !(x !== r || u.program !== v.currentProgram);
          },
          copyFrame: function (r, u, v, x, y) {
            this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(
              r,
              u,
              v,
              x,
              y
            );
            return this;
          },
          copyToGame: function (r) {
            this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(r);
            return this;
          },
          drawFrame: function (r, u, v, x) {
            this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(
              r,
              u,
              v,
              x
            );
            return this;
          },
          blendFrames: function (r, u, v, x, y) {
            this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(
              r,
              u,
              v,
              x,
              y
            );
            return this;
          },
          blendFramesAdditive: function (r, u, v, x, y) {
            this.setUtility(
              this.UTILITY_PIPELINE.addShader
            ).blendFramesAdditive(r, u, v, x, y);
            return this;
          },
          clearFrame: function (r, u) {
            this.UTILITY_PIPELINE.clearFrame(r, u);
            return this;
          },
          blitFrame: function (r, u, v, x, y, z) {
            this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(
              r,
              u,
              v,
              x,
              y,
              z
            );
            return this;
          },
          copyFrameRect: function (r, u, v, x, y, z, A, B) {
            this.UTILITY_PIPELINE.copyFrameRect(r, u, v, x, y, z, A, B);
            return this;
          },
          forceZero: function () {
            return this.current && this.current.forceZero;
          },
          setMulti: function () {
            return this.set(this.MULTI_PIPELINE);
          },
          setUtility: function (r) {
            return this.UTILITY_PIPELINE.bind(r);
          },
          rebind: function (r) {
            void 0 === r && this.previous && (r = this.previous);
            var u = this.renderer,
              v = u.gl;
            v.disable(v.DEPTH_TEST);
            v.disable(v.CULL_FACE);
            u.hasActiveStencilMask()
              ? v.clear(v.DEPTH_BUFFER_BIT)
              : (v.disable(v.STENCIL_TEST),
                v.clear(v.DEPTH_BUFFER_BIT | v.STENCIL_BUFFER_BIT));
            v.viewport(0, 0, u.width, u.height);
            u.currentProgram = null;
            u.setBlendMode(0, !0);
            v = this.pipelines.entries;
            for (var x in v) v[x].glReset = !0;
            r && ((this.current = r), r.rebind());
            u.resetTextures();
          },
          clear: function () {
            var r = this.renderer;
            this.flush();
            this.current
              ? (this.current.unbind(),
                (this.previous = this.current),
                (this.current = null))
              : (this.previous = null);
            r.currentProgram = null;
            r.setBlendMode(0, !0);
          },
          destroy: function () {
            this.flush();
            this.classes.clear();
            this.postPipelineClasses.clear();
            this.pipelines.clear();
            this.previous =
              this.current =
              this.pipelines =
              this.postPipelineClasses =
              this.classes =
              this.game =
              this.renderer =
                null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(2),
          k = a(866),
          e = a(867),
          b = a(107),
          c = a(58);
        a = new t({
          Extends: c,
          initialize: function (f) {
            f.fragShader = d(f, "fragShader", k);
            f.vertShader = d(f, "vertShader", e);
            f.batchSize = d(f, "batchSize", 1);
            f.vertices = d(f, "vertices", [-1, 1, -1, -7, 7, 1]);
            f.attributes = d(f, "attributes", [
              {
                name: "inPosition",
                size: 2,
                type: b.FLOAT,
              },
            ]);
            c.call(this, f);
          },
          boot: function () {
            c.prototype.boot.call(this);
            this.set1i("uMainSampler", 0);
            this.set1i("uMaskSampler", 1);
          },
          resize: function (f, g) {
            c.prototype.resize.call(this, f, g);
            this.set2f("uResolution", f, g);
          },
          beginMask: function (f, g, m) {
            g = this.gl;
            if (f.bitmapMask && g) {
              var n = this.renderer;
              n.flush();
              n.pushFramebuffer(f.mainFramebuffer);
              g.disable(g.STENCIL_TEST);
              g.clearColor(0, 0, 0, 0);
              g.clear(g.COLOR_BUFFER_BIT);
              n.currentCameraMask.mask !== f &&
                ((n.currentMask.mask = f), (n.currentMask.camera = m));
            }
          },
          endMask: function (f, g) {
            var m = this.gl,
              n = this.renderer,
              q = f.bitmapMask;
            q &&
              m &&
              (n.flush(),
              n.pushFramebuffer(f.maskFramebuffer),
              m.clearColor(0, 0, 0, 0),
              m.clear(m.COLOR_BUFFER_BIT),
              n.setBlendMode(0, !0),
              q.renderWebGL(n, q, g),
              n.flush(),
              n.popFramebuffer(),
              n.popFramebuffer(),
              (g = n.getCurrentStencilMask())
                ? (m.enable(m.STENCIL_TEST),
                  g.mask.applyStencil(n, g.camera, !0))
                : (n.currentMask.mask = null),
              n.pipelines.set(this),
              m.activeTexture(m.TEXTURE1),
              m.bindTexture(m.TEXTURE_2D, f.maskTexture),
              m.activeTexture(m.TEXTURE0),
              m.bindTexture(m.TEXTURE_2D, f.mainTexture),
              this.set1i("uInvertMaskAlpha", f.invertAlpha),
              m.drawArrays(this.topology, 0, 3),
              n.resetTextures());
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          AFTER_FLUSH: a(868),
          BEFORE_FLUSH: a(869),
          BIND: a(870),
          BOOT: a(871),
          DESTROY: a(872),
          REBIND: a(873),
          RESIZE: a(874),
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(2),
          k = a(107);
        a = new t({
          initialize: function (e, b, c, f, g) {
            this.pipeline = e;
            this.name = b;
            this.renderer = e.renderer;
            this.gl = this.renderer.gl;
            this.program = this.renderer.createProgram(c, f);
            this.attributes;
            this.vertexSize = this.vertexComponentCount = 0;
            this.uniforms = {};
            this.createAttributes(g);
            this.createUniforms();
          },
          createAttributes: function (e) {
            for (
              var b = 0, c = 0, f = [], g = (this.vertexComponentCount = 0);
              g < e.length;
              g++
            ) {
              var m = e[g],
                n = m.name,
                q = d(m, "size", 1),
                r = d(m, "type", k.FLOAT),
                u = r.size;
              f.push({
                name: n,
                size: q,
                type: r.enum,
                normalized: m.normalized ? !0 : !1,
                offset: c,
                enabled: !1,
                location: -1,
              });
              4 === u ? (b += q) : b++;
              c += q * u;
            }
            this.vertexSize = c;
            this.vertexComponentCount = b;
            this.attributes = f;
          },
          bind: function (e, b) {
            void 0 === e && (e = !1);
            void 0 === b && (b = !1);
            b && this.pipeline.flush();
            this.renderer.setProgram(this.program);
            e && this.setAttribPointers();
            return this;
          },
          rebind: function () {
            this.renderer.setProgram(this.program);
            this.setAttribPointers(!0);
            return this;
          },
          setAttribPointers: function (e) {
            void 0 === e && (e = !1);
            for (
              var b = this.gl,
                c = this.vertexSize,
                f = this.attributes,
                g = this.program,
                m = 0;
              m < f.length;
              m++
            ) {
              var n = f[m],
                q = n.size,
                r = n.type,
                u = n.offset,
                v = n.enabled,
                x = n.location,
                y = n.normalized ? !0 : !1;
              e
                ? ((v = b.getAttribLocation(g, n.name)),
                  0 <= v
                    ? (b.enableVertexAttribArray(v),
                      b.vertexAttribPointer(v, q, r, y, c, u),
                      (n.enabled = !0),
                      (n.location = v))
                    : -1 !== v && b.disableVertexAttribArray(v))
                : v
                ? b.vertexAttribPointer(x, q, r, y, c, u)
                : !v &&
                  -1 < x &&
                  (b.disableVertexAttribArray(x), (n.location = -1));
            }
            return this;
          },
          createUniforms: function () {
            var e = this.gl,
              b = this.program,
              c = this.uniforms,
              f,
              g,
              m = e.getProgramParameter(b, e.ACTIVE_UNIFORMS);
            for (f = 0; f < m; f++)
              if ((g = e.getActiveUniform(b, f))) {
                g = g.name;
                var n = e.getUniformLocation(b, g);
                null !== n &&
                  (c[g] = {
                    name: g,
                    location: n,
                    value1: null,
                    value2: null,
                    value3: null,
                    value4: null,
                  });
                n = g.indexOf("[");
                0 < n &&
                  ((g = g.substr(0, n)),
                  c.hasOwnProperty(g) ||
                    ((n = e.getUniformLocation(b, g)),
                    null !== n &&
                      (c[g] = {
                        name: g,
                        location: n,
                        value1: null,
                        value2: null,
                        value3: null,
                        value4: null,
                      })));
              }
            return this;
          },
          hasUniform: function (e) {
            return this.uniforms.hasOwnProperty(e);
          },
          resetUniform: function (e) {
            if ((e = this.uniforms[e]))
              (e.value1 = null),
                (e.value2 = null),
                (e.value3 = null),
                (e.value4 = null);
            return this;
          },
          setUniform1: function (e, b, c, f) {
            b = this.uniforms[b];
            if (!b) return this;
            if (f || b.value1 !== c)
              (b.value1 = c),
                this.renderer.setProgram(this.program),
                e.call(this.gl, b.location, c),
                (this.pipeline.currentShader = this);
            return this;
          },
          setUniform2: function (e, b, c, f, g) {
            b = this.uniforms[b];
            if (!b) return this;
            if (g || b.value1 !== c || b.value2 !== f)
              (b.value1 = c),
                (b.value2 = f),
                this.renderer.setProgram(this.program),
                e.call(this.gl, b.location, c, f),
                (this.pipeline.currentShader = this);
            return this;
          },
          setUniform3: function (e, b, c, f, g, m) {
            b = this.uniforms[b];
            if (!b) return this;
            if (m || b.value1 !== c || b.value2 !== f || b.value3 !== g)
              (b.value1 = c),
                (b.value2 = f),
                (b.value3 = g),
                this.renderer.setProgram(this.program),
                e.call(this.gl, b.location, c, f, g),
                (this.pipeline.currentShader = this);
            return this;
          },
          setUniform4: function (e, b, c, f, g, m, n) {
            b = this.uniforms[b];
            if (!b) return this;
            if (
              n ||
              b.value1 !== c ||
              b.value2 !== f ||
              b.value3 !== g ||
              b.value4 !== m
            )
              (b.value1 = c),
                (b.value2 = f),
                (b.value3 = g),
                (b.value4 = m),
                this.renderer.setProgram(this.program),
                e.call(this.gl, b.location, c, f, g, m),
                (this.pipeline.currentShader = this);
            return this;
          },
          set1f: function (e, b) {
            return this.setUniform1(this.gl.uniform1f, e, b);
          },
          set2f: function (e, b, c) {
            return this.setUniform2(this.gl.uniform2f, e, b, c);
          },
          set3f: function (e, b, c, f) {
            return this.setUniform3(this.gl.uniform3f, e, b, c, f);
          },
          set4f: function (e, b, c, f, g) {
            return this.setUniform4(this.gl.uniform4f, e, b, c, f, g);
          },
          set1fv: function (e, b) {
            return this.setUniform1(this.gl.uniform1fv, e, b, !0);
          },
          set2fv: function (e, b) {
            return this.setUniform1(this.gl.uniform2fv, e, b, !0);
          },
          set3fv: function (e, b) {
            return this.setUniform1(this.gl.uniform3fv, e, b, !0);
          },
          set4fv: function (e, b) {
            return this.setUniform1(this.gl.uniform4fv, e, b, !0);
          },
          set1iv: function (e, b) {
            return this.setUniform1(this.gl.uniform1iv, e, b, !0);
          },
          set2iv: function (e, b) {
            return this.setUniform1(this.gl.uniform2iv, e, b, !0);
          },
          set3iv: function (e, b) {
            return this.setUniform1(this.gl.uniform3iv, e, b, !0);
          },
          set4iv: function (e, b) {
            return this.setUniform1(this.gl.uniform4iv, e, b, !0);
          },
          set1i: function (e, b) {
            return this.setUniform1(this.gl.uniform1i, e, b);
          },
          set2i: function (e, b, c) {
            return this.setUniform2(this.gl.uniform2i, e, b, c);
          },
          set3i: function (e, b, c, f) {
            return this.setUniform3(this.gl.uniform3i, e, b, c, f);
          },
          set4i: function (e, b, c, f, g) {
            return this.setUniform4(this.gl.uniform4i, e, b, c, f, g);
          },
          setMatrix2fv: function (e, b, c) {
            return this.setUniform2(this.gl.uniformMatrix2fv, e, b, c, !0);
          },
          setMatrix3fv: function (e, b, c) {
            return this.setUniform2(this.gl.uniformMatrix3fv, e, b, c, !0);
          },
          setMatrix4fv: function (e, b, c) {
            return this.setUniform2(this.gl.uniformMatrix4fv, e, b, c, !0);
          },
          destroy: function () {
            this.gl.deleteProgram(this.program);
            this.uniforms =
              this.attributes =
              this.program =
              this.gl =
              this.renderer =
              this.pipeline =
                null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(59),
          k = a(2),
          e = a(875),
          b = a(876),
          c = a(25),
          f = a(107),
          g = a(58);
        a = new t({
          Extends: g,
          initialize: function (m) {
            m.fragShader = k(m, "fragShader", e);
            m.vertShader = k(m, "vertShader", b);
            m.attributes = k(m, "attributes", [
              {
                name: "inPosition",
                size: 2,
              },
              {
                name: "inColor",
                size: 4,
                type: f.UNSIGNED_BYTE,
                normalized: !0,
              },
            ]);
            g.call(this, m);
            this.calcMatrix = new c();
            this.tempTriangle = [
              {
                x: 0,
                y: 0,
                width: 0,
              },
              {
                x: 0,
                y: 0,
                width: 0,
              },
              {
                x: 0,
                y: 0,
                width: 0,
              },
              {
                x: 0,
                y: 0,
                width: 0,
              },
            ];
            this.strokeTint = {
              TL: 0,
              TR: 0,
              BL: 0,
              BR: 0,
            };
            this.fillTint = {
              TL: 0,
              TR: 0,
              BL: 0,
              BR: 0,
            };
            this.currentFrame = {
              u0: 0,
              v0: 0,
              u1: 1,
              v1: 1,
            };
            this.firstQuad = [0, 0, 0, 0, 0];
            this.prevQuad = [0, 0, 0, 0, 0];
            this.polygonCache = [];
          },
          batchFillRect: function (m, n, q, r, u, v) {
            this.renderer.pipelines.set(this);
            var x = this.calcMatrix;
            v && v.multiply(u, x);
            v = m + q;
            var y = n + r;
            r = x.getX(m, n);
            q = x.getY(m, n);
            u = x.getX(m, y);
            m = x.getY(m, y);
            var z = x.getX(v, y);
            y = x.getY(v, y);
            var A = x.getX(v, n);
            n = x.getY(v, n);
            x = this.fillTint;
            this.batchQuad(r, q, u, m, z, y, A, n, x.TL, x.TR, x.BL, x.BR);
          },
          batchFillTriangle: function (m, n, q, r, u, v, x, y) {
            this.renderer.pipelines.set(this);
            var z = this.calcMatrix;
            y && y.multiply(x, z);
            x = z.getX(m, n);
            m = z.getY(m, n);
            n = z.getX(q, r);
            q = z.getY(q, r);
            r = z.getX(u, v);
            u = z.getY(u, v);
            v = this.fillTint;
            this.batchTri(x, m, n, q, r, u, v.TL, v.TR, v.BL);
          },
          batchStrokeTriangle: function (m, n, q, r, u, v, x, y, z) {
            var A = this.tempTriangle;
            A[0].x = m;
            A[0].y = n;
            A[0].width = x;
            A[1].x = q;
            A[1].y = r;
            A[1].width = x;
            A[2].x = u;
            A[2].y = v;
            A[2].width = x;
            A[3].x = m;
            A[3].y = n;
            A[3].width = x;
            this.batchStrokePath(A, x, !1, y, z);
          },
          batchFillPath: function (m, n, q) {
            this.renderer.pipelines.set(this);
            var r = this.calcMatrix;
            q && q.multiply(n, r);
            n = m.length;
            q = this.polygonCache;
            for (
              var u,
                v = this.fillTint.TL,
                x = this.fillTint.TR,
                y = this.fillTint.BL,
                z = 0;
              z < n;
              ++z
            )
              (u = m[z]), q.push(u.x, u.y);
            m = d(q);
            n = m.length;
            for (u = 0; u < n; u += 3) {
              var A = 2 * m[u + 0];
              z = 2 * m[u + 1];
              var B = 2 * m[u + 2],
                D = q[A + 0],
                E = q[A + 1];
              A = q[z + 0];
              var C = q[z + 1];
              z = q[B + 0];
              var F = q[B + 1];
              B = r.getX(D, E);
              D = r.getY(D, E);
              E = r.getX(A, C);
              A = r.getY(A, C);
              C = r.getX(z, F);
              z = r.getY(z, F);
              this.batchTri(B, D, E, A, C, z, v, x, y);
            }
            q.length = 0;
          },
          batchStrokePath: function (m, n, q, r, u) {
            this.renderer.pipelines.set(this);
            this.prevQuad[4] = 0;
            this.firstQuad[4] = 0;
            for (var v = m.length - 1, x = 0; x < v; x++) {
              var y = m[x],
                z = m[x + 1];
              this.batchLine(
                y.x,
                y.y,
                z.x,
                z.y,
                y.width / 2,
                z.width / 2,
                n,
                x,
                !q && x === v - 1,
                r,
                u
              );
            }
          },
          batchLine: function (m, n, q, r, u, v, x, y, z, A, B) {
            this.renderer.pipelines.set(this);
            var D = this.calcMatrix;
            B && B.multiply(A, D);
            A = q - m;
            B = r - n;
            var E = Math.sqrt(A * A + B * B);
            A = (u * (r - n)) / E;
            B = (u * (m - q)) / E;
            var C = (v * (r - n)) / E,
              F = (v * (m - q)) / E;
            E = q - C;
            var G = r - F;
            v = m - A;
            u = n - B;
            q += C;
            C = r + F;
            A = m + A;
            F = n + B;
            n = D.getX(E, G);
            m = D.getY(E, G);
            r = D.getX(v, u);
            v = D.getY(v, u);
            u = D.getX(q, C);
            q = D.getY(q, C);
            B = D.getX(A, F);
            D = D.getY(A, F);
            C = this.strokeTint;
            A = C.TL;
            E = C.TR;
            G = C.BL;
            C = C.BR;
            this.batchQuad(B, D, r, v, n, m, u, q, A, E, G, C);
            2 >= x ||
              ((x = this.prevQuad),
              (F = this.firstQuad),
              0 < y && x[4]
                ? this.batchQuad(B, D, r, v, x[0], x[1], x[2], x[3], A, E, G, C)
                : ((F[0] = B), (F[1] = D), (F[2] = r), (F[3] = v), (F[4] = 1)),
              z && F[4]
                ? this.batchQuad(n, m, u, q, F[0], F[1], F[2], F[3], A, E, G, C)
                : ((x[0] = n), (x[1] = m), (x[2] = u), (x[3] = q), (x[4] = 1)));
          },
          batchVert: function (m, n, q) {
            var r = this.vertexViewF32,
              u = this.vertexViewU32,
              v =
                this.vertexCount * this.currentShader.vertexComponentCount - 1;
            r[++v] = m;
            r[++v] = n;
            u[++v] = q;
            this.vertexCount++;
          },
          batchQuad: function (m, n, q, r, u, v, x, y, z, A, B, D) {
            var E = !1;
            this.shouldFlush(6) && (this.flush(), (E = !0));
            this.batchVert(m, n, z);
            this.batchVert(q, r, B);
            this.batchVert(u, v, D);
            this.batchVert(m, n, z);
            this.batchVert(u, v, D);
            this.batchVert(x, y, A);
            return E;
          },
          batchTri: function (m, n, q, r, u, v, x, y, z) {
            var A = !1;
            this.shouldFlush(3) && (this.flush(), (A = !0));
            this.batchVert(m, n, x);
            this.batchVert(q, r, y);
            this.batchVert(u, v, z);
            return A;
          },
          destroy: function () {
            g.prototype.destroy.call(this);
            this.polygonCache = null;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(2),
          k = a(877),
          e = a(108),
          b = a(3),
          c = a(58),
          f = 10,
          g = new b();
        a = new t({
          Extends: e,
          initialize: function (m) {
            f = m.game.renderer.config.maxLights;
            for (var n = d(m, "fragShader", k), q = [], r = 1; r <= f; r++)
              q.push({
                name: "lights" + r,
                fragShader: n.replace("%LIGHT_COUNT%", r.toString()),
              });
            m.shaders = q;
            e.call(this, m);
            this.inverseRotationMatrix = new Float32Array([
              1, 0, 0, 0, 1, 0, 0, 0, 1,
            ]);
            this.defaultNormalMap;
            this.lightsActive = !0;
          },
          boot: function () {
            c.prototype.boot.call(this);
            var m = this.gl,
              n = m.createTexture();
            m.activeTexture(m.TEXTURE0);
            m.bindTexture(m.TEXTURE_2D, n);
            m.texImage2D(
              m.TEXTURE_2D,
              0,
              m.RGBA,
              1,
              1,
              0,
              m.RGBA,
              m.UNSIGNED_BYTE,
              new Uint8Array([127, 127, 255, 255])
            );
            this.defaultNormalMap = {
              glTexture: n,
            };
            for (m = 0; m < this.shaders.length; m++)
              this["lightShader" + (m + 1)] = this.shaders[m];
          },
          onRender: function (m, n) {
            var q = m.sys.lights;
            this.lightsActive = !1;
            if (q && q.active) {
              m = q.getLights(n);
              var r = m.length;
              if (0 !== r) {
                this.lightsActive = !0;
                this.setShader(this["lightShader" + r], !0);
                var u = this.renderer.height,
                  v = n.matrix;
                this.set1i("uMainSampler", 0);
                this.set1i("uNormSampler", 1);
                this.set2f("uResolution", this.width / 2, this.height / 2);
                this.set4f("uCamera", n.x, n.y, n.rotation, n.zoom);
                this.set3f(
                  "uAmbientLightColor",
                  q.ambientColor.r,
                  q.ambientColor.g,
                  q.ambientColor.b
                );
                for (q = 0; q < r; q++) {
                  var x = m[q].light,
                    y = x.color,
                    z = "uLights[" + q + "].";
                  v.transformPoint(x.x, x.y, g);
                  this.set2f(
                    z + "position",
                    g.x - n.scrollX * x.scrollFactorX * n.zoom,
                    u - (g.y - n.scrollY * x.scrollFactorY * n.zoom)
                  );
                  this.set3f(z + "color", y.r, y.g, y.b);
                  this.set1f(z + "intensity", x.intensity);
                  this.set1f(z + "radius", x.radius);
                }
                this.currentNormalMapRotation = null;
              }
            }
          },
          setNormalMapRotation: function (m) {
            if (m !== this.currentNormalMapRotation || 0 === this.vertexCount) {
              0 < this.vertexCount && this.flush();
              var n = this.inverseRotationMatrix;
              if (m) {
                var q = -m,
                  r = Math.cos(q);
                q = Math.sin(q);
                n[1] = q;
                n[3] = -q;
                n[0] = n[4] = r;
              } else (n[0] = n[4] = 1), (n[1] = n[3] = 0);
              this.setMatrix3fv("uInverseRotationMatrix", !1, n);
              this.currentNormalMapRotation = m;
            }
          },
          setTexture2D: function (m, n) {
            var q = this.renderer;
            void 0 === m && (m = q.tempTextures[0]);
            var r = this.getNormalMap(n);
            q.isNewNormalMap(m, r) &&
              (this.flush(), q.setTextureZero(m), q.setNormalMap(r));
            this.setNormalMapRotation(n ? n.rotation : 0);
            return (this.currentUnit = 0);
          },
          setGameObject: function (m, n) {
            void 0 === n && (n = m.frame);
            var q = this.renderer;
            n = n.glTexture;
            var r = this.getNormalMap(m);
            q.isNewNormalMap() &&
              (this.flush(), q.setTextureZero(n), q.setNormalMap(r));
            this.setNormalMapRotation(m.rotation);
            return (this.currentUnit = 0);
          },
          getNormalMap: function (m) {
            var n;
            m
              ? m.displayTexture
                ? (n = m.displayTexture.dataSource[m.displayFrame.sourceIndex])
                : m.texture
                ? (n = m.texture.dataSource[m.frame.sourceIndex])
                : m.tileset &&
                  (n = Array.isArray(m.tileset)
                    ? m.tileset[0].image.dataSource[0]
                    : m.tileset.image.dataSource[0])
              : (n = this.defaultNormalMap);
            n || (n = this.defaultNormalMap);
            return n.glTexture;
          },
          batchSprite: function (m, n, q) {
            this.lightsActive && e.prototype.batchSprite.call(this, m, n, q);
          },
          batchTexture: function (
            m,
            n,
            q,
            r,
            u,
            v,
            x,
            y,
            z,
            A,
            B,
            D,
            E,
            C,
            F,
            G,
            H,
            K,
            I,
            M,
            N,
            P,
            J,
            L,
            O,
            Q,
            S,
            R,
            T,
            U,
            V,
            X
          ) {
            this.lightsActive &&
              e.prototype.batchTexture.call(
                this,
                m,
                n,
                q,
                r,
                u,
                v,
                x,
                y,
                z,
                A,
                B,
                D,
                E,
                C,
                F,
                G,
                H,
                K,
                I,
                M,
                N,
                P,
                J,
                L,
                O,
                Q,
                S,
                R,
                T,
                U,
                V,
                X
              );
          },
          batchTextureFrame: function (m, n, q, r, u, v, x) {
            this.lightsActive &&
              e.prototype.batchTextureFrame.call(this, m, n, q, r, u, v, x);
          },
        });
        a.LIGHT_COUNT = f;
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(2),
          k = a(880),
          e = a(881),
          b = a(58);
        a = new t({
          Extends: b,
          initialize: function (c) {
            c.vertShader = d(c, "vertShader", e);
            c.fragShader = d(c, "fragShader", k);
            c.attributes = d(c, "attributes", [
              {
                name: "inPosition",
                size: 2,
              },
              {
                name: "inLightPosition",
                size: 2,
              },
              {
                name: "inLightRadius",
              },
              {
                name: "inLightAttenuation",
              },
              {
                name: "inLightColor",
                size: 4,
              },
            ]);
            b.call(this, c);
          },
          onRender: function (c, f) {
            this.set2f("uResolution", this.width, this.height);
            this.set1f("uCameraZoom", f.zoom);
          },
          batchPointLight: function (c, f, g, m, n, q, r, u, v, x, y, z) {
            var A = c.color,
              B = c.intensity,
              D = c.radius,
              E = c.attenuation,
              C = A.r * B,
              F = A.g * B;
            A = A.b * B;
            c = f.alpha * c.alpha;
            this.shouldFlush(6) && this.flush();
            this.batchLightVert(g, m, y, z, D, E, C, F, A, c);
            this.batchLightVert(n, q, y, z, D, E, C, F, A, c);
            this.batchLightVert(r, u, y, z, D, E, C, F, A, c);
            this.batchLightVert(g, m, y, z, D, E, C, F, A, c);
            this.batchLightVert(r, u, y, z, D, E, C, F, A, c);
            this.batchLightVert(v, x, y, z, D, E, C, F, A, c);
          },
          batchLightVert: function (c, f, g, m, n, q, r, u, v, x) {
            var y = this.vertexViewF32,
              z =
                this.vertexCount * this.currentShader.vertexComponentCount - 1;
            y[++z] = c;
            y[++z] = f;
            y[++z] = g;
            y[++z] = m;
            y[++z] = n;
            y[++z] = q;
            y[++z] = r;
            y[++z] = u;
            y[++z] = v;
            y[++z] = x;
            this.vertexCount++;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(2),
          k = a(108);
        a = new t({
          Extends: k,
          initialize: function (e) {
            e.topology = 5;
            e.batchSize = d(e, "batchSize", 256);
            k.call(this, e);
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(2),
          k = a(108),
          e = a(882),
          b = a(883),
          c = a(58);
        a = new t({
          Extends: k,
          initialize: function (f) {
            f.fragShader = d(f, "fragShader", e);
            f.vertShader = d(f, "vertShader", b);
            f.forceZero = !0;
            k.call(this, f);
          },
          boot: function () {
            c.prototype.boot.call(this);
            this.set1i("uMainSampler", 0);
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(884),
          k = a(35);
        t = a(0);
        var e = a(198),
          b = a(885),
          c = a(886),
          f = a(2),
          g = a(887),
          m = a(382),
          n = a(58);
        a = new t({
          Extends: n,
          initialize: function (q) {
            q.renderTarget = f(q, "renderTarget", [
              {
                scale: 1,
              },
              {
                scale: 1,
              },
              {
                scale: 0.5,
              },
              {
                scale: 0.5,
              },
            ]);
            q.vertShader = f(q, "vertShader", m);
            q.shaders = f(q, "shaders", [
              {
                name: "Copy",
                fragShader: c,
              },
              {
                name: "AddBlend",
                fragShader: d,
              },
              {
                name: "LinearBlend",
                fragShader: g,
              },
              {
                name: "ColorMatrix",
                fragShader: b,
              },
            ]);
            q.attributes = f(q, "attributes", [
              {
                name: "inPosition",
                size: 2,
              },
              {
                name: "inTexCoord",
                size: 2,
              },
            ]);
            q.vertices = [
              -1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1,
              1, -1, 1, 0,
            ];
            q.batchSize = 1;
            n.call(this, q);
            this.colorMatrix = new e();
            this.copyShader;
            this.addShader;
            this.linearShader;
            this.colorMatrixShader;
            this.fullFrame1;
            this.fullFrame2;
            this.halfFrame1;
            this.halfFrame2;
          },
          boot: function () {
            n.prototype.boot.call(this);
            var q = this.shaders,
              r = this.renderTargets;
            this.copyShader = q[0];
            this.addShader = q[1];
            this.linearShader = q[2];
            this.colorMatrixShader = q[3];
            this.fullFrame1 = r[0];
            this.fullFrame2 = r[1];
            this.halfFrame1 = r[2];
            this.halfFrame2 = r[3];
          },
          copyFrame: function (q, r, u, v, x) {
            void 0 === u && (u = 1);
            void 0 === v && (v = !0);
            void 0 === x && (x = !0);
            var y = this.gl;
            this.setShader(this.copyShader);
            this.set1i("uMainSampler", 0);
            this.set1f("uBrightness", u);
            y.activeTexture(y.TEXTURE0);
            y.bindTexture(y.TEXTURE_2D, q.texture);
            r
              ? (y.viewport(0, 0, r.width, r.height),
                y.bindFramebuffer(y.FRAMEBUFFER, r.framebuffer),
                y.framebufferTexture2D(
                  y.FRAMEBUFFER,
                  y.COLOR_ATTACHMENT0,
                  y.TEXTURE_2D,
                  r.texture,
                  0
                ))
              : y.viewport(0, 0, q.width, q.height);
            v &&
              (x ? y.clearColor(0, 0, 0, 0) : y.clearColor(0, 0, 0, 1),
              y.clear(y.COLOR_BUFFER_BIT));
            y.bufferData(y.ARRAY_BUFFER, this.vertexData, y.STATIC_DRAW);
            y.drawArrays(y.TRIANGLES, 0, 6);
            y.bindFramebuffer(y.FRAMEBUFFER, null);
            y.bindTexture(y.TEXTURE_2D, null);
          },
          blitFrame: function (q, r, u, v, x, y) {
            void 0 === u && (u = 1);
            void 0 === v && (v = !0);
            void 0 === x && (x = !0);
            void 0 === y && (y = !1);
            var z = this.gl;
            this.setShader(this.copyShader);
            this.set1i("uMainSampler", 0);
            this.set1f("uBrightness", u);
            z.activeTexture(z.TEXTURE0);
            z.bindTexture(z.TEXTURE_2D, q.texture);
            q.height > r.height
              ? (z.viewport(0, 0, q.width, q.height), this.setTargetUVs(q, r))
              : z.viewport(0, r.height - q.height, q.width, q.height);
            z.bindFramebuffer(z.FRAMEBUFFER, r.framebuffer);
            z.framebufferTexture2D(
              z.FRAMEBUFFER,
              z.COLOR_ATTACHMENT0,
              z.TEXTURE_2D,
              r.texture,
              0
            );
            v &&
              (x ? z.clearColor(0, 0, 0, 0) : z.clearColor(0, 0, 0, 1),
              z.clear(z.COLOR_BUFFER_BIT));
            if (y) {
              var A = this.renderer.currentBlendMode;
              this.renderer.setBlendMode(k.ERASE);
            }
            z.bufferData(z.ARRAY_BUFFER, this.vertexData, z.STATIC_DRAW);
            z.drawArrays(z.TRIANGLES, 0, 6);
            y && this.renderer.setBlendMode(A);
            z.bindFramebuffer(z.FRAMEBUFFER, null);
            z.bindTexture(z.TEXTURE_2D, null);
            this.resetUVs();
          },
          copyFrameRect: function (q, r, u, v, x, y, z, A) {
            void 0 === z && (z = !0);
            void 0 === A && (A = !0);
            var B = this.gl;
            B.bindFramebuffer(B.FRAMEBUFFER, q.framebuffer);
            B.framebufferTexture2D(
              B.FRAMEBUFFER,
              B.COLOR_ATTACHMENT0,
              B.TEXTURE_2D,
              q.texture,
              0
            );
            z &&
              (A ? B.clearColor(0, 0, 0, 0) : B.clearColor(0, 0, 0, 1),
              B.clear(B.COLOR_BUFFER_BIT));
            B.activeTexture(B.TEXTURE0);
            B.bindTexture(B.TEXTURE_2D, r.texture);
            B.copyTexSubImage2D(B.TEXTURE_2D, 0, 0, 0, u, v, x, y);
            B.bindFramebuffer(B.FRAMEBUFFER, null);
            B.bindTexture(B.TEXTURE_2D, null);
          },
          copyToGame: function (q) {
            var r = this.gl;
            this.setShader(this.copyShader);
            this.set1i("uMainSampler", 0);
            this.set1f("uBrightness", 1);
            this.renderer.popFramebuffer();
            r.activeTexture(r.TEXTURE0);
            r.bindTexture(r.TEXTURE_2D, q.texture);
            r.bufferData(r.ARRAY_BUFFER, this.vertexData, r.STATIC_DRAW);
            r.drawArrays(r.TRIANGLES, 0, 6);
            this.renderer.resetTextures();
          },
          drawFrame: function (q, r, u, v) {
            void 0 === u && (u = !0);
            void 0 === v && (v = this.colorMatrix);
            var x = this.gl;
            this.setShader(this.colorMatrixShader);
            this.set1i("uMainSampler", 0);
            this.set1fv("uColorMatrix", v.getData());
            this.set1f("uAlpha", v.alpha);
            x.activeTexture(x.TEXTURE0);
            x.bindTexture(x.TEXTURE_2D, q.texture);
            r
              ? (x.viewport(0, 0, r.width, r.height),
                x.bindFramebuffer(x.FRAMEBUFFER, r.framebuffer),
                x.framebufferTexture2D(
                  x.FRAMEBUFFER,
                  x.COLOR_ATTACHMENT0,
                  x.TEXTURE_2D,
                  r.texture,
                  0
                ))
              : x.viewport(0, 0, q.width, q.height);
            u ? x.clearColor(0, 0, 0, 0) : x.clearColor(0, 0, 0, 1);
            x.clear(x.COLOR_BUFFER_BIT);
            x.bufferData(x.ARRAY_BUFFER, this.vertexData, x.STATIC_DRAW);
            x.drawArrays(x.TRIANGLES, 0, 6);
            x.bindFramebuffer(x.FRAMEBUFFER, null);
            x.bindTexture(x.TEXTURE_2D, null);
          },
          blendFrames: function (q, r, u, v, x, y) {
            void 0 === v && (v = 1);
            void 0 === x && (x = !0);
            void 0 === y && (y = this.linearShader);
            var z = this.gl;
            this.setShader(y);
            this.set1i("uMainSampler1", 0);
            this.set1i("uMainSampler2", 1);
            this.set1f("uStrength", v);
            z.activeTexture(z.TEXTURE0);
            z.bindTexture(z.TEXTURE_2D, q.texture);
            z.activeTexture(z.TEXTURE1);
            z.bindTexture(z.TEXTURE_2D, r.texture);
            u
              ? (z.bindFramebuffer(z.FRAMEBUFFER, u.framebuffer),
                z.framebufferTexture2D(
                  z.FRAMEBUFFER,
                  z.COLOR_ATTACHMENT0,
                  z.TEXTURE_2D,
                  u.texture,
                  0
                ),
                z.viewport(0, 0, u.width, u.height))
              : z.viewport(0, 0, q.width, q.height);
            x ? z.clearColor(0, 0, 0, 0) : z.clearColor(0, 0, 0, 1);
            z.clear(z.COLOR_BUFFER_BIT);
            z.bufferData(z.ARRAY_BUFFER, this.vertexData, z.STATIC_DRAW);
            z.drawArrays(z.TRIANGLES, 0, 6);
            z.bindFramebuffer(z.FRAMEBUFFER, null);
            z.bindTexture(z.TEXTURE_2D, null);
          },
          blendFramesAdditive: function (q, r, u, v, x) {
            this.blendFrames(q, r, u, v, x, this.addShader);
          },
          clearFrame: function (q, r) {
            void 0 === r && (r = !0);
            var u = this.gl;
            u.viewport(0, 0, q.width, q.height);
            u.bindFramebuffer(u.FRAMEBUFFER, q.framebuffer);
            r ? u.clearColor(0, 0, 0, 0) : u.clearColor(0, 0, 0, 1);
            u.clear(u.COLOR_BUFFER_BIT);
            u.bindFramebuffer(u.FRAMEBUFFER, this.renderer.currentFramebuffer);
          },
          setUVs: function (q, r, u, v, x, y, z, A) {
            var B = this.vertexViewF32;
            B[2] = q;
            B[3] = r;
            B[6] = u;
            B[7] = v;
            B[10] = x;
            B[11] = y;
            B[14] = q;
            B[15] = r;
            B[18] = x;
            B[19] = y;
            B[22] = z;
            B[23] = A;
          },
          setTargetUVs: function (q, r) {
            q = r.height / q.height;
            q = 0.5 < q ? 0.5 - (q - 0.5) : 0.5 + (0.5 - q);
            this.setUVs(0, q, 0, 1 + q, 1, 1 + q, 1, q);
          },
          flipX: function () {
            this.setUVs(1, 0, 1, 1, 0, 1, 0, 0);
          },
          flipY: function () {
            this.setUVs(0, 1, 0, 0, 1, 0, 1, 1);
          },
          resetUVs: function () {
            this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_QUAD_VS\n\nprecision mediump float;\n\nattribute vec2 inPosition;\nattribute vec2 inTexCoord;\n\nvarying vec2 outFragCoord;\nvarying vec2 outTexCoord;\n\nvoid main ()\n{\n    outFragCoord = inPosition.xy * 0.5 + 0.5;\n    outTexCoord = inTexCoord;\n\n    gl_Position = vec4(inPosition, 0, 1);\n}\n";
      },
      function (h, t, a) {
        var d = a(31),
          k = a(38),
          e = a(2);
        h.exports = function (b, c) {
          var f = b.getContext("experimental-webgl"),
            g = e(c, "callback");
          b = e(c, "type", "image/png");
          var m = e(c, "encoder", 0.92),
            n = e(c, "x", 0),
            q = e(c, "y", 0),
            r = e(c, "getPixel", !1),
            u = e(c, "isFramebuffer", !1),
            v = u ? e(c, "bufferWidth", 1) : f.drawingBufferWidth,
            x = u ? e(c, "bufferHeight", 1) : f.drawingBufferHeight;
          if (r)
            (b = new Uint8Array(4)),
              f.readPixels(n, u ? q : x - q, 1, 1, f.RGBA, f.UNSIGNED_BYTE, b),
              g.call(null, new k(b[0], b[1], b[2], b[3] / 255));
          else {
            u = e(c, "width", v);
            c = e(c, "height", x);
            r = new Uint8Array(u * c * 4);
            f.readPixels(n, x - q - c, u, c, f.RGBA, f.UNSIGNED_BYTE, r);
            var y = d.createWebGL(this, u, c);
            f = y.getContext("2d");
            n = f.getImageData(0, 0, u, c);
            q = n.data;
            for (x = 0; x < c; x++)
              for (v = 0; v < u; v++) {
                var z = 4 * ((c - x - 1) * u + v),
                  A = 4 * (x * u + v);
                q[A + 0] = r[z + 0];
                q[A + 1] = r[z + 1];
                q[A + 2] = r[z + 2];
                q[A + 3] = r[z + 3];
              }
            f.putImageData(n, 0, 0);
            var B = new Image();
            B.onerror = function () {
              g.call(null);
              d.remove(y);
            };
            B.onload = function () {
              g.call(null, B);
              d.remove(y);
            };
            B.src = y.toDataURL(b, m);
          }
        };
      },
      function (h, t, a) {
        var d = a(33);
        h.exports = function (k) {
          var e = k.config;
          if (!e.hideBanner) {
            var b = "WebGL";
            e.renderType === d.CANVAS
              ? (b = "Canvas")
              : e.renderType === d.HEADLESS && (b = "Headless");
            var c = e.audio,
              f = k.device.audio;
            c =
              f.webAudio && !c.disableWebAudio
                ? "Web Audio"
                : c.noAudio || (!f.webAudio && !f.audioData)
                ? "No Audio"
                : "HTML5 Audio";
            if (!k.device.browser.ie) {
              var g = "",
                m = [g];
              if (Array.isArray(e.bannerBackgroundColor)) {
                var n;
                e.bannerBackgroundColor.forEach(function (q) {
                  g = g.concat("%c ");
                  m.push("background: " + q);
                  n = q;
                });
                m[m.length - 1] =
                  "color: " + e.bannerTextColor + "; background: " + n;
              } else
                (g = g.concat("%c ")),
                  m.push(
                    "color: " +
                      e.bannerTextColor +
                      "; background: " +
                      e.bannerBackgroundColor
                  );
              m.push("background: transparent");
              e.gameTitle &&
                ((g = g.concat(e.gameTitle)),
                e.gameVersion && (g = g.concat(" v" + e.gameVersion)),
                e.hidePhaser || (g = g.concat(" / ")));
              e.hidePhaser ||
                (g = g.concat(
                  "Phaser v" + d.VERSION + " (" + b + " | " + c + ")"
                ));
              g = g.concat(" %c " + e.gameURL);
              m[0] = g;
              console.log.apply(console, m);
            }
          }
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(6),
          k = a(1),
          e = a(386);
        a = new t({
          initialize: function (b, c) {
            this.game = b;
            this.raf = new e();
            this.running = this.started = !1;
            this.minFps = d(c, "min", 5);
            this.targetFps = d(c, "target", 60);
            this._min = 1e3 / this.minFps;
            this._target = 1e3 / this.targetFps;
            this.actualFps = this.targetFps;
            this.framesThisSecond = this.nextFpsUpdate = 0;
            this.callback = k;
            this.forceSetTimeOut = d(c, "forceSetTimeOut", !1);
            this.frame = this.lastTime = this.startTime = this.time = 0;
            this.inFocus = !0;
            this.deltaIndex = this.delta = this._coolDown = this._pauseTime = 0;
            this.deltaHistory = [];
            this.deltaSmoothingMax = d(c, "deltaHistory", 10);
            this.panicMax = d(c, "panicMax", 120);
            this.now = this.rawDelta = 0;
            this.smoothStep = d(c, "smoothStep", !0);
          },
          blur: function () {
            this.inFocus = !1;
          },
          focus: function () {
            this.inFocus = !0;
            this.resetDelta();
          },
          pause: function () {
            this._pauseTime = window.performance.now();
          },
          resume: function () {
            this.resetDelta();
            this.startTime += this.time - this._pauseTime;
          },
          resetDelta: function () {
            var b = window.performance.now();
            this.lastTime = this.time = b;
            this.nextFpsUpdate = b + 1e3;
            for (b = this.framesThisSecond = 0; b < this.deltaSmoothingMax; b++)
              this.deltaHistory[b] = Math.min(
                this._target,
                this.deltaHistory[b]
              );
            this.deltaIndex = this.delta = 0;
            this._coolDown = this.panicMax;
          },
          start: function (b) {
            if (this.started) return this;
            this.running = this.started = !0;
            for (var c = 0; c < this.deltaSmoothingMax; c++)
              this.deltaHistory[c] = this._target;
            this.resetDelta();
            this.startTime = window.performance.now();
            this.callback = b;
            this.raf.start(
              this.step.bind(this),
              this.forceSetTimeOut,
              this._target
            );
          },
          step: function () {
            var b = window.performance.now();
            this.now = b;
            var c = b - this.lastTime;
            0 > c && (c = 0);
            this.rawDelta = c;
            var f = this.deltaIndex,
              g = this.deltaHistory,
              m = this.deltaSmoothingMax,
              n = c;
            if (this.smoothStep) {
              if (0 < this._coolDown || !this.inFocus)
                this._coolDown--, (n = Math.min(n, this._target));
              n > this._min && ((n = g[f]), (n = Math.min(n, this._min)));
              g[f] = n;
              this.deltaIndex++;
              this.deltaIndex > m && (this.deltaIndex = 0);
              for (f = c = 0; f < m; f++) c += g[f];
              c /= m;
            }
            this.delta = c;
            this.time += this.rawDelta;
            b > this.nextFpsUpdate &&
              ((this.actualFps =
                0.25 * this.framesThisSecond + 0.75 * this.actualFps),
              (this.nextFpsUpdate = b + 1e3),
              (this.framesThisSecond = 0));
            this.framesThisSecond++;
            this.callback(b, c, c / this._target);
            this.lastTime = b;
            this.frame++;
          },
          tick: function () {
            this.step();
          },
          sleep: function () {
            this.running && (this.raf.stop(), (this.running = !1));
          },
          wake: function (b) {
            this.running ||
              (b &&
                (this.startTime +=
                  -this.lastTime + (this.lastTime + window.performance.now())),
              this.raf.start(this.step.bind(this), this.useRAF),
              (this.running = !0),
              this.step());
          },
          getDuration: function () {
            return Math.round(this.lastTime - this.startTime) / 1e3;
          },
          getDurationMS: function () {
            return Math.round(this.lastTime - this.startTime);
          },
          stop: function () {
            this.started = this.running = !1;
            this.raf.stop();
            return this;
          },
          destroy: function () {
            this.stop();
            this.callback = k;
            this.game = this.raf = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(1);
        a = new t({
          initialize: function () {
            this.isRunning = !1;
            this.callback = d;
            this.tick = 0;
            this.isSetTimeOut = !1;
            this.timeOutID = null;
            this.target = this.lastTime = 0;
            var k = this;
            this.step = function b() {
              var c = window.performance.now();
              k.lastTime = k.tick;
              k.tick = c;
              k.callback(c);
              k.timeOutID = window.requestAnimationFrame(b);
            };
            this.stepTimeout = function c() {
              var f = Date.now(),
                g = Math.min(Math.max(2 * k.target + k.tick - f, 0), k.target);
              k.lastTime = k.tick;
              k.tick = f;
              k.callback(f);
              k.timeOutID = window.setTimeout(c, g);
            };
          },
          start: function (k, e, b) {
            this.isRunning ||
              ((this.callback = k),
              (this.isSetTimeOut = e),
              (this.target = b),
              (this.isRunning = !0),
              (this.timeOutID = e
                ? window.setTimeout(this.stepTimeout, 0)
                : window.requestAnimationFrame(this.step)));
          },
          stop: function () {
            this.isRunning = !1;
            this.isSetTimeOut
              ? clearTimeout(this.timeOutID)
              : window.cancelAnimationFrame(this.timeOutID);
          },
          destroy: function () {
            this.stop();
            this.callback = d;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(22);
        h.exports = function (k) {
          var e,
            b = k.events;
          void 0 !== document.hidden
            ? (e = "visibilitychange")
            : ["webkit", "moz", "ms"].forEach(function (f) {
                void 0 !== document[f + "Hidden"] &&
                  ((document.hidden = function () {
                    return document[f + "Hidden"];
                  }),
                  (e = f + "visibilitychange"));
              });
          var c = function (f) {
            document.hidden || "pause" === f.type
              ? b.emit(d.HIDDEN)
              : b.emit(d.VISIBLE);
          };
          e && document.addEventListener(e, c, !1);
          window.onblur = function () {
            b.emit(d.BLUR);
          };
          window.onfocus = function () {
            b.emit(d.FOCUS);
          };
          window.focus && k.config.autoFocus && window.focus();
        };
      },
      function (h, t, a) {
        var d = a(389),
          k = a(31),
          e = a(6);
        h.exports = function (b) {
          var c = e(b, "data", []),
            f = e(b, "canvas", null),
            g = e(b, "palette", d),
            m = e(b, "pixelWidth", 1),
            n = e(b, "pixelHeight", m),
            q = e(b, "resizeCanvas", !0),
            r = e(b, "clearCanvas", !0),
            u = e(b, "preRender", null);
          b = e(b, "postRender", null);
          var v = Math.floor(Math.abs(c[0].length * m)),
            x = Math.floor(Math.abs(c.length * n));
          f || ((f = k.create2D(this, v, x)), (r = q = !1));
          q && ((f.width = v), (f.height = x));
          q = f.getContext("2d");
          r && q.clearRect(0, 0, v, x);
          u && u(f, q);
          for (r = 0; r < c.length; r++)
            for (u = c[r], v = 0; v < u.length; v++)
              (x = u[v]),
                "." !== x &&
                  " " !== x &&
                  ((q.fillStyle = g[x]), q.fillRect(v * m, r * n, m, n));
          b && b(f, q);
          return f;
        };
      },
      function (h, t) {
        h.exports = {
          0: "#000",
          1: "#9D9D9D",
          2: "#FFF",
          3: "#BE2633",
          4: "#E06F8B",
          5: "#493C2B",
          6: "#A46422",
          7: "#EB8931",
          8: "#F7E26B",
          9: "#2F484E",
          A: "#44891A",
          B: "#A3CE27",
          C: "#1B2632",
          D: "#005784",
          E: "#31A2F2",
          F: "#B2DCEF",
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(358),
          k = a(94),
          e = a(3),
          b = new t({
            Extends: k,
            initialize: function (c, f, g, m) {
              k.call(this, "CubicBezierCurve");
              Array.isArray(c) &&
                ((m = new e(c[6], c[7])),
                (g = new e(c[4], c[5])),
                (f = new e(c[2], c[3])),
                (c = new e(c[0], c[1])));
              this.p0 = c;
              this.p1 = f;
              this.p2 = g;
              this.p3 = m;
            },
            getStartPoint: function (c) {
              void 0 === c && (c = new e());
              return c.copy(this.p0);
            },
            getResolution: function (c) {
              return c;
            },
            getPoint: function (c, f) {
              void 0 === f && (f = new e());
              var g = this.p0,
                m = this.p1,
                n = this.p2,
                q = this.p3;
              return f.set(d(c, g.x, m.x, n.x, q.x), d(c, g.y, m.y, n.y, q.y));
            },
            draw: function (c, f) {
              void 0 === f && (f = 32);
              f = this.getPoints(f);
              c.beginPath();
              c.moveTo(this.p0.x, this.p0.y);
              for (var g = 1; g < f.length; g++) c.lineTo(f[g].x, f[g].y);
              c.strokePath();
              return c;
            },
            toJSON: function () {
              return {
                type: this.type,
                points: [
                  this.p0.x,
                  this.p0.y,
                  this.p1.x,
                  this.p1.y,
                  this.p2.x,
                  this.p2.y,
                  this.p3.x,
                  this.p3.y,
                ],
              };
            },
          });
        b.fromJSON = function (c) {
          var f = c.points;
          c = new e(f[0], f[1]);
          var g = new e(f[2], f[3]),
            m = new e(f[4], f[5]);
          f = new e(f[6], f[7]);
          return new b(c, g, m, f);
        };
        h.exports = b;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(94),
          k = a(36),
          e = a(6),
          b = a(196),
          c = a(3),
          f = new t({
            Extends: d,
            initialize: function (g, m, n, q, r, u, v, x) {
              "object" === typeof g
                ? ((x = g),
                  (g = e(x, "x", 0)),
                  (m = e(x, "y", 0)),
                  (n = e(x, "xRadius", 0)),
                  (q = e(x, "yRadius", n)),
                  (r = e(x, "startAngle", 0)),
                  (u = e(x, "endAngle", 360)),
                  (v = e(x, "clockwise", !1)),
                  (x = e(x, "rotation", 0)))
                : (void 0 === q && (q = n),
                  void 0 === r && (r = 0),
                  void 0 === u && (u = 360),
                  void 0 === v && (v = !1),
                  void 0 === x && (x = 0));
              d.call(this, "EllipseCurve");
              this.p0 = new c(g, m);
              this._xRadius = n;
              this._yRadius = q;
              this._startAngle = k(r);
              this._endAngle = k(u);
              this._clockwise = v;
              this._rotation = k(x);
            },
            getStartPoint: function (g) {
              void 0 === g && (g = new c());
              return this.getPoint(0, g);
            },
            getResolution: function (g) {
              return 2 * g;
            },
            getPoint: function (g, m) {
              void 0 === m && (m = new c());
              for (
                var n = 2 * Math.PI,
                  q = this._endAngle - this._startAngle,
                  r = Math.abs(q) < Number.EPSILON;
                0 > q;

              )
                q += n;
              for (; q > n; ) q -= n;
              q < Number.EPSILON && (q = r ? 0 : n);
              this._clockwise && !r && (q = q === n ? -n : q - n);
              n = this._startAngle + g * q;
              g = this.p0.x + this._xRadius * Math.cos(n);
              var u = this.p0.y + this._yRadius * Math.sin(n);
              0 !== this._rotation &&
                ((n = Math.cos(this._rotation)),
                (q = Math.sin(this._rotation)),
                (r = g - this.p0.x),
                (u -= this.p0.y),
                (g = r * n - u * q + this.p0.x),
                (u = r * q + u * n + this.p0.y));
              return m.set(g, u);
            },
            setXRadius: function (g) {
              this.xRadius = g;
              return this;
            },
            setYRadius: function (g) {
              this.yRadius = g;
              return this;
            },
            setWidth: function (g) {
              this.xRadius = g / 2;
              return this;
            },
            setHeight: function (g) {
              this.yRadius = g / 2;
              return this;
            },
            setStartAngle: function (g) {
              this.startAngle = g;
              return this;
            },
            setEndAngle: function (g) {
              this.endAngle = g;
              return this;
            },
            setClockwise: function (g) {
              this.clockwise = g;
              return this;
            },
            setRotation: function (g) {
              this.rotation = g;
              return this;
            },
            x: {
              get: function () {
                return this.p0.x;
              },
              set: function (g) {
                this.p0.x = g;
              },
            },
            y: {
              get: function () {
                return this.p0.y;
              },
              set: function (g) {
                this.p0.y = g;
              },
            },
            xRadius: {
              get: function () {
                return this._xRadius;
              },
              set: function (g) {
                this._xRadius = g;
              },
            },
            yRadius: {
              get: function () {
                return this._yRadius;
              },
              set: function (g) {
                this._yRadius = g;
              },
            },
            startAngle: {
              get: function () {
                return b(this._startAngle);
              },
              set: function (g) {
                this._startAngle = k(g);
              },
            },
            endAngle: {
              get: function () {
                return b(this._endAngle);
              },
              set: function (g) {
                this._endAngle = k(g);
              },
            },
            clockwise: {
              get: function () {
                return this._clockwise;
              },
              set: function (g) {
                this._clockwise = g;
              },
            },
            angle: {
              get: function () {
                return b(this._rotation);
              },
              set: function (g) {
                this._rotation = k(g);
              },
            },
            rotation: {
              get: function () {
                return this._rotation;
              },
              set: function (g) {
                this._rotation = g;
              },
            },
            toJSON: function () {
              return {
                type: this.type,
                x: this.p0.x,
                y: this.p0.y,
                xRadius: this._xRadius,
                yRadius: this._yRadius,
                startAngle: b(this._startAngle),
                endAngle: b(this._endAngle),
                clockwise: this._clockwise,
                rotation: b(this._rotation),
              };
            },
          });
        f.fromJSON = function (g) {
          return new f(g);
        };
        h.exports = f;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(94),
          k = a(199),
          e = a(10),
          b = a(3),
          c = new t({
            Extends: d,
            initialize: function (f, g) {
              d.call(this, "LineCurve");
              Array.isArray(f) &&
                ((g = new b(f[2], f[3])), (f = new b(f[0], f[1])));
              this.p0 = f;
              this.p1 = g;
              this.arcLengthDivisions = 1;
            },
            getBounds: function (f) {
              void 0 === f && (f = new e());
              return k([this.p0, this.p1], f);
            },
            getStartPoint: function (f) {
              void 0 === f && (f = new b());
              return f.copy(this.p0);
            },
            getResolution: function (f) {
              void 0 === f && (f = 1);
              return f;
            },
            getPoint: function (f, g) {
              void 0 === g && (g = new b());
              if (1 === f) return g.copy(this.p1);
              g.copy(this.p1).subtract(this.p0).scale(f).add(this.p0);
              return g;
            },
            getPointAt: function (f, g) {
              return this.getPoint(f, g);
            },
            getTangent: function (f, g) {
              void 0 === g && (g = new b());
              g.copy(this.p1).subtract(this.p0).normalize();
              return g;
            },
            getUtoTmapping: function (f, g, m) {
              g
                ? ((f = this.getLengths(m)),
                  (f = f[f.length - 1]),
                  (g = Math.min(g, f) / f))
                : (g = f);
              return g;
            },
            draw: function (f) {
              f.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y);
              return f;
            },
            toJSON: function () {
              return {
                type: this.type,
                points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y],
              };
            },
          });
        c.fromJSON = function (f) {
          var g = f.points;
          f = new b(g[0], g[1]);
          g = new b(g[2], g[3]);
          return new c(f, g);
        };
        h.exports = c;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(3);
        a = new t({
          initialize: function (k, e) {
            this.active = !1;
            this.p0 = new d(k, e);
          },
          getPoint: function (k, e) {
            void 0 === e && (e = new d());
            return e.copy(this.p0);
          },
          getPointAt: function (k, e) {
            return this.getPoint(k, e);
          },
          getResolution: function () {
            return 1;
          },
          getLength: function () {
            return 0;
          },
          toJSON: function () {
            return {
              type: "MoveTo",
              points: [this.p0.x, this.p0.y],
            };
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(94),
          k = a(359),
          e = a(3),
          b = new t({
            Extends: d,
            initialize: function (c, f, g) {
              d.call(this, "QuadraticBezier");
              Array.isArray(c) &&
                ((g = new e(c[4], c[5])),
                (f = new e(c[2], c[3])),
                (c = new e(c[0], c[1])));
              this.p0 = c;
              this.p1 = f;
              this.p2 = g;
            },
            getStartPoint: function (c) {
              void 0 === c && (c = new e());
              return c.copy(this.p0);
            },
            getResolution: function (c) {
              return c;
            },
            getPoint: function (c, f) {
              void 0 === f && (f = new e());
              var g = this.p0,
                m = this.p1,
                n = this.p2;
              return f.set(k(c, g.x, m.x, n.x), k(c, g.y, m.y, n.y));
            },
            draw: function (c, f) {
              void 0 === f && (f = 32);
              f = this.getPoints(f);
              c.beginPath();
              c.moveTo(this.p0.x, this.p0.y);
              for (var g = 1; g < f.length; g++) c.lineTo(f[g].x, f[g].y);
              c.strokePath();
              return c;
            },
            toJSON: function () {
              return {
                type: this.type,
                points: [
                  this.p0.x,
                  this.p0.y,
                  this.p1.x,
                  this.p1.y,
                  this.p2.x,
                  this.p2.y,
                ],
              };
            },
          });
        b.fromJSON = function (c) {
          var f = c.points;
          c = new e(f[0], f[1]);
          var g = new e(f[2], f[3]);
          f = new e(f[4], f[5]);
          return new b(c, g, f);
        };
        h.exports = b;
      },
      function (h, t, a) {
        var d = a(194);
        t = a(0);
        var k = a(94),
          e = a(3),
          b = new t({
            Extends: k,
            initialize: function (c) {
              void 0 === c && (c = []);
              k.call(this, "SplineCurve");
              this.points = [];
              this.addPoints(c);
            },
            addPoints: function (c) {
              for (var f = 0; f < c.length; f++) {
                var g = new e();
                "number" === typeof c[f]
                  ? ((g.x = c[f]), (g.y = c[f + 1]), f++)
                  : Array.isArray(c[f])
                  ? ((g.x = c[f][0]), (g.y = c[f][1]))
                  : ((g.x = c[f].x), (g.y = c[f].y));
                this.points.push(g);
              }
              return this;
            },
            addPoint: function (c, f) {
              c = new e(c, f);
              this.points.push(c);
              return c;
            },
            getStartPoint: function (c) {
              void 0 === c && (c = new e());
              return c.copy(this.points[0]);
            },
            getResolution: function (c) {
              return c * this.points.length;
            },
            getPoint: function (c, f) {
              void 0 === f && (f = new e());
              var g = this.points,
                m = (g.length - 1) * c;
              c = Math.floor(m);
              m -= c;
              var n = g[0 === c ? c : c - 1],
                q = g[c],
                r = g[c > g.length - 2 ? g.length - 1 : c + 1];
              g = g[c > g.length - 3 ? g.length - 1 : c + 2];
              return f.set(d(m, n.x, q.x, r.x, g.x), d(m, n.y, q.y, r.y, g.y));
            },
            toJSON: function () {
              for (var c = [], f = 0; f < this.points.length; f++)
                c.push(this.points[f].x), c.push(this.points[f].y);
              return {
                type: this.type,
                points: c,
              };
            },
          });
        b.fromJSON = function (c) {
          return new b(c.points);
        };
        h.exports = b;
      },
      function (h, t, a) {
        t = new (a(0))({
          initialize: function (d, k, e, b) {
            (k && "" !== k) ||
              (k =
                "precision mediump float;\nuniform vec2 resolution;\nvarying vec2 fragCoord;\nvoid main () {\n    vec2 uv = fragCoord / resolution.xy;\n    gl_FragColor = vec4(uv.xyx, 1.0);\n}");
            (e && "" !== e) ||
              (e =
                "precision mediump float;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uViewMatrix;\nuniform vec2 uResolution;\nattribute vec2 inPosition;\nvarying vec2 fragCoord;\nvarying vec2 outTexCoord;\nvoid main () {\n   gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);\n   fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);\n   outTexCoord = vec2(inPosition.x / uResolution.x, fragCoord.y / uResolution.y);\n}");
            void 0 === b && (b = null);
            this.key = d;
            this.fragmentSrc = k;
            this.vertexSrc = e;
            this.uniforms = b;
          },
        });
        h.exports = t;
      },
      function (h, t, a) {
        t = a(38);
        t.ColorSpectrum = a(909);
        t.ColorToRGBA = a(910);
        t.ComponentToHex = a(398);
        t.GetColor = a(103);
        t.GetColor32 = a(328);
        t.HexStringToColor = a(327);
        t.HSLToColor = a(911);
        t.HSVColorWheel = a(912);
        t.HSVToRGB = a(188);
        t.HueToComponent = a(399);
        t.IntegerToColor = a(189);
        t.IntegerToRGB = a(330);
        t.Interpolate = a(913);
        t.ObjectToColor = a(331);
        t.RandomRGB = a(914);
        t.RGBStringToColor = a(332);
        t.RGBToHSV = a(329);
        t.RGBToString = a(915);
        t.ValueToColor = a(187);
        h.exports = t;
      },
      function (h, t) {
        h.exports = function (a) {
          a = a.toString(16);
          return 1 === a.length ? "0" + a : a;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          0 > k && (k += 1);
          1 < k && --k;
          return k < 1 / 6
            ? a + 6 * (d - a) * k
            : 0.5 > k
            ? d
            : k < 2 / 3
            ? a + (d - a) * (2 / 3 - k) * 6
            : a;
        };
      },
      function (h, t, a) {
        var d = a(105);
        h.exports = function (k) {
          if (
            "complete" === document.readyState ||
            "interactive" === document.readyState
          )
            k();
          else {
            var e = function () {
              document.removeEventListener("deviceready", e, !0);
              document.removeEventListener("DOMContentLoaded", e, !0);
              window.removeEventListener("load", e, !0);
              k();
            };
            document.body
              ? d.cordova
                ? document.addEventListener("deviceready", e, !1)
                : (document.addEventListener("DOMContentLoaded", e, !0),
                  window.addEventListener("load", e, !0))
              : window.setTimeout(e, 20);
          }
        };
      },
      function (h, t) {
        h.exports = function (a) {
          if (!a) return window.innerHeight;
          var d = Math.abs(window.orientation),
            k = document.createElement("div");
          k.setAttribute(
            "style",
            "position: fixed; height: 100vh; width: 0; top: 0"
          );
          document.documentElement.appendChild(k);
          a = 90 === d ? k.offsetHeight : window.innerWidth;
          d = 90 === d ? window.innerWidth : k.offsetHeight;
          document.documentElement.removeChild(k);
          return 90 !== Math.abs(window.orientation) ? d : a;
        };
      },
      function (h, t, a) {
        var d = a(201);
        h.exports = function (k, e) {
          var b = window.screen;
          if (
            (b = b
              ? b.orientation || b.mozOrientation || b.msOrientation
              : !1) &&
            "string" === typeof b.type
          )
            return b.type;
          if ("string" === typeof b) return b;
          if ("number" === typeof window.orientation)
            return 0 === window.orientation || 180 === window.orientation
              ? d.ORIENTATION.PORTRAIT
              : d.ORIENTATION.LANDSCAPE;
          if (window.matchMedia) {
            if (window.matchMedia("(orientation: portrait)").matches)
              return d.ORIENTATION.PORTRAIT;
            if (window.matchMedia("(orientation: landscape)").matches)
              return d.ORIENTATION.LANDSCAPE;
          } else
            return e > k ? d.ORIENTATION.PORTRAIT : d.ORIENTATION.LANDSCAPE;
        };
      },
      function (h, t) {
        h.exports = {
          NO_CENTER: 0,
          CENTER_BOTH: 1,
          CENTER_HORIZONTALLY: 2,
          CENTER_VERTICALLY: 3,
        };
      },
      function (h, t) {
        h.exports = {
          LANDSCAPE: "landscape-primary",
          PORTRAIT: "portrait-primary",
        };
      },
      function (h, t) {
        h.exports = {
          NONE: 0,
          WIDTH_CONTROLS_HEIGHT: 1,
          HEIGHT_CONTROLS_WIDTH: 2,
          FIT: 3,
          ENVELOP: 4,
          RESIZE: 5,
        };
      },
      function (h, t) {
        h.exports = {
          NO_ZOOM: 1,
          ZOOM_2X: 2,
          ZOOM_4X: 4,
          MAX_ZOOM: -1,
        };
      },
      function (h, t) {
        h.exports = function (a) {
          var d;
          "" !== a &&
            ("string" === typeof a
              ? (d = document.getElementById(a))
              : a && 1 === a.nodeType && (d = a));
          d || (d = document.body);
          return d;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          var d = "";
          try {
            window.DOMParser
              ? (d = new DOMParser().parseFromString(a, "text/xml"))
              : ((d = new ActiveXObject("Microsoft.XMLDOM")), d.loadXML(a));
          } catch (k) {
            d = null;
          }
          return d &&
            d.documentElement &&
            !d.getElementsByTagName("parsererror").length
            ? d
            : null;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(203),
          k = a(9),
          e = a(51),
          b = a(22),
          c = a(410),
          f = a(411),
          g = a(412),
          m = a(413),
          n = a(25),
          q = a(177);
        a = new t({
          initialize: function (r, u) {
            this.game = r;
            this.scaleManager;
            this.canvas;
            this.config = u;
            this.enabled = !0;
            this.events = new k();
            this.isOver = !0;
            this.defaultCursor = "";
            this.keyboard = u.inputKeyboard ? new c(this) : null;
            this.mouse = u.inputMouse ? new f(this) : null;
            this.touch = u.inputTouch ? new m(this) : null;
            this.pointers = [];
            this.pointersTotal = u.inputActivePointers;
            u.inputTouch &&
              1 === this.pointersTotal &&
              (this.pointersTotal = 2);
            for (var v = 0; v <= this.pointersTotal; v++) {
              var x = new g(this, v);
              x.smoothFactor = u.inputSmoothFactor;
              this.pointers.push(x);
            }
            this.mousePointer = u.inputMouse ? this.pointers[0] : null;
            this.activePointer = this.pointers[0];
            this.globalTopOnly = !0;
            this.time = 0;
            this._tempPoint = {
              x: 0,
              y: 0,
            };
            this._tempHitTest = [];
            this._tempMatrix = new n();
            this._tempMatrix2 = new n();
            this._tempSkip = !1;
            this.mousePointerContainer = [this.mousePointer];
            r.events.once(b.BOOT, this.boot, this);
          },
          boot: function () {
            this.canvas = this.game.canvas;
            this.scaleManager = this.game.scale;
            this.events.emit(e.MANAGER_BOOT);
            this.game.events.on(b.PRE_RENDER, this.preRender, this);
            this.game.events.once(b.DESTROY, this.destroy, this);
          },
          setCanvasOver: function (r) {
            this.isOver = !0;
            this.events.emit(e.GAME_OVER, r);
          },
          setCanvasOut: function (r) {
            this.isOver = !1;
            this.events.emit(e.GAME_OUT, r);
          },
          preRender: function () {
            var r = this.game.loop.now,
              u = this.game.loop.delta,
              v = this.game.scene.getScenes(!0, !0);
            this.time = r;
            this.events.emit(e.MANAGER_UPDATE);
            for (var x = 0; x < v.length; x++) {
              var y = v[x];
              if (
                y.sys.input &&
                y.sys.input.updatePoll(r, u) &&
                this.globalTopOnly
              )
                break;
            }
          },
          setDefaultCursor: function (r) {
            this.defaultCursor = r;
            this.canvas.style.cursor !== r && (this.canvas.style.cursor = r);
          },
          setCursor: function (r) {
            r.cursor && (this.canvas.style.cursor = r.cursor);
          },
          resetCursor: function (r) {
            r.cursor &&
              this.canvas &&
              (this.canvas.style.cursor = this.defaultCursor);
          },
          addPointer: function (r) {
            void 0 === r && (r = 1);
            var u = [];
            10 < this.pointersTotal + r && (r = 10 - this.pointersTotal);
            for (var v = 0; v < r; v++) {
              var x = new g(this, this.pointers.length);
              x.smoothFactor = this.config.inputSmoothFactor;
              this.pointers.push(x);
              this.pointersTotal++;
              u.push(x);
            }
            return u;
          },
          updateInputPlugins: function (r, u) {
            var v = this.game.scene.getScenes(!0, !0);
            this._tempSkip = !1;
            for (var x = 0; x < v.length; x++) {
              var y = v[x];
              if (
                y.sys.input &&
                ((y.sys.input.update(r, u) && this.globalTopOnly) ||
                  this._tempSkip)
              )
                break;
            }
          },
          onTouchStart: function (r) {
            for (
              var u = this.pointers, v = [], x = 0;
              x < r.changedTouches.length;
              x++
            )
              for (
                var y = r.changedTouches[x], z = 1;
                z < this.pointersTotal;
                z++
              ) {
                var A = u[z];
                if (!A.active) {
                  A.touchstart(y, r);
                  this.activePointer = A;
                  v.push(A);
                  break;
                }
              }
            this.updateInputPlugins(d.TOUCH_START, v);
          },
          onTouchMove: function (r) {
            for (
              var u = this.pointers, v = [], x = 0;
              x < r.changedTouches.length;
              x++
            )
              for (
                var y = r.changedTouches[x], z = 1;
                z < this.pointersTotal;
                z++
              ) {
                var A = u[z];
                if (A.active && A.identifier === y.identifier) {
                  A.touchmove(y, r);
                  this.activePointer = A;
                  v.push(A);
                  break;
                }
              }
            this.updateInputPlugins(d.TOUCH_MOVE, v);
          },
          onTouchEnd: function (r) {
            for (
              var u = this.pointers, v = [], x = 0;
              x < r.changedTouches.length;
              x++
            )
              for (
                var y = r.changedTouches[x], z = 1;
                z < this.pointersTotal;
                z++
              ) {
                var A = u[z];
                if (A.active && A.identifier === y.identifier) {
                  A.touchend(y, r);
                  v.push(A);
                  break;
                }
              }
            this.updateInputPlugins(d.TOUCH_END, v);
          },
          onTouchCancel: function (r) {
            for (
              var u = this.pointers, v = [], x = 0;
              x < r.changedTouches.length;
              x++
            )
              for (
                var y = r.changedTouches[x], z = 1;
                z < this.pointersTotal;
                z++
              ) {
                var A = u[z];
                if (A.active && A.identifier === y.identifier) {
                  A.touchcancel(y, r);
                  v.push(A);
                  break;
                }
              }
            this.updateInputPlugins(d.TOUCH_CANCEL, v);
          },
          onMouseDown: function (r) {
            var u = this.mousePointer;
            u.down(r);
            u.updateMotion();
            this.activePointer = u;
            this.updateInputPlugins(d.MOUSE_DOWN, this.mousePointerContainer);
          },
          onMouseMove: function (r) {
            var u = this.mousePointer;
            u.move(r);
            u.updateMotion();
            this.activePointer = u;
            this.updateInputPlugins(d.MOUSE_MOVE, this.mousePointerContainer);
          },
          onMouseUp: function (r) {
            var u = this.mousePointer;
            u.up(r);
            u.updateMotion();
            this.activePointer = u;
            this.updateInputPlugins(d.MOUSE_UP, this.mousePointerContainer);
          },
          onMouseWheel: function (r) {
            var u = this.mousePointer;
            u.wheel(r);
            this.activePointer = u;
            this.updateInputPlugins(d.MOUSE_WHEEL, this.mousePointerContainer);
          },
          onPointerLockChange: function (r) {
            var u = this.mouse.locked;
            this.mousePointer.locked = u;
            this.events.emit(e.POINTERLOCK_CHANGE, r, u);
          },
          inputCandidate: function (r, u) {
            var v = r.input;
            if (!v || !v.enabled || (!v.alwaysEnabled && !r.willRender(u)))
              return !1;
            v = !0;
            if ((r = r.parentContainer)) {
              do {
                if (!r.willRender(u)) {
                  v = !1;
                  break;
                }
                r = r.parentContainer;
              } while (r);
            }
            return v;
          },
          hitTest: function (r, u, v, x) {
            void 0 === x && (x = this._tempHitTest);
            var y = this._tempPoint,
              z = v.scrollX,
              A = v.scrollY;
            x.length = 0;
            v.getWorldPoint(r.x, r.y, y);
            r.worldX = y.x;
            r.worldY = y.y;
            r = {
              x: 0,
              y: 0,
            };
            for (
              var B = this._tempMatrix, D = this._tempMatrix2, E = 0;
              E < u.length;
              E++
            ) {
              var C = u[E];
              if (this.inputCandidate(C, v)) {
                var F = y.x + z * C.scrollFactorX - z,
                  G = y.y + A * C.scrollFactorY - A;
                C.parentContainer
                  ? (C.getWorldTransformMatrix(B, D), B.applyInverse(F, G, r))
                  : q(F, G, C.x, C.y, C.rotation, C.scaleX, C.scaleY, r);
                this.pointWithinHitArea(C, r.x, r.y) && x.push(C);
              }
            }
            return x;
          },
          pointWithinHitArea: function (r, u, v) {
            u += r.displayOriginX;
            v += r.displayOriginY;
            var x = r.input;
            return x && x.hitAreaCallback(x.hitArea, u, v, r)
              ? ((x.localX = u), (x.localY = v), !0)
              : !1;
          },
          pointWithinInteractiveObject: function (r, u, v) {
            if (!r.hitArea) return !1;
            u += r.gameObject.displayOriginX;
            v += r.gameObject.displayOriginY;
            r.localX = u;
            r.localY = v;
            return r.hitAreaCallback(r.hitArea, u, v, r);
          },
          transformPointer: function (r, u, v, x) {
            var y = r.position,
              z = r.prevPosition;
            z.x = y.x;
            z.y = y.y;
            u = this.scaleManager.transformX(u);
            v = this.scaleManager.transformY(v);
            r = r.smoothFactor;
            x && 0 !== r
              ? ((y.x = u * r + z.x * (1 - r)), (y.y = v * r + z.y * (1 - r)))
              : ((y.x = u), (y.y = v));
          },
          destroy: function () {
            this.events.removeAllListeners();
            this.game.events.off(b.PRE_RENDER);
            this.keyboard && this.keyboard.destroy();
            this.mouse && this.mouse.destroy();
            this.touch && this.touch.destroy();
            for (var r = 0; r < this.pointers.length; r++)
              this.pointers[r].destroy();
            this.pointers = [];
            this._tempHitTest = [];
            this._tempMatrix.destroy();
            this.game = this.canvas = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(93);
        t = a(0);
        var k = a(22),
          e = a(51),
          b = a(143),
          c = a(1);
        a = new t({
          initialize: function (f) {
            this.manager = f;
            this.queue = [];
            this.preventDefault = !0;
            this.captures = [];
            this.enabled = !1;
            this.target;
            this.onKeyUp = this.onKeyDown = c;
            f.events.once(e.MANAGER_BOOT, this.boot, this);
          },
          boot: function () {
            var f = this.manager.config;
            this.enabled = f.inputKeyboard;
            this.target = f.inputKeyboardEventTarget;
            this.addCapture(f.inputKeyboardCapture);
            !this.target && window && (this.target = window);
            this.enabled && this.target && this.startListeners();
            this.manager.game.events.on(k.POST_STEP, this.postUpdate, this);
          },
          startListeners: function () {
            var f = this;
            this.onKeyDown = function (m) {
              if (!m.defaultPrevented && f.enabled && f.manager) {
                f.queue.push(m);
                f.manager.events.emit(e.MANAGER_PROCESS);
                var n = m.altKey || m.ctrlKey || m.shiftKey || m.metaKey;
                f.preventDefault &&
                  !n &&
                  -1 < f.captures.indexOf(m.keyCode) &&
                  m.preventDefault();
              }
            };
            this.onKeyUp = function (m) {
              if (!m.defaultPrevented && f.enabled && f.manager) {
                f.queue.push(m);
                f.manager.events.emit(e.MANAGER_PROCESS);
                var n = m.altKey || m.ctrlKey || m.shiftKey || m.metaKey;
                f.preventDefault &&
                  !n &&
                  -1 < f.captures.indexOf(m.keyCode) &&
                  m.preventDefault();
              }
            };
            var g = this.target;
            g &&
              (g.addEventListener("keydown", this.onKeyDown, !1),
              g.addEventListener("keyup", this.onKeyUp, !1),
              (this.enabled = !0));
          },
          stopListeners: function () {
            var f = this.target;
            f.removeEventListener("keydown", this.onKeyDown, !1);
            f.removeEventListener("keyup", this.onKeyUp, !1);
            this.enabled = !1;
          },
          postUpdate: function () {
            this.queue = [];
          },
          addCapture: function (f) {
            "string" === typeof f && (f = f.split(","));
            Array.isArray(f) || (f = [f]);
            for (var g = this.captures, m = 0; m < f.length; m++) {
              var n = f[m];
              "string" === typeof n && (n = b[n.trim().toUpperCase()]);
              -1 === g.indexOf(n) && g.push(n);
            }
            this.preventDefault = 0 < g.length;
          },
          removeCapture: function (f) {
            "string" === typeof f && (f = f.split(","));
            Array.isArray(f) || (f = [f]);
            for (var g = this.captures, m = 0; m < f.length; m++) {
              var n = f[m];
              "string" === typeof n && (n = b[n.toUpperCase()]);
              d(g, n);
            }
            this.preventDefault = 0 < g.length;
          },
          clearCaptures: function () {
            this.captures = [];
            this.preventDefault = !1;
          },
          destroy: function () {
            this.stopListeners();
            this.clearCaptures();
            this.queue = [];
            this.manager.game.events.off(k.POST_RENDER, this.postUpdate, this);
            this.target = null;
            this.enabled = !1;
            this.manager = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(191),
          k = a(51),
          e = a(1);
        a = new t({
          initialize: function (b) {
            this.manager = b;
            this.preventDefaultMove =
              this.preventDefaultUp =
              this.preventDefaultDown =
                !0;
            this.enabled = this.preventDefaultWheel = !1;
            this.target;
            this.locked = !1;
            this.pointerLockChange =
              this.onMouseWheel =
              this.onMouseOut =
              this.onMouseOver =
              this.onMouseUpWindow =
              this.onMouseDownWindow =
              this.onMouseUp =
              this.onMouseDown =
              this.onMouseMove =
                e;
            this.isTop = !0;
            b.events.once(k.MANAGER_BOOT, this.boot, this);
          },
          boot: function () {
            var b = this.manager.config;
            this.enabled = b.inputMouse;
            this.target = b.inputMouseEventTarget;
            this.passive = b.inputMousePassive;
            this.preventDefaultDown = b.inputMousePreventDefaultDown;
            this.preventDefaultUp = b.inputMousePreventDefaultUp;
            this.preventDefaultMove = b.inputMousePreventDefaultMove;
            this.preventDefaultWheel = b.inputMousePreventDefaultWheel;
            this.target
              ? "string" === typeof this.target &&
                (this.target = document.getElementById(this.target))
              : (this.target = this.manager.game.canvas);
            b.disableContextMenu && this.disableContextMenu();
            this.enabled && this.target && this.startListeners();
          },
          disableContextMenu: function () {
            document.body.addEventListener("contextmenu", function (b) {
              b.preventDefault();
              return !1;
            });
            return this;
          },
          requestPointerLock: function () {
            if (d.pointerLock) {
              var b = this.target;
              b.requestPointerLock =
                b.requestPointerLock ||
                b.mozRequestPointerLock ||
                b.webkitRequestPointerLock;
              b.requestPointerLock();
            }
          },
          releasePointerLock: function () {
            d.pointerLock &&
              ((document.exitPointerLock =
                document.exitPointerLock ||
                document.mozExitPointerLock ||
                document.webkitExitPointerLock),
              document.exitPointerLock());
          },
          startListeners: function () {
            var b = this.target;
            if (b) {
              var c = this,
                f = this.manager,
                g = f.canvas,
                m = window && window.focus && f.game.config.autoFocus;
              this.onMouseMove = function (q) {
                !q.defaultPrevented &&
                  c.enabled &&
                  f &&
                  f.enabled &&
                  (f.onMouseMove(q),
                  c.preventDefaultMove && q.preventDefault());
              };
              this.onMouseDown = function (q) {
                m && window.focus();
                !q.defaultPrevented &&
                  c.enabled &&
                  f &&
                  f.enabled &&
                  (f.onMouseDown(q),
                  c.preventDefaultDown && q.target === g && q.preventDefault());
              };
              this.onMouseDownWindow = function (q) {
                if (
                  !q.defaultPrevented &&
                  c.enabled &&
                  f &&
                  f.enabled &&
                  q.target !== g
                )
                  f.onMouseDown(q);
              };
              this.onMouseUp = function (q) {
                !q.defaultPrevented &&
                  c.enabled &&
                  f &&
                  f.enabled &&
                  (f.onMouseUp(q),
                  c.preventDefaultUp && q.target === g && q.preventDefault());
              };
              this.onMouseUpWindow = function (q) {
                if (
                  !q.defaultPrevented &&
                  c.enabled &&
                  f &&
                  f.enabled &&
                  q.target !== g
                )
                  f.onMouseUp(q);
              };
              this.onMouseOver = function (q) {
                !q.defaultPrevented &&
                  c.enabled &&
                  f &&
                  f.enabled &&
                  f.setCanvasOver(q);
              };
              this.onMouseOut = function (q) {
                !q.defaultPrevented &&
                  c.enabled &&
                  f &&
                  f.enabled &&
                  f.setCanvasOut(q);
              };
              this.onMouseWheel = function (q) {
                if (!q.defaultPrevented && c.enabled && f && f.enabled)
                  f.onMouseWheel(q);
                c.preventDefaultWheel && q.target === g && q.preventDefault();
              };
              var n = {
                passive: !0,
              };
              b.addEventListener("mousemove", this.onMouseMove);
              b.addEventListener("mousedown", this.onMouseDown);
              b.addEventListener("mouseup", this.onMouseUp);
              b.addEventListener("mouseover", this.onMouseOver, n);
              b.addEventListener("mouseout", this.onMouseOut, n);
              this.preventDefaultWheel
                ? b.addEventListener("wheel", this.onMouseWheel, {
                    passive: !1,
                  })
                : b.addEventListener("wheel", this.onMouseWheel, n);
              if (window && f.game.config.inputWindowEvents)
                try {
                  window.top.addEventListener(
                    "mousedown",
                    this.onMouseDownWindow,
                    n
                  ),
                    window.top.addEventListener(
                      "mouseup",
                      this.onMouseUpWindow,
                      n
                    );
                } catch (q) {
                  window.addEventListener(
                    "mousedown",
                    this.onMouseDownWindow,
                    n
                  ),
                    window.addEventListener("mouseup", this.onMouseUpWindow, n),
                    (this.isTop = !1);
                }
              d.pointerLock &&
                ((this.pointerLockChange = function (q) {
                  var r = c.target;
                  c.locked =
                    document.pointerLockElement === r ||
                    document.mozPointerLockElement === r ||
                    document.webkitPointerLockElement === r
                      ? !0
                      : !1;
                  f.onPointerLockChange(q);
                }),
                document.addEventListener(
                  "pointerlockchange",
                  this.pointerLockChange,
                  !0
                ),
                document.addEventListener(
                  "mozpointerlockchange",
                  this.pointerLockChange,
                  !0
                ),
                document.addEventListener(
                  "webkitpointerlockchange",
                  this.pointerLockChange,
                  !0
                ));
              this.enabled = !0;
            }
          },
          stopListeners: function () {
            var b = this.target;
            b.removeEventListener("mousemove", this.onMouseMove);
            b.removeEventListener("mousedown", this.onMouseDown);
            b.removeEventListener("mouseup", this.onMouseUp);
            b.removeEventListener("mouseover", this.onMouseOver);
            b.removeEventListener("mouseout", this.onMouseOut);
            window &&
              ((b = this.isTop ? window.top : window),
              b.removeEventListener("mousedown", this.onMouseDownWindow),
              b.removeEventListener("mouseup", this.onMouseUpWindow));
            d.pointerLock &&
              (document.removeEventListener(
                "pointerlockchange",
                this.pointerLockChange,
                !0
              ),
              document.removeEventListener(
                "mozpointerlockchange",
                this.pointerLockChange,
                !0
              ),
              document.removeEventListener(
                "webkitpointerlockchange",
                this.pointerLockChange,
                !0
              ));
          },
          destroy: function () {
            this.stopListeners();
            this.target = null;
            this.enabled = !1;
            this.manager = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(349);
        t = a(0);
        var k = a(50),
          e = a(124),
          b = a(360),
          c = a(3),
          f = a(105);
        a = new t({
          initialize: function (g, m) {
            this.manager = g;
            this.id = m;
            this.event;
            this.downElement;
            this.upElement;
            this.camera = null;
            this.buttons = this.button = 0;
            this.position = new c();
            this.prevPosition = new c();
            this.midPoint = new c(-1, -1);
            this.velocity = new c();
            this.smoothFactor = this.distance = this.angle = 0;
            this.motionFactor = 0.2;
            this.upTime =
              this.upY =
              this.upX =
              this.downTime =
              this.downY =
              this.downX =
              this.moveTime =
              this.worldY =
              this.worldX =
                0;
            this.wasCanceled =
              this.wasTouch =
              this.isDown =
              this.primaryDown =
                !1;
            this.identifier = this.movementY = this.movementX = 0;
            this.pointerId = null;
            this.active = 0 === m ? !0 : !1;
            this.locked = !1;
            this.deltaZ = this.deltaY = this.deltaX = 0;
          },
          updateWorldPoint: function (g) {
            g = g.getWorldPoint(this.x, this.y);
            this.worldX = g.x;
            this.worldY = g.y;
            return this;
          },
          positionToCamera: function (g, m) {
            return g.getWorldPoint(this.x, this.y, m);
          },
          updateMotion: function () {
            var g = this.position.x,
              m = this.position.y,
              n = this.midPoint.x,
              q = this.midPoint.y;
            if (g !== n || m !== q) {
              n = b(this.motionFactor, n, g);
              q = b(this.motionFactor, q, m);
              e(n, g, 0.1) && (n = g);
              e(q, m, 0.1) && (q = m);
              this.midPoint.set(n, q);
              var r = g - n,
                u = m - q;
              this.velocity.set(r, u);
              this.angle = d(n, q, g, m);
              this.distance = Math.sqrt(r * r + u * u);
            }
          },
          up: function (g) {
            "buttons" in g && (this.buttons = g.buttons);
            this.event = g;
            this.button = g.button;
            this.upElement = g.target;
            this.manager.transformPointer(this, g.pageX, g.pageY, !1);
            0 === g.button &&
              ((this.primaryDown = !1),
              (this.upX = this.x),
              (this.upY = this.y));
            0 === this.buttons &&
              ((this.isDown = !1),
              (this.upTime = g.timeStamp),
              (this.wasTouch = !1));
          },
          down: function (g) {
            "buttons" in g && (this.buttons = g.buttons);
            this.event = g;
            this.button = g.button;
            this.downElement = g.target;
            this.manager.transformPointer(this, g.pageX, g.pageY, !1);
            0 === g.button &&
              ((this.primaryDown = !0),
              (this.downX = this.x),
              (this.downY = this.y));
            f.macOS &&
              g.ctrlKey &&
              ((this.buttons = 2), (this.primaryDown = !1));
            this.isDown || ((this.isDown = !0), (this.downTime = g.timeStamp));
            this.wasTouch = !1;
          },
          move: function (g) {
            "buttons" in g && (this.buttons = g.buttons);
            this.event = g;
            this.manager.transformPointer(this, g.pageX, g.pageY, !0);
            this.locked &&
              ((this.movementX =
                g.movementX || g.mozMovementX || g.webkitMovementX || 0),
              (this.movementY =
                g.movementY || g.mozMovementY || g.webkitMovementY || 0));
            this.moveTime = g.timeStamp;
            this.wasTouch = !1;
          },
          wheel: function (g) {
            "buttons" in g && (this.buttons = g.buttons);
            this.event = g;
            this.manager.transformPointer(this, g.pageX, g.pageY, !1);
            this.deltaX = g.deltaX;
            this.deltaY = g.deltaY;
            this.deltaZ = g.deltaZ;
            this.wasTouch = !1;
          },
          touchstart: function (g, m) {
            g.pointerId && (this.pointerId = g.pointerId);
            this.identifier = g.identifier;
            this.target = g.target;
            this.active = !0;
            this.buttons = 1;
            this.event = m;
            this.downElement = g.target;
            this.manager.transformPointer(this, g.pageX, g.pageY, !1);
            this.primaryDown = !0;
            this.downX = this.x;
            this.downY = this.y;
            this.downTime = m.timeStamp;
            this.wasTouch = this.isDown = !0;
            this.wasCanceled = !1;
            this.updateMotion();
          },
          touchmove: function (g, m) {
            this.event = m;
            this.manager.transformPointer(this, g.pageX, g.pageY, !0);
            this.moveTime = m.timeStamp;
            this.wasTouch = !0;
            this.updateMotion();
          },
          touchend: function (g, m) {
            this.buttons = 0;
            this.event = m;
            this.upElement = g.target;
            this.manager.transformPointer(this, g.pageX, g.pageY, !1);
            this.primaryDown = !1;
            this.upX = this.x;
            this.upY = this.y;
            this.upTime = m.timeStamp;
            this.isDown = !1;
            this.wasTouch = !0;
            this.active = this.wasCanceled = !1;
            this.updateMotion();
          },
          touchcancel: function (g, m) {
            this.buttons = 0;
            this.event = m;
            this.upElement = g.target;
            this.manager.transformPointer(this, g.pageX, g.pageY, !1);
            this.primaryDown = !1;
            this.upX = this.x;
            this.upY = this.y;
            this.upTime = m.timeStamp;
            this.isDown = !1;
            this.wasCanceled = this.wasTouch = !0;
            this.active = !1;
          },
          noButtonDown: function () {
            return 0 === this.buttons;
          },
          leftButtonDown: function () {
            return this.buttons & 1 ? !0 : !1;
          },
          rightButtonDown: function () {
            return this.buttons & 2 ? !0 : !1;
          },
          middleButtonDown: function () {
            return this.buttons & 4 ? !0 : !1;
          },
          backButtonDown: function () {
            return this.buttons & 8 ? !0 : !1;
          },
          forwardButtonDown: function () {
            return this.buttons & 16 ? !0 : !1;
          },
          leftButtonReleased: function () {
            return 0 === this.button && !this.isDown;
          },
          rightButtonReleased: function () {
            return 2 === this.button && !this.isDown;
          },
          middleButtonReleased: function () {
            return 1 === this.button && !this.isDown;
          },
          backButtonReleased: function () {
            return 3 === this.button && !this.isDown;
          },
          forwardButtonReleased: function () {
            return 4 === this.button && !this.isDown;
          },
          getDistance: function () {
            return this.isDown
              ? k(this.downX, this.downY, this.x, this.y)
              : k(this.downX, this.downY, this.upX, this.upY);
          },
          getDistanceX: function () {
            return this.isDown
              ? Math.abs(this.downX - this.x)
              : Math.abs(this.downX - this.upX);
          },
          getDistanceY: function () {
            return this.isDown
              ? Math.abs(this.downY - this.y)
              : Math.abs(this.downY - this.upY);
          },
          getDuration: function () {
            return this.isDown
              ? this.manager.time - this.downTime
              : this.upTime - this.downTime;
          },
          getAngle: function () {
            return this.isDown
              ? d(this.downX, this.downY, this.x, this.y)
              : d(this.downX, this.downY, this.upX, this.upY);
          },
          getInterpolatedPosition: function (g, m) {
            void 0 === g && (g = 10);
            void 0 === m && (m = []);
            for (
              var n = this.prevPosition.x,
                q = this.prevPosition.y,
                r = this.position.x,
                u = this.position.y,
                v = 0;
              v < g;
              v++
            ) {
              var x = (1 / g) * v;
              m[v] = {
                x: b(x, n, r),
                y: b(x, q, u),
              };
            }
            return m;
          },
          destroy: function () {
            this.position = this.manager = this.camera = null;
          },
          x: {
            get: function () {
              return this.position.x;
            },
            set: function (g) {
              this.position.x = g;
            },
          },
          y: {
            get: function () {
              return this.position.y;
            },
            set: function (g) {
              this.position.y = g;
            },
          },
          time: {
            get: function () {
              return this.event ? this.event.timeStamp : 0;
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(51),
          k = a(1);
        a = new t({
          initialize: function (e) {
            this.manager = e;
            this.capture = !0;
            this.enabled = !1;
            this.target;
            this.onTouchOut =
              this.onTouchOver =
              this.onTouchCancelWindow =
              this.onTouchCancel =
              this.onTouchEndWindow =
              this.onTouchEnd =
              this.onTouchMove =
              this.onTouchStartWindow =
              this.onTouchStart =
                k;
            e.events.once(d.MANAGER_BOOT, this.boot, this);
          },
          boot: function () {
            var e = this.manager.config;
            this.enabled = e.inputTouch;
            this.target = e.inputTouchEventTarget;
            this.capture = e.inputTouchCapture;
            this.target || (this.target = this.manager.game.canvas);
            e.disableContextMenu && this.disableContextMenu();
            this.enabled && this.target && this.startListeners();
          },
          disableContextMenu: function () {
            document.body.addEventListener("contextmenu", function (e) {
              e.preventDefault();
              return !1;
            });
            return this;
          },
          startListeners: function () {
            var e = this,
              b = this.manager.canvas,
              c = window && window.focus && this.manager.game.config.autoFocus;
            this.onTouchStart = function (n) {
              c && window.focus();
              !n.defaultPrevented &&
                e.enabled &&
                e.manager &&
                e.manager.enabled &&
                (e.manager.onTouchStart(n),
                e.capture &&
                  n.cancelable &&
                  n.target === b &&
                  n.preventDefault());
            };
            this.onTouchStartWindow = function (n) {
              if (
                !n.defaultPrevented &&
                e.enabled &&
                e.manager &&
                e.manager.enabled &&
                n.target !== b
              )
                e.manager.onTouchStart(n);
            };
            this.onTouchMove = function (n) {
              !n.defaultPrevented &&
                e.enabled &&
                e.manager &&
                e.manager.enabled &&
                (e.manager.onTouchMove(n),
                e.capture && n.cancelable && n.preventDefault());
            };
            this.onTouchEnd = function (n) {
              !n.defaultPrevented &&
                e.enabled &&
                e.manager &&
                e.manager.enabled &&
                (e.manager.onTouchEnd(n),
                e.capture &&
                  n.cancelable &&
                  n.target === b &&
                  n.preventDefault());
            };
            this.onTouchEndWindow = function (n) {
              if (
                !n.defaultPrevented &&
                e.enabled &&
                e.manager &&
                e.manager.enabled &&
                n.target !== b
              )
                e.manager.onTouchEnd(n);
            };
            this.onTouchCancel = function (n) {
              !n.defaultPrevented &&
                e.enabled &&
                e.manager &&
                e.manager.enabled &&
                (e.manager.onTouchCancel(n), e.capture && n.preventDefault());
            };
            this.onTouchCancelWindow = function (n) {
              if (
                !n.defaultPrevented &&
                e.enabled &&
                e.manager &&
                e.manager.enabled
              )
                e.manager.onTouchCancel(n);
            };
            this.onTouchOver = function (n) {
              !n.defaultPrevented &&
                e.enabled &&
                e.manager &&
                e.manager.enabled &&
                e.manager.setCanvasOver(n);
            };
            this.onTouchOut = function (n) {
              !n.defaultPrevented &&
                e.enabled &&
                e.manager &&
                e.manager.enabled &&
                e.manager.setCanvasOut(n);
            };
            var f = this.target;
            if (f) {
              var g = {
                  passive: !0,
                },
                m = {
                  passive: !1,
                };
              f.addEventListener(
                "touchstart",
                this.onTouchStart,
                this.capture ? m : g
              );
              f.addEventListener(
                "touchmove",
                this.onTouchMove,
                this.capture ? m : g
              );
              f.addEventListener(
                "touchend",
                this.onTouchEnd,
                this.capture ? m : g
              );
              f.addEventListener(
                "touchcancel",
                this.onTouchCancel,
                this.capture ? m : g
              );
              f.addEventListener(
                "touchover",
                this.onTouchOver,
                this.capture ? m : g
              );
              f.addEventListener(
                "touchout",
                this.onTouchOut,
                this.capture ? m : g
              );
              window &&
                this.manager.game.config.inputWindowEvents &&
                (window.addEventListener(
                  "touchstart",
                  this.onTouchStartWindow,
                  m
                ),
                window.addEventListener("touchend", this.onTouchEndWindow, m),
                window.addEventListener(
                  "touchcancel",
                  this.onTouchCancelWindow,
                  m
                ));
              this.enabled = !0;
            }
          },
          stopListeners: function () {
            var e = this.target;
            e.removeEventListener("touchstart", this.onTouchStart);
            e.removeEventListener("touchmove", this.onTouchMove);
            e.removeEventListener("touchend", this.onTouchEnd);
            e.removeEventListener("touchcancel", this.onTouchCancel);
            e.removeEventListener("touchover", this.onTouchOver);
            e.removeEventListener("touchout", this.onTouchOut);
            window &&
              (window.removeEventListener(
                "touchstart",
                this.onTouchStartWindow
              ),
              window.removeEventListener("touchend", this.onTouchEndWindow));
          },
          destroy: function () {
            this.stopListeners();
            this.target = null;
            this.enabled = !1;
            this.manager = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(22),
          k = a(9),
          e = a(8),
          b = a(16),
          c = a(5),
          f = a(2),
          g = a(24),
          m = a(93);
        a = new t({
          Extends: k,
          initialize: function (n) {
            k.call(this);
            this.game = n;
            this.plugins = [];
            this.scenePlugins = [];
            this._pendingGlobal = [];
            this._pendingScene = [];
            if (n.isBooted) this.boot();
            else n.events.once(d.BOOT, this.boot, this);
          },
          boot: function () {
            var n,
              q = this.game.config,
              r = q.installGlobalPlugins;
            r = r.concat(this._pendingGlobal);
            for (n = 0; n < r.length; n++) {
              var u = r[n];
              var v = f(u, "key", null);
              var x = f(u, "plugin", null);
              var y = f(u, "start", !1);
              var z = f(u, "mapping", null);
              u = f(u, "data", null);
              v &&
                (x
                  ? this.install(v, x, y, z, u)
                  : console.warn("Missing `plugin` for key: " + v));
            }
            r = q.installScenePlugins;
            r = r.concat(this._pendingScene);
            for (n = 0; n < r.length; n++)
              (u = r[n]),
                (v = f(u, "key", null)),
                (x = f(u, "plugin", null)),
                (z = f(u, "mapping", null)),
                v &&
                  (x
                    ? this.installScenePlugin(v, x, z)
                    : console.warn("Missing `plugin` for key: " + v));
            this._pendingGlobal = [];
            this._pendingScene = [];
            this.game.events.once(d.DESTROY, this.destroy, this);
          },
          addToScene: function (n, q, r) {
            var u,
              v = this.game,
              x = n.scene,
              y = n.settings.map,
              z = n.settings.isBooted;
            for (u = 0; u < q.length; u++) {
              var A = q[u];
              v[A]
                ? ((n[A] = v[A]), y.hasOwnProperty(A) && (x[y[A]] = n[A]))
                : "game" === A && y.hasOwnProperty(A) && (x[y[A]] = v);
            }
            for (v = 0; v < r.length; v++)
              for (q = r[v], u = 0; u < q.length; u++)
                if (((A = q[u]), g.hasCore(A))) {
                  A = g.getCore(A);
                  var B = A.mapping,
                    D = new A.plugin(x, this, B);
                  n[B] = D;
                  A.custom ? (x[B] = D) : y.hasOwnProperty(B) && (x[y[B]] = D);
                  z && D.boot();
                }
            q = this.plugins;
            for (u = 0; u < q.length; u++)
              (n = q[u]), n.mapping && (x[n.mapping] = n.plugin);
          },
          getDefaultScenePlugins: function () {
            var n = this.game.config.defaultPlugins;
            return (n = n.concat(this.scenePlugins));
          },
          installScenePlugin: function (n, q, r, u, v) {
            void 0 === v && (v = !1);
            if ("function" !== typeof q)
              console.warn("Invalid Scene Plugin: " + n);
            else {
              if (!g.hasCore(n))
                g.register(n, q, r, !0), this.scenePlugins.push(n);
              else if (!v && g.hasCore(n)) {
                console.warn("Scene Plugin key in use: " + n);
                return;
              }
              u &&
                ((q = new q(u, this, n)),
                (u.sys[n] = q),
                r && "" !== r && (u[r] = q),
                q.boot());
            }
          },
          install: function (n, q, r, u, v) {
            void 0 === r && (r = !1);
            void 0 === u && (u = null);
            void 0 === v && (v = null);
            if ("function" !== typeof q)
              return console.warn("Invalid Plugin: " + n), null;
            if (g.hasCustom(n))
              return console.warn("Plugin key in use: " + n), null;
            null !== u && (r = !0);
            if (this.game.isBooted) {
              if ((g.registerCustom(n, q, u, v), r)) return this.start(n);
            } else
              this._pendingGlobal.push({
                key: n,
                plugin: q,
                start: r,
                mapping: u,
                data: v,
              });
            return null;
          },
          getIndex: function (n) {
            for (var q = this.plugins, r = 0; r < q.length; r++)
              if (q[r].key === n) return r;
            return -1;
          },
          getEntry: function (n) {
            n = this.getIndex(n);
            if (-1 !== n) return this.plugins[n];
          },
          isActive: function (n) {
            return (n = this.getEntry(n)) && n.active;
          },
          start: function (n, q) {
            void 0 === q && (q = n);
            var r = this.getEntry(q);
            r && !r.active
              ? ((r.active = !0), r.plugin.start())
              : r || (r = this.createEntry(n, q));
            return r ? r.plugin : null;
          },
          createEntry: function (n, q) {
            if ((n = g.getCustom(n))) {
              var r = new n.plugin(this);
              n = {
                key: q,
                plugin: r,
                active: !0,
                mapping: n.mapping,
                data: n.data,
              };
              this.plugins.push(n);
              r.init(n.data);
              r.start();
            }
            return n;
          },
          stop: function (n) {
            (n = this.getEntry(n)) &&
              n.active &&
              ((n.active = !1), n.plugin.stop());
            return this;
          },
          get: function (n, q) {
            void 0 === q && (q = !0);
            var r = this.getEntry(n);
            return r
              ? r.plugin
              : (r = this.getClass(n)) && q
              ? (r = this.createEntry(n, n))
                ? r.plugin
                : null
              : r
              ? r
              : null;
          },
          getClass: function (n) {
            return g.getCustomClass(n);
          },
          removeGlobalPlugin: function (n) {
            var q = this.getEntry(n);
            q && m(this.plugins, q);
            g.removeCustom(n);
          },
          removeScenePlugin: function (n) {
            m(this.scenePlugins, n);
            g.remove(n);
          },
          registerGameObject: function (n, q, r) {
            q && c.register(n, q);
            r && b.register(n, r);
            return this;
          },
          removeGameObject: function (n, q, r) {
            void 0 === q && (q = !0);
            void 0 === r && (r = !0);
            q && c.remove(n);
            r && b.remove(n);
            return this;
          },
          registerFileType: function (n, q, r) {
            e.register(n, q);
            r && r.sys.load && (r.sys.load[n] = q);
          },
          destroy: function () {
            for (var n = 0; n < this.plugins.length; n++)
              this.plugins[n].plugin.destroy();
            g.destroyCustomPlugins();
            this.game.noReturn && g.destroyCorePlugins();
            this.game = null;
            this.plugins = [];
            this.scenePlugins = [];
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(201);
        t = a(0);
        var k = a(9),
          e = a(104),
          b = a(22),
          c = a(401),
          f = a(407),
          g = a(402),
          m = a(1),
          n = a(10),
          q = a(416),
          r = a(76),
          u = a(3);
        a = new t({
          Extends: k,
          initialize: function (v) {
            k.call(this);
            this.game = v;
            this.canvas;
            this.canvasBounds = new n();
            this.parent = null;
            this.parentIsWindow = !1;
            this.parentSize = new q();
            this.gameSize = new q();
            this.baseSize = new q();
            this.displaySize = new q();
            this.scaleMode = d.SCALE_MODE.NONE;
            this.zoom = 1;
            this._resetZoom = !1;
            this.displayScale = new u(1, 1);
            this.autoRound = !1;
            this.autoCenter = d.CENTER.NO_CENTER;
            this.orientation = d.ORIENTATION.LANDSCAPE;
            this.fullscreen;
            this.fullscreenTarget = null;
            this.dirty = this._createdFullscreenTarget = !1;
            this.resizeInterval = 500;
            this._lastCheck = 0;
            this._checkOrientation = !1;
            this.listeners = {
              orientationChange: m,
              windowResize: m,
              fullScreenChange: m,
              fullScreenError: m,
            };
          },
          preBoot: function () {
            this.parseConfig(this.game.config);
            this.game.events.once(b.BOOT, this.boot, this);
          },
          boot: function () {
            var v = this.game;
            this.canvas = v.canvas;
            this.fullscreen = v.device.fullscreen;
            this.scaleMode !== d.SCALE_MODE.RESIZE &&
              this.displaySize.setAspectMode(this.scaleMode);
            this.scaleMode === d.SCALE_MODE.NONE
              ? this.resize(this.width, this.height)
              : (this.getParentBounds(),
                0 < this.parentSize.width &&
                  0 < this.parentSize.height &&
                  this.displaySize.setParent(this.parentSize),
                this.refresh());
            v.events.on(b.PRE_STEP, this.step, this);
            v.events.once(b.READY, this.refresh, this);
            v.events.once(b.DESTROY, this.destroy, this);
            this.startListeners();
          },
          parseConfig: function (v) {
            this.getParent(v);
            this.getParentBounds();
            var x = v.width,
              y = v.height,
              z = v.scaleMode,
              A = v.zoom,
              B = v.autoRound;
            if ("string" === typeof x) {
              var D = this.parentSize.width;
              0 === D && (D = window.innerWidth);
              x = parseInt(x, 10) / 100;
              x = Math.floor(D * x);
            }
            "string" === typeof y &&
              ((D = this.parentSize.height),
              0 === D && (D = window.innerHeight),
              (y = parseInt(y, 10) / 100),
              (y = Math.floor(D * y)));
            this.scaleMode = z;
            this.autoRound = B;
            this.autoCenter = v.autoCenter;
            this.resizeInterval = v.resizeInterval;
            B && ((x = Math.floor(x)), (y = Math.floor(y)));
            this.gameSize.setSize(x, y);
            A === d.ZOOM.MAX_ZOOM && (A = this.getMaxZoom());
            this.zoom = A;
            1 !== A && (this._resetZoom = !0);
            this.baseSize.setSize(x, y);
            B &&
              ((this.baseSize.width = Math.floor(this.baseSize.width)),
              (this.baseSize.height = Math.floor(this.baseSize.height)));
            0 < v.minWidth &&
              this.displaySize.setMin(v.minWidth * A, v.minHeight * A);
            0 < v.maxWidth &&
              this.displaySize.setMax(v.maxWidth * A, v.maxHeight * A);
            this.displaySize.setSize(x, y);
            this.orientation = g(x, y);
          },
          getParent: function (v) {
            var x = v.parent;
            null !== x &&
              ((this.parent = f(x)),
              (this.parentIsWindow = this.parent === document.body),
              v.expandParent &&
                v.scaleMode !== d.SCALE_MODE.NONE &&
                ((x = this.parent.getBoundingClientRect()),
                this.parentIsWindow || 0 === x.height) &&
                ((document.documentElement.style.height = "100%"),
                (document.body.style.height = "100%"),
                (x = this.parent.getBoundingClientRect()),
                this.parentIsWindow ||
                  0 !== x.height ||
                  ((this.parent.style.overflow = "hidden"),
                  (this.parent.style.width = "100%"),
                  (this.parent.style.height = "100%"))),
              v.fullscreenTarget &&
                !this.fullscreenTarget &&
                (this.fullscreenTarget = f(v.fullscreenTarget)));
          },
          getParentBounds: function () {
            if (!this.parent) return !1;
            var v = this.parentSize,
              x = this.parent.getBoundingClientRect();
            this.parentIsWindow &&
              this.game.device.os.iOS &&
              (x.height = c(!0));
            var y = x.width;
            x = x.height;
            return v.width !== y || v.height !== x ? (v.setSize(y, x), !0) : !1;
          },
          lockOrientation: function (v) {
            var x =
              screen.lockOrientation ||
              screen.mozLockOrientation ||
              screen.msLockOrientation;
            return x ? x.call(screen, v) : !1;
          },
          setParentSize: function (v, x) {
            this.parentSize.setSize(v, x);
            return this.refresh();
          },
          setGameSize: function (v, x) {
            var y = this.autoRound;
            y && ((v = Math.floor(v)), (x = Math.floor(x)));
            var z = this.width,
              A = this.height;
            this.gameSize.resize(v, x);
            this.baseSize.resize(v, x);
            y &&
              ((this.baseSize.width = Math.floor(this.baseSize.width)),
              (this.baseSize.height = Math.floor(this.baseSize.height)));
            this.displaySize.setAspectRatio(v / x);
            this.canvas.width = this.baseSize.width;
            this.canvas.height = this.baseSize.height;
            return this.refresh(z, A);
          },
          resize: function (v, x) {
            var y = this.zoom,
              z = this.autoRound;
            z && ((v = Math.floor(v)), (x = Math.floor(x)));
            var A = this.width,
              B = this.height;
            this.gameSize.resize(v, x);
            this.baseSize.resize(v, x);
            z &&
              ((this.baseSize.width = Math.floor(this.baseSize.width)),
              (this.baseSize.height = Math.floor(this.baseSize.height)));
            this.displaySize.setSize(v * y, x * y);
            this.canvas.width = this.baseSize.width;
            this.canvas.height = this.baseSize.height;
            var D = this.canvas.style,
              E = v * y;
            y *= x;
            z && ((E = Math.floor(E)), (y = Math.floor(y)));
            if (E !== v || y !== x) (D.width = E + "px"), (D.height = y + "px");
            return this.refresh(A, B);
          },
          setZoom: function (v) {
            this.zoom = v;
            this._resetZoom = !0;
            return this.refresh();
          },
          setMaxZoom: function () {
            this.zoom = this.getMaxZoom();
            this._resetZoom = !0;
            return this.refresh();
          },
          refresh: function (v, x) {
            void 0 === v && (v = this.width);
            void 0 === x && (x = this.height);
            this.updateScale();
            this.updateBounds();
            this.updateOrientation();
            this.displayScale.set(
              this.baseSize.width / this.canvasBounds.width,
              this.baseSize.height / this.canvasBounds.height
            );
            var y = this.game.domContainer;
            if (y) {
              this.baseSize.setCSS(y);
              var z = this.canvas.style;
              y = y.style;
              y.transform =
                "scale(" +
                this.displaySize.width / this.baseSize.width +
                "," +
                this.displaySize.height / this.baseSize.height +
                ")";
              y.marginLeft = z.marginLeft;
              y.marginTop = z.marginTop;
            }
            this.emit(
              e.RESIZE,
              this.gameSize,
              this.baseSize,
              this.displaySize,
              v,
              x
            );
            return this;
          },
          updateOrientation: function () {
            if (this._checkOrientation) {
              this._checkOrientation = !1;
              var v = g(this.width, this.height);
              v !== this.orientation &&
                ((this.orientation = v), this.emit(e.ORIENTATION_CHANGE, v));
            }
          },
          updateScale: function () {
            var v = this.canvas.style,
              x = this.gameSize.width,
              y = this.gameSize.height,
              z = this.zoom,
              A = this.autoRound;
            this.scaleMode === d.SCALE_MODE.NONE
              ? (this.displaySize.setSize(x * z, y * z),
                (x = this.displaySize.width),
                (y = this.displaySize.height),
                A && ((x = Math.floor(x)), (y = Math.floor(y))),
                this._resetZoom &&
                  ((v.width = x + "px"),
                  (v.height = y + "px"),
                  (this._resetZoom = !1)))
              : this.scaleMode === d.SCALE_MODE.RESIZE
              ? (this.displaySize.setSize(
                  this.parentSize.width,
                  this.parentSize.height
                ),
                this.gameSize.setSize(
                  this.displaySize.width,
                  this.displaySize.height
                ),
                this.baseSize.setSize(
                  this.displaySize.width,
                  this.displaySize.height
                ),
                (x = this.displaySize.width),
                (y = this.displaySize.height),
                A && ((x = Math.floor(x)), (y = Math.floor(y))),
                (this.canvas.width = x),
                (this.canvas.height = y))
              : (this.displaySize.setSize(
                  this.parentSize.width,
                  this.parentSize.height
                ),
                (x = this.displaySize.width),
                (y = this.displaySize.height),
                A && ((x = Math.floor(x)), (y = Math.floor(y))),
                (v.width = x + "px"),
                (v.height = y + "px"));
            this.getParentBounds();
            this.updateCenter();
          },
          getMaxZoom: function () {
            var v = r(this.parentSize.width, this.gameSize.width, 0, !0),
              x = r(this.parentSize.height, this.gameSize.height, 0, !0);
            return Math.max(Math.min(v, x), 1);
          },
          updateCenter: function () {
            var v = this.autoCenter;
            if (v !== d.CENTER.NO_CENTER) {
              var x = this.canvas,
                y = x.style,
                z = x.getBoundingClientRect();
              x = Math.floor((this.parentSize.width - z.width) / 2);
              z = Math.floor((this.parentSize.height - z.height) / 2);
              v === d.CENTER.CENTER_HORIZONTALLY
                ? (z = 0)
                : v === d.CENTER.CENTER_VERTICALLY && (x = 0);
              y.marginLeft = x + "px";
              y.marginTop = z + "px";
            }
          },
          updateBounds: function () {
            var v = this.canvasBounds,
              x = this.canvas.getBoundingClientRect();
            v.x =
              x.left +
              (window.pageXOffset || 0) -
              (document.documentElement.clientLeft || 0);
            v.y =
              x.top +
              (window.pageYOffset || 0) -
              (document.documentElement.clientTop || 0);
            v.width = x.width;
            v.height = x.height;
          },
          transformX: function (v) {
            return (v - this.canvasBounds.left) * this.displayScale.x;
          },
          transformY: function (v) {
            return (v - this.canvasBounds.top) * this.displayScale.y;
          },
          startFullscreen: function (v) {
            void 0 === v &&
              (v = {
                navigationUI: "hide",
              });
            var x = this.fullscreen;
            if (!x.available) this.emit(e.FULLSCREEN_UNSUPPORTED);
            else if (!x.active) {
              var y = this.getFullscreenTarget();
              if (x.keyboard) y[x.request](Element.ALLOW_KEYBOARD_INPUT);
              else y[x.request](v);
            }
          },
          fullscreenSuccessHandler: function () {
            this.getParentBounds();
            this.refresh();
            this.emit(e.ENTER_FULLSCREEN);
          },
          fullscreenErrorHandler: function (v) {
            this.removeFullscreenTarget();
            this.emit(e.FULLSCREEN_FAILED, v);
          },
          getFullscreenTarget: function () {
            if (!this.fullscreenTarget) {
              var v = document.createElement("div");
              v.style.margin = "0";
              v.style.padding = "0";
              v.style.width = "100%";
              v.style.height = "100%";
              this.fullscreenTarget = v;
              this._createdFullscreenTarget = !0;
            }
            this._createdFullscreenTarget &&
              (this.canvas.parentNode.insertBefore(
                this.fullscreenTarget,
                this.canvas
              ),
              this.fullscreenTarget.appendChild(this.canvas));
            return this.fullscreenTarget;
          },
          removeFullscreenTarget: function () {
            if (this._createdFullscreenTarget) {
              var v = this.fullscreenTarget;
              if (v && v.parentNode) {
                var x = v.parentNode;
                x.insertBefore(this.canvas, v);
                x.removeChild(v);
              }
            }
          },
          stopFullscreen: function () {
            var v = this.fullscreen;
            if (!v.available) return this.emit(e.FULLSCREEN_UNSUPPORTED), !1;
            if (v.active) document[v.cancel]();
            this.removeFullscreenTarget();
            this.getParentBounds();
            this.emit(e.LEAVE_FULLSCREEN);
            this.refresh();
          },
          toggleFullscreen: function (v) {
            this.fullscreen.active
              ? this.stopFullscreen()
              : this.startFullscreen(v);
          },
          startListeners: function () {
            var v = this,
              x = this.listeners;
            x.orientationChange = function () {
              v.updateBounds();
              v._checkOrientation = !0;
              v.dirty = !0;
            };
            x.windowResize = function () {
              v.updateBounds();
              v.dirty = !0;
            };
            window.addEventListener(
              "orientationchange",
              x.orientationChange,
              !1
            );
            window.addEventListener("resize", x.windowResize, !1);
            this.fullscreen.available &&
              ((x.fullScreenChange = function (y) {
                return v.onFullScreenChange(y);
              }),
              (x.fullScreenError = function (y) {
                return v.onFullScreenError(y);
              }),
              ["webkit", "moz", ""].forEach(function (y) {
                document.addEventListener(
                  y + "fullscreenchange",
                  x.fullScreenChange,
                  !1
                );
                document.addEventListener(
                  y + "fullscreenerror",
                  x.fullScreenError,
                  !1
                );
              }),
              document.addEventListener(
                "MSFullscreenChange",
                x.fullScreenChange,
                !1
              ),
              document.addEventListener(
                "MSFullscreenError",
                x.fullScreenError,
                !1
              ));
          },
          onFullScreenChange: function () {
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.msFullscreenElement ||
            document.mozFullScreenElement
              ? this.fullscreenSuccessHandler()
              : this.stopFullscreen();
          },
          onFullScreenError: function () {
            this.removeFullscreenTarget();
          },
          step: function (v, x) {
            this.parent &&
              ((this._lastCheck += x),
              this.dirty || this._lastCheck > this.resizeInterval) &&
              (this.getParentBounds() && this.refresh(),
              (this.dirty = !1),
              (this._lastCheck = 0));
          },
          stopListeners: function () {
            var v = this.listeners;
            window.removeEventListener(
              "orientationchange",
              v.orientationChange,
              !1
            );
            window.removeEventListener("resize", v.windowResize, !1);
            ["webkit", "moz", ""].forEach(function (x) {
              document.removeEventListener(
                x + "fullscreenchange",
                v.fullScreenChange,
                !1
              );
              document.removeEventListener(
                x + "fullscreenerror",
                v.fullScreenError,
                !1
              );
            });
            document.removeEventListener(
              "MSFullscreenChange",
              v.fullScreenChange,
              !1
            );
            document.removeEventListener(
              "MSFullscreenError",
              v.fullScreenError,
              !1
            );
          },
          destroy: function () {
            this.removeAllListeners();
            this.stopListeners();
            this.fullscreenTarget =
              this.parent =
              this.canvasBounds =
              this.canvas =
              this.game =
                null;
            this.parentSize.destroy();
            this.gameSize.destroy();
            this.baseSize.destroy();
            this.displaySize.destroy();
          },
          isFullscreen: {
            get: function () {
              return this.fullscreen.active;
            },
          },
          width: {
            get: function () {
              return this.gameSize.width;
            },
          },
          height: {
            get: function () {
              return this.gameSize.height;
            },
          },
          isPortrait: {
            get: function () {
              return this.orientation === d.ORIENTATION.PORTRAIT;
            },
          },
          isLandscape: {
            get: function () {
              return this.orientation === d.ORIENTATION.LANDSCAPE;
            },
          },
          isGamePortrait: {
            get: function () {
              return this.height > this.width;
            },
          },
          isGameLandscape: {
            get: function () {
              return this.width > this.height;
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(18);
        t = a(0);
        var k = a(76),
          e = a(3),
          b = new t({
            initialize: function (c, f, g, m) {
              void 0 === c && (c = 0);
              void 0 === f && (f = c);
              void 0 === g && (g = 0);
              void 0 === m && (m = null);
              this._width = c;
              this._height = f;
              this._parent = m;
              this.aspectMode = g;
              this.aspectRatio = 0 === f ? 1 : c / f;
              this.minHeight = this.minWidth = 0;
              this.maxHeight = this.maxWidth = Number.MAX_VALUE;
              this.snapTo = new e();
            },
            setAspectMode: function (c) {
              void 0 === c && (c = 0);
              this.aspectMode = c;
              return this.setSize(this._width, this._height);
            },
            setSnap: function (c, f) {
              void 0 === c && (c = 0);
              void 0 === f && (f = c);
              this.snapTo.set(c, f);
              return this.setSize(this._width, this._height);
            },
            setParent: function (c) {
              this._parent = c;
              return this.setSize(this._width, this._height);
            },
            setMin: function (c, f) {
              void 0 === c && (c = 0);
              void 0 === f && (f = c);
              this.minWidth = d(c, 0, this.maxWidth);
              this.minHeight = d(f, 0, this.maxHeight);
              return this.setSize(this._width, this._height);
            },
            setMax: function (c, f) {
              void 0 === c && (c = Number.MAX_VALUE);
              void 0 === f && (f = c);
              this.maxWidth = d(c, this.minWidth, Number.MAX_VALUE);
              this.maxHeight = d(f, this.minHeight, Number.MAX_VALUE);
              return this.setSize(this._width, this._height);
            },
            setSize: function (c, f) {
              void 0 === c && (c = 0);
              void 0 === f && (f = c);
              switch (this.aspectMode) {
                case b.NONE:
                  this._width = this.getNewWidth(k(c, this.snapTo.x));
                  this._height = this.getNewHeight(k(f, this.snapTo.y));
                  this.aspectRatio =
                    0 === this._height ? 1 : this._width / this._height;
                  break;
                case b.WIDTH_CONTROLS_HEIGHT:
                  this._width = this.getNewWidth(k(c, this.snapTo.x));
                  this._height = this.getNewHeight(
                    (1 / this.aspectRatio) * this._width,
                    !1
                  );
                  break;
                case b.HEIGHT_CONTROLS_WIDTH:
                  this._height = this.getNewHeight(k(f, this.snapTo.y));
                  this._width = this.getNewWidth(
                    this._height * this.aspectRatio,
                    !1
                  );
                  break;
                case b.FIT:
                  this.constrain(c, f, !0);
                  break;
                case b.ENVELOP:
                  this.constrain(c, f, !1);
              }
              return this;
            },
            setAspectRatio: function (c) {
              this.aspectRatio = c;
              return this.setSize(this._width, this._height);
            },
            resize: function (c, f) {
              this._width = this.getNewWidth(k(c, this.snapTo.x));
              this._height = this.getNewHeight(k(f, this.snapTo.y));
              this.aspectRatio =
                0 === this._height ? 1 : this._width / this._height;
              return this;
            },
            getNewWidth: function (c, f) {
              void 0 === f && (f = !0);
              c = d(c, this.minWidth, this.maxWidth);
              f &&
                this._parent &&
                c > this._parent.width &&
                (c = Math.max(this.minWidth, this._parent.width));
              return c;
            },
            getNewHeight: function (c, f) {
              void 0 === f && (f = !0);
              c = d(c, this.minHeight, this.maxHeight);
              f &&
                this._parent &&
                c > this._parent.height &&
                (c = Math.max(this.minHeight, this._parent.height));
              return c;
            },
            constrain: function (c, f, g) {
              void 0 === c && (c = 0);
              void 0 === f && (f = c);
              void 0 === g && (g = !0);
              c = this.getNewWidth(c);
              f = this.getNewHeight(f);
              var m = this.snapTo,
                n = 0 === f ? 1 : c / f;
              if ((g && this.aspectRatio > n) || (!g && this.aspectRatio < n))
                (c = k(c, m.x)),
                  (f = c / this.aspectRatio),
                  0 < m.y && ((f = k(f, m.y)), (c = f * this.aspectRatio));
              else if (
                (g && this.aspectRatio < n) ||
                (!g && this.aspectRatio > n)
              )
                (f = k(f, m.y)),
                  (c = f * this.aspectRatio),
                  0 < m.x &&
                    ((c = k(c, m.x)), (f = (1 / this.aspectRatio) * c));
              this._width = c;
              this._height = f;
              return this;
            },
            fitTo: function (c, f) {
              return this.constrain(c, f, !0);
            },
            envelop: function (c, f) {
              return this.constrain(c, f, !1);
            },
            setWidth: function (c) {
              return this.setSize(c, this._height);
            },
            setHeight: function (c) {
              return this.setSize(this._width, c);
            },
            toString: function () {
              return (
                "[{ Size (width=" +
                this._width +
                " height=" +
                this._height +
                " aspectRatio=" +
                this.aspectRatio +
                " aspectMode=" +
                this.aspectMode +
                ") }]"
              );
            },
            setCSS: function (c) {
              c &&
                c.style &&
                ((c.style.width = this._width + "px"),
                (c.style.height = this._height + "px"));
            },
            copy: function (c) {
              c.setAspectMode(this.aspectMode);
              c.aspectRatio = this.aspectRatio;
              return c.setSize(this.width, this.height);
            },
            destroy: function () {
              this.snapTo = this._parent = null;
            },
            width: {
              get: function () {
                return this._width;
              },
              set: function (c) {
                this.setSize(c, this._height);
              },
            },
            height: {
              get: function () {
                return this._height;
              },
              set: function (c) {
                this.setSize(this._width, c);
              },
            },
          });
        b.NONE = 0;
        b.WIDTH_CONTROLS_HEIGHT = 1;
        b.HEIGHT_CONTROLS_WIDTH = 2;
        b.FIT = 3;
        b.ENVELOP = 4;
        h.exports = b;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(144),
          k = a(20),
          e = a(22),
          b = a(6),
          c = a(95),
          f = a(1),
          g = a(418),
          m = a(204);
        a = new t({
          initialize: function (n, q) {
            this.game = n;
            this.keys = {};
            this.scenes = [];
            this._pending = [];
            this._start = [];
            this._queue = [];
            this._data = {};
            this.isBooted = this.isProcessing = !1;
            this.customViewports = 0;
            if (q) {
              Array.isArray(q) || (q = [q]);
              for (var r = 0; r < q.length; r++)
                this._pending.push({
                  key: "default",
                  scene: q[r],
                  autoStart: 0 === r,
                  data: {},
                });
            }
            n.events.once(e.READY, this.bootQueue, this);
          },
          bootQueue: function () {
            if (!this.isBooted) {
              var n;
              for (n = 0; n < this._pending.length; n++) {
                var q = this._pending[n];
                var r = q.key;
                var u = q.scene;
                var v;
                u instanceof g
                  ? (v = this.createSceneFromInstance(r, u))
                  : "object" === typeof u
                  ? (v = this.createSceneFromObject(r, u))
                  : "function" === typeof u &&
                    (v = this.createSceneFromFunction(r, u));
                r = v.sys.settings.key;
                this.keys[r] = v;
                this.scenes.push(v);
                this._data[r] &&
                  ((v.sys.settings.data = this._data[r].data),
                  this._data[r].autoStart && (q.autoStart = !0));
                (q.autoStart || v.sys.settings.active) && this._start.push(r);
              }
              this._pending.length = 0;
              this._data = {};
              this.isBooted = !0;
              for (n = 0; n < this._start.length; n++)
                (q = this._start[n]), this.start(q);
              this._start.length = 0;
            }
          },
          processQueue: function () {
            var n = this._pending.length,
              q = this._queue.length;
            if (0 !== n || 0 !== q)
              if (n) {
                for (q = 0; q < n; q++) {
                  var r = this._pending[q];
                  this.add(r.key, r.scene, r.autoStart, r.data);
                }
                for (q = 0; q < this._start.length; q++)
                  (r = this._start[q]), this.start(r);
                this._start.length = 0;
                this._pending.length = 0;
              } else {
                for (q = 0; q < this._queue.length; q++)
                  (r = this._queue[q]), this[r.op](r.keyA, r.keyB);
                this._queue.length = 0;
              }
          },
          add: function (n, q, r, u) {
            void 0 === r && (r = !1);
            void 0 === u && (u = {});
            if (this.isProcessing || !this.isBooted)
              return (
                this._pending.push({
                  key: n,
                  scene: q,
                  autoStart: r,
                  data: u,
                }),
                this.isBooted ||
                  (this._data[n] = {
                    data: u,
                  }),
                null
              );
            n = this.getKey(n, q);
            if (q instanceof g) var v = this.createSceneFromInstance(n, q);
            else
              "object" === typeof q
                ? ((q.key = n), (v = this.createSceneFromObject(n, q)))
                : "function" === typeof q &&
                  (v = this.createSceneFromFunction(n, q));
            v.sys.settings.data = u;
            n = v.sys.settings.key;
            this.keys[n] = v;
            this.scenes.push(v);
            if (r || v.sys.settings.active)
              this._pending.length ? this._start.push(n) : this.start(n);
            return v;
          },
          remove: function (n) {
            if (this.isProcessing)
              this._queue.push({
                op: "remove",
                keyA: n,
                keyB: null,
              });
            else {
              n = this.getScene(n);
              if (!n || n.sys.isTransitioning()) return this;
              var q = this.scenes.indexOf(n),
                r = n.sys.settings.key;
              -1 < q &&
                (delete this.keys[r],
                this.scenes.splice(q, 1),
                -1 < this._start.indexOf(r) &&
                  ((q = this._start.indexOf(r)), this._start.splice(q, 1)),
                n.sys.destroy());
            }
            return this;
          },
          bootScene: function (n) {
            var q = n.sys,
              r = q.settings;
            q.sceneUpdate = f;
            n.init &&
              (n.init.call(n, r.data),
              (r.status = d.INIT),
              r.isTransition &&
                q.events.emit(
                  k.TRANSITION_INIT,
                  r.transitionFrom,
                  r.transitionDuration
                ));
            if (q.load) {
              var u = q.load;
              u.reset();
            }
            u && n.preload
              ? (n.preload.call(n),
                0 === u.list.size
                  ? this.create(n)
                  : ((r.status = d.LOADING),
                    u.once(c.COMPLETE, this.loadComplete, this),
                    u.start()))
              : this.create(n);
          },
          loadComplete: function (n) {
            this.create(n.scene);
          },
          payloadComplete: function (n) {
            this.bootScene(n.scene);
          },
          update: function (n, q) {
            this.processQueue();
            this.isProcessing = !0;
            for (var r = this.scenes.length - 1; 0 <= r; r--) {
              var u = this.scenes[r].sys;
              u.settings.status > d.START &&
                u.settings.status <= d.RUNNING &&
                u.step(n, q);
            }
          },
          render: function (n) {
            for (var q = 0; q < this.scenes.length; q++) {
              var r = this.scenes[q].sys;
              r.settings.visible &&
                r.settings.status >= d.LOADING &&
                r.settings.status < d.SLEEPING &&
                r.render(n);
            }
            this.isProcessing = !1;
          },
          create: function (n) {
            var q = n.sys,
              r = q.settings;
            if (
              n.create &&
              ((r.status = d.CREATING),
              n.create.call(n, r.data),
              r.status === d.DESTROYED)
            )
              return;
            r.isTransition &&
              q.events.emit(
                k.TRANSITION_START,
                r.transitionFrom,
                r.transitionDuration
              );
            n.update && (q.sceneUpdate = n.update);
            r.status = d.RUNNING;
            q.events.emit(k.CREATE, n);
          },
          createSceneFromFunction: function (n, q) {
            q = new q();
            if (q instanceof g) {
              var r = q.sys.settings.key;
              "" !== r && (n = r);
              if (this.keys.hasOwnProperty(n))
                throw Error("Cannot add a Scene with duplicate key: " + n);
              return this.createSceneFromInstance(n, q);
            }
            q.sys = new m(q);
            q.sys.settings.key = n;
            q.sys.init(this.game);
            return q;
          },
          createSceneFromInstance: function (n, q) {
            "" === q.sys.settings.key && (q.sys.settings.key = n);
            q.sys.init(this.game);
            return q;
          },
          createSceneFromObject: function (n, q) {
            var r = new g(q);
            "" === r.sys.settings.key && (r.sys.settings.key = n);
            r.sys.init(this.game);
            n = ["init", "preload", "create", "update", "render"];
            for (var u = 0; u < n.length; u++) {
              var v = b(q, n[u], null);
              v && (r[n[u]] = v);
            }
            if (q.hasOwnProperty("extend"))
              for (var x in q.extend)
                q.extend.hasOwnProperty(x) &&
                  ((n = q.extend[x]),
                  "data" === x &&
                  r.hasOwnProperty("data") &&
                  "object" === typeof n
                    ? r.data.merge(n)
                    : "sys" !== x && (r[x] = n));
            return r;
          },
          getKey: function (n, q) {
            n || (n = "default");
            if ("function" === typeof q) return n;
            q instanceof g
              ? (n = q.sys.settings.key)
              : "object" === typeof q && q.hasOwnProperty("key") && (n = q.key);
            if (this.keys.hasOwnProperty(n))
              throw Error("Cannot add a Scene with duplicate key: " + n);
            return n;
          },
          getScenes: function (n, q) {
            void 0 === n && (n = !0);
            void 0 === q && (q = !1);
            for (var r = [], u = this.scenes, v = 0; v < u.length; v++) {
              var x = u[v];
              x && (!n || (n && x.sys.isActive())) && r.push(x);
            }
            return q ? r.reverse() : r;
          },
          getScene: function (n) {
            if ("string" === typeof n) {
              if (this.keys[n]) return this.keys[n];
            } else
              for (var q = 0; q < this.scenes.length; q++)
                if (n === this.scenes[q]) return n;
            return null;
          },
          isActive: function (n) {
            return (n = this.getScene(n)) ? n.sys.isActive() : null;
          },
          isPaused: function (n) {
            return (n = this.getScene(n)) ? n.sys.isPaused() : null;
          },
          isVisible: function (n) {
            return (n = this.getScene(n)) ? n.sys.isVisible() : null;
          },
          isSleeping: function (n) {
            return (n = this.getScene(n)) ? n.sys.isSleeping() : null;
          },
          pause: function (n, q) {
            (n = this.getScene(n)) && n.sys.pause(q);
            return this;
          },
          resume: function (n, q) {
            (n = this.getScene(n)) && n.sys.resume(q);
            return this;
          },
          sleep: function (n, q) {
            (n = this.getScene(n)) &&
              !n.sys.isTransitioning() &&
              n.sys.sleep(q);
            return this;
          },
          wake: function (n, q) {
            (n = this.getScene(n)) && n.sys.wake(q);
            return this;
          },
          run: function (n, q) {
            var r = this.getScene(n);
            if (!r) {
              for (r = 0; r < this._pending.length; r++)
                if (this._pending[r].key === n) {
                  this.queueOp("start", n, q);
                  break;
                }
              return this;
            }
            r.sys.isSleeping()
              ? r.sys.wake(q)
              : r.sys.isPaused()
              ? r.sys.resume(q)
              : this.start(n, q);
          },
          start: function (n, q) {
            if (!this.isBooted)
              return (
                (this._data[n] = {
                  autoStart: !0,
                  data: q,
                }),
                this
              );
            if ((n = this.getScene(n))) {
              var r = n.sys;
              if (r.isActive() || r.isPaused())
                r.shutdown(), (r.sceneUpdate = f), r.start(q);
              else {
                r.sceneUpdate = f;
                r.start(q);
                if (r.load) var u = r.load;
                if (
                  u &&
                  r.settings.hasOwnProperty("pack") &&
                  (u.reset(),
                  u.addPack({
                    payload: r.settings.pack,
                  }))
                )
                  return (
                    (r.settings.status = d.LOADING),
                    u.once(c.COMPLETE, this.payloadComplete, this),
                    u.start(),
                    this
                  );
              }
              this.bootScene(n);
            }
            return this;
          },
          stop: function (n, q) {
            (n = this.getScene(n)) &&
              !n.sys.isTransitioning() &&
              n.sys.shutdown(q);
            return this;
          },
          switch: function (n, q) {
            var r = this.getScene(n),
              u = this.getScene(q);
            r &&
              u &&
              r !== u &&
              (this.sleep(n),
              this.isSleeping(q) ? this.wake(q) : this.start(q));
            return this;
          },
          getAt: function (n) {
            return this.scenes[n];
          },
          getIndex: function (n) {
            n = this.getScene(n);
            return this.scenes.indexOf(n);
          },
          bringToTop: function (n) {
            if (this.isProcessing)
              this._queue.push({
                op: "bringToTop",
                keyA: n,
                keyB: null,
              });
            else {
              var q = this.getIndex(n);
              -1 !== q &&
                q < this.scenes.length &&
                ((n = this.getScene(n)),
                this.scenes.splice(q, 1),
                this.scenes.push(n));
            }
            return this;
          },
          sendToBack: function (n) {
            if (this.isProcessing)
              this._queue.push({
                op: "sendToBack",
                keyA: n,
                keyB: null,
              });
            else {
              var q = this.getIndex(n);
              -1 !== q &&
                0 < q &&
                ((n = this.getScene(n)),
                this.scenes.splice(q, 1),
                this.scenes.unshift(n));
            }
            return this;
          },
          moveDown: function (n) {
            if (this.isProcessing)
              this._queue.push({
                op: "moveDown",
                keyA: n,
                keyB: null,
              });
            else {
              var q = this.getIndex(n);
              if (0 < q) {
                var r = q - 1;
                n = this.getScene(n);
                var u = this.getAt(r);
                this.scenes[q] = u;
                this.scenes[r] = n;
              }
            }
            return this;
          },
          moveUp: function (n) {
            if (this.isProcessing)
              this._queue.push({
                op: "moveUp",
                keyA: n,
                keyB: null,
              });
            else {
              var q = this.getIndex(n);
              if (q < this.scenes.length - 1) {
                var r = q + 1;
                n = this.getScene(n);
                var u = this.getAt(r);
                this.scenes[q] = u;
                this.scenes[r] = n;
              }
            }
            return this;
          },
          moveAbove: function (n, q) {
            if (n === q) return this;
            if (this.isProcessing)
              this._queue.push({
                op: "moveAbove",
                keyA: n,
                keyB: q,
              });
            else if (
              ((n = this.getIndex(n)),
              (q = this.getIndex(q)),
              -1 !== n && -1 !== q)
            ) {
              var r = this.getAt(q);
              this.scenes.splice(q, 1);
              this.scenes.splice(n + 1, 0, r);
            }
            return this;
          },
          moveBelow: function (n, q) {
            if (n === q) return this;
            if (this.isProcessing)
              this._queue.push({
                op: "moveBelow",
                keyA: n,
                keyB: q,
              });
            else if (
              ((n = this.getIndex(n)),
              (q = this.getIndex(q)),
              -1 !== n && -1 !== q)
            ) {
              var r = this.getAt(q);
              this.scenes.splice(q, 1);
              0 === n ? this.scenes.unshift(r) : this.scenes.splice(n, 0, r);
            }
            return this;
          },
          queueOp: function (n, q, r) {
            this._queue.push({
              op: n,
              keyA: q,
              keyB: r,
            });
            return this;
          },
          swapPosition: function (n, q) {
            if (n === q) return this;
            if (this.isProcessing)
              this._queue.push({
                op: "swapPosition",
                keyA: n,
                keyB: q,
              });
            else if (
              ((n = this.getIndex(n)),
              (q = this.getIndex(q)),
              n !== q && -1 !== n && -1 !== q)
            ) {
              var r = this.getAt(n);
              this.scenes[n] = this.scenes[q];
              this.scenes[q] = r;
            }
            return this;
          },
          dump: function () {
            for (
              var n = [],
                q =
                  "pending init start loading creating running paused sleeping shutdown destroyed".split(
                    " "
                  ),
                r = 0;
              r < this.scenes.length;
              r++
            ) {
              var u = this.scenes[r].sys,
                v =
                  !u.settings.visible ||
                  (u.settings.status !== d.RUNNING &&
                    u.settings.status !== d.PAUSED)
                    ? "[-] "
                    : "[*] ";
              v += u.settings.key + " (" + q[u.settings.status] + ")";
              n.push(v);
            }
          },
          destroy: function () {
            for (var n = 0; n < this.scenes.length; n++)
              this.scenes[n].sys.destroy();
            this.update = f;
            this.scenes = [];
            this._pending = [];
            this._start = [];
            this._queue = [];
            this.game = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(204);
        a = new t({
          initialize: function (k) {
            this.sys = new d(this, k);
            this.game;
            this.anims;
            this.cache;
            this.registry;
            this.sound;
            this.textures;
            this.events;
            this.cameras;
            this.add;
            this.make;
            this.scene;
            this.children;
            this.lights;
            this.data;
            this.input;
            this.load;
            this.time;
            this.tweens;
            this.physics;
            this.matter;
            this.scale;
            this.plugins;
            this.renderer;
          },
          update: function () {},
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(2),
          k = a(205);
        h.exports = function (e) {
          var b = e.game.config.defaultPhysicsSystem;
          e = d(e.settings, "physics", !1);
          if (b || e) {
            var c = [];
            b && c.push(k(b + "Physics"));
            if (e)
              for (var f in e)
                (f = k(f.concat("Physics"))), -1 === c.indexOf(f) && c.push(f);
            return c;
          }
        };
      },
      function (h, t, a) {
        var d = a(2);
        h.exports = function (k) {
          var e = k.plugins.getDefaultScenePlugins();
          k = d(k.settings, "plugins", !1);
          return Array.isArray(k) ? k : e ? e : [];
        };
      },
      function (h, t, a) {
        var d = a(144),
          k = a(6),
          e = a(127),
          b = a(978);
        h.exports = {
          create: function (c) {
            "string" === typeof c
              ? (c = {
                  key: c,
                })
              : void 0 === c && (c = {});
            return {
              status: d.PENDING,
              key: k(c, "key", ""),
              active: k(c, "active", !1),
              visible: k(c, "visible", !0),
              isBooted: !1,
              isTransition: !1,
              transitionFrom: null,
              transitionDuration: 0,
              transitionAllowInput: !0,
              data: {},
              pack: k(c, "pack", !1),
              cameras: k(c, "cameras", null),
              map: k(c, "map", e(b, k(c, "mapAdd", {}))),
              physics: k(c, "physics", {}),
              loader: k(c, "loader", {}),
              plugins: k(c, "plugins", !1),
              input: k(c, "input", {}),
            };
          },
        };
      },
      function (h, t, a) {
        var d = a(31),
          k = a(423);
        t = a(0);
        var e = a(38),
          b = a(33),
          c = a(9),
          f = a(106),
          g = a(22),
          m = a(388),
          n = a(6),
          q = a(425),
          r = a(206);
        a = new t({
          Extends: c,
          initialize: function (u) {
            c.call(this);
            this.game = u;
            this.name = "TextureManager";
            this.list = {};
            this._tempCanvas = d.create2D(this, 1, 1);
            this._tempContext = this._tempCanvas.getContext("2d");
            this._pending = 0;
            u.events.once(g.BOOT, this.boot, this);
          },
          boot: function () {
            this._pending = 3;
            this.on(f.LOAD, this.updatePending, this);
            this.on(f.ERROR, this.updatePending, this);
            var u = this.game.config;
            this.addBase64("__DEFAULT", u.defaultImage);
            this.addBase64("__MISSING", u.missingImage);
            this.addBase64("__WHITE", u.whiteImage);
            this.game.events.once(g.DESTROY, this.destroy, this);
          },
          updatePending: function () {
            this._pending--;
            0 === this._pending &&
              (this.off(f.LOAD), this.off(f.ERROR), this.emit(f.READY));
          },
          checkKey: function (u) {
            return this.exists(u)
              ? (console.error("Texture key already in use: " + u), !1)
              : !0;
          },
          remove: function (u) {
            if ("string" === typeof u)
              if (this.exists(u)) u = this.get(u);
              else
                return (
                  console.warn("No texture found matching key: " + u), this
                );
            this.list.hasOwnProperty(u.key) &&
              (u.destroy(), this.emit(f.REMOVE, u.key));
            return this;
          },
          removeKey: function (u) {
            this.list.hasOwnProperty(u) && delete this.list[u];
            return this;
          },
          addBase64: function (u, v) {
            if (this.checkKey(u)) {
              var x = this,
                y = new Image();
              y.onerror = function () {
                x.emit(f.ERROR, u);
              };
              y.onload = function () {
                var z = x.create(u, y);
                q.Image(z, 0);
                x.emit(f.ADD, u, z);
                x.emit(f.LOAD, u, z);
              };
              y.src = v;
            }
            return this;
          },
          getBase64: function (u, v, x, y) {
            void 0 === x && (x = "image/png");
            void 0 === y && (y = 0.92);
            var z = "";
            (u = this.getFrame(u, v)) &&
            (u.source.isRenderTexture || u.source.isGLTexture)
              ? console.warn("Cannot getBase64 from WebGL Texture")
              : u &&
                ((z = u.canvasData),
                (v = d.create2D(this, z.width, z.height)),
                v
                  .getContext("2d")
                  .drawImage(
                    u.source.image,
                    z.x,
                    z.y,
                    z.width,
                    z.height,
                    0,
                    0,
                    z.width,
                    z.height
                  ),
                (z = v.toDataURL(x, y)),
                d.remove(v));
            return z;
          },
          addImage: function (u, v, x) {
            var y = null;
            this.checkKey(u) &&
              ((y = this.create(u, v)),
              q.Image(y, 0),
              x && y.setDataSource(x),
              this.emit(f.ADD, u, y));
            return y;
          },
          addGLTexture: function (u, v, x, y) {
            var z = null;
            this.checkKey(u) &&
              (void 0 === x && (x = v.width),
              void 0 === y && (y = v.height),
              (z = this.create(u, v, x, y)),
              z.add("__BASE", 0, 0, 0, x, y),
              this.emit(f.ADD, u, z));
            return z;
          },
          addRenderTexture: function (u, v) {
            var x = null;
            this.checkKey(u) &&
              ((x = this.create(u, v)),
              x.add("__BASE", 0, 0, 0, v.width, v.height),
              this.emit(f.ADD, u, x));
            return x;
          },
          generate: function (u, v) {
            if (this.checkKey(u)) {
              var x = d.create(this, 1, 1);
              v.canvas = x;
              m(v);
              return this.addCanvas(u, x);
            }
            return null;
          },
          createCanvas: function (u, v, x) {
            void 0 === v && (v = 256);
            void 0 === x && (x = 256);
            return this.checkKey(u)
              ? ((v = d.create(this, v, x, b.CANVAS, !0)), this.addCanvas(u, v))
              : null;
          },
          addCanvas: function (u, v, x) {
            void 0 === x && (x = !1);
            var y = null;
            x
              ? (y = new k(this, u, v, v.width, v.height))
              : this.checkKey(u) &&
                ((y = new k(this, u, v, v.width, v.height)),
                (this.list[u] = y),
                this.emit(f.ADD, u, y));
            return y;
          },
          addAtlas: function (u, v, x, y) {
            return Array.isArray(x.textures) || Array.isArray(x.frames)
              ? this.addAtlasJSONArray(u, v, x, y)
              : this.addAtlasJSONHash(u, v, x, y);
          },
          addAtlasJSONArray: function (u, v, x, y) {
            var z = null;
            if (this.checkKey(u)) {
              z = this.create(u, v);
              if (Array.isArray(x)) {
                v = 1 === x.length;
                for (var A = 0; A < z.source.length; A++)
                  q.JSONArray(z, A, v ? x[0] : x[A]);
              } else q.JSONArray(z, 0, x);
              y && z.setDataSource(y);
              this.emit(f.ADD, u, z);
            }
            return z;
          },
          addAtlasJSONHash: function (u, v, x, y) {
            var z = null;
            if (this.checkKey(u)) {
              z = this.create(u, v);
              if (Array.isArray(x))
                for (v = 0; v < x.length; v++) q.JSONHash(z, v, x[v]);
              else q.JSONHash(z, 0, x);
              y && z.setDataSource(y);
              this.emit(f.ADD, u, z);
            }
            return z;
          },
          addAtlasXML: function (u, v, x, y) {
            var z = null;
            this.checkKey(u) &&
              ((z = this.create(u, v)),
              q.AtlasXML(z, 0, x),
              y && z.setDataSource(y),
              this.emit(f.ADD, u, z));
            return z;
          },
          addUnityAtlas: function (u, v, x, y) {
            var z = null;
            this.checkKey(u) &&
              ((z = this.create(u, v)),
              q.UnityYAML(z, 0, x),
              y && z.setDataSource(y),
              this.emit(f.ADD, u, z));
            return z;
          },
          addSpriteSheet: function (u, v, x) {
            var y = null;
            this.checkKey(u) &&
              ((y = this.create(u, v)),
              q.SpriteSheet(
                y,
                0,
                0,
                0,
                y.source[0].width,
                y.source[0].height,
                x
              ),
              this.emit(f.ADD, u, y));
            return y;
          },
          addSpriteSheetFromAtlas: function (u, v) {
            if (!this.checkKey(u)) return null;
            var x = n(v, "atlas", null),
              y = n(v, "frame", null);
            if (x && y && (x = this.get(x).get(y)))
              return (
                (y = this.create(u, x.source.image)),
                x.trimmed
                  ? q.SpriteSheetFromAtlas(y, x, v)
                  : q.SpriteSheet(
                      y,
                      0,
                      x.cutX,
                      x.cutY,
                      x.cutWidth,
                      x.cutHeight,
                      v
                    ),
                this.emit(f.ADD, u, y),
                y
              );
          },
          create: function (u, v, x, y) {
            var z = null;
            this.checkKey(u) &&
              ((z = new r(this, u, v, x, y)), (this.list[u] = z));
            return z;
          },
          exists: function (u) {
            return this.list.hasOwnProperty(u);
          },
          get: function (u) {
            void 0 === u && (u = "__DEFAULT");
            return this.list[u]
              ? this.list[u]
              : u instanceof r
              ? u
              : this.list.__MISSING;
          },
          cloneFrame: function (u, v) {
            if (this.list[u]) return this.list[u].get(v).clone();
          },
          getFrame: function (u, v) {
            if (this.list[u]) return this.list[u].get(v);
          },
          getTextureKeys: function () {
            var u = [],
              v;
            for (v in this.list)
              "__DEFAULT" !== v && "__MISSING" !== v && u.push(v);
            return u;
          },
          getPixel: function (u, v, x, y) {
            if ((x = this.getFrame(x, y)))
              if (
                ((u -= x.x),
                (v -= x.y),
                (y = x.data.cut),
                (u += y.x),
                (v += y.y),
                u >= y.x && u < y.r && v >= y.y && v < y.b)
              )
                return (
                  (y = this._tempContext),
                  y.clearRect(0, 0, 1, 1),
                  y.drawImage(x.source.image, u, v, 1, 1, 0, 0, 1, 1),
                  (u = y.getImageData(0, 0, 1, 1)),
                  new e(u.data[0], u.data[1], u.data[2], u.data[3])
                );
            return null;
          },
          getPixelAlpha: function (u, v, x, y) {
            if ((x = this.getFrame(x, y)))
              if (
                ((u -= x.x),
                (v -= x.y),
                (y = x.data.cut),
                (u += y.x),
                (v += y.y),
                u >= y.x && u < y.r && v >= y.y && v < y.b)
              )
                return (
                  (y = this._tempContext),
                  y.clearRect(0, 0, 1, 1),
                  y.drawImage(x.source.image, u, v, 1, 1, 0, 0, 1, 1),
                  y.getImageData(0, 0, 1, 1).data[3]
                );
            return null;
          },
          setTexture: function (u, v, x) {
            this.list[v] &&
              ((u.texture = this.list[v]), (u.frame = u.texture.get(x)));
            return u;
          },
          renameTexture: function (u, v) {
            var x = this.get(u);
            return x && u !== v
              ? ((x.key = v), (this.list[v] = x), delete this.list[u], !0)
              : !1;
          },
          each: function (u, v) {
            for (var x = [null], y = 1; y < arguments.length; y++)
              x.push(arguments[y]);
            for (var z in this.list) (x[0] = this.list[z]), u.apply(v, x);
          },
          destroy: function () {
            for (var u in this.list) this.list[u].destroy();
            this.list = {};
            this.game = null;
            d.remove(this._tempCanvas);
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(18),
          k = a(38),
          e = a(33),
          b = a(138),
          c = a(206);
        a = new t({
          Extends: c,
          initialize: function (f, g, m, n, q) {
            c.call(this, f, g, m, n, q);
            this.add("__BASE", 0, 0, 0, n, q);
            this._source = this.frames.__BASE.source;
            this.canvas = this._source.image;
            this.context = this.canvas.getContext("2d");
            this.width = n;
            this.height = q;
            this.imageData = this.context.getImageData(0, 0, n, q);
            this.data = null;
            this.imageData && (this.data = this.imageData.data);
            this.pixels = null;
            this.buffer;
            this.data &&
              (this.imageData.data.buffer
                ? ((this.buffer = this.imageData.data.buffer),
                  (this.pixels = new Uint32Array(this.buffer)))
                : window.ArrayBuffer
                ? ((this.buffer = new ArrayBuffer(this.imageData.data.length)),
                  (this.pixels = new Uint32Array(this.buffer)))
                : (this.pixels = this.imageData.data));
          },
          update: function () {
            this.imageData = this.context.getImageData(
              0,
              0,
              this.width,
              this.height
            );
            this.data = this.imageData.data;
            this.imageData.data.buffer
              ? ((this.buffer = this.imageData.data.buffer),
                (this.pixels = new Uint32Array(this.buffer)))
              : window.ArrayBuffer
              ? ((this.buffer = new ArrayBuffer(this.imageData.data.length)),
                (this.pixels = new Uint32Array(this.buffer)))
              : (this.pixels = this.imageData.data);
            this.manager.game.config.renderType === e.WEBGL && this.refresh();
            return this;
          },
          draw: function (f, g, m) {
            this.context.drawImage(m, f, g);
            return this.update();
          },
          drawFrame: function (f, g, m, n) {
            void 0 === m && (m = 0);
            void 0 === n && (n = 0);
            if ((f = this.manager.getFrame(f, g))) {
              g = f.canvasData;
              var q = f.cutWidth,
                r = f.cutHeight,
                u = f.source.resolution;
              this.context.drawImage(
                f.source.image,
                g.x,
                g.y,
                q,
                r,
                m,
                n,
                q / u,
                r / u
              );
              return this.update();
            }
            return this;
          },
          setPixel: function (f, g, m, n, q, r) {
            void 0 === r && (r = 255);
            f = Math.abs(Math.floor(f));
            g = Math.abs(Math.floor(g));
            if (-1 < this.getIndex(f, g)) {
              var u = this.context.getImageData(f, g, 1, 1);
              u.data[0] = m;
              u.data[1] = n;
              u.data[2] = q;
              u.data[3] = r;
              this.context.putImageData(u, f, g);
            }
            return this;
          },
          putData: function (f, g, m, n, q, r, u) {
            void 0 === n && (n = 0);
            void 0 === q && (q = 0);
            void 0 === r && (r = f.width);
            void 0 === u && (u = f.height);
            this.context.putImageData(f, g, m, n, q, r, u);
            return this;
          },
          getData: function (f, g, m, n) {
            f = d(Math.floor(f), 0, this.width - 1);
            g = d(Math.floor(g), 0, this.height - 1);
            m = d(m, 1, this.width - f);
            n = d(n, 1, this.height - g);
            return this.context.getImageData(f, g, m, n);
          },
          getPixel: function (f, g, m) {
            m || (m = new k());
            f = this.getIndex(f, g);
            -1 < f &&
              ((g = this.data),
              m.setTo(g[f + 0], g[f + 1], g[f + 2], g[f + 3]));
            return m;
          },
          getPixels: function (f, g, m, n) {
            void 0 === f && (f = 0);
            void 0 === g && (g = 0);
            void 0 === m && (m = this.width);
            void 0 === n && (n = m);
            f = Math.abs(Math.round(f));
            g = Math.abs(Math.round(g));
            var q = d(f, 0, this.width);
            f = d(f + m, 0, this.width);
            var r = d(g, 0, this.height);
            g = d(g + n, 0, this.height);
            n = new k();
            for (m = []; r < g; r++) {
              for (var u = [], v = q; v < f; v++)
                (n = this.getPixel(v, r, n)),
                  u.push({
                    x: v,
                    y: r,
                    color: n.color,
                    alpha: n.alphaGL,
                  });
              m.push(u);
            }
            return m;
          },
          getIndex: function (f, g) {
            f = Math.abs(Math.round(f));
            g = Math.abs(Math.round(g));
            return f < this.width && g < this.height
              ? 4 * (f + g * this.width)
              : -1;
          },
          refresh: function () {
            this._source.update();
            return this;
          },
          getCanvas: function () {
            return this.canvas;
          },
          getContext: function () {
            return this.context;
          },
          clear: function (f, g, m, n) {
            void 0 === f && (f = 0);
            void 0 === g && (g = 0);
            void 0 === m && (m = this.width);
            void 0 === n && (n = this.height);
            this.context.clearRect(f, g, m, n);
            return this.update();
          },
          setSize: function (f, g) {
            void 0 === g && (g = f);
            if (f !== this.width || g !== this.height)
              (this.canvas.width = f),
                (this.canvas.height = g),
                (this._source.width = f),
                (this._source.height = g),
                (this._source.isPowerOf2 = b(f, g)),
                this.frames.__BASE.setSize(f, g, 0, 0),
                (this.width = f),
                (this.height = g),
                this.refresh();
            return this;
          },
          destroy: function () {
            c.prototype.destroy.call(this);
            this.buffer =
              this.pixels =
              this.data =
              this.imageData =
              this.context =
              this.canvas =
              this._source =
                null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(31);
        t = a(0);
        var k = a(138),
          e = a(168);
        a = new t({
          initialize: function (b, c, f, g, m) {
            void 0 === m && (m = !1);
            var n = b.manager.game;
            this.renderer = n.renderer;
            this.texture = b;
            this.image = this.source = c;
            this.compressionAlgorithm = null;
            this.resolution = 1;
            this.width = f || c.naturalWidth || c.videoWidth || c.width || 0;
            this.height =
              g || c.naturalHeight || c.videoHeight || c.height || 0;
            this.scaleMode = e.DEFAULT;
            this.isCanvas = c instanceof HTMLCanvasElement;
            this.isVideo =
              window.hasOwnProperty("HTMLVideoElement") &&
              c instanceof HTMLVideoElement;
            this.isRenderTexture = "RenderTexture" === c.type;
            this.isGLTexture =
              window.hasOwnProperty("WebGLTexture") &&
              c instanceof WebGLTexture;
            this.isPowerOf2 = k(this.width, this.height);
            this.glTexture = null;
            this.glIndex = 0;
            this.glIndexCounter = -1;
            this.flipY = m;
            this.init(n);
          },
          init: function (b) {
            var c = this.renderer;
            c &&
              (c.gl
                ? this.isCanvas
                  ? (this.glTexture = c.createCanvasTexture(
                      this.image,
                      !1,
                      this.flipY
                    ))
                  : this.isVideo
                  ? (this.glTexture = c.createVideoTexture(
                      this.image,
                      !1,
                      this.flipY
                    ))
                  : this.isRenderTexture
                  ? ((this.image = this.source.canvas),
                    (this.glTexture = c.createTextureFromSource(
                      null,
                      this.width,
                      this.height,
                      this.scaleMode
                    )))
                  : (this.glTexture = this.isGLTexture
                      ? this.source
                      : c.createTextureFromSource(
                          this.image,
                          this.width,
                          this.height,
                          this.scaleMode
                        ))
                : this.isRenderTexture && (this.image = this.source.canvas));
            b.config.antialias || this.setFilter(1);
          },
          setFilter: function (b) {
            this.renderer.gl &&
              this.renderer.setTextureFilter(this.glTexture, b);
            this.scaleMode = b;
          },
          setFlipY: function (b) {
            void 0 === b && (b = !0);
            this.flipY = b;
            return this;
          },
          update: function () {
            var b = this.renderer.gl;
            b && this.isCanvas
              ? (this.glTexture = this.renderer.updateCanvasTexture(
                  this.image,
                  this.glTexture,
                  this.flipY
                ))
              : b &&
                this.isVideo &&
                (this.glTexture = this.renderer.updateVideoTexture(
                  this.image,
                  this.glTexture,
                  this.flipY
                ));
          },
          destroy: function () {
            this.glTexture && this.renderer.deleteTexture(this.glTexture, !0);
            this.isCanvas && d.remove(this.image);
            this.glTexture =
              this.image =
              this.source =
              this.texture =
              this.renderer =
                null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          AtlasXML: a(979),
          Canvas: a(980),
          Image: a(981),
          JSONArray: a(982),
          JSONHash: a(983),
          SpriteSheet: a(984),
          SpriteSheetFromAtlas: a(985),
          UnityYAML: a(986),
        };
      },
      function (h, t, a) {
        var d = a(427),
          k = a(430),
          e = a(432);
        h.exports = {
          create: function (b) {
            var c = b.config.audio,
              f = b.device.audio;
            return c.noAudio || (!f.webAudio && !f.audioData)
              ? new k(b)
              : f.webAudio && !c.disableWebAudio
              ? new e(b)
              : new d(b);
          },
        };
      },
      function (h, t, a) {
        var d = a(145);
        t = a(0);
        var k = a(70),
          e = a(429);
        a = new t({
          Extends: d,
          initialize: function (b) {
            this.override = !0;
            this.audioPlayDelay = 0.1;
            this.loopEndOffset = 0.05;
            this.onBlurPausedSounds = [];
            this.lockedActionsQueue = (this.locked = "ontouchstart" in window)
              ? []
              : null;
            this._mute = !1;
            this._volume = 1;
            d.call(this, b);
          },
          add: function (b, c) {
            b = new e(this, b, c);
            this.sounds.push(b);
            return b;
          },
          unlock: function () {
            this.locked = !1;
            var b = this;
            this.game.cache.audio.entries.each(function (m, n) {
              for (m = 0; m < n.length; m++)
                if ("true" === n[m].dataset.locked) return (b.locked = !0), !1;
              return !0;
            });
            if (this.locked) {
              var c = !1,
                f = function () {
                  c = !0;
                },
                g = function () {
                  if (c) c = !1;
                  else {
                    document.body.removeEventListener("touchmove", f);
                    document.body.removeEventListener("touchend", g);
                    var m = [];
                    b.game.cache.audio.entries.each(function (q, r) {
                      for (q = 0; q < r.length; q++) {
                        var u = r[q];
                        "true" === u.dataset.locked && m.push(u);
                      }
                      return !0;
                    });
                    if (0 !== m.length) {
                      var n = m[m.length - 1];
                      n.oncanplaythrough = function () {
                        n.oncanplaythrough = null;
                        m.forEach(function (q) {
                          q.dataset.locked = "false";
                        });
                        b.unlocked = !0;
                      };
                      m.forEach(function (q) {
                        q.load();
                      });
                    }
                  }
                };
              this.once(
                k.UNLOCKED,
                function () {
                  for (
                    this.forEachActiveSound(function (n) {
                      null === n.currentMarker &&
                        0 === n.duration &&
                        (n.duration = n.tags[0].duration);
                      n.totalDuration = n.tags[0].duration;
                    });
                    this.lockedActionsQueue.length;

                  ) {
                    var m = this.lockedActionsQueue.shift();
                    m.sound[m.prop].apply
                      ? m.sound[m.prop].apply(m.sound, m.value || [])
                      : (m.sound[m.prop] = m.value);
                  }
                },
                this
              );
              document.body.addEventListener("touchmove", f, !1);
              document.body.addEventListener("touchend", g, !1);
            }
          },
          onBlur: function () {
            this.forEachActiveSound(function (b) {
              b.isPlaying && (this.onBlurPausedSounds.push(b), b.onBlur());
            });
          },
          onFocus: function () {
            this.onBlurPausedSounds.forEach(function (b) {
              b.onFocus();
            });
            this.onBlurPausedSounds.length = 0;
          },
          destroy: function () {
            d.prototype.destroy.call(this);
            this.onBlurPausedSounds.length = 0;
            this.onBlurPausedSounds = null;
          },
          isLocked: function (b, c, f) {
            return "true" === b.tags[0].dataset.locked
              ? (this.lockedActionsQueue.push({
                  sound: b,
                  prop: c,
                  value: f,
                }),
                !0)
              : !1;
          },
          setMute: function (b) {
            this.mute = b;
            return this;
          },
          mute: {
            get: function () {
              return this._mute;
            },
            set: function (b) {
              this._mute = b;
              this.forEachActiveSound(function (c) {
                c.updateMute();
              });
              this.emit(k.GLOBAL_MUTE, this, b);
            },
          },
          setVolume: function (b) {
            this.volume = b;
            return this;
          },
          volume: {
            get: function () {
              return this._volume;
            },
            set: function (b) {
              this._volume = b;
              this.forEachActiveSound(function (c) {
                c.updateVolume();
              });
              this.emit(k.GLOBAL_VOLUME, this, b);
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(78);
        h.exports = function (k, e, b, c, f) {
          void 0 === c && (c = 0);
          void 0 === f && (f = k.length);
          if (d(k, c, f))
            for (; c < f; c++) {
              var g = k[c];
              if (
                !e ||
                (e && void 0 === b && g.hasOwnProperty(e)) ||
                (e && void 0 !== b && g[e] === b)
              )
                return g;
            }
          return null;
        };
      },
      function (h, t, a) {
        var d = a(146);
        t = a(0);
        var k = a(70),
          e = a(18);
        a = new t({
          Extends: d,
          initialize: function (b, c, f) {
            void 0 === f && (f = {});
            this.tags = b.game.cache.audio.get(c);
            if (!this.tags)
              throw Error(
                'There is no audio asset with key "' +
                  c +
                  '" in the audio cache'
              );
            this.audio = null;
            this.previousTime = this.startTime = 0;
            this.duration = this.tags[0].duration;
            this.totalDuration = this.tags[0].duration;
            d.call(this, b, c, f);
          },
          play: function (b, c) {
            if (
              this.manager.isLocked(this, "play", [b, c]) ||
              !d.prototype.play.call(this, b, c) ||
              !this.pickAndPlayAudioTag()
            )
              return !1;
            this.emit(k.PLAY, this);
            return !0;
          },
          pause: function () {
            if (
              this.manager.isLocked(this, "pause") ||
              0 < this.startTime ||
              !d.prototype.pause.call(this)
            )
              return !1;
            this.currentConfig.seek =
              this.audio.currentTime -
              (this.currentMarker ? this.currentMarker.start : 0);
            this.stopAndReleaseAudioTag();
            this.emit(k.PAUSE, this);
            return !0;
          },
          resume: function () {
            if (
              this.manager.isLocked(this, "resume") ||
              0 < this.startTime ||
              !d.prototype.resume.call(this) ||
              !this.pickAndPlayAudioTag()
            )
              return !1;
            this.emit(k.RESUME, this);
            return !0;
          },
          stop: function () {
            if (
              this.manager.isLocked(this, "stop") ||
              !d.prototype.stop.call(this)
            )
              return !1;
            this.stopAndReleaseAudioTag();
            this.emit(k.STOP, this);
            return !0;
          },
          pickAndPlayAudioTag: function () {
            if (!this.pickAudioTag()) return this.reset(), !1;
            var b = this.currentConfig.delay,
              c =
                (this.currentMarker ? this.currentMarker.start : 0) +
                this.currentConfig.seek;
            this.previousTime = c;
            this.audio.currentTime = c;
            this.applyConfig();
            0 === b
              ? ((this.startTime = 0),
                this.audio.paused && this.playCatchPromise())
              : ((this.startTime = window.performance.now() + 1e3 * b),
                this.audio.paused || this.audio.pause());
            this.resetConfig();
            return !0;
          },
          pickAudioTag: function () {
            if (this.audio) return !0;
            for (var b = 0; b < this.tags.length; b++) {
              var c = this.tags[b];
              if ("false" === c.dataset.used)
                return (c.dataset.used = "true"), (this.audio = c), !0;
            }
            if (!this.manager.override) return !1;
            var f = [];
            this.manager.forEachActiveSound(function (g) {
              g.key === this.key && g.audio && f.push(g);
            }, this);
            f.sort(function (g, m) {
              return g.loop === m.loop
                ? m.seek / m.duration - g.seek / g.duration
                : g.loop
                ? 1
                : -1;
            });
            b = f[0];
            this.audio = b.audio;
            b.reset();
            b.audio = null;
            b.startTime = 0;
            b.previousTime = 0;
            return !0;
          },
          playCatchPromise: function () {
            var b = this.audio.play();
            b &&
              b.catch(function (c) {
                console.warn(c);
              });
          },
          stopAndReleaseAudioTag: function () {
            this.previousTime = this.startTime = 0;
            this.audio &&
              (this.audio.pause(),
              (this.audio.dataset.used = "false"),
              (this.audio = null));
          },
          reset: function () {
            d.prototype.stop.call(this);
          },
          onBlur: function () {
            this.isPlaying = !1;
            this.isPaused = !0;
            this.currentConfig.seek =
              this.audio.currentTime -
              (this.currentMarker ? this.currentMarker.start : 0);
            this.currentConfig.delay = Math.max(
              0,
              (this.startTime - window.performance.now()) / 1e3
            );
            this.stopAndReleaseAudioTag();
          },
          onFocus: function () {
            this.isPlaying = !0;
            this.isPaused = !1;
            this.pickAndPlayAudioTag();
          },
          update: function (b) {
            if (this.isPlaying)
              if (0 < this.startTime)
                this.startTime < b - this.manager.audioPlayDelay &&
                  ((this.audio.currentTime +=
                    Math.max(0, b - this.startTime) / 1e3),
                  (this.startTime = 0),
                  (this.previousTime = this.audio.currentTime),
                  this.playCatchPromise());
              else {
                b = this.currentMarker ? this.currentMarker.start : 0;
                var c = b + this.duration,
                  f = this.audio.currentTime;
                if (this.currentConfig.loop)
                  f >= c - this.manager.loopEndOffset
                    ? ((this.audio.currentTime = b + Math.max(0, f - c)),
                      (f = this.audio.currentTime))
                    : f < b &&
                      ((this.audio.currentTime += b),
                      (f = this.audio.currentTime)),
                    f < this.previousTime && this.emit(k.LOOPED, this);
                else if (f >= c) {
                  this.reset();
                  this.stopAndReleaseAudioTag();
                  this.emit(k.COMPLETE, this);
                  return;
                }
                this.previousTime = f;
              }
          },
          destroy: function () {
            d.prototype.destroy.call(this);
            this.tags = null;
            this.audio && this.stopAndReleaseAudioTag();
          },
          updateMute: function () {
            this.audio &&
              (this.audio.muted = this.currentConfig.mute || this.manager.mute);
          },
          updateVolume: function () {
            this.audio &&
              (this.audio.volume = e(
                this.currentConfig.volume * this.manager.volume,
                0,
                1
              ));
          },
          calculateRate: function () {
            d.prototype.calculateRate.call(this);
            this.audio && (this.audio.playbackRate = this.totalRate);
          },
          mute: {
            get: function () {
              return this.currentConfig.mute;
            },
            set: function (b) {
              this.currentConfig.mute = b;
              this.manager.isLocked(this, "mute", b) ||
                (this.updateMute(), this.emit(k.MUTE, this, b));
            },
          },
          setMute: function (b) {
            this.mute = b;
            return this;
          },
          volume: {
            get: function () {
              return this.currentConfig.volume;
            },
            set: function (b) {
              this.currentConfig.volume = b;
              this.manager.isLocked(this, "volume", b) ||
                (this.updateVolume(), this.emit(k.VOLUME, this, b));
            },
          },
          setVolume: function (b) {
            this.volume = b;
            return this;
          },
          rate: {
            get: function () {
              return this.currentConfig.rate;
            },
            set: function (b) {
              this.currentConfig.rate = b;
              this.manager.isLocked(this, k.RATE, b) ||
                (this.calculateRate(), this.emit(k.RATE, this, b));
            },
          },
          setRate: function (b) {
            this.rate = b;
            return this;
          },
          detune: {
            get: function () {
              return this.currentConfig.detune;
            },
            set: function (b) {
              this.currentConfig.detune = b;
              this.manager.isLocked(this, k.DETUNE, b) ||
                (this.calculateRate(), this.emit(k.DETUNE, this, b));
            },
          },
          setDetune: function (b) {
            this.detune = b;
            return this;
          },
          seek: {
            get: function () {
              return this.isPlaying
                ? this.audio.currentTime -
                    (this.currentMarker ? this.currentMarker.start : 0)
                : this.isPaused
                ? this.currentConfig.seek
                : 0;
            },
            set: function (b) {
              this.manager.isLocked(this, "seek", b) ||
                0 < this.startTime ||
                (!this.isPlaying && !this.isPaused) ||
                ((b = Math.min(Math.max(0, b), this.duration)),
                this.isPlaying
                  ? ((this.previousTime = b), (this.audio.currentTime = b))
                  : this.isPaused && (this.currentConfig.seek = b),
                this.emit(k.SEEK, this, b));
            },
          },
          setSeek: function (b) {
            this.seek = b;
            return this;
          },
          loop: {
            get: function () {
              return this.currentConfig.loop;
            },
            set: function (b) {
              this.currentConfig.loop = b;
              this.manager.isLocked(this, "loop", b) ||
                (this.audio && (this.audio.loop = b),
                this.emit(k.LOOP, this, b));
            },
          },
          setLoop: function (b) {
            this.loop = b;
            return this;
          },
          pan: {
            get: function () {
              return this.currentConfig.pan;
            },
            set: function (b) {
              this.currentConfig.pan = b;
              this.emit(k.PAN, this, b);
            },
          },
          setPan: function (b) {
            this.pan = b;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(145);
        t = a(0);
        var k = a(9),
          e = a(431);
        a = a(1);
        a = new t({
          Extends: k,
          initialize: function (b) {
            k.call(this);
            this.game = b;
            this.sounds = [];
            this.mute = !1;
            this.rate = this.volume = 1;
            this.detune = 0;
            this.pauseOnBlur = !0;
            this.locked = !1;
          },
          add: function (b, c) {
            b = new e(this, b, c);
            this.sounds.push(b);
            return b;
          },
          addAudioSprite: function (b, c) {
            b = this.add(b, c);
            b.spritemap = {};
            return b;
          },
          play: function (b, c) {
            return !1;
          },
          playAudioSprite: function (b, c, f) {
            return !1;
          },
          remove: function (b) {
            return d.prototype.remove.call(this, b);
          },
          removeByKey: function (b) {
            return d.prototype.removeByKey.call(this, b);
          },
          pauseAll: a,
          resumeAll: a,
          stopAll: a,
          update: a,
          setRate: a,
          setDetune: a,
          setMute: a,
          setVolume: a,
          forEachActiveSound: function (b, c) {
            d.prototype.forEachActiveSound.call(this, b, c);
          },
          destroy: function () {
            d.prototype.destroy.call(this);
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(146);
        t = a(0);
        var k = a(9),
          e = a(17);
        a = function () {
          return !1;
        };
        var b = function () {
          return this;
        };
        t = new t({
          Extends: k,
          initialize: function (c, f, g) {
            void 0 === g && (g = {});
            k.call(this);
            this.manager = c;
            this.key = f;
            this.isPaused = this.isPlaying = !1;
            this.totalRate = 1;
            this.totalDuration = this.duration = 0;
            this.currentConfig = this.config = e(
              {
                mute: !1,
                volume: 1,
                rate: 1,
                detune: 0,
                seek: 0,
                loop: !1,
                delay: 0,
                pan: 0,
              },
              g
            );
            this.mute = !1;
            this.rate = this.volume = 1;
            this.seek = this.detune = 0;
            this.loop = !1;
            this.pan = 0;
            this.markers = {};
            this.currentMarker = null;
            this.pendingRemove = !1;
          },
          addMarker: a,
          updateMarker: a,
          removeMarker: function () {
            return null;
          },
          play: a,
          pause: a,
          resume: a,
          stop: a,
          destroy: function () {
            d.prototype.destroy.call(this);
          },
          setMute: b,
          setVolume: b,
          setRate: b,
          setDetune: b,
          setSeek: b,
          setLoop: b,
          setPan: b,
        });
        h.exports = t;
      },
      function (h, t, a) {
        var d = a(433),
          k = a(145);
        t = a(0);
        var e = a(70),
          b = a(22),
          c = a(434);
        a = new t({
          Extends: k,
          initialize: function (f) {
            this.context = this.createAudioContext(f);
            this.masterMuteNode = this.context.createGain();
            this.masterVolumeNode = this.context.createGain();
            this.masterMuteNode.connect(this.masterVolumeNode);
            this.masterVolumeNode.connect(this.context.destination);
            this.destination = this.masterMuteNode;
            this.locked =
              "suspended" === this.context.state &&
              ("ontouchstart" in window || "onclick" in window);
            k.call(this, f);
            if (this.locked && f.isBooted) this.unlock();
            else f.events.once(b.BOOT, this.unlock, this);
          },
          createAudioContext: function (f) {
            f = f.config.audio;
            if (f.context) return f.context.resume(), f.context;
            if (window.hasOwnProperty("AudioContext"))
              return new AudioContext();
            if (window.hasOwnProperty("webkitAudioContext"))
              return new window.webkitAudioContext();
          },
          setAudioContext: function (f) {
            this.context && this.context.close();
            this.masterMuteNode && this.masterMuteNode.disconnect();
            this.masterVolumeNode && this.masterVolumeNode.disconnect();
            this.context = f;
            this.masterMuteNode = f.createGain();
            this.masterVolumeNode = f.createGain();
            this.masterMuteNode.connect(this.masterVolumeNode);
            this.masterVolumeNode.connect(f.destination);
            this.destination = this.masterMuteNode;
            return this;
          },
          add: function (f, g) {
            f = new c(this, f, g);
            this.sounds.push(f);
            return f;
          },
          decodeAudio: function (f, g) {
            f = Array.isArray(f)
              ? f
              : [
                  {
                    key: f,
                    data: g,
                  },
                ];
            var m = this.game.cache.audio,
              n = f.length;
            for (g = 0; g < f.length; g++) {
              var q = f[g],
                r = q.key;
              q = q.data;
              "string" === typeof q && (q = d(q));
              var u = function (v, x) {
                m.add(v, x);
                this.emit(e.DECODED, v);
                n--;
                0 === n && this.emit(e.DECODED_ALL);
              }.bind(this, r);
              r = function (v, x) {
                console.error(
                  "Error decoding audio: " + v + " - ",
                  x ? x.message : ""
                );
                n--;
                0 === n && this.emit(e.DECODED_ALL);
              }.bind(this, r);
              this.context.decodeAudioData(q, u, r);
            }
          },
          unlock: function () {
            var f = this,
              g = document.body,
              m = function q() {
                if (f.context && g) {
                  var r = g.removeEventListener;
                  f.context.resume().then(
                    function () {
                      r("touchstart", q);
                      r("touchend", q);
                      r("click", q);
                      r("keydown", q);
                      f.unlocked = !0;
                    },
                    function () {
                      r("touchstart", q);
                      r("touchend", q);
                      r("click", q);
                      r("keydown", q);
                    }
                  );
                }
              };
            g &&
              (g.addEventListener("touchstart", m, !1),
              g.addEventListener("touchend", m, !1),
              g.addEventListener("click", m, !1),
              g.addEventListener("keydown", m, !1));
          },
          onBlur: function () {
            this.locked || this.context.suspend();
          },
          onFocus: function () {
            var f = this.context;
            ("suspended" !== f.state && "interrupted" !== f.state) ||
              this.locked ||
              f.resume();
          },
          update: function (f, g) {
            k.prototype.update.call(this, f, g);
            (f = this.context) && "interrupted" === f.state && f.resume();
          },
          destroy: function () {
            this.destination = null;
            this.masterVolumeNode.disconnect();
            this.masterVolumeNode = null;
            this.masterMuteNode.disconnect();
            this.masterMuteNode = null;
            if (this.game.config.audio.context) this.context.suspend();
            else {
              var f = this;
              this.context.close().then(function () {
                f.context = null;
              });
            }
            k.prototype.destroy.call(this);
          },
          setMute: function (f) {
            this.mute = f;
            return this;
          },
          mute: {
            get: function () {
              return 0 === this.masterMuteNode.gain.value;
            },
            set: function (f) {
              this.masterMuteNode.gain.setValueAtTime(f ? 0 : 1, 0);
              this.emit(e.GLOBAL_MUTE, this, f);
            },
          },
          setVolume: function (f) {
            this.volume = f;
            return this;
          },
          volume: {
            get: function () {
              return this.masterVolumeNode.gain.value;
            },
            set: function (f) {
              this.masterVolumeNode.gain.setValueAtTime(f, 0);
              this.emit(e.GLOBAL_VOLUME, this, f);
            },
          },
        });
        h.exports = a;
      },
      function (h, t) {
        var a = new Uint8Array(256);
        for (t = 0; 64 > t; t++)
          a[
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charCodeAt(
              t
            )
          ] = t;
        h.exports = function (d) {
          d = d.substr(d.indexOf(",") + 1);
          var k = d.length,
            e = 0.75 * k,
            b = 0;
          "=" === d[k - 1] && (e--, "=" === d[k - 2] && e--);
          for (
            var c = new ArrayBuffer(e), f = new Uint8Array(c), g = 0;
            g < k;
            g += 4
          ) {
            e = a[d.charCodeAt(g)];
            var m = a[d.charCodeAt(g + 1)];
            var n = a[d.charCodeAt(g + 2)];
            var q = a[d.charCodeAt(g + 3)];
            f[b++] = (e << 2) | (m >> 4);
            f[b++] = ((m & 15) << 4) | (n >> 2);
            f[b++] = ((n & 3) << 6) | (q & 63);
          }
          return c;
        };
      },
      function (h, t, a) {
        var d = a(146);
        t = a(0);
        var k = a(70);
        a = new t({
          Extends: d,
          initialize: function (e, b, c) {
            void 0 === c && (c = {});
            this.audioBuffer = e.game.cache.audio.get(b);
            if (!this.audioBuffer)
              throw Error('Audio key "' + b + '" missing from cache');
            this.loopSource = this.source = null;
            this.muteNode = e.context.createGain();
            this.volumeNode = e.context.createGain();
            this.pannerNode = null;
            this.loopTime = this.startTime = this.playTime = 0;
            this.rateUpdates = [];
            this.hasLooped = this.hasEnded = !1;
            this.muteNode.connect(this.volumeNode);
            e.context.createStereoPanner
              ? ((this.pannerNode = e.context.createStereoPanner()),
                this.volumeNode.connect(this.pannerNode),
                this.pannerNode.connect(e.destination))
              : this.volumeNode.connect(e.destination);
            this.totalDuration = this.duration = this.audioBuffer.duration;
            d.call(this, e, b, c);
          },
          play: function (e, b) {
            if (!d.prototype.play.call(this, e, b)) return !1;
            this.stopAndRemoveBufferSource();
            this.createAndStartBufferSource();
            this.emit(k.PLAY, this);
            return !0;
          },
          pause: function () {
            if (
              this.manager.context.currentTime < this.startTime ||
              !d.prototype.pause.call(this)
            )
              return !1;
            this.currentConfig.seek = this.getCurrentTime();
            this.stopAndRemoveBufferSource();
            this.emit(k.PAUSE, this);
            return !0;
          },
          resume: function () {
            if (
              this.manager.context.currentTime < this.startTime ||
              !d.prototype.resume.call(this)
            )
              return !1;
            this.createAndStartBufferSource();
            this.emit(k.RESUME, this);
            return !0;
          },
          stop: function () {
            if (!d.prototype.stop.call(this)) return !1;
            this.stopAndRemoveBufferSource();
            this.emit(k.STOP, this);
            return !0;
          },
          createAndStartBufferSource: function () {
            var e = this.currentConfig.seek,
              b = this.manager.context.currentTime + this.currentConfig.delay,
              c = (this.currentMarker ? this.currentMarker.start : 0) + e,
              f = this.duration - e;
            this.playTime = b - e;
            this.startTime = b;
            this.source = this.createBufferSource();
            this.applyConfig();
            this.source.start(Math.max(0, b), Math.max(0, c), Math.max(0, f));
            this.resetConfig();
          },
          createAndStartLoopBufferSource: function () {
            var e = this.getLoopTime(),
              b = this.currentMarker ? this.currentMarker.start : 0,
              c = this.duration;
            this.loopTime = e;
            this.loopSource = this.createBufferSource();
            this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0);
            this.loopSource.start(
              Math.max(0, e),
              Math.max(0, b),
              Math.max(0, c)
            );
          },
          createBufferSource: function () {
            var e = this,
              b = this.manager.context.createBufferSource();
            b.buffer = this.audioBuffer;
            b.connect(this.muteNode);
            b.onended = function (c) {
              c.target === e.source &&
                (e.currentConfig.loop ? (e.hasLooped = !0) : (e.hasEnded = !0));
            };
            return b;
          },
          stopAndRemoveBufferSource: function () {
            this.source &&
              (this.source.stop(),
              this.source.disconnect(),
              (this.source = null));
            this.startTime = this.playTime = 0;
            this.stopAndRemoveLoopBufferSource();
          },
          stopAndRemoveLoopBufferSource: function () {
            this.loopSource &&
              (this.loopSource.stop(),
              this.loopSource.disconnect(),
              (this.loopSource = null));
            this.loopTime = 0;
          },
          applyConfig: function () {
            this.rateUpdates.length = 0;
            this.rateUpdates.push({
              time: 0,
              rate: 1,
            });
            d.prototype.applyConfig.call(this);
          },
          update: function () {
            this.hasEnded
              ? ((this.hasEnded = !1),
                d.prototype.stop.call(this),
                this.stopAndRemoveBufferSource(),
                this.emit(k.COMPLETE, this))
              : this.hasLooped &&
                ((this.hasLooped = !1),
                (this.source = this.loopSource),
                (this.loopSource = null),
                (this.playTime = this.startTime = this.loopTime),
                (this.rateUpdates.length = 0),
                this.rateUpdates.push({
                  time: 0,
                  rate: this.totalRate,
                }),
                this.createAndStartLoopBufferSource(),
                this.emit(k.LOOPED, this));
          },
          destroy: function () {
            d.prototype.destroy.call(this);
            this.audioBuffer = null;
            this.stopAndRemoveBufferSource();
            this.muteNode.disconnect();
            this.muteNode = null;
            this.volumeNode.disconnect();
            this.volumeNode = null;
            this.pannerNode &&
              (this.pannerNode.disconnect(), (this.pannerNode = null));
            this.rateUpdates.length = 0;
            this.rateUpdates = null;
          },
          calculateRate: function () {
            d.prototype.calculateRate.call(this);
            var e = this.manager.context.currentTime;
            this.source &&
              "number" === typeof this.totalRate &&
              this.source.playbackRate.setValueAtTime(this.totalRate, e);
            this.isPlaying &&
              (this.rateUpdates.push({
                time: Math.max(this.startTime, e) - this.playTime,
                rate: this.totalRate,
              }),
              this.loopSource &&
                (this.stopAndRemoveLoopBufferSource(),
                this.createAndStartLoopBufferSource()));
          },
          getCurrentTime: function () {
            for (var e = 0, b = 0; b < this.rateUpdates.length; b++)
              e +=
                ((b < this.rateUpdates.length - 1
                  ? this.rateUpdates[b + 1].time
                  : this.manager.context.currentTime - this.playTime) -
                  this.rateUpdates[b].time) *
                this.rateUpdates[b].rate;
            return e;
          },
          getLoopTime: function () {
            for (var e = 0, b = 0; b < this.rateUpdates.length - 1; b++)
              e +=
                (this.rateUpdates[b + 1].time - this.rateUpdates[b].time) *
                this.rateUpdates[b].rate;
            b = this.rateUpdates[this.rateUpdates.length - 1];
            return this.playTime + b.time + (this.duration - e) / b.rate;
          },
          rate: {
            get: function () {
              return this.currentConfig.rate;
            },
            set: function (e) {
              this.currentConfig.rate = e;
              this.calculateRate();
              this.emit(k.RATE, this, e);
            },
          },
          setRate: function (e) {
            this.rate = e;
            return this;
          },
          detune: {
            get: function () {
              return this.currentConfig.detune;
            },
            set: function (e) {
              this.currentConfig.detune = e;
              this.calculateRate();
              this.emit(k.DETUNE, this, e);
            },
          },
          setDetune: function (e) {
            this.detune = e;
            return this;
          },
          mute: {
            get: function () {
              return 0 === this.muteNode.gain.value;
            },
            set: function (e) {
              this.currentConfig.mute = e;
              this.muteNode.gain.setValueAtTime(e ? 0 : 1, 0);
              this.emit(k.MUTE, this, e);
            },
          },
          setMute: function (e) {
            this.mute = e;
            return this;
          },
          volume: {
            get: function () {
              return this.volumeNode.gain.value;
            },
            set: function (e) {
              this.currentConfig.volume = e;
              this.volumeNode.gain.setValueAtTime(e, 0);
              this.emit(k.VOLUME, this, e);
            },
          },
          setVolume: function (e) {
            this.volume = e;
            return this;
          },
          seek: {
            get: function () {
              return this.isPlaying
                ? this.manager.context.currentTime < this.startTime
                  ? this.startTime - this.playTime
                  : this.getCurrentTime()
                : this.isPaused
                ? this.currentConfig.seek
                : 0;
            },
            set: function (e) {
              this.manager.context.currentTime < this.startTime ||
                (!this.isPlaying && !this.isPaused) ||
                ((e = Math.min(Math.max(0, e), this.duration)),
                (this.currentConfig.seek = e),
                this.isPlaying &&
                  (this.stopAndRemoveBufferSource(),
                  this.createAndStartBufferSource()),
                this.emit(k.SEEK, this, e));
            },
          },
          setSeek: function (e) {
            this.seek = e;
            return this;
          },
          loop: {
            get: function () {
              return this.currentConfig.loop;
            },
            set: function (e) {
              this.currentConfig.loop = e;
              this.isPlaying &&
                (this.stopAndRemoveLoopBufferSource(),
                e && this.createAndStartLoopBufferSource());
              this.emit(k.LOOP, this, e);
            },
          },
          setLoop: function (e) {
            this.loop = e;
            return this;
          },
          pan: {
            get: function () {
              return this.pannerNode ? this.pannerNode.pan.value : 0;
            },
            set: function (e) {
              this.currentConfig.pan = e;
              this.pannerNode &&
                this.pannerNode.pan.setValueAtTime(
                  e,
                  this.manager.context.currentTime
                );
              this.emit(k.PAN, this, e);
            },
          },
          setPan: function (e) {
            this.pan = e;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a) {
          for (
            var d = a.length, k = a[0].length, e = Array(k), b = 0;
            b < k;
            b++
          ) {
            e[b] = Array(d);
            for (var c = d - 1; -1 < c; c--) e[b][c] = a[c][b];
          }
          return e;
        };
      },
      function (h, t) {
        function a(e, b, c) {
          var f = e[b];
          e[b] = e[c];
          e[c] = f;
        }

        function d(e, b) {
          return e < b ? -1 : e > b ? 1 : 0;
        }
        var k = function (e, b, c, f, g) {
          void 0 === c && (c = 0);
          void 0 === f && (f = e.length - 1);
          for (void 0 === g && (g = d); f > c; ) {
            if (600 < f - c) {
              var m = f - c + 1,
                n = b - c + 1,
                q = Math.log(m),
                r = 0.5 * Math.exp((2 * q) / 3);
              q =
                0.5 *
                Math.sqrt((q * r * (m - r)) / m) *
                (0 > n - m / 2 ? -1 : 1);
              k(
                e,
                b,
                Math.max(c, Math.floor(b - (n * r) / m + q)),
                Math.min(f, Math.floor(b + ((m - n) * r) / m + q)),
                g
              );
            }
            m = e[b];
            n = c;
            r = f;
            a(e, c, b);
            for (0 < g(e[f], m) && a(e, c, f); n < r; ) {
              a(e, n, r);
              n++;
              for (r--; 0 > g(e[n], m); ) n++;
              for (; 0 < g(e[r], m); ) r--;
            }
            0 === g(e[c], m) ? a(e, c, r) : (r++, a(e, r, f));
            r <= b && (c = r + 1);
            b <= r && (f = r - 1);
          }
        };
        h.exports = k;
      },
      function (h, t, a) {
        var d = a(6),
          k = a(131);
        h.exports = function (e, b, c) {
          var f = d(c, "max", 0),
            g = d(c, "qty", 1),
            m = d(c, "random", !1),
            n = d(c, "randomB", !1),
            q = d(c, "repeat", 0);
          c = d(c, "yoyo", !1);
          var r = [];
          n && k(b);
          -1 === q &&
            (0 === f
              ? (q = 0)
              : ((q = e.length * b.length * g),
                c && (q *= 2),
                (q = Math.ceil(f / q))));
          for (n = 0; n <= q; n++) {
            var u = e;
            for (var v = b, x = g, y = [], z = 0; z < u.length; z++)
              for (var A = 0; A < v.length; A++)
                for (var B = 0; B < x; B++)
                  y.push({
                    a: u[z],
                    b: v[A],
                  });
            u = y;
            m && k(u);
            r = r.concat(u);
            c && (u.reverse(), (r = r.concat(u)));
          }
          f && r.splice(f);
          return r;
        };
      },
      function (h, t, a) {
        h.exports = {
          PROCESS_QUEUE_ADD: a(1041),
          PROCESS_QUEUE_REMOVE: a(1042),
        };
      },
      function (h, t, a) {
        var d = a(13);
        h.exports = function (k, e) {
          var b = d(e, "anims", null);
          if (null === b) return k;
          if ("string" === typeof b) k.anims.play(b);
          else if ("object" === typeof b) {
            e = k.anims;
            var c = d(b, "key", void 0);
            if (c) {
              var f = d(b, "startFrame", void 0),
                g = d(b, "delay", 0),
                m = d(b, "repeat", 0),
                n = d(b, "repeatDelay", 0),
                q = d(b, "yoyo", !1),
                r = d(b, "play", !1);
              b = d(b, "delayedPlay", 0);
              c = {
                key: c,
                delay: g,
                repeat: m,
                repeatDelay: n,
                yoyo: q,
                startFrame: f,
              };
              r ? e.play(c) : 0 < b ? e.playAfterDelay(c, b) : e.load(c);
            }
          }
          return k;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(109);
        a = new t({
          initialize: function (k, e, b, c, f) {
            this.parent = k;
            this.x = e;
            this.y = b;
            this.frame = c;
            this.data = {};
            this.tint = 16777215;
            this._visible = f;
            this._alpha = 1;
            this.flipY = this.flipX = !1;
          },
          setFrame: function (k) {
            this.frame =
              void 0 === k
                ? this.parent.frame
                : k instanceof d && k.texture === this.parent.texture
                ? k
                : this.parent.texture.get(k);
            return this;
          },
          resetFlip: function () {
            this.flipY = this.flipX = !1;
            return this;
          },
          reset: function (k, e, b) {
            this.x = k;
            this.y = e;
            this.flipY = this.flipX = !1;
            this._alpha = 1;
            this._visible = !0;
            this.parent.dirty = !0;
            b && this.setFrame(b);
            return this;
          },
          setPosition: function (k, e) {
            this.x = k;
            this.y = e;
            return this;
          },
          setFlipX: function (k) {
            this.flipX = k;
            return this;
          },
          setFlipY: function (k) {
            this.flipY = k;
            return this;
          },
          setFlip: function (k, e) {
            this.flipX = k;
            this.flipY = e;
            return this;
          },
          setVisible: function (k) {
            this.visible = k;
            return this;
          },
          setAlpha: function (k) {
            this.alpha = k;
            return this;
          },
          setTint: function (k) {
            this.tint = k;
            return this;
          },
          destroy: function () {
            this.parent.dirty = !0;
            this.parent.children.remove(this);
            this.data = this.frame = this.parent = void 0;
          },
          visible: {
            get: function () {
              return this._visible;
            },
            set: function (k) {
              this.parent.dirty |= this._visible !== k;
              this._visible = k;
            },
          },
          alpha: {
            get: function () {
              return this._alpha;
            },
            set: function (k) {
              this.parent.dirty |= 0 < this._alpha !== 0 < k;
              this._alpha = k;
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(10);
        h.exports = function (k, e, b) {
          void 0 === b && (b = new d());
          var c = Math.min(k.x, e.x),
            f = Math.min(k.y, e.y);
          return b.setTo(
            c,
            f,
            Math.max(k.right, e.right) - c,
            Math.max(k.bottom, e.bottom) - f
          );
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(11),
          k = a(1055),
          e = a(15),
          b = a(7),
          c = a(202),
          f = a(20),
          g = a(140);
        a = new t({
          Extends: e,
          Mixins: [
            d.AlphaSingle,
            d.BlendMode,
            d.Depth,
            d.Origin,
            d.ScrollFactor,
            d.Transform,
            d.Visible,
            k,
          ],
          initialize: function (m, n, q, r, u, v) {
            e.call(this, m, "DOMElement");
            this.parent = m.sys.game.domContainer;
            this.cache = m.sys.cache.html;
            this.node;
            this.transformOnly = !1;
            this.skewY = this.skewX = 0;
            this.rotate3d = new g();
            this.rotate3dAngle = "deg";
            this.pointerEvents = "auto";
            this.displayHeight =
              this.displayWidth =
              this.height =
              this.width =
                0;
            this.handler = this.dispatchNativeEvent.bind(this);
            this.setPosition(n, q);
            "string" === typeof r
              ? "#" === r[0]
                ? this.setElement(r.substr(1), u, v)
                : this.createElement(r, u, v)
              : r && this.setElement(r, u, v);
            m.sys.events.on(f.SLEEP, this.handleSceneEvent, this);
            m.sys.events.on(f.WAKE, this.handleSceneEvent, this);
          },
          addedToScene: function () {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function () {
            this.scene.sys.updateList.remove(this);
          },
          handleSceneEvent: function (m) {
            var n = this.node,
              q = n.style;
            n && (q.display = m.settings.visible ? "block" : "none");
          },
          setSkew: function (m, n) {
            void 0 === m && (m = 0);
            void 0 === n && (n = m);
            this.skewX = m;
            this.skewY = n;
            return this;
          },
          setPerspective: function (m) {
            this.parent.style.perspective = m + "px";
            return this;
          },
          perspective: {
            get: function () {
              return parseFloat(this.parent.style.perspective);
            },
            set: function (m) {
              this.parent.style.perspective = m + "px";
            },
          },
          addListener: function (m) {
            if (this.node) {
              m = m.split(" ");
              for (var n = 0; n < m.length; n++)
                this.node.addEventListener(m[n], this.handler, !1);
            }
            return this;
          },
          removeListener: function (m) {
            if (this.node) {
              m = m.split(" ");
              for (var n = 0; n < m.length; n++)
                this.node.removeEventListener(m[n], this.handler);
            }
            return this;
          },
          dispatchNativeEvent: function (m) {
            this.emit(m.type, m);
          },
          createElement: function (m, n, q) {
            return this.setElement(document.createElement(m), n, q);
          },
          setElement: function (m, n, q) {
            this.removeElement();
            if ("string" === typeof m) {
              "#" === m[0] && (m = m.substr(1));
              var r = document.getElementById(m);
            } else "object" === typeof m && 1 === m.nodeType && (r = m);
            if (!r) return this;
            this.node = r;
            if (n && b(n)) for (var u in n) r.style[u] = n[u];
            else "string" === typeof n && (r.style = n);
            r.style.zIndex = "0";
            r.style.display = "inline";
            r.style.position = "absolute";
            r.phaser = this;
            this.parent && this.parent.appendChild(r);
            q && (r.innerText = q);
            return this.updateSize();
          },
          createFromCache: function (m, n) {
            (m = this.cache.get(m)) && this.createFromHTML(m, n);
            return this;
          },
          createFromHTML: function (m, n) {
            void 0 === n && (n = "div");
            this.removeElement();
            this.node = n = document.createElement(n);
            n.style.zIndex = "0";
            n.style.display = "inline";
            n.style.position = "absolute";
            n.phaser = this;
            this.parent && this.parent.appendChild(n);
            n.innerHTML = m;
            return this.updateSize();
          },
          removeElement: function () {
            this.node && (c(this.node), (this.node = null));
            return this;
          },
          updateSize: function () {
            var m = this.node,
              n = m.getBoundingClientRect();
            this.width = m.clientWidth;
            this.height = m.clientHeight;
            this.displayWidth = n.width || 0;
            this.displayHeight = n.height || 0;
            return this;
          },
          getChildByProperty: function (m, n) {
            if (this.node)
              for (
                var q = this.node.querySelectorAll("*"), r = 0;
                r < q.length;
                r++
              )
                if (q[r][m] === n) return q[r];
            return null;
          },
          getChildByID: function (m) {
            return this.getChildByProperty("id", m);
          },
          getChildByName: function (m) {
            return this.getChildByProperty("name", m);
          },
          setClassName: function (m) {
            this.node && ((this.node.className = m), this.updateSize());
            return this;
          },
          setText: function (m) {
            this.node && ((this.node.innerText = m), this.updateSize());
            return this;
          },
          setHTML: function (m) {
            this.node && ((this.node.innerHTML = m), this.updateSize());
            return this;
          },
          preUpdate: function () {
            var m = this.parentContainer,
              n = this.node;
            n && m && !m.willRender() && (n.style.display = "none");
          },
          willRender: function () {
            return !0;
          },
          preDestroy: function () {
            this.removeElement();
            this.scene.sys.events.off(f.SLEEP, this.handleSceneEvent, this);
            this.scene.sys.events.off(f.WAKE, this.handleSceneEvent, this);
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(1056),
          k = a(15);
        t = a(25);
        var e = new t(),
          b = new t(),
          c = new t();
        h.exports = function (f, g, m, n) {
          if (g.node) {
            f = g.node.style;
            var q = g.scene.sys.settings;
            if (
              !f ||
              !q.visible ||
              k.RENDER_MASK !== g.renderFlags ||
              (0 !== g.cameraFilter && g.cameraFilter & m.id) ||
              (g.parentContainer && !g.parentContainer.willRender())
            )
              f.display = "none";
            else {
              var r = g.parentContainer;
              q = m.alpha * g.alpha;
              r && (q *= r.alpha);
              var u = "0%",
                v = "0%";
              if (n) {
                r = g.width * g.scaleX * g.originX;
                var x = g.height * g.scaleY * g.originY;
                b.applyITRS(g.x - r, g.y - x, g.rotation, g.scaleX, g.scaleY);
                e.copyFrom(m.matrix);
                e.multiplyWithOffset(
                  n,
                  -m.scrollX * g.scrollFactorX,
                  -m.scrollY * g.scrollFactorY
                );
                b.e = g.x - r;
                b.f = g.y - x;
              } else
                (r = g.width * g.originX),
                  (x = g.height * g.originY),
                  b.applyITRS(g.x - r, g.y - x, g.rotation, g.scaleX, g.scaleY),
                  e.copyFrom(m.matrix),
                  (u = 100 * g.originX + "%"),
                  (v = 100 * g.originY + "%"),
                  (b.e -= m.scrollX * g.scrollFactorX),
                  (b.f -= m.scrollY * g.scrollFactorY);
              e.multiply(b, c);
              g.transformOnly ||
                ((f.display = "block"),
                (f.opacity = q),
                (f.zIndex = g._depth),
                (f.pointerEvents = g.pointerEvents),
                (f.mixBlendMode = d[g._blendMode]));
              f.transform =
                c.getCSSMatrix() +
                " skew(" +
                g.skewX +
                "rad, " +
                g.skewY +
                "rad) rotate3d(" +
                g.rotate3d.x +
                "," +
                g.rotate3d.y +
                "," +
                g.rotate3d.z +
                "," +
                g.rotate3d.w +
                g.rotate3dAngle +
                ")";
              f.transformOrigin = u + " " + v;
            }
          }
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(11),
          k = a(15);
        a = a(1060);
        a = new t({
          Extends: k,
          Mixins: [
            d.Alpha,
            d.BlendMode,
            d.Depth,
            d.Flip,
            d.Origin,
            d.ScrollFactor,
            d.Size,
            d.Texture,
            d.Tint,
            d.Transform,
            d.Visible,
            a,
          ],
          initialize: function (e) {
            k.call(this, e, "Extern");
          },
          addedToScene: function () {
            this.scene.sys.updateList.add(this);
          },
          removedFromScene: function () {
            this.scene.sys.updateList.remove(this);
          },
          preUpdate: function () {},
          render: function () {},
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(218),
          k = a(98),
          e = a(14),
          b = a(4);
        h.exports = function (c, f, g) {
          void 0 === g && (g = new b());
          f = k(f, 0, e.PI2);
          return d(c, f, g);
        };
      },
      function (h, t, a) {
        var d = a(447),
          k = a(218),
          e = a(98),
          b = a(14);
        h.exports = function (c, f, g, m) {
          void 0 === m && (m = []);
          !f && 0 < g && (f = d(c) / g);
          for (g = 0; g < f; g++) {
            var n = e(g / f, 0, b.PI2);
            m.push(k(c, n));
          }
          return m;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          var d = a.width / 2;
          a = a.height / 2;
          var k = Math.pow(d - a, 2) / Math.pow(d + a, 2);
          return (
            Math.PI * (d + a) * (1 + (3 * k) / (10 + Math.sqrt(4 - 3 * k)))
          );
        };
      },
      function (h, t, a) {
        var d = a(217),
          k = a(30);
        h.exports = function (e, b, c, f, g, m) {
          var n = b.commandBuffer,
            q = n.length;
          g = g || e.currentContext;
          if (0 !== q && k(e, g, b, c, f)) {
            c.addToRenderList(b);
            g.beginPath();
            for (c = 0; c < q; ++c)
              switch (n[c]) {
                case d.ARC:
                  g.arc(
                    n[c + 1],
                    n[c + 2],
                    n[c + 3],
                    n[c + 4],
                    n[c + 5],
                    n[c + 6]
                  );
                  c += 7;
                  break;
                case d.LINE_STYLE:
                  var r = n[c + 1];
                  var u = n[c + 2];
                  f = n[c + 3];
                  e = (u & 16711680) >>> 16;
                  b = (u & 65280) >>> 8;
                  u &= 255;
                  g.strokeStyle =
                    "rgba(" + e + "," + b + "," + u + "," + f + ")";
                  g.lineWidth = r;
                  c += 3;
                  break;
                case d.FILL_STYLE:
                  r = n[c + 1];
                  f = n[c + 2];
                  e = (r & 16711680) >>> 16;
                  b = (r & 65280) >>> 8;
                  u = r & 255;
                  g.fillStyle = "rgba(" + e + "," + b + "," + u + "," + f + ")";
                  c += 2;
                  break;
                case d.BEGIN_PATH:
                  g.beginPath();
                  break;
                case d.CLOSE_PATH:
                  g.closePath();
                  break;
                case d.FILL_PATH:
                  m || g.fill();
                  break;
                case d.STROKE_PATH:
                  m || g.stroke();
                  break;
                case d.FILL_RECT:
                  m
                    ? g.rect(n[c + 1], n[c + 2], n[c + 3], n[c + 4])
                    : g.fillRect(n[c + 1], n[c + 2], n[c + 3], n[c + 4]);
                  c += 4;
                  break;
                case d.FILL_TRIANGLE:
                  g.beginPath();
                  g.moveTo(n[c + 1], n[c + 2]);
                  g.lineTo(n[c + 3], n[c + 4]);
                  g.lineTo(n[c + 5], n[c + 6]);
                  g.closePath();
                  m || g.fill();
                  c += 6;
                  break;
                case d.STROKE_TRIANGLE:
                  g.beginPath();
                  g.moveTo(n[c + 1], n[c + 2]);
                  g.lineTo(n[c + 3], n[c + 4]);
                  g.lineTo(n[c + 5], n[c + 6]);
                  g.closePath();
                  m || g.stroke();
                  c += 6;
                  break;
                case d.LINE_TO:
                  g.lineTo(n[c + 1], n[c + 2]);
                  c += 2;
                  break;
                case d.MOVE_TO:
                  g.moveTo(n[c + 1], n[c + 2]);
                  c += 2;
                  break;
                case d.LINE_FX_TO:
                  g.lineTo(n[c + 1], n[c + 2]);
                  c += 5;
                  break;
                case d.MOVE_FX_TO:
                  g.moveTo(n[c + 1], n[c + 2]);
                  c += 5;
                  break;
                case d.SAVE:
                  g.save();
                  break;
                case d.RESTORE:
                  g.restore();
                  break;
                case d.TRANSLATE:
                  g.translate(n[c + 1], n[c + 2]);
                  c += 2;
                  break;
                case d.SCALE:
                  g.scale(n[c + 1], n[c + 2]);
                  c += 2;
                  break;
                case d.ROTATE:
                  g.rotate(n[c + 1]);
                  c += 1;
                  break;
                case d.GRADIENT_FILL_STYLE:
                  c += 5;
                  break;
                case d.GRADIENT_LINE_STYLE:
                  c += 6;
              }
            g.restore();
          }
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(137),
          k = a(80),
          e = a(2),
          b = a(68);
        a = new t({
          initialize: function (c, f, g, m) {
            void 0 === m && (m = !1);
            this.propertyKey = f;
            this.defaultValue = this.propertyValue = g;
            this.end = this.start = this.counter = this.steps = 0;
            this.ease;
            this.emitOnly = m;
            this.onEmit = this.defaultEmit;
            this.onUpdate = this.defaultUpdate;
            this.loadConfig(c);
          },
          loadConfig: function (c, f) {
            void 0 === c && (c = {});
            f && (this.propertyKey = f);
            this.propertyValue = e(c, this.propertyKey, this.defaultValue);
            this.setMethods();
            this.emitOnly && (this.onUpdate = this.defaultUpdate);
          },
          toJSON: function () {
            return this.propertyValue;
          },
          onChange: function (c) {
            this.propertyValue = c;
            return this.setMethods();
          },
          setMethods: function () {
            var c = this.propertyValue,
              f = typeof c;
            this.onEmit = this.defaultEmit;
            this.onUpdate = this.defaultUpdate;
            if ("number" === f)
              (this.onEmit = this.staticValueEmit),
                (this.onUpdate = this.staticValueUpdate);
            else if (Array.isArray(c)) this.onEmit = this.randomStaticValueEmit;
            else if ("function" === f)
              this.emitOnly ? (this.onEmit = c) : (this.onUpdate = c);
            else if ("object" === f && this.hasBoth(c, "start", "end")) {
              this.start = c.start;
              this.end = c.end;
              if ((f = this.has(c, "random")))
                this.onEmit = this.randomRangedValueEmit;
              if (this.has(c, "steps"))
                (this.steps = c.steps),
                  (this.counter = this.start),
                  (this.onEmit = this.steppedEmit);
              else {
                var g = this.has(c, "ease") ? c.ease : "Linear";
                this.ease = k(g, c.easeParams);
                f || (this.onEmit = this.easedValueEmit);
                this.onUpdate = this.easeValueUpdate;
              }
            } else
              "object" === f && this.hasBoth(c, "min", "max")
                ? ((this.start = c.min),
                  (this.end = c.max),
                  (this.onEmit = this.randomRangedValueEmit))
                : "object" === f && this.has(c, "random")
                ? ((c = c.random),
                  Array.isArray(c) && ((this.start = c[0]), (this.end = c[1])),
                  (this.onEmit = this.randomRangedValueEmit))
                : "object" === f &&
                  this.hasEither(c, "onEmit", "onUpdate") &&
                  (this.has(c, "onEmit") && (this.onEmit = c.onEmit),
                  this.has(c, "onUpdate") && (this.onUpdate = c.onUpdate));
            return this;
          },
          has: function (c, f) {
            return c.hasOwnProperty(f);
          },
          hasBoth: function (c, f, g) {
            return c.hasOwnProperty(f) && c.hasOwnProperty(g);
          },
          hasEither: function (c, f, g) {
            return c.hasOwnProperty(f) || c.hasOwnProperty(g);
          },
          defaultEmit: function (c, f, g) {
            return g;
          },
          defaultUpdate: function (c, f, g, m) {
            return m;
          },
          staticValueEmit: function () {
            return this.propertyValue;
          },
          staticValueUpdate: function () {
            return this.propertyValue;
          },
          randomStaticValueEmit: function () {
            return this.propertyValue[
              Math.floor(Math.random() * this.propertyValue.length)
            ];
          },
          randomRangedValueEmit: function (c, f) {
            var g = d(this.start, this.end);
            c && c.data[f] && (c.data[f].min = g);
            return g;
          },
          steppedEmit: function () {
            var c = this.counter;
            this.counter = b(
              this.counter + (this.end - this.start) / this.steps,
              this.start,
              this.end
            );
            return c;
          },
          easedValueEmit: function (c, f) {
            c &&
              c.data[f] &&
              ((c = c.data[f]), (c.min = this.start), (c.max = this.end));
            return this.start;
          },
          easeValueUpdate: function (c, f, g) {
            c = c.data[f];
            return (c.max - c.min) * this.ease(g) + c.min;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(2);
        a = new t({
          initialize: function (k, e, b, c, f) {
            "object" === typeof k
              ? ((f = k),
                (k = d(f, "x", 0)),
                (e = d(f, "y", 0)),
                (b = d(f, "power", 0)),
                (c = d(f, "epsilon", 100)),
                (f = d(f, "gravity", 50)))
              : (void 0 === k && (k = 0),
                void 0 === e && (e = 0),
                void 0 === b && (b = 0),
                void 0 === c && (c = 100),
                void 0 === f && (f = 50));
            this.x = k;
            this.y = e;
            this.active = !0;
            this._gravity = f;
            this._epsilon = this._power = 0;
            this.power = b;
            this.epsilon = c;
          },
          update: function (k, e) {
            var b = this.x - k.x,
              c = this.y - k.y,
              f = b * b + c * c;
            if (0 !== f) {
              var g = Math.sqrt(f);
              f < this._epsilon && (f = this._epsilon);
              e = ((this._power * e) / (f * g)) * 100;
              k.velocityX += b * e;
              k.velocityY += c * e;
            }
          },
          epsilon: {
            get: function () {
              return Math.sqrt(this._epsilon);
            },
            set: function (k) {
              this._epsilon = k * k;
            },
          },
          power: {
            get: function () {
              return this._power / this._gravity;
            },
            set: function (k) {
              this._power = k * this._gravity;
            },
          },
          gravity: {
            get: function () {
              return this._gravity;
            },
            set: function (k) {
              var e = this.power;
              this._gravity = k;
              this.power = e;
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(36),
          k = a(50);
        a = new t({
          initialize: function (e) {
            this.emitter = e;
            this.frame = null;
            this.accelerationY =
              this.accelerationX =
              this.velocityY =
              this.velocityX =
              this.y =
              this.x =
                0;
            this.maxVelocityY = this.maxVelocityX = 1e4;
            this.bounce = 0;
            this.alpha = this.scaleY = this.scaleX = 1;
            this.rotation = this.angle = 0;
            this.tint = 16777215;
            this.lifeCurrent = this.life = 1e3;
            this.lifeT = this.delayCurrent = 0;
            this.data = {
              tint: {
                min: 16777215,
                max: 16777215,
                current: 16777215,
              },
              alpha: {
                min: 1,
                max: 1,
              },
              rotate: {
                min: 0,
                max: 0,
              },
              scaleX: {
                min: 1,
                max: 1,
              },
              scaleY: {
                min: 1,
                max: 1,
              },
            };
          },
          isAlive: function () {
            return 0 < this.lifeCurrent;
          },
          resetPosition: function () {
            this.y = this.x = 0;
          },
          fire: function (e, b) {
            var c = this.emitter;
            this.frame = c.getFrame();
            c.emitZone && c.emitZone.getPoint(this);
            this.x = void 0 === e ? this.x + c.x.onEmit(this, "x") : this.x + e;
            this.y = void 0 === b ? this.y + c.y.onEmit(this, "y") : this.y + b;
            this.lifeCurrent = this.life = c.lifespan.onEmit(this, "lifespan");
            this.lifeT = 0;
            e = c.speedX.onEmit(this, "speedX");
            b = c.speedY ? c.speedY.onEmit(this, "speedY") : e;
            if (c.radial) {
              var f = d(c.angle.onEmit(this, "angle"));
              this.velocityX = Math.cos(f) * Math.abs(e);
              this.velocityY = Math.sin(f) * Math.abs(b);
            } else
              c.moveTo
                ? ((b = c.moveToX.onEmit(this, "moveToX")),
                  (f = c.moveToY ? c.moveToY.onEmit(this, "moveToY") : b),
                  (e = Math.atan2(f - this.y, b - this.x)),
                  (b = k(this.x, this.y, b, f) / (this.life / 1e3)),
                  (this.velocityX = Math.cos(e) * b),
                  (this.velocityY = Math.sin(e) * b))
                : ((this.velocityX = e), (this.velocityY = b));
            c.acceleration &&
              ((this.accelerationX = c.accelerationX.onEmit(
                this,
                "accelerationX"
              )),
              (this.accelerationY = c.accelerationY.onEmit(
                this,
                "accelerationY"
              )));
            this.maxVelocityX = c.maxVelocityX.onEmit(this, "maxVelocityX");
            this.maxVelocityY = c.maxVelocityY.onEmit(this, "maxVelocityY");
            this.delayCurrent = c.delay.onEmit(this, "delay");
            this.scaleX = c.scaleX.onEmit(this, "scaleX");
            this.scaleY = c.scaleY
              ? c.scaleY.onEmit(this, "scaleY")
              : this.scaleX;
            this.angle = c.rotate.onEmit(this, "rotate");
            this.rotation = d(this.angle);
            this.bounce = c.bounce.onEmit(this, "bounce");
            this.alpha = c.alpha.onEmit(this, "alpha");
            this.tint = c.tint.onEmit(this, "tint");
          },
          computeVelocity: function (e, b, c, f) {
            var g = this.velocityX,
              m = this.velocityY,
              n = this.accelerationX,
              q = this.accelerationY,
              r = this.maxVelocityX,
              u = this.maxVelocityY;
            g += e.gravityX * c;
            m += e.gravityY * c;
            n && (g += n * c);
            q && (m += q * c);
            g > r ? (g = r) : g < -r && (g = -r);
            m > u ? (m = u) : m < -u && (m = -u);
            this.velocityX = g;
            this.velocityY = m;
            for (e = 0; e < f.length; e++) f[e].update(this, b, c);
          },
          checkBounds: function (e) {
            var b = e.bounds,
              c = -this.bounce;
            this.x < b.x && e.collideLeft
              ? ((this.x = b.x), (this.velocityX *= c))
              : this.x > b.right &&
                e.collideRight &&
                ((this.x = b.right), (this.velocityX *= c));
            this.y < b.y && e.collideTop
              ? ((this.y = b.y), (this.velocityY *= c))
              : this.y > b.bottom &&
                e.collideBottom &&
                ((this.y = b.bottom), (this.velocityY *= c));
          },
          update: function (e, b, c) {
            if (0 < this.delayCurrent) return (this.delayCurrent -= e), !1;
            var f = this.emitter,
              g = 1 - this.lifeCurrent / this.life;
            this.lifeT = g;
            this.computeVelocity(f, e, b, c);
            this.x += this.velocityX * b;
            this.y += this.velocityY * b;
            f.bounds && this.checkBounds(f);
            if (f.deathZone && f.deathZone.willKill(this))
              return (this.lifeCurrent = 0), !0;
            this.scaleX = f.scaleX.onUpdate(this, "scaleX", g, this.scaleX);
            this.scaleY = f.scaleY
              ? f.scaleY.onUpdate(this, "scaleY", g, this.scaleY)
              : this.scaleX;
            this.angle = f.rotate.onUpdate(this, "rotate", g, this.angle);
            this.rotation = d(this.angle);
            this.alpha = f.alpha.onUpdate(this, "alpha", g, this.alpha);
            this.tint = f.tint.onUpdate(this, "tint", g, this.tint);
            this.lifeCurrent -= e;
            return 0 >= this.lifeCurrent;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(35);
        t = a(0);
        var k = a(11),
          e = a(453),
          b = a(454),
          c = a(449),
          f = a(2),
          g = a(210),
          m = a(455),
          n = a(126),
          q = a(451),
          r = a(456),
          u = a(10),
          v = a(79),
          x = a(3),
          y = a(68);
        a = new t({
          Mixins: [k.BlendMode, k.Mask, k.ScrollFactor, k.Visible],
          initialize: function (z, A) {
            this.manager = z;
            this.texture = z.texture;
            this.frames = [z.defaultFrame];
            this.defaultFrame = z.defaultFrame;
            this.configFastMap =
              "active blendMode collideBottom collideLeft collideRight collideTop deathCallback deathCallbackScope emitCallback emitCallbackScope follow frequency gravityX gravityY maxParticles name on particleBringToTop particleClass radial timeScale trackVisible visible".split(
                " "
              );
            this.configOpMap =
              "accelerationX accelerationY angle alpha bounce delay lifespan maxVelocityX maxVelocityY moveToX moveToY quantity rotate scaleX scaleY speedX speedY tint x y".split(
                " "
              );
            this.name = "";
            this.particleClass = q;
            this.x = new c(A, "x", 0, !0);
            this.y = new c(A, "y", 0, !0);
            this.radial = !0;
            this.gravityY = this.gravityX = 0;
            this.acceleration = !1;
            this.accelerationX = new c(A, "accelerationX", 0, !0);
            this.accelerationY = new c(A, "accelerationY", 0, !0);
            this.maxVelocityX = new c(A, "maxVelocityX", 1e4, !0);
            this.maxVelocityY = new c(A, "maxVelocityY", 1e4, !0);
            this.speedX = new c(A, "speedX", 0, !0);
            this.speedY = new c(A, "speedY", 0, !0);
            this.moveTo = !1;
            this.moveToX = new c(A, "moveToX", 0, !0);
            this.moveToY = new c(A, "moveToY", 0, !0);
            this.bounce = new c(A, "bounce", 0, !0);
            this.scaleX = new c(A, "scaleX", 1);
            this.scaleY = new c(A, "scaleY", 1);
            this.tint = new c(A, "tint", 16777215);
            this.alpha = new c(A, "alpha", 1);
            this.lifespan = new c(A, "lifespan", 1e3, !0);
            this.angle = new c(
              A,
              "angle",
              {
                min: 0,
                max: 360,
              },
              !0
            );
            this.rotate = new c(A, "rotate", 0);
            this.deathCallbackScope =
              this.deathCallback =
              this.emitCallbackScope =
              this.emitCallback =
                null;
            this.maxParticles = 0;
            this.quantity = new c(A, "quantity", 1, !0);
            this.delay = new c(A, "delay", 0, !0);
            this.frequency = 0;
            this.particleBringToTop = this.on = !0;
            this.timeScale = 1;
            this.bounds = this.deathZone = this.emitZone = null;
            this.visible =
              this.active =
              this.collideBottom =
              this.collideTop =
              this.collideRight =
              this.collideLeft =
                !0;
            this.blendMode = d.NORMAL;
            this.follow = null;
            this.followOffset = new x();
            this.trackVisible = !1;
            this.currentFrame = 0;
            this.randomFrame = !0;
            this.frameQuantity = 1;
            this.dead = [];
            this.alive = [];
            this._frameCounter = this._counter = 0;
            A && this.fromJSON(A);
          },
          fromJSON: function (z) {
            if (!z) return this;
            var A;
            for (A = 0; A < this.configFastMap.length; A++) {
              var B = this.configFastMap[A];
              n(z, B) && (this[B] = f(z, B));
            }
            for (A = 0; A < this.configOpMap.length; A++)
              (B = this.configOpMap[A]), n(z, B) && this[B].loadConfig(z);
            this.acceleration =
              0 !== this.accelerationX.propertyValue ||
              0 !== this.accelerationY.propertyValue;
            this.moveTo =
              0 !== this.moveToX.propertyValue ||
              0 !== this.moveToY.propertyValue;
            n(z, "speed") &&
              (this.speedX.loadConfig(z, "speed"), (this.speedY = null));
            if (m(z, ["speedX", "speedY"]) || this.moveTo) this.radial = !1;
            n(z, "scale") &&
              (this.scaleX.loadConfig(z, "scale"), (this.scaleY = null));
            n(z, "callbackScope") &&
              (this.deathCallbackScope =
                this.emitCallbackScope =
                A =
                  f(z, "callbackScope", null));
            n(z, "emitZone") && this.setEmitZone(z.emitZone);
            n(z, "deathZone") && this.setDeathZone(z.deathZone);
            n(z, "bounds") && this.setBounds(z.bounds);
            n(z, "followOffset") &&
              this.followOffset.setFromObject(f(z, "followOffset", 0));
            n(z, "frame") && this.setFrame(z.frame);
            n(z, "reserve") && this.reserve(z.reserve);
            return this;
          },
          toJSON: function (z) {
            void 0 === z && (z = {});
            var A;
            for (A = 0; A < this.configFastMap.length; A++) {
              var B = this.configFastMap[A];
              z[B] = this[B];
            }
            for (A = 0; A < this.configOpMap.length; A++)
              (B = this.configOpMap[A]), this[B] && (z[B] = this[B].toJSON());
            this.speedY || (delete z.speedX, (z.speed = this.speedX.toJSON()));
            this.scaleY || (delete z.scaleX, (z.scale = this.scaleX.toJSON()));
            return z;
          },
          startFollow: function (z, A, B, D) {
            void 0 === A && (A = 0);
            void 0 === B && (B = 0);
            void 0 === D && (D = !1);
            this.follow = z;
            this.followOffset.set(A, B);
            this.trackVisible = D;
            return this;
          },
          stopFollow: function () {
            this.follow = null;
            this.followOffset.set(0, 0);
            this.trackVisible = !1;
            return this;
          },
          getFrame: function () {
            if (1 === this.frames.length) return this.defaultFrame;
            if (this.randomFrame) return g(this.frames);
            var z = this.frames[this.currentFrame];
            this._frameCounter++;
            this._frameCounter === this.frameQuantity &&
              ((this._frameCounter = 0),
              (this.currentFrame = y(
                this.currentFrame + 1,
                0,
                this._frameLength
              )));
            return z;
          },
          setFrame: function (z, A, B) {
            void 0 === A && (A = !0);
            void 0 === B && (B = 1);
            this.randomFrame = A;
            this.frameQuantity = B;
            this._frameCounter = this.currentFrame = 0;
            A = typeof z;
            Array.isArray(z) || "string" === A || "number" === A
              ? this.manager.setEmitterFrames(z, this)
              : "object" === A &&
                ((A = z),
                (z = f(A, "frames", null)) &&
                  this.manager.setEmitterFrames(z, this),
                (this.randomFrame = f(A, "cycle", !1) ? !1 : !0),
                (this.frameQuantity = f(A, "quantity", B)));
            this._frameLength = this.frames.length;
            1 === this._frameLength &&
              ((this.frameQuantity = 1), (this.randomFrame = !1));
            return this;
          },
          setRadial: function (z) {
            void 0 === z && (z = !0);
            this.radial = z;
            return this;
          },
          setPosition: function (z, A) {
            this.x.onChange(z);
            this.y.onChange(A);
            return this;
          },
          setBounds: function (z, A, B, D) {
            "object" === typeof z &&
              ((D = z),
              (z = D.x),
              (A = D.y),
              (B = n(D, "w") ? D.w : D.width),
              (D = n(D, "h") ? D.h : D.height));
            this.bounds
              ? this.bounds.setTo(z, A, B, D)
              : (this.bounds = new u(z, A, B, D));
            return this;
          },
          setSpeedX: function (z) {
            this.speedX.onChange(z);
            this.radial = !1;
            return this;
          },
          setSpeedY: function (z) {
            this.speedY && (this.speedY.onChange(z), (this.radial = !1));
            return this;
          },
          setSpeed: function (z) {
            this.speedX.onChange(z);
            this.speedY = null;
            this.radial = !0;
            return this;
          },
          setScaleX: function (z) {
            this.scaleX.onChange(z);
            return this;
          },
          setScaleY: function (z) {
            this.scaleY.onChange(z);
            return this;
          },
          setScale: function (z) {
            this.scaleX.onChange(z);
            this.scaleY = null;
            return this;
          },
          setGravityX: function (z) {
            this.gravityX = z;
            return this;
          },
          setGravityY: function (z) {
            this.gravityY = z;
            return this;
          },
          setGravity: function (z, A) {
            this.gravityX = z;
            this.gravityY = A;
            return this;
          },
          setAlpha: function (z) {
            this.alpha.onChange(z);
            return this;
          },
          setTint: function (z) {
            this.tint.onChange(z);
            return this;
          },
          setEmitterAngle: function (z) {
            this.angle.onChange(z);
            return this;
          },
          setAngle: function (z) {
            this.angle.onChange(z);
            return this;
          },
          setLifespan: function (z) {
            this.lifespan.onChange(z);
            return this;
          },
          setQuantity: function (z) {
            this.quantity.onChange(z);
            return this;
          },
          setFrequency: function (z, A) {
            this.frequency = z;
            this._counter = 0;
            if (A) this.quantity.onChange(A);
            return this;
          },
          setEmitZone: function (z) {
            if (void 0 === z) this.emitZone = null;
            else {
              var A = f(z, "type", "random"),
                B = f(z, "source", null);
              switch (A) {
                case "random":
                  this.emitZone = new r(B);
                  break;
                case "edge":
                  A = f(z, "quantity", 1);
                  var D = f(z, "stepRate", 0),
                    E = f(z, "yoyo", !1);
                  z = f(z, "seamless", !0);
                  this.emitZone = new b(B, A, D, E, z);
              }
            }
            return this;
          },
          setDeathZone: function (z) {
            if (void 0 === z) this.deathZone = null;
            else {
              var A = f(z, "type", "onEnter");
              (z = f(z, "source", null)) &&
                "function" === typeof z.contains &&
                (this.deathZone = new e(z, "onEnter" === A ? !0 : !1));
            }
            return this;
          },
          reserve: function (z) {
            for (var A = this.dead, B = 0; B < z; B++)
              A.push(new this.particleClass(this));
            return this;
          },
          getAliveParticleCount: function () {
            return this.alive.length;
          },
          getDeadParticleCount: function () {
            return this.dead.length;
          },
          getParticleCount: function () {
            return this.getAliveParticleCount() + this.getDeadParticleCount();
          },
          atLimit: function () {
            return (
              0 < this.maxParticles &&
              this.getParticleCount() === this.maxParticles
            );
          },
          onParticleEmit: function (z, A) {
            void 0 === z
              ? (this.emitCallbackScope = this.emitCallback = null)
              : "function" === typeof z &&
                ((this.emitCallback = z), A && (this.emitCallbackScope = A));
            return this;
          },
          onParticleDeath: function (z, A) {
            void 0 === z
              ? (this.deathCallbackScope = this.deathCallback = null)
              : "function" === typeof z &&
                ((this.deathCallback = z), A && (this.deathCallbackScope = A));
            return this;
          },
          killAll: function () {
            for (var z = this.dead, A = this.alive; 0 < A.length; )
              z.push(A.pop());
            return this;
          },
          forEachAlive: function (z, A) {
            for (var B = this.alive, D = B.length, E = 0; E < D; ++E)
              z.call(A, B[E], this);
            return this;
          },
          forEachDead: function (z, A) {
            for (var B = this.dead, D = B.length, E = 0; E < D; ++E)
              z.call(A, B[E], this);
            return this;
          },
          start: function () {
            this.on = !0;
            this._counter = 0;
            return this;
          },
          stop: function () {
            this.on = !1;
            return this;
          },
          pause: function () {
            this.active = !1;
            return this;
          },
          resume: function () {
            this.active = !0;
            return this;
          },
          remove: function () {
            this.manager.removeEmitter(this);
            return this;
          },
          depthSort: function () {
            v(this.alive, this.depthSortCallback);
            return this;
          },
          flow: function (z, A) {
            void 0 === A && (A = 1);
            this.frequency = z;
            this.quantity.onChange(A);
            return this.start();
          },
          explode: function (z, A, B) {
            this.frequency = -1;
            return this.emitParticle(z, A, B);
          },
          emitParticleAt: function (z, A, B) {
            return this.emitParticle(B, z, A);
          },
          emitParticle: function (z, A, B) {
            if (!this.atLimit()) {
              void 0 === z && (z = this.quantity.onEmit());
              var D = this.dead;
              A = this.follow ? this.follow.x + this.followOffset.x : A;
              B = this.follow ? this.follow.y + this.followOffset.y : B;
              for (var E = 0; E < z; E++) {
                var C = D.pop();
                C || (C = new this.particleClass(this));
                C.fire(A, B);
                this.particleBringToTop
                  ? this.alive.push(C)
                  : this.alive.unshift(C);
                this.emitCallback &&
                  this.emitCallback.call(this.emitCallbackScope, C, this);
                if (this.atLimit()) break;
              }
              return C;
            }
          },
          preUpdate: function (z, A) {
            A *= this.timeScale;
            var B = A / 1e3;
            this.trackVisible && (this.visible = this.follow.visible);
            var D = this.manager.getProcessors();
            z = this.alive;
            var E = this.dead,
              C,
              F = [],
              G = z.length;
            for (C = 0; C < G; C++) {
              var H = z[C];
              H.update(A, B, D) &&
                F.push({
                  index: C,
                  particle: H,
                });
            }
            G = F.length;
            if (0 < G)
              for (
                B = this.deathCallback, D = this.deathCallbackScope, C = G - 1;
                0 <= C;
                C--
              )
                (G = F[C]),
                  z.splice(G.index, 1),
                  E.push(G.particle),
                  B && B.call(D, G.particle),
                  G.particle.resetPosition();
            this.on &&
              (0 === this.frequency
                ? this.emitParticle()
                : 0 < this.frequency &&
                  ((this._counter -= A),
                  0 >= this._counter &&
                    (this.emitParticle(),
                    (this._counter =
                      this.frequency - Math.abs(this._counter)))));
          },
          depthSortCallback: function (z, A) {
            return z.y - A.y;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = new (a(0))({
          initialize: function (d, k) {
            this.source = d;
            this.killOnEnter = k;
          },
          willKill: function (d) {
            return (
              ((d = this.source.contains(d.x, d.y)) && this.killOnEnter) ||
              (!d && !this.killOnEnter)
            );
          },
        });
        h.exports = t;
      },
      function (h, t, a) {
        t = new (a(0))({
          initialize: function (d, k, e, b, c) {
            void 0 === b && (b = !1);
            void 0 === c && (c = !0);
            this.source = d;
            this.points = [];
            this.quantity = k;
            this.stepRate = e;
            this.yoyo = b;
            this.counter = -1;
            this.seamless = c;
            this._direction = this._length = 0;
            this.updateSource();
          },
          updateSource: function () {
            this.points = this.source.getPoints(this.quantity, this.stepRate);
            if (this.seamless) {
              var d = this.points[0],
                k = this.points[this.points.length - 1];
              d.x === k.x && d.y === k.y && this.points.pop();
            }
            d = this._length;
            this._length = this.points.length;
            this._length < d &&
              this.counter > this._length &&
              (this.counter = this._length - 1);
            return this;
          },
          changeSource: function (d) {
            this.source = d;
            return this.updateSource();
          },
          getPoint: function (d) {
            0 === this._direction
              ? (this.counter++,
                this.counter >= this._length &&
                  (this.yoyo
                    ? ((this._direction = 1), (this.counter = this._length - 1))
                    : (this.counter = 0)))
              : (this.counter--,
                -1 === this.counter &&
                  (this.counter = this.yoyo
                    ? (this._direction = 0)
                    : this._length - 1));
            var k = this.points[this.counter];
            k && ((d.x = k.x), (d.y = k.y));
          },
        });
        h.exports = t;
      },
      function (h, t) {
        h.exports = function (a, d) {
          for (var k = 0; k < d.length; k++)
            if (a.hasOwnProperty(d[k])) return !0;
          return !1;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(3);
        a = new t({
          initialize: function (k) {
            this.source = k;
            this._tempVec = new d();
          },
          getPoint: function (k) {
            var e = this._tempVec;
            this.source.getRandomPoint(e);
            k.x = e.x;
            k.y = e.y;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(11),
          k = a(73);
        a = new t({
          Extends: k,
          Mixins: [d.PathFollower],
          initialize: function (e, b, c, f, g, m) {
            k.call(this, e, c, f, g, m);
            this.path = b;
          },
          preUpdate: function (e, b) {
            this.anims.update(e, b);
            this.pathUpdate(e);
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          var e = a.canvas,
            b = a.context,
            c = a.style,
            f = [],
            g = 0,
            m = k.length;
          0 < c.maxLines && c.maxLines < k.length && (m = c.maxLines);
          c.syncFont(e, b);
          for (e = 0; e < m; e++) {
            var n = c.strokeThickness;
            n += b.measureText(k[e]).width;
            c.wordWrap && (n -= b.measureText(" ").width);
            f[e] = Math.ceil(n);
            g = Math.max(g, f[e]);
          }
          d = d.fontSize + c.strokeThickness;
          k = d * m;
          a = a.lineSpacing;
          1 < m && (k += a * (m - 1));
          return {
            width: g,
            height: k,
            lines: m,
            lineWidths: f,
            lineSpacing: a,
            lineHeight: d,
          };
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(13),
          k = a(6),
          e = a(460),
          b = {
            fontFamily: ["fontFamily", "Courier"],
            fontSize: ["fontSize", "16px"],
            fontStyle: ["fontStyle", ""],
            backgroundColor: ["backgroundColor", null],
            color: ["color", "#fff"],
            stroke: ["stroke", "#fff"],
            strokeThickness: ["strokeThickness", 0],
            shadowOffsetX: ["shadow.offsetX", 0],
            shadowOffsetY: ["shadow.offsetY", 0],
            shadowColor: ["shadow.color", "#000"],
            shadowBlur: ["shadow.blur", 0],
            shadowStroke: ["shadow.stroke", !1],
            shadowFill: ["shadow.fill", !1],
            align: ["align", "left"],
            maxLines: ["maxLines", 0],
            fixedWidth: ["fixedWidth", 0],
            fixedHeight: ["fixedHeight", 0],
            resolution: ["resolution", 0],
            rtl: ["rtl", !1],
            testString: ["testString", "|M\u00c3\u2030qgy"],
            baselineX: ["baselineX", 1.2],
            baselineY: ["baselineY", 1.4],
            wordWrapWidth: ["wordWrap.width", null],
            wordWrapCallback: ["wordWrap.callback", null],
            wordWrapCallbackScope: ["wordWrap.callbackScope", null],
            wordWrapUseAdvanced: ["wordWrap.useAdvancedWrap", !1],
          };
        a = new t({
          initialize: function (c, f) {
            this.parent = c;
            this.fontFamily;
            this.fontSize;
            this.fontStyle;
            this.backgroundColor;
            this.color;
            this.stroke;
            this.strokeThickness;
            this.shadowOffsetX;
            this.shadowOffsetY;
            this.shadowColor;
            this.shadowBlur;
            this.shadowStroke;
            this.shadowFill;
            this.align;
            this.maxLines;
            this.fixedWidth;
            this.fixedHeight;
            this.resolution;
            this.rtl;
            this.testString;
            this.baselineX;
            this.baselineY;
            this.wordWrapWidth;
            this.wordWrapCallback;
            this.wordWrapCallbackScope;
            this.wordWrapUseAdvanced;
            this._font;
            this.setStyle(f, !1, !0);
            this.metrics = (c = k(f, "metrics", !1))
              ? {
                  ascent: k(c, "ascent", 0),
                  descent: k(c, "descent", 0),
                  fontSize: k(c, "fontSize", 0),
                }
              : e(this);
          },
          setStyle: function (c, f, g) {
            void 0 === f && (f = !0);
            void 0 === g && (g = !1);
            c &&
              c.hasOwnProperty("fontSize") &&
              "number" === typeof c.fontSize &&
              (c.fontSize = c.fontSize.toString() + "px");
            for (var m in b) {
              var n = g ? b[m][1] : this[m];
              this[m] =
                "wordWrapCallback" === m || "wordWrapCallbackScope" === m
                  ? k(c, b[m][0], n)
                  : d(c, b[m][0], n);
            }
            g = k(c, "font", null);
            null !== g && this.setFont(g, !1);
            this._font = [this.fontStyle, this.fontSize, this.fontFamily]
              .join(" ")
              .trim();
            c = k(c, "fill", null);
            null !== c && (this.color = c);
            return f ? this.update(!0) : this.parent;
          },
          syncFont: function (c, f) {
            f.font = this._font;
          },
          syncStyle: function (c, f) {
            f.textBaseline = "alphabetic";
            f.fillStyle = this.color;
            f.strokeStyle = this.stroke;
            f.lineWidth = this.strokeThickness;
            f.lineCap = "round";
            f.lineJoin = "round";
          },
          syncShadow: function (c, f) {
            f
              ? ((c.shadowOffsetX = this.shadowOffsetX),
                (c.shadowOffsetY = this.shadowOffsetY),
                (c.shadowColor = this.shadowColor),
                (c.shadowBlur = this.shadowBlur))
              : ((c.shadowOffsetX = 0),
                (c.shadowOffsetY = 0),
                (c.shadowColor = 0),
                (c.shadowBlur = 0));
          },
          update: function (c) {
            c &&
              ((this._font = [this.fontStyle, this.fontSize, this.fontFamily]
                .join(" ")
                .trim()),
              (this.metrics = e(this)));
            return this.parent.updateText();
          },
          setFont: function (c, f) {
            void 0 === f && (f = !0);
            if ("string" !== typeof c) {
              var g = k(c, "fontFamily", "Courier");
              var m = k(c, "fontSize", "16px");
              c = k(c, "fontStyle", "");
            } else {
              g = c.split(" ");
              var n = 0;
              c = 2 < g.length ? g[n++] : "";
              m = g[n++] || "16px";
              g = g[n++] || "Courier";
            }
            if (
              g !== this.fontFamily ||
              m !== this.fontSize ||
              c !== this.fontStyle
            )
              (this.fontFamily = g),
                (this.fontSize = m),
                (this.fontStyle = c),
                f && this.update(!0);
            return this.parent;
          },
          setFontFamily: function (c) {
            this.fontFamily !== c && ((this.fontFamily = c), this.update(!0));
            return this.parent;
          },
          setFontStyle: function (c) {
            this.fontStyle !== c && ((this.fontStyle = c), this.update(!0));
            return this.parent;
          },
          setFontSize: function (c) {
            "number" === typeof c && (c = c.toString() + "px");
            this.fontSize !== c && ((this.fontSize = c), this.update(!0));
            return this.parent;
          },
          setTestString: function (c) {
            this.testString = c;
            return this.update(!0);
          },
          setFixedSize: function (c, f) {
            this.fixedWidth = c;
            this.fixedHeight = f;
            c && (this.parent.width = c);
            f && (this.parent.height = f);
            return this.update(!1);
          },
          setBackgroundColor: function (c) {
            this.backgroundColor = c;
            return this.update(!1);
          },
          setFill: function (c) {
            this.color = c;
            return this.update(!1);
          },
          setColor: function (c) {
            this.color = c;
            return this.update(!1);
          },
          setResolution: function (c) {
            this.resolution = c;
            return this.update(!1);
          },
          setStroke: function (c, f) {
            void 0 === f && (f = this.strokeThickness);
            if (void 0 === c && 0 !== this.strokeThickness)
              (this.strokeThickness = 0), this.update(!0);
            else if (this.stroke !== c || this.strokeThickness !== f)
              (this.stroke = c), (this.strokeThickness = f), this.update(!0);
            return this.parent;
          },
          setShadow: function (c, f, g, m, n, q) {
            void 0 === c && (c = 0);
            void 0 === f && (f = 0);
            void 0 === g && (g = "#000");
            void 0 === m && (m = 0);
            void 0 === n && (n = !1);
            void 0 === q && (q = !0);
            this.shadowOffsetX = c;
            this.shadowOffsetY = f;
            this.shadowColor = g;
            this.shadowBlur = m;
            this.shadowStroke = n;
            this.shadowFill = q;
            return this.update(!1);
          },
          setShadowOffset: function (c, f) {
            void 0 === c && (c = 0);
            void 0 === f && (f = c);
            this.shadowOffsetX = c;
            this.shadowOffsetY = f;
            return this.update(!1);
          },
          setShadowColor: function (c) {
            void 0 === c && (c = "#000");
            this.shadowColor = c;
            return this.update(!1);
          },
          setShadowBlur: function (c) {
            void 0 === c && (c = 0);
            this.shadowBlur = c;
            return this.update(!1);
          },
          setShadowStroke: function (c) {
            this.shadowStroke = c;
            return this.update(!1);
          },
          setShadowFill: function (c) {
            this.shadowFill = c;
            return this.update(!1);
          },
          setWordWrapWidth: function (c, f) {
            void 0 === f && (f = !1);
            this.wordWrapWidth = c;
            this.wordWrapUseAdvanced = f;
            return this.update(!1);
          },
          setWordWrapCallback: function (c, f) {
            void 0 === f && (f = null);
            this.wordWrapCallback = c;
            this.wordWrapCallbackScope = f;
            return this.update(!1);
          },
          setAlign: function (c) {
            void 0 === c && (c = "left");
            this.align = c;
            return this.update(!1);
          },
          setMaxLines: function (c) {
            void 0 === c && (c = 0);
            this.maxLines = c;
            return this.update(!1);
          },
          getTextMetrics: function () {
            var c = this.metrics;
            return {
              ascent: c.ascent,
              descent: c.descent,
              fontSize: c.fontSize,
            };
          },
          toJSON: function () {
            var c = {},
              f;
            for (f in b) c[f] = this[f];
            c.metrics = this.getTextMetrics();
            return c;
          },
          destroy: function () {
            this.parent = void 0;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(31);
        h.exports = function (k) {
          var e = d.create(this),
            b = e.getContext("2d");
          k.syncFont(e, b);
          var c = b.measureText(k.testString);
          if ("actualBoundingBoxAscent" in c) {
            var f = c.actualBoundingBoxAscent;
            c = c.actualBoundingBoxDescent;
            d.remove(e);
            return {
              ascent: f,
              descent: c,
              fontSize: f + c,
            };
          }
          var g = Math.ceil(c.width * k.baselineX);
          c = g;
          f = 2 * c;
          c = (c * k.baselineY) | 0;
          e.width = g;
          e.height = f;
          b.fillStyle = "#f00";
          b.fillRect(0, 0, g, f);
          b.font = k._font;
          b.textBaseline = "alphabetic";
          b.fillStyle = "#000";
          b.fillText(k.testString, 0, c);
          k = {
            ascent: 0,
            descent: 0,
            fontSize: 0,
          };
          b = b.getImageData(0, 0, g, f);
          if (!b)
            return (
              (k.ascent = c),
              (k.descent = c + 6),
              (k.fontSize = k.ascent + k.descent),
              d.remove(e),
              k
            );
          b = b.data;
          var m = b.length;
          g *= 4;
          var n,
            q,
            r = 0,
            u = !1;
          for (n = 0; n < c; n++) {
            for (q = 0; q < g; q += 4)
              if (255 !== b[r + q]) {
                u = !0;
                break;
              }
            if (u) break;
            else r += g;
          }
          k.ascent = c - n;
          r = m - g;
          u = !1;
          for (n = f; n > c; n--) {
            for (q = 0; q < g; q += 4)
              if (255 !== b[r + q]) {
                u = !0;
                break;
              }
            if (u) break;
            else r -= g;
          }
          k.descent = n - c;
          k.fontSize = k.ascent + k.descent;
          d.remove(e);
          return k;
        };
      },
      function (h, t, a) {
        t = a(1097);
        var d = a(0),
          k = a(36),
          e = a(59),
          b = a(65),
          c = a(14),
          f = a(34);
        a = new d({
          Extends: f,
          Mixins: [t],
          initialize: function (g, m, n, q, r, u, v, x, y) {
            void 0 === m && (m = 0);
            void 0 === n && (n = 0);
            void 0 === q && (q = 128);
            void 0 === r && (r = 0);
            void 0 === u && (u = 360);
            void 0 === v && (v = !1);
            f.call(this, g, "Arc", new b(0, 0, q));
            this._startAngle = r;
            this._endAngle = u;
            this._anticlockwise = v;
            this._iterations = 0.01;
            this.setPosition(m, n);
            g = 2 * this.geom.radius;
            this.setSize(g, g);
            void 0 !== x && this.setFillStyle(x, y);
            this.updateDisplayOrigin();
            this.updateData();
          },
          iterations: {
            get: function () {
              return this._iterations;
            },
            set: function (g) {
              this._iterations = g;
              this.updateData();
            },
          },
          radius: {
            get: function () {
              return this.geom.radius;
            },
            set: function (g) {
              this.geom.radius = g;
              g *= 2;
              this.setSize(g, g);
              this.updateDisplayOrigin();
              this.updateData();
            },
          },
          startAngle: {
            get: function () {
              return this._startAngle;
            },
            set: function (g) {
              this._startAngle = g;
              this.updateData();
            },
          },
          endAngle: {
            get: function () {
              return this._endAngle;
            },
            set: function (g) {
              this._endAngle = g;
              this.updateData();
            },
          },
          anticlockwise: {
            get: function () {
              return this._anticlockwise;
            },
            set: function (g) {
              this._anticlockwise = g;
              this.updateData();
            },
          },
          setRadius: function (g) {
            this.radius = g;
            return this;
          },
          setIterations: function (g) {
            void 0 === g && (g = 0.01);
            this.iterations = g;
            return this;
          },
          setStartAngle: function (g, m) {
            this._startAngle = g;
            void 0 !== m && (this._anticlockwise = m);
            return this.updateData();
          },
          setEndAngle: function (g, m) {
            this._endAngle = g;
            void 0 !== m && (this._anticlockwise = m);
            return this.updateData();
          },
          updateData: function () {
            var g = this._iterations,
              m = g,
              n = this.geom.radius,
              q = k(this._startAngle),
              r = k(this._endAngle),
              u = this._anticlockwise;
            r -= q;
            u
              ? r < -c.PI2
                ? (r = -c.PI2)
                : 0 < r && (r = -c.PI2 + (r % c.PI2))
              : r > c.PI2
              ? (r = c.PI2)
              : 0 > r && (r = c.PI2 + (r % c.PI2));
            u = [n + Math.cos(q) * n, n + Math.sin(q) * n];
            for (var v; 1 > m; )
              (v = r * m + q),
                u.push(n + Math.cos(v) * n, n + Math.sin(v) * n),
                (m += g);
            v = r + q;
            u.push(n + Math.cos(v) * n, n + Math.sin(v) * n);
            u.push(n + Math.cos(q) * n, n + Math.sin(q) * n);
            this.pathIndexes = e(u);
            this.pathData = u;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(1100),
          k = a(59),
          e = a(10),
          b = a(34);
        a = new t({
          Extends: b,
          Mixins: [d],
          initialize: function (c, f, g, m, n, q) {
            void 0 === f && (f = 0);
            void 0 === g && (g = 0);
            b.call(this, c, "Curve", m);
            this._smoothness = 32;
            this._curveBounds = new e();
            this.closePath = !1;
            this.setPosition(f, g);
            void 0 !== n && this.setFillStyle(n, q);
            this.updateData();
          },
          smoothness: {
            get: function () {
              return this._smoothness;
            },
            set: function (c) {
              this._smoothness = c;
              this.updateData();
            },
          },
          setSmoothness: function (c) {
            this._smoothness = c;
            return this.updateData();
          },
          updateData: function () {
            var c = this._curveBounds,
              f = this._smoothness;
            this.geom.getBounds(c, f);
            this.setSize(c.width, c.height);
            this.updateDisplayOrigin();
            c = [];
            f = this.geom.getPoints(f);
            for (var g = 0; g < f.length; g++) c.push(f[g].x, f[g].y);
            c.push(f[0].x, f[0].y);
            this.pathIndexes = k(c);
            this.pathData = c;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(59),
          k = a(1103),
          e = a(111),
          b = a(34);
        a = new t({
          Extends: b,
          Mixins: [k],
          initialize: function (c, f, g, m, n, q, r) {
            void 0 === f && (f = 0);
            void 0 === g && (g = 0);
            void 0 === m && (m = 128);
            void 0 === n && (n = 128);
            b.call(this, c, "Ellipse", new e(m / 2, n / 2, m, n));
            this._smoothness = 64;
            this.setPosition(f, g);
            this.width = m;
            this.height = n;
            void 0 !== q && this.setFillStyle(q, r);
            this.updateDisplayOrigin();
            this.updateData();
          },
          smoothness: {
            get: function () {
              return this._smoothness;
            },
            set: function (c) {
              this._smoothness = c;
              this.updateData();
            },
          },
          setSize: function (c, f) {
            this.width = c;
            this.height = f;
            this.geom.setPosition(c / 2, f / 2);
            this.geom.setSize(c, f);
            return this.updateData();
          },
          setSmoothness: function (c) {
            this._smoothness = c;
            return this.updateData();
          },
          updateData: function () {
            for (
              var c = [], f = this.geom.getPoints(this._smoothness), g = 0;
              g < f.length;
              g++
            )
              c.push(f[g].x, f[g].y);
            c.push(f[0].x, f[0].y);
            this.pathIndexes = d(c);
            this.pathData = c;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(34);
        a = a(1106);
        a = new t({
          Extends: d,
          Mixins: [a],
          initialize: function (k, e, b, c, f, g, m, n, q, r, u) {
            void 0 === e && (e = 0);
            void 0 === b && (b = 0);
            void 0 === c && (c = 128);
            void 0 === f && (f = 128);
            void 0 === g && (g = 32);
            void 0 === m && (m = 32);
            d.call(this, k, "Grid", null);
            this.cellWidth = g;
            this.cellHeight = m;
            this.showCells = !0;
            this.outlineFillAlpha = this.outlineFillColor = 0;
            this.showOutline = !0;
            this.showAltCells = !1;
            this.altFillColor;
            this.altFillAlpha;
            this.setPosition(e, b);
            this.setSize(c, f);
            this.setFillStyle(n, q);
            void 0 !== r && this.setOutlineStyle(r, u);
            this.updateDisplayOrigin();
          },
          setFillStyle: function (k, e) {
            void 0 === e && (e = 1);
            void 0 === k
              ? (this.showCells = !1)
              : ((this.fillColor = k),
                (this.fillAlpha = e),
                (this.showCells = !0));
            return this;
          },
          setAltFillStyle: function (k, e) {
            void 0 === e && (e = 1);
            void 0 === k
              ? (this.showAltCells = !1)
              : ((this.altFillColor = k),
                (this.altFillAlpha = e),
                (this.showAltCells = !0));
            return this;
          },
          setOutlineStyle: function (k, e) {
            void 0 === e && (e = 1);
            void 0 === k
              ? (this.showOutline = !1)
              : ((this.outlineFillColor = k),
                (this.outlineFillAlpha = e),
                (this.showOutline = !0));
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(1109);
        var d = a(0),
          k = a(34);
        a = new d({
          Extends: k,
          Mixins: [t],
          initialize: function (e, b, c, f, g, m, n, q) {
            void 0 === b && (b = 0);
            void 0 === c && (c = 0);
            void 0 === f && (f = 48);
            void 0 === g && (g = 32);
            void 0 === m && (m = 15658734);
            void 0 === n && (n = 10066329);
            void 0 === q && (q = 13421772);
            k.call(this, e, "IsoBox", null);
            this.projection = 4;
            this.fillTop = m;
            this.fillLeft = n;
            this.fillRight = q;
            this.isFilled = this.showRight = this.showLeft = this.showTop = !0;
            this.setPosition(b, c);
            this.setSize(f, g);
            this.updateDisplayOrigin();
          },
          setProjection: function (e) {
            this.projection = e;
            return this;
          },
          setFaces: function (e, b, c) {
            void 0 === e && (e = !0);
            void 0 === b && (b = !0);
            void 0 === c && (c = !0);
            this.showTop = e;
            this.showLeft = b;
            this.showRight = c;
            return this;
          },
          setFillStyle: function (e, b, c) {
            this.fillTop = e;
            this.fillLeft = b;
            this.fillRight = c;
            this.isFilled = !0;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(1112),
          k = a(34);
        a = new t({
          Extends: k,
          Mixins: [d],
          initialize: function (e, b, c, f, g, m, n, q, r) {
            void 0 === b && (b = 0);
            void 0 === c && (c = 0);
            void 0 === f && (f = 48);
            void 0 === g && (g = 32);
            void 0 === m && (m = !1);
            void 0 === n && (n = 15658734);
            void 0 === q && (q = 10066329);
            void 0 === r && (r = 13421772);
            k.call(this, e, "IsoTriangle", null);
            this.projection = 4;
            this.fillTop = n;
            this.fillLeft = q;
            this.fillRight = r;
            this.showRight = this.showLeft = this.showTop = !0;
            this.isReversed = m;
            this.isFilled = !0;
            this.setPosition(b, c);
            this.setSize(f, g);
            this.updateDisplayOrigin();
          },
          setProjection: function (e) {
            this.projection = e;
            return this;
          },
          setReversed: function (e) {
            this.isReversed = e;
            return this;
          },
          setFaces: function (e, b, c) {
            void 0 === e && (e = !0);
            void 0 === b && (b = !0);
            void 0 === c && (c = !0);
            this.showTop = e;
            this.showLeft = b;
            this.showRight = c;
            return this;
          },
          setFillStyle: function (e, b, c) {
            this.fillTop = e;
            this.fillLeft = b;
            this.fillRight = c;
            this.isFilled = !0;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(34),
          k = a(47);
        a = a(1115);
        a = new t({
          Extends: d,
          Mixins: [a],
          initialize: function (e, b, c, f, g, m, n, q, r) {
            void 0 === b && (b = 0);
            void 0 === c && (c = 0);
            void 0 === f && (f = 0);
            void 0 === g && (g = 0);
            void 0 === m && (m = 128);
            void 0 === n && (n = 0);
            d.call(this, e, "Line", new k(f, g, m, n));
            e = Math.max(1, this.geom.right - this.geom.left);
            f = Math.max(1, this.geom.bottom - this.geom.top);
            this._endWidth = this._startWidth = this.lineWidth = 1;
            this.setPosition(b, c);
            this.setSize(e, f);
            void 0 !== q && this.setStrokeStyle(1, q, r);
            this.updateDisplayOrigin();
          },
          setLineWidth: function (e, b) {
            void 0 === b && (b = e);
            this._startWidth = e;
            this._endWidth = b;
            this.lineWidth = e;
            return this;
          },
          setTo: function (e, b, c, f) {
            this.geom.setTo(e, b, c, f);
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(1118);
        var d = a(0),
          k = a(59),
          e = a(469),
          b = a(227),
          c = a(34),
          f = a(472);
        a = new d({
          Extends: c,
          Mixins: [t],
          initialize: function (g, m, n, q, r, u) {
            void 0 === m && (m = 0);
            void 0 === n && (n = 0);
            c.call(this, g, "Polygon", new b(q));
            g = e(this.geom);
            this.setPosition(m, n);
            this.setSize(g.width, g.height);
            void 0 !== r && this.setFillStyle(r, u);
            this.updateDisplayOrigin();
            this.updateData();
          },
          smooth: function (g) {
            void 0 === g && (g = 1);
            for (var m = 0; m < g; m++) f(this.geom);
            return this.updateData();
          },
          updateData: function () {
            for (var g = [], m = this.geom.points, n = 0; n < m.length; n++)
              g.push(m[n].x, m[n].y);
            g.push(m[0].x, m[0].y);
            this.pathIndexes = k(g);
            this.pathData = g;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(10);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          for (
            var b = Infinity, c = Infinity, f = -b, g = -c, m, n = 0;
            n < k.points.length;
            n++
          )
            (m = k.points[n]),
              (b = Math.min(b, m.x)),
              (c = Math.min(c, m.y)),
              (f = Math.max(f, m.x)),
              (g = Math.max(g, m.y));
          e.x = b;
          e.y = c;
          e.width = f - b;
          e.height = g - c;
          return e;
        };
      },
      function (h, t, a) {
        var d = a(67),
          k = a(47),
          e = a(471);
        h.exports = function (b, c, f, g) {
          void 0 === g && (g = []);
          var m = b.points;
          b = e(b);
          !c && 0 < f && (c = b / f);
          for (f = 0; f < c; f++)
            for (var n = (f / c) * b, q = 0, r = 0; r < m.length; r++) {
              var u = m[r],
                v = m[(r + 1) % m.length];
              u = new k(u.x, u.y, v.x, v.y);
              v = d(u);
              if (n < q || n > q + v) q += v;
              else {
                n = u.getPoint((n - q) / v);
                g.push(n);
                break;
              }
            }
          return g;
        };
      },
      function (h, t, a) {
        var d = a(67),
          k = a(47);
        h.exports = function (e) {
          e = e.points;
          for (var b = 0, c = 0; c < e.length; c++) {
            var f = e[c],
              g = e[(c + 1) % e.length];
            f = new k(f.x, f.y, g.x, g.y);
            b += d(f);
          }
          return b;
        };
      },
      function (h, t) {
        var a = function (d, k) {
          d[0] = k[0];
          d[1] = k[1];
          return d;
        };
        h.exports = function (d) {
          var k,
            e = [],
            b = d.points;
          for (k = 0; k < b.length; k++) e.push([b[k].x, b[k].y]);
          b = [];
          0 < e.length && b.push(a([0, 0], e[0]));
          for (k = 0; k < e.length - 1; k++) {
            var c = e[k],
              f = e[k + 1],
              g = c[0];
            c = c[1];
            var m = f[0];
            f = f[1];
            b.push([0.85 * g + 0.15 * m, 0.85 * c + 0.15 * f]);
            b.push([0.15 * g + 0.85 * m, 0.15 * c + 0.85 * f]);
          }
          1 < e.length && b.push(a([0, 0], e[e.length - 1]));
          return d.setTo(b);
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(10),
          k = a(34);
        a = a(1121);
        a = new t({
          Extends: k,
          Mixins: [a],
          initialize: function (e, b, c, f, g, m, n) {
            void 0 === b && (b = 0);
            void 0 === c && (c = 0);
            void 0 === f && (f = 128);
            void 0 === g && (g = 128);
            k.call(this, e, "Rectangle", new d(0, 0, f, g));
            this.setPosition(b, c);
            this.setSize(f, g);
            void 0 !== m && this.setFillStyle(m, n);
            this.updateDisplayOrigin();
            this.updateData();
          },
          setSize: function (e, b) {
            this.width = e;
            this.height = b;
            this.geom.setSize(e, b);
            this.updateData();
            return this;
          },
          updateData: function () {
            var e = [],
              b = this.geom,
              c = this._tempLine;
            b.getLineA(c);
            e.push(c.x1, c.y1, c.x2, c.y2);
            b.getLineB(c);
            e.push(c.x2, c.y2);
            b.getLineC(c);
            e.push(c.x2, c.y2);
            b.getLineD(c);
            e.push(c.x2, c.y2);
            this.pathData = e;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(1124);
        var d = a(0),
          k = a(59),
          e = a(34);
        a = new d({
          Extends: e,
          Mixins: [t],
          initialize: function (b, c, f, g, m, n, q, r) {
            void 0 === c && (c = 0);
            void 0 === f && (f = 0);
            void 0 === g && (g = 5);
            void 0 === m && (m = 32);
            void 0 === n && (n = 64);
            e.call(this, b, "Star", null);
            this._points = g;
            this._innerRadius = m;
            this._outerRadius = n;
            this.setPosition(c, f);
            this.setSize(2 * n, 2 * n);
            void 0 !== q && this.setFillStyle(q, r);
            this.updateDisplayOrigin();
            this.updateData();
          },
          setPoints: function (b) {
            this._points = b;
            return this.updateData();
          },
          setInnerRadius: function (b) {
            this._innerRadius = b;
            return this.updateData();
          },
          setOuterRadius: function (b) {
            this._outerRadius = b;
            return this.updateData();
          },
          points: {
            get: function () {
              return this._points;
            },
            set: function (b) {
              this._points = b;
              this.updateData();
            },
          },
          innerRadius: {
            get: function () {
              return this._innerRadius;
            },
            set: function (b) {
              this._innerRadius = b;
              this.updateData();
            },
          },
          outerRadius: {
            get: function () {
              return this._outerRadius;
            },
            set: function (b) {
              this._outerRadius = b;
              this.updateData();
            },
          },
          updateData: function () {
            var b = [],
              c = this._points,
              f = this._innerRadius,
              g = this._outerRadius,
              m = (Math.PI / 2) * 3,
              n = Math.PI / c;
            b.push(g, g + -g);
            for (var q = 0; q < c; q++)
              b.push(g + Math.cos(m) * g, g + Math.sin(m) * g),
                (m += n),
                b.push(g + Math.cos(m) * f, g + Math.sin(m) * f),
                (m += n);
            b.push(g, g + -g);
            this.pathIndexes = k(b);
            this.pathData = b;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(34),
          k = a(82);
        a = a(1127);
        a = new t({
          Extends: d,
          Mixins: [a],
          initialize: function (e, b, c, f, g, m, n, q, r, u, v) {
            void 0 === b && (b = 0);
            void 0 === c && (c = 0);
            void 0 === f && (f = 0);
            void 0 === g && (g = 128);
            void 0 === m && (m = 64);
            void 0 === n && (n = 0);
            void 0 === q && (q = 128);
            void 0 === r && (r = 128);
            d.call(this, e, "Triangle", new k(f, g, m, n, q, r));
            e = this.geom.right - this.geom.left;
            f = this.geom.bottom - this.geom.top;
            this.setPosition(b, c);
            this.setSize(e, f);
            void 0 !== u && this.setFillStyle(u, v);
            this.updateDisplayOrigin();
            this.updateData();
          },
          setTo: function (e, b, c, f, g, m) {
            this.geom.setTo(e, b, c, f, g, m);
            return this.updateData();
          },
          updateData: function () {
            var e = [],
              b = this.geom,
              c = this._tempLine;
            b.getLineA(c);
            e.push(c.x1, c.y1, c.x2, c.y2);
            b.getLineB(c);
            e.push(c.x2, c.y2);
            b.getLineC(c);
            e.push(c.x2, c.y2);
            this.pathData = e;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(4),
          k = a(67);
        h.exports = function (e, b, c) {
          void 0 === c && (c = new d());
          var f = e.getLineA(),
            g = e.getLineB();
          e = e.getLineC();
          if (0 >= b || 1 <= b) return (c.x = f.x1), (c.y = f.y1), c;
          var m = k(f),
            n = k(g),
            q = k(e);
          b *= m + n + q;
          b < m
            ? ((b /= m),
              (c.x = f.x1 + (f.x2 - f.x1) * b),
              (c.y = f.y1 + (f.y2 - f.y1) * b))
            : b > m + n
            ? ((b = (b - (m + n)) / q),
              (c.x = e.x1 + (e.x2 - e.x1) * b),
              (c.y = e.y1 + (e.y2 - e.y1) * b))
            : ((b = (b - m) / n),
              (c.x = g.x1 + (g.x2 - g.x1) * b),
              (c.y = g.y1 + (g.y2 - g.y1) * b));
          return c;
        };
      },
      function (h, t, a) {
        var d = a(67),
          k = a(4);
        h.exports = function (e, b, c, f) {
          void 0 === f && (f = []);
          var g = e.getLineA(),
            m = e.getLineB();
          e = e.getLineC();
          var n = d(g),
            q = d(m),
            r = d(e),
            u = n + q + r;
          !b && 0 < c && (b = u / c);
          for (c = 0; c < b; c++) {
            var v = (c / b) * u,
              x = new k();
            v < n
              ? ((v /= n),
                (x.x = g.x1 + (g.x2 - g.x1) * v),
                (x.y = g.y1 + (g.y2 - g.y1) * v))
              : v > n + q
              ? ((v -= n + q),
                (v /= r),
                (x.x = e.x1 + (e.x2 - e.x1) * v),
                (x.y = e.y1 + (e.y2 - e.y1) * v))
              : ((v -= n),
                (v /= q),
                (x.x = m.x1 + (m.x2 - m.x1) * v),
                (x.y = m.y1 + (m.y2 - m.y1) * v));
            f.push(x);
          }
          return f;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          if (a && "number" !== typeof a) {
            if (a.hasOwnProperty(d)) return (a[d] = k), !0;
            if (-1 !== d.indexOf(".")) {
              d = d.split(".");
              for (var e = a, b = 0; b < d.length; b++)
                if (e.hasOwnProperty(d[b])) (a = e), (e = e[d[b]]);
                else return !1;
              a[d[d.length - 1]] = k;
              return !0;
            }
          }
          return !1;
        };
      },
      function (h, t, a) {
        var d = a(116),
          k = a(117);
        h.exports = function (e, b, c, f, g, m, n) {
          void 0 === f && (f = !1);
          void 0 === m && (m = 16777215);
          void 0 === n && (n = 1);
          if (e.length !== b.length)
            console.warn("GenerateVerts: vertices and uvs count not equal");
          else {
            var q = {
                faces: [],
                vertices: [],
              },
              r,
              u,
              v,
              x = f ? 3 : 2,
              y = Array.isArray(m),
              z = Array.isArray(n);
            if (Array.isArray(c) && 0 < c.length)
              for (r = 0; r < c.length; r++) {
                var A = c[r];
                var B = 2 * c[r];
                var D = c[r] * x;
                var E = e[D];
                var C = e[D + 1];
                var F = f ? e[D + 2] : 0;
                var G = b[B];
                B = b[B + 1];
                var H = y ? m[A] : m;
                A = z ? n[A] : n;
                var K = (v = u = 0);
                g && ((u = g[D]), (v = g[D + 1]), (K = f ? g[D + 2] : 0));
                q.vertices.push(new k(E, C, F, G, B, H, A, u, v, K));
              }
            else
              for (r = D = c = 0; r < e.length; r += x)
                (E = e[r]),
                  (C = e[r + 1]),
                  (F = f ? e[r + 2] : 0),
                  (G = b[c]),
                  (B = b[c + 1]),
                  (H = y ? m[D] : m),
                  (A = z ? n[D] : n),
                  (K = v = u = 0),
                  g && ((u = g[r]), (v = g[r + 1]), (K = f ? g[r + 2] : 0)),
                  q.vertices.push(new k(E, C, F, G, B, H, A, u, v, K)),
                  (c += 2),
                  D++;
            for (r = 0; r < q.vertices.length; r += 3)
              q.faces.push(
                new d(q.vertices[r], q.vertices[r + 1], q.vertices[r + 2])
              );
            return q;
          }
        };
      },
      function (h, t, a) {
        var d = a(116);
        t = a(69);
        var k = a(39),
          e = a(117),
          b = new k(),
          c = new k(),
          f = new t();
        h.exports = function (g, m, n, q, r, u, v, x, y, z) {
          void 0 === n && (n = 1);
          void 0 === q && (q = 0);
          void 0 === r && (r = 0);
          void 0 === u && (u = 0);
          void 0 === v && (v = 0);
          void 0 === x && (x = 0);
          void 0 === y && (y = 0);
          void 0 === z && (z = !0);
          var A = {
              faces: [],
              verts: [],
            },
            B = g.materials;
          b.set(q, r, u);
          c.set(v, x, y);
          f.fromRotationXYTranslation(c, b, z);
          for (q = 0; q < g.models.length; q++)
            for (
              v = g.models[q],
                r = v.vertices,
                u = v.textureCoords,
                v = v.faces,
                x = 0;
              x < v.length;
              x++
            ) {
              var D = v[x],
                E = D.vertices[0],
                C = D.vertices[1],
                F = D.vertices[2],
                G = r[E.vertexIndex];
              z = r[C.vertexIndex];
              y = r[F.vertexIndex];
              E = E.textureCoordsIndex;
              C = C.textureCoordsIndex;
              var H = F.textureCoordsIndex;
              F =
                -1 === E
                  ? {
                      u: 0,
                      v: 1,
                    }
                  : u[E];
              E =
                -1 === C
                  ? {
                      u: 0,
                      v: 0,
                    }
                  : u[C];
              C =
                -1 === H
                  ? {
                      u: 1,
                      v: 1,
                    }
                  : u[H];
              H = 16777215;
              "" !== D.material && B[D.material] && (H = B[D.material]);
              D = new e(G.x * n, G.y * n, G.z * n, F.u, F.v, H).transformMat4(
                f
              );
              z = new e(z.x * n, z.y * n, z.z * n, E.u, E.v, H).transformMat4(
                f
              );
              y = new e(y.x * n, y.y * n, y.z * n, C.u, C.v, H).transformMat4(
                f
              );
              A.verts.push(D, z, y);
              A.faces.push(new d(D, z, y));
            }
          m &&
            ((m.faces = m.faces.concat(A.faces)),
            (m.vertices = m.vertices.concat(A.verts)));
          return A;
        };
      },
      function (h, t, a) {
        var d = a(65);
        t = a(0);
        var k = a(11),
          e = a(200),
          b = a(12),
          c = new t({
            Extends: d,
            Mixins: [k.ScrollFactor, k.Visible],
            initialize: function (f, g, m, n, q, r, u) {
              d.call(this, f, g, m);
              this.color = new e(n, q, r);
              this.intensity = u;
              this.renderFlags = 15;
              this.cameraFilter = 0;
              this.setScrollFactor(1, 1);
            },
            willRender: function (f) {
              return !(
                c.RENDER_MASK !== this.renderFlags ||
                (0 !== this.cameraFilter && this.cameraFilter & f.id)
              );
            },
            setColor: function (f) {
              f = b.getFloatsFromUintRGB(f);
              this.color.set(f[0], f[1], f[2]);
              return this;
            },
            setIntensity: function (f) {
              this.intensity = f;
              return this;
            },
            setRadius: function (f) {
              this.radius = f;
              return this;
            },
          });
        c.RENDER_MASK = 15;
        h.exports = c;
      },
      function (h, t, a) {
        var d = a(151);
        t = a(0);
        var k = a(50),
          e = a(481),
          b = a(150),
          c = a(200),
          f = a(74),
          g = a(79),
          m = a(12);
        a = new t({
          initialize: function () {
            this.lights = [];
            this.ambientColor = new c(0.1, 0.1, 0.1);
            this.active = !1;
            this.maxLights = -1;
            this.visibleLights = 0;
          },
          addPointLight: function (n, q, r, u, v, x) {
            return this.systems.displayList.add(
              new b(this.scene, n, q, r, u, v, x)
            );
          },
          enable: function () {
            -1 === this.maxLights &&
              (this.maxLights = this.systems.renderer.config.maxLights);
            this.active = !0;
            return this;
          },
          disable: function () {
            this.active = !1;
            return this;
          },
          getLights: function (n) {
            for (
              var q = this.lights, r = n.worldView, u = [], v = 0;
              v < q.length;
              v++
            ) {
              var x = q[v];
              x.willRender(n) &&
                d(x, r) &&
                u.push({
                  light: x,
                  distance: k(x.x, x.y, r.centerX, r.centerY),
                });
            }
            u.length > this.maxLights &&
              (g(u, this.sortByDistance), (u = u.slice(0, this.maxLights)));
            this.visibleLights = u.length;
            return u;
          },
          sortByDistance: function (n, q) {
            return n.distance >= q.distance;
          },
          setAmbientColor: function (n) {
            n = m.getFloatsFromUintRGB(n);
            this.ambientColor.set(n[0], n[1], n[2]);
            return this;
          },
          getMaxVisibleLights: function () {
            return this.maxLights;
          },
          getLightCount: function () {
            return this.lights.length;
          },
          addLight: function (n, q, r, u, v) {
            void 0 === n && (n = 0);
            void 0 === q && (q = 0);
            void 0 === r && (r = 128);
            void 0 === u && (u = 16777215);
            void 0 === v && (v = 1);
            u = m.getFloatsFromUintRGB(u);
            n = new e(n, q, r, u[0], u[1], u[2], v);
            this.lights.push(n);
            return n;
          },
          removeLight: function (n) {
            n = this.lights.indexOf(n);
            0 <= n && f(this.lights, n);
            return this;
          },
          shutdown: function () {
            this.lights.length = 0;
          },
          destroy: function () {
            this.shutdown();
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(56);
        var d = a(17);
        a = {
          Circle: a(1191),
          Ellipse: a(1201),
          Intersects: a(484),
          Line: a(1221),
          Mesh: a(1243),
          Point: a(1246),
          Polygon: a(1260),
          Rectangle: a(502),
          Triangle: a(1293),
        };
        a = d(!1, a, t);
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          CircleToCircle: a(231),
          CircleToRectangle: a(151),
          GetCircleToCircle: a(1211),
          GetCircleToRectangle: a(1212),
          GetLineToCircle: a(232),
          GetLineToLine: a(485),
          GetLineToPoints: a(486),
          GetLineToPolygon: a(487),
          GetLineToRectangle: a(234),
          GetRaysFromPointToPolygon: a(1213),
          GetRectangleIntersection: a(1214),
          GetRectangleToRectangle: a(1215),
          GetRectangleToTriangle: a(1216),
          GetTriangleToCircle: a(1217),
          GetTriangleToLine: a(492),
          GetTriangleToTriangle: a(1218),
          LineToCircle: a(233),
          LineToLine: a(96),
          LineToRectangle: a(488),
          PointToLine: a(496),
          PointToLineSegment: a(1219),
          RectangleToRectangle: a(152),
          RectangleToTriangle: a(489),
          RectangleToValues: a(1220),
          TriangleToCircle: a(491),
          TriangleToLine: a(493),
          TriangleToTriangle: a(494),
        };
      },
      function (h, t, a) {
        var d = a(39);
        h.exports = function (k, e, b) {
          var c = k.x1,
            f = k.y1,
            g = e.x1,
            m = e.y1,
            n = k.x2 - c;
          k = k.y2 - f;
          var q = e.x2 - g;
          e = e.y2 - m;
          if (0 === n || 0 === e * n - q * k) return !1;
          m = (n * (m - f) + k * (c - g)) / (q * k - e * n);
          g = (g + q * m - c) / n;
          if (0 > g || 0 > m || 1 < m) return null;
          void 0 === b && (b = new d());
          return b.set(c + n * g, f + k * g, g);
        };
      },
      function (h, t, a) {
        var d = a(39),
          k = a(485),
          e = new (a(47))(),
          b = new d();
        h.exports = function (c, f, g) {
          void 0 === g && (g = new d());
          var m = !1;
          g.set();
          b.set();
          for (var n = f[0], q = 1; q < f.length; q++) {
            var r = f[q];
            e.setTo(n.x, n.y, r.x, r.y);
            n = r;
            k(c, e, b) && (!m || b.z < g.z) && (g.copy(b), (m = !0));
          }
          return m ? g : null;
        };
      },
      function (h, t, a) {
        t = a(39);
        var d = a(140),
          k = a(486),
          e = new t();
        h.exports = function (b, c, f) {
          void 0 === f && (f = new d());
          Array.isArray(c) || (c = [c]);
          var g = !1;
          f.set();
          e.set();
          for (var m = 0; m < c.length; m++)
            k(b, c[m].points, e) &&
              (!g || e.z < f.z) &&
              (f.set(e.x, e.y, e.z, m), (g = !0));
          return g ? f : null;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          var k = a.x1,
            e = a.y1,
            b = a.x2;
          a = a.y2;
          var c = d.x,
            f = d.y,
            g = d.right;
          d = d.bottom;
          if (
            (k >= c && k <= g && e >= f && e <= d) ||
            (b >= c && b <= g && a >= f && a <= d)
          )
            return !0;
          if (k < c && b >= c) {
            var m = e + ((a - e) * (c - k)) / (b - k);
            if (m > f && m <= d) return !0;
          } else if (
            k > g &&
            b <= g &&
            ((m = e + ((a - e) * (g - k)) / (b - k)), m >= f && m <= d)
          )
            return !0;
          if (e < f && a >= f) {
            if (((m = k + ((b - k) * (f - e)) / (a - e)), m >= c && m <= g))
              return !0;
          } else if (
            e > d &&
            a <= d &&
            ((m = k + ((b - k) * (d - e)) / (a - e)), m >= c && m <= g)
          )
            return !0;
          return !1;
        };
      },
      function (h, t, a) {
        var d = a(96),
          k = a(57),
          e = a(235),
          b = a(490);
        h.exports = function (c, f) {
          if (
            f.left > c.right ||
            f.right < c.left ||
            f.top > c.bottom ||
            f.bottom < c.top
          )
            return !1;
          var g = f.getLineA(),
            m = f.getLineB(),
            n = f.getLineC();
          if (
            k(c, g.x1, g.y1) ||
            k(c, g.x2, g.y2) ||
            k(c, m.x1, m.y1) ||
            k(c, m.x2, m.y2) ||
            k(c, n.x1, n.y1) ||
            k(c, n.x2, n.y2)
          )
            return !0;
          var q = c.getLineA(),
            r = c.getLineB(),
            u = c.getLineC(),
            v = c.getLineD();
          if (
            d(g, q) ||
            d(g, r) ||
            d(g, u) ||
            d(g, v) ||
            d(m, q) ||
            d(m, r) ||
            d(m, u) ||
            d(m, v) ||
            d(n, q) ||
            d(n, r) ||
            d(n, u) ||
            d(n, v)
          )
            return !0;
          c = b(c);
          return 0 < e(f, c, !0).length;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = []);
          d.push({
            x: a.x,
            y: a.y,
          });
          d.push({
            x: a.right,
            y: a.y,
          });
          d.push({
            x: a.right,
            y: a.bottom,
          });
          d.push({
            x: a.x,
            y: a.bottom,
          });
          return d;
        };
      },
      function (h, t, a) {
        var d = a(233),
          k = a(115);
        h.exports = function (e, b) {
          return e.left > b.right ||
            e.right < b.left ||
            e.top > b.bottom ||
            e.bottom < b.top
            ? !1
            : k(e, b.x, b.y) ||
              d(e.getLineA(), b) ||
              d(e.getLineB(), b) ||
              d(e.getLineC(), b)
            ? !0
            : !1;
        };
      },
      function (h, t, a) {
        var d = a(4),
          k = a(493),
          e = a(96);
        h.exports = function (b, c, f) {
          void 0 === f && (f = []);
          if (k(b, c)) {
            var g = b.getLineA(),
              m = b.getLineB(),
              n = b.getLineC();
            b = [new d(), new d(), new d()];
            c = [e(g, c, b[0]), e(m, c, b[1]), e(n, c, b[2])];
            for (g = 0; 3 > g; g++) c[g] && f.push(b[g]);
          }
          return f;
        };
      },
      function (h, t, a) {
        var d = a(96);
        h.exports = function (k, e) {
          return k.contains(e.x1, e.y1) ||
            k.contains(e.x2, e.y2) ||
            d(k.getLineA(), e) ||
            d(k.getLineB(), e) ||
            d(k.getLineC(), e)
            ? !0
            : !1;
        };
      },
      function (h, t, a) {
        var d = a(235),
          k = a(495),
          e = a(96);
        h.exports = function (b, c) {
          if (
            b.left > c.right ||
            b.right < c.left ||
            b.top > c.bottom ||
            b.bottom < c.top
          )
            return !1;
          var f = b.getLineA(),
            g = b.getLineB(),
            m = b.getLineC(),
            n = c.getLineA(),
            q = c.getLineB(),
            r = c.getLineC();
          if (
            e(f, n) ||
            e(f, q) ||
            e(f, r) ||
            e(g, n) ||
            e(g, q) ||
            e(g, r) ||
            e(m, n) ||
            e(m, q) ||
            e(m, r)
          )
            return !0;
          f = k(b);
          f = d(c, f, !0);
          if (0 < f.length) return !0;
          f = k(c);
          f = d(b, f, !0);
          return 0 < f.length ? !0 : !1;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = []);
          d.push({
            x: a.x1,
            y: a.y1,
          });
          d.push({
            x: a.x2,
            y: a.y2,
          });
          d.push({
            x: a.x3,
            y: a.y3,
          });
          return d;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          void 0 === k && (k = 1);
          var e = d.x1,
            b = d.y1,
            c = d.x2;
          d = d.y2;
          var f = a.x;
          a = a.y;
          var g = (c - e) * (c - e) + (d - b) * (d - b);
          if (0 === g) return !1;
          var m = ((f - e) * (c - e) + (a - b) * (d - b)) / g;
          return 0 > m
            ? Math.sqrt((e - f) * (e - f) + (b - a) * (b - a)) <= k
            : 0 <= m && 1 >= m
            ? Math.abs(((b - a) * (c - e) - (e - f) * (d - b)) / g) *
                Math.sqrt(g) <=
              k
            : Math.sqrt((c - f) * (c - f) + (d - a) * (d - a)) <= k;
        };
      },
      function (h, t, a) {
        var d = a(14),
          k = a(68),
          e = a(97);
        h.exports = function (b) {
          b = e(b) - d.TAU;
          return k(b, -Math.PI, Math.PI);
        };
      },
      function (h, t) {
        function a(b) {
          0 === b.models.length &&
            b.models.push({
              faces: [],
              name: "untitled",
              textureCoords: [],
              vertexNormals: [],
              vertices: [],
            });
          k = "";
          return b.models[b.models.length - 1];
        }
        var d = !0,
          k = "",
          e = "";
        h.exports = function (b, c) {
          void 0 === c && (c = !0);
          d = c;
          c = {
            materials: {},
            materialLibraries: [],
            models: [],
          };
          e = k = "";
          b = b.split("\n");
          for (var f = 0; f < b.length; f++) {
            var g = b[f],
              m = g.indexOf("#");
            g = (-1 < m ? g.substring(0, m) : g)
              .replace(/\s\s+/g, " ")
              .trim()
              .split(" ");
            switch (g[0].toLowerCase()) {
              case "o":
                c.models.push({
                  faces: [],
                  name: 2 <= g.length ? g[1] : "untitled",
                  textureCoords: [],
                  vertexNormals: [],
                  vertices: [],
                });
                k = "";
                break;
              case "g":
                2 === g.length && (k = g[1]);
                break;
              case "v":
                var n = g;
                g = c;
                var q = n.length;
                m = 2 <= q ? parseFloat(n[1]) : 0;
                var r = 3 <= q ? parseFloat(n[2]) : 0;
                n = 4 <= q ? parseFloat(n[3]) : 0;
                a(g).vertices.push({
                  x: m,
                  y: r,
                  z: n,
                });
                break;
              case "vt":
                n = g;
                g = c;
                q = n.length;
                m = 2 <= q ? parseFloat(n[1]) : 0;
                r = 3 <= q ? parseFloat(n[2]) : 0;
                n = 4 <= q ? parseFloat(n[3]) : 0;
                isNaN(m) && (m = 0);
                isNaN(r) && (r = 0);
                isNaN(n) && (n = 0);
                d && (r = 1 - r);
                a(g).textureCoords.push({
                  u: m,
                  v: r,
                  w: n,
                });
                break;
              case "vn":
                n = g;
                g = c;
                q = n.length;
                m = 2 <= q ? parseFloat(n[1]) : 0;
                r = 3 <= q ? parseFloat(n[2]) : 0;
                n = 4 <= q ? parseFloat(n[3]) : 0;
                a(g).vertexNormals.push({
                  x: m,
                  y: r,
                  z: n,
                });
                break;
              case "f":
                m = c;
                r = g.length - 1;
                if (!(3 > r)) {
                  n = {
                    group: k,
                    material: e,
                    vertices: [],
                  };
                  for (q = 0; q < r; q++) {
                    var u = g[q + 1].split("/"),
                      v = u.length;
                    if (!(1 > v || 3 < v)) {
                      var x = 0,
                        y = 0;
                      var z = parseInt(u[0], 10);
                      1 < v && "" !== u[1] && (x = parseInt(u[1], 10));
                      2 < v && (y = parseInt(u[2], 10));
                      0 !== z &&
                        (0 > z && (z = a(m).vertices.length + 1 + z),
                        --x,
                        --z,
                        --y,
                        n.vertices.push({
                          textureCoordsIndex: x,
                          vertexIndex: z,
                          vertexNormalIndex: y,
                        }));
                    }
                  }
                  a(m).faces.push(n);
                }
                break;
              case "mtllib":
                2 <= g.length && c.materialLibraries.push(g[1]);
                break;
              case "usemtl":
                2 <= g.length && (e = g[1]);
            }
          }
          return c;
        };
      },
      function (h, t, a) {
        var d = a(103);
        h.exports = function (k) {
          var e = {};
          k = k.split("\n");
          for (var b = "", c = 0; c < k.length; c++) {
            var f = k[c].trim();
            if (0 !== f.indexOf("#") && "" !== f)
              switch (
                ((f = f.replace(/\s\s+/g, " ").trim().split(" ")),
                f[0].toLowerCase())
              ) {
                case "newmtl":
                  b = f[1];
                  break;
                case "kd":
                  var g = Math.floor(255 * f[1]);
                  e[b] = d(
                    g,
                    2 <= f.length ? Math.floor(255 * f[2]) : g,
                    3 <= f.length ? Math.floor(255 * f[3]) : g
                  );
              }
          }
          return e;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return Math.sqrt(a.x * a.x + a.y * a.y);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a.x * a.x + a.y * a.y;
        };
      },
      function (h, t, a) {
        t = a(10);
        t.Area = a(1267);
        t.Ceil = a(1268);
        t.CeilAll = a(1269);
        t.CenterOn = a(190);
        t.Clone = a(1270);
        t.Contains = a(57);
        t.ContainsPoint = a(1271);
        t.ContainsRect = a(503);
        t.CopyFrom = a(1272);
        t.Decompose = a(490);
        t.Equals = a(1273);
        t.FitInside = a(1274);
        t.FitOutside = a(1275);
        t.Floor = a(1276);
        t.FloorAll = a(1277);
        t.FromPoints = a(199);
        t.FromXY = a(1278);
        t.GetAspectRatio = a(237);
        t.GetCenter = a(1279);
        t.GetPoint = a(171);
        t.GetPoints = a(306);
        t.GetSize = a(1280);
        t.Inflate = a(1281);
        t.Intersection = a(1282);
        t.MarchingAnts = a(316);
        t.MergePoints = a(1283);
        t.MergeRect = a(1284);
        t.MergeXY = a(1285);
        t.Offset = a(1286);
        t.OffsetPoint = a(1287);
        t.Overlaps = a(1288);
        t.Perimeter = a(130);
        t.PerimeterPoint = a(1289);
        t.Random = a(174);
        t.RandomOutside = a(1290);
        t.SameDimensions = a(1291);
        t.Scale = a(1292);
        t.Union = a(441);
        h.exports = t;
      },
      function (h, t) {
        h.exports = function (a, d) {
          return d.width * d.height > a.width * a.height
            ? !1
            : d.x > a.x &&
                d.x < a.right &&
                d.right > a.x &&
                d.right < a.right &&
                d.y > a.y &&
                d.y < a.bottom &&
                d.bottom > a.y &&
                d.bottom < a.bottom;
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          e.x = (k.x1 + k.x2 + k.x3) / 3;
          e.y = (k.y1 + k.y2 + k.y3) / 3;
          return e;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          a.x1 += d;
          a.y1 += k;
          a.x2 += d;
          a.y2 += k;
          a.x3 += d;
          a.y3 += k;
          return a;
        };
      },
      function (h, t, a) {
        function d(e, b, c, f) {
          e -= c;
          b -= f;
          return Math.sqrt(e * e + b * b);
        }
        var k = a(4);
        h.exports = function (e, b) {
          void 0 === b && (b = new k());
          var c = e.x1,
            f = e.y1,
            g = e.x2,
            m = e.y2,
            n = e.x3;
          e = e.y3;
          var q = d(n, e, g, m),
            r = d(c, f, n, e),
            u = d(g, m, c, f),
            v = q + r + u;
          b.x = (c * q + g * r + n * u) / v;
          b.y = (f * q + m * r + e * u) / v;
          return b;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return function (k, e, b, c) {
            return (
              (k = a.getPixelAlpha(e, b, c.texture.key, c.frame.name)) && k >= d
            );
          };
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          return {
            gameObject: a,
            enabled: !0,
            alwaysEnabled: !1,
            draggable: !1,
            dropZone: !1,
            cursor: !1,
            target: null,
            camera: null,
            hitArea: d,
            hitAreaCallback: k,
            hitAreaDebug: null,
            customHitArea: !1,
            localX: 0,
            localY: 0,
            dragState: 0,
            dragStartX: 0,
            dragStartY: 0,
            dragStartXGlobal: 0,
            dragStartYGlobal: 0,
            dragX: 0,
            dragY: 0,
          };
        };
      },
      function (h, t, a) {
        t = new (a(0))({
          initialize: function (d, k) {
            this.pad = d;
            this.events = d.events;
            this.index = k;
            this.value = 0;
            this.threshold = 0.1;
          },
          update: function (d) {
            this.value = d;
          },
          getValue: function () {
            return Math.abs(this.value) < this.threshold ? 0 : this.value;
          },
          destroy: function () {
            this.events = this.pad = null;
          },
        });
        h.exports = t;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(239);
        a = new t({
          initialize: function (k, e) {
            this.pad = k;
            this.events = k.manager;
            this.index = e;
            this.value = 0;
            this.threshold = 1;
            this.pressed = !1;
          },
          update: function (k) {
            this.value = k;
            var e = this.pad,
              b = this.index;
            k >= this.threshold
              ? this.pressed ||
                ((this.pressed = !0),
                this.events.emit(d.BUTTON_DOWN, e, this, k),
                this.pad.emit(d.GAMEPAD_BUTTON_DOWN, b, k, this))
              : this.pressed &&
                ((this.pressed = !1),
                this.events.emit(d.BUTTON_UP, e, this, k),
                this.pad.emit(d.GAMEPAD_BUTTON_UP, b, k, this));
          },
          destroy: function () {
            this.events = this.pad = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(509),
          k = a(510);
        t = a(0);
        var e = a(9),
          b = a(3);
        a = new t({
          Extends: e,
          initialize: function (c, f) {
            e.call(this);
            this.manager = c;
            this.pad = f;
            this.id = f.id;
            this.index = f.index;
            for (var g = [], m = 0; m < f.buttons.length; m++)
              g.push(new k(this, m));
            this.buttons = g;
            c = [];
            for (m = 0; m < f.axes.length; m++) c.push(new d(this, m));
            this.axes = c;
            this.vibration = f.vibrationActuator;
            f = {
              value: 0,
              pressed: !1,
            };
            this._LCLeft = g[14] ? g[14] : f;
            this._LCRight = g[15] ? g[15] : f;
            this._LCTop = g[12] ? g[12] : f;
            this._LCBottom = g[13] ? g[13] : f;
            this._RCLeft = g[2] ? g[2] : f;
            this._RCRight = g[1] ? g[1] : f;
            this._RCTop = g[3] ? g[3] : f;
            this._RCBottom = g[0] ? g[0] : f;
            this._FBLeftTop = g[4] ? g[4] : f;
            this._FBLeftBottom = g[6] ? g[6] : f;
            this._FBRightTop = g[5] ? g[5] : f;
            this._FBRightBottom = g[7] ? g[7] : f;
            f = {
              value: 0,
            };
            this._HAxisLeft = c[0] ? c[0] : f;
            this._VAxisLeft = c[1] ? c[1] : f;
            this._HAxisRight = c[2] ? c[2] : f;
            this._VAxisRight = c[3] ? c[3] : f;
            this.leftStick = new b();
            this.rightStick = new b();
            this._created = performance.now();
          },
          getAxisTotal: function () {
            return this.axes.length;
          },
          getAxisValue: function (c) {
            return this.axes[c].getValue();
          },
          setAxisThreshold: function (c) {
            for (var f = 0; f < this.axes.length; f++)
              this.axes[f].threshold = c;
          },
          getButtonTotal: function () {
            return this.buttons.length;
          },
          getButtonValue: function (c) {
            return this.buttons[c].value;
          },
          isButtonDown: function (c) {
            return this.buttons[c].pressed;
          },
          update: function (c) {
            if (!(c.timestamp < this._created)) {
              var f,
                g = this.buttons,
                m = c.buttons,
                n = g.length;
              for (f = 0; f < n; f++) g[f].update(m[f].value);
              g = this.axes;
              c = c.axes;
              n = g.length;
              for (f = 0; f < n; f++) g[f].update(c[f]);
              2 <= n &&
                (this.leftStick.set(g[0].getValue(), g[1].getValue()),
                4 <= n &&
                  this.rightStick.set(g[2].getValue(), g[3].getValue()));
            }
          },
          destroy: function () {
            this.removeAllListeners();
            this.pad = this.manager = null;
            var c;
            for (c = 0; c < this.buttons.length; c++) this.buttons[c].destroy();
            for (c = 0; c < this.axes.length; c++) this.axes[c].destroy();
            this.buttons = [];
            this.axes = [];
          },
          connected: {
            get: function () {
              return this.pad.connected;
            },
          },
          timestamp: {
            get: function () {
              return this.pad.timestamp;
            },
          },
          left: {
            get: function () {
              return this._LCLeft.pressed;
            },
          },
          right: {
            get: function () {
              return this._LCRight.pressed;
            },
          },
          up: {
            get: function () {
              return this._LCTop.pressed;
            },
          },
          down: {
            get: function () {
              return this._LCBottom.pressed;
            },
          },
          A: {
            get: function () {
              return this._RCBottom.pressed;
            },
          },
          Y: {
            get: function () {
              return this._RCTop.pressed;
            },
          },
          X: {
            get: function () {
              return this._RCLeft.pressed;
            },
          },
          B: {
            get: function () {
              return this._RCRight.pressed;
            },
          },
          L1: {
            get: function () {
              return this._FBLeftTop.value;
            },
          },
          L2: {
            get: function () {
              return this._FBLeftBottom.value;
            },
          },
          R1: {
            get: function () {
              return this._FBRightTop.value;
            },
          },
          R2: {
            get: function () {
              return this._FBRightBottom.value;
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(9),
          k = a(154);
        a = new t({
          Extends: d,
          initialize: function (e, b) {
            d.call(this);
            this.plugin = e;
            this.keyCode = b;
            this.originalEvent = void 0;
            this.enabled = !0;
            this.isDown = !1;
            this.isUp = !0;
            this.metaKey = this.shiftKey = this.ctrlKey = this.altKey = !1;
            this.timeUp = this.duration = this.timeDown = this.location = 0;
            this.emitOnRepeat = !1;
            this.repeats = 0;
            this._justUp = this._justDown = !1;
            this._tick = -1;
          },
          setEmitOnRepeat: function (e) {
            this.emitOnRepeat = e;
            return this;
          },
          onDown: function (e) {
            this.originalEvent = e;
            this.enabled &&
              ((this.altKey = e.altKey),
              (this.ctrlKey = e.ctrlKey),
              (this.shiftKey = e.shiftKey),
              (this.metaKey = e.metaKey),
              (this.location = e.location),
              this.repeats++,
              this.isDown
                ? this.emitOnRepeat && this.emit(k.DOWN, this, e)
                : ((this.isDown = !0),
                  (this.isUp = !1),
                  (this.timeDown = e.timeStamp),
                  (this.duration = 0),
                  (this._justDown = !0),
                  (this._justUp = !1),
                  this.emit(k.DOWN, this, e)));
          },
          onUp: function (e) {
            this.originalEvent = e;
            this.enabled &&
              ((this.isDown = !1),
              (this.isUp = !0),
              (this.timeUp = e.timeStamp),
              (this.duration = this.timeUp - this.timeDown),
              (this.repeats = 0),
              (this._justDown = !1),
              (this._justUp = !0),
              (this._tick = -1),
              this.emit(k.UP, this, e));
          },
          reset: function () {
            this.enabled = this.preventDefault = !0;
            this.isDown = !1;
            this.isUp = !0;
            this.metaKey = this.shiftKey = this.ctrlKey = this.altKey = !1;
            this.repeats = this.timeUp = this.duration = this.timeDown = 0;
            this._justUp = this._justDown = !1;
            this._tick = -1;
            return this;
          },
          getDuration: function () {
            return this.isDown ? this.plugin.game.loop.time - this.timeDown : 0;
          },
          destroy: function () {
            this.removeAllListeners();
            this.plugin = this.originalEvent = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(154),
          k = a(2),
          e = a(514),
          b = a(516);
        a = new t({
          initialize: function (c, f, g) {
            void 0 === g && (g = {});
            if (2 > f.length) return !1;
            this.manager = c;
            this.enabled = !0;
            this.keyCodes = [];
            for (c = 0; c < f.length; c++) {
              var m = f[c];
              "string" === typeof m
                ? this.keyCodes.push(m.toUpperCase().charCodeAt(0))
                : "number" === typeof m
                ? this.keyCodes.push(m)
                : m.hasOwnProperty("keyCode") && this.keyCodes.push(m.keyCode);
            }
            this.current = this.keyCodes[0];
            this.index = 0;
            this.size = this.keyCodes.length;
            this.timeLastMatched = 0;
            this.matched = !1;
            this.timeMatched = 0;
            this.resetOnWrongKey = k(g, "resetOnWrongKey", !0);
            this.maxKeyDelay = k(g, "maxKeyDelay", 0);
            this.resetOnMatch = k(g, "resetOnMatch", !1);
            this.deleteOnMatch = k(g, "deleteOnMatch", !1);
            var n = this;
            this.onKeyDown = function (q) {
              !n.matched &&
                n.enabled &&
                e(q, n) &&
                (n.manager.emit(d.COMBO_MATCH, n, q),
                n.resetOnMatch ? b(n) : n.deleteOnMatch && n.destroy());
            };
            this.manager.on(d.ANY_KEY_DOWN, this.onKeyDown);
          },
          progress: {
            get: function () {
              return this.index / this.size;
            },
          },
          destroy: function () {
            this.enabled = !1;
            this.keyCodes = [];
            this.manager.off(d.ANY_KEY_DOWN, this.onKeyDown);
            this.manager = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(515);
        h.exports = function (k, e) {
          if (e.matched) return !0;
          var b = !1,
            c = !1;
          k.keyCode === e.current &&
            (0 < e.index && 0 < e.maxKeyDelay
              ? k.timeStamp <= e.timeLastMatched + e.maxKeyDelay &&
                ((c = !0), (b = d(k, e)))
              : ((c = !0), (b = d(k, e))));
          !c &&
            e.resetOnWrongKey &&
            ((e.index = 0), (e.current = e.keyCodes[0]));
          b &&
            ((e.timeLastMatched = k.timeStamp),
            (e.matched = !0),
            (e.timeMatched = k.timeStamp));
          return b;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          d.timeLastMatched = a.timeStamp;
          d.index++;
          if (d.index === d.size) return !0;
          d.current = d.keyCodes[d.index];
          return !1;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          a.current = a.keyCodes[0];
          a.index = 0;
          a.timeLastMatched = 0;
          a.matched = !1;
          a.timeMatched = 0;
          return a;
        };
      },
      function (h, t, a) {
        var d = a(240);
        h.exports = function (k, e) {
          e = d(e, k.xhrSettings);
          var b = new XMLHttpRequest();
          b.open("GET", k.src, e.async, e.user, e.password);
          b.responseType = k.xhrSettings.responseType;
          b.timeout = e.timeout;
          if (e.headers)
            for (var c in e.headers) b.setRequestHeader(c, e.headers[c]);
          e.header &&
            e.headerValue &&
            b.setRequestHeader(e.header, e.headerValue);
          e.requestedWith &&
            b.setRequestHeader("X-Requested-With", e.requestedWith);
          e.overrideMimeType && b.overrideMimeType(e.overrideMimeType);
          e.withCredentials && (b.withCredentials = !0);
          b.onload = k.onLoad.bind(k, b);
          b.onerror = k.onError.bind(k, b);
          b.onprogress = k.onProgress.bind(k);
          b.send();
          return b;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(519),
          f = a(7),
          g = new t({
            Extends: k,
            initialize: function (m, n, q, r, u) {
              if (f(n)) {
                var v = n;
                n = b(v, "key");
                r = b(v, "xhrSettings");
                u = b(v, "context", u);
              }
              k.call(this, m, {
                type: "audio",
                cache: m.cacheManager.audio,
                extension: q.type,
                responseType: "arraybuffer",
                key: n,
                url: q.url,
                xhrSettings: r,
                config: {
                  context: u,
                },
              });
            },
            onProcess: function () {
              this.state = d.FILE_PROCESSING;
              var m = this;
              this.config.context.decodeAudioData(
                this.xhrLoader.response,
                function (n) {
                  m.data = n;
                  m.onProcessComplete();
                },
                function (n) {
                  console.error(
                    "Error decoding audio: " + m.key + " - ",
                    n ? n.message : null
                  );
                  m.onProcessError();
                }
              );
              this.config.context = null;
            },
          });
        g.create = function (m, n, q, r, u) {
          var v = m.systems.game,
            x = v.config.audio,
            y = v.device.audio;
          f(n) && ((q = b(n, "url", [])), (r = b(n, "config", {})));
          return (q = g.getAudioURL(v, q))
            ? y.webAudio && !x.disableWebAudio
              ? new g(m, n, q, u, v.sound.context)
              : new c(m, n, q, r)
            : null;
        };
        g.getAudioURL = function (m, n) {
          Array.isArray(n) || (n = [n]);
          for (var q = 0; q < n.length; q++) {
            var r = b(n[q], "url", n[q]);
            if (0 === r.indexOf("blob:") || 0 === r.indexOf("data:"))
              return {
                url: r,
                type: "",
              };
            var u = r.match(/\.([a-zA-Z0-9]+)($|\?)/);
            u = b(n[q], "type", u ? u[1] : "").toLowerCase();
            if (m.device.audio[u])
              return {
                url: r,
                type: u,
              };
          }
          return null;
        };
        e.register("audio", function (m, n, q, r) {
          var u = this.systems.game,
            v = u.device.audio;
          if (u.config.audio.noAudio || (!v.webAudio && !v.audioData))
            return this;
          if (Array.isArray(m))
            for (q = 0; q < m.length; q++)
              (n = g.create(this, m[q])) && this.addFile(n);
          else (n = g.create(this, m, n, q, r)) && this.addFile(n);
          return this;
        });
        h.exports = g;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(95),
          k = a(23),
          e = a(2),
          b = a(155),
          c = a(7);
        a = new t({
          Extends: k,
          initialize: function (f, g, m, n) {
            if (c(g)) {
              var q = g;
              g = e(q, "key");
              n = e(q, "config", n);
            }
            k.call(this, f, {
              type: "audio",
              cache: f.cacheManager.audio,
              extension: m.type,
              key: g,
              url: m.url,
              config: n,
            });
            this.locked = "ontouchstart" in window;
            this.loaded = !1;
            this.filesTotal = this.filesLoaded = 0;
          },
          onLoad: function () {
            this.loaded || ((this.loaded = !0), this.loader.nextFile(this, !0));
          },
          onError: function () {
            for (var f = 0; f < this.data.length; f++) {
              var g = this.data[f];
              g.oncanplaythrough = null;
              g.onerror = null;
            }
            this.loader.nextFile(this, !1);
          },
          onProgress: function (f) {
            f = f.target;
            f.oncanplaythrough = null;
            f.onerror = null;
            this.filesLoaded++;
            this.percentComplete = Math.min(
              this.filesLoaded / this.filesTotal,
              1
            );
            this.loader.emit(d.FILE_PROGRESS, this, this.percentComplete);
            if (this.filesLoaded === this.filesTotal) this.onLoad();
          },
          load: function () {
            this.data = [];
            var f = (this.config && this.config.instances) || 1;
            this.filesTotal = f;
            for (
              var g = (this.percentComplete = this.filesLoaded = 0);
              g < f;
              g++
            ) {
              var m = new Audio();
              m.dataset || (m.dataset = {});
              m.dataset.name = this.key + ("0" + g).slice(-2);
              m.dataset.used = "false";
              this.locked
                ? (m.dataset.locked = "true")
                : ((m.dataset.locked = "false"),
                  (m.preload = "auto"),
                  (m.oncanplaythrough = this.onProgress.bind(this)),
                  (m.onerror = this.onError.bind(this)));
              this.data.push(m);
            }
            for (g = 0; g < this.data.length; g++)
              (m = this.data[g]),
                (m.src = b(this, this.loader.baseURL)),
                this.locked || m.load();
            this.locked && setTimeout(this.onLoad.bind(this));
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(7),
          f = new t({
            Extends: k,
            initialize: function (g, m, n, q) {
              var r = "js";
              if (c(m)) {
                var u = m;
                m = b(u, "key");
                n = b(u, "url");
                q = b(u, "xhrSettings");
                r = b(u, "extension", r);
              }
              k.call(this, g, {
                type: "script",
                cache: !1,
                extension: r,
                responseType: "text",
                key: m,
                url: n,
                xhrSettings: q,
              });
            },
            onProcess: function () {
              this.state = d.FILE_PROCESSING;
              this.data = document.createElement("script");
              this.data.language = "javascript";
              this.data.type = "text/javascript";
              this.data.defer = !1;
              this.data.text = this.xhrLoader.responseText;
              document.head.appendChild(this.data);
              this.onProcessComplete();
            },
          });
        e.register("script", function (g, m, n) {
          if (Array.isArray(g))
            for (m = 0; m < g.length; m++) this.addFile(new f(this, g[m]));
          else this.addFile(new f(this, g, m, n));
          return this;
        });
        h.exports = f;
      },
      function (h, t, a) {
        var d = a(522),
          k = a(157);
        t = a(0);
        var e = a(62),
          b = a(524),
          c = a(525);
        a = new t({
          initialize: function (f) {
            this.world = f;
            this.scene = f.scene;
            this.sys = f.scene.sys;
          },
          collider: function (f, g, m, n, q) {
            return this.world.addCollider(f, g, m, n, q);
          },
          overlap: function (f, g, m, n, q) {
            return this.world.addOverlap(f, g, m, n, q);
          },
          existing: function (f, g) {
            this.world.enableBody(f, g ? e.STATIC_BODY : e.DYNAMIC_BODY);
            return f;
          },
          staticImage: function (f, g, m, n) {
            f = new d(this.scene, f, g, m, n);
            this.sys.displayList.add(f);
            this.world.enableBody(f, e.STATIC_BODY);
            return f;
          },
          image: function (f, g, m, n) {
            f = new d(this.scene, f, g, m, n);
            this.sys.displayList.add(f);
            this.world.enableBody(f, e.DYNAMIC_BODY);
            return f;
          },
          staticSprite: function (f, g, m, n) {
            f = new k(this.scene, f, g, m, n);
            this.sys.displayList.add(f);
            this.sys.updateList.add(f);
            this.world.enableBody(f, e.STATIC_BODY);
            return f;
          },
          sprite: function (f, g, m, n) {
            f = new k(this.scene, f, g, m, n);
            this.sys.displayList.add(f);
            this.sys.updateList.add(f);
            this.world.enableBody(f, e.DYNAMIC_BODY);
            return f;
          },
          staticGroup: function (f, g) {
            return this.sys.updateList.add(
              new c(this.world, this.world.scene, f, g)
            );
          },
          group: function (f, g) {
            return this.sys.updateList.add(
              new b(this.world, this.world.scene, f, g)
            );
          },
          destroy: function () {
            this.sys = this.scene = this.world = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(243),
          k = a(125);
        a = new t({
          Extends: k,
          Mixins: [
            d.Acceleration,
            d.Angular,
            d.Bounce,
            d.Debug,
            d.Drag,
            d.Enable,
            d.Friction,
            d.Gravity,
            d.Immovable,
            d.Mass,
            d.Pushable,
            d.Size,
            d.Velocity,
          ],
          initialize: function (e, b, c, f, g) {
            k.call(this, e, b, c, f, g);
            this.body = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(244),
          k = a(65),
          e = a(231),
          b = a(151);
        h.exports = function (c, f, g, m, n, q) {
          c = d(c, f - m, g - m, 2 * m, 2 * m, n, q);
          if (0 === c.length) return c;
          f = new k(f, g, m);
          g = new k();
          m = [];
          for (n = 0; n < c.length; n++)
            (q = c[n]),
              q.isCircle
                ? (g.setTo(q.center.x, q.center.y, q.halfWidth),
                  e(f, g) && m.push(q))
                : b(f, q) && m.push(q);
          return m;
        };
      },
      function (h, t, a) {
        var d = a(157);
        t = a(0);
        var k = a(62),
          e = a(2),
          b = a(113),
          c = a(7);
        a = new t({
          Extends: b,
          initialize: function (f, g, m, n) {
            if (m || n)
              if (c(m))
                (n = m),
                  (m = null),
                  (n.internalCreateCallback = this.createCallbackHandler),
                  (n.internalRemoveCallback = this.removeCallbackHandler);
              else if (Array.isArray(m) && c(m[0])) {
                n = m[0];
                var q = this;
                m.forEach(function (r) {
                  r.internalCreateCallback = q.createCallbackHandler;
                  r.internalRemoveCallback = q.removeCallbackHandler;
                });
                m = null;
              } else
                n = {
                  internalCreateCallback: this.createCallbackHandler,
                  internalRemoveCallback: this.removeCallbackHandler,
                };
            else
              n = {
                internalCreateCallback: this.createCallbackHandler,
                internalRemoveCallback: this.removeCallbackHandler,
              };
            this.world = f;
            n.classType = e(n, "classType", d);
            this.physicsType = k.DYNAMIC_BODY;
            this.defaults = {
              setCollideWorldBounds: e(n, "collideWorldBounds", !1),
              setBoundsRectangle: e(n, "customBoundsRectangle", null),
              setAccelerationX: e(n, "accelerationX", 0),
              setAccelerationY: e(n, "accelerationY", 0),
              setAllowDrag: e(n, "allowDrag", !0),
              setAllowGravity: e(n, "allowGravity", !0),
              setAllowRotation: e(n, "allowRotation", !0),
              setBounceX: e(n, "bounceX", 0),
              setBounceY: e(n, "bounceY", 0),
              setDragX: e(n, "dragX", 0),
              setDragY: e(n, "dragY", 0),
              setEnable: e(n, "enable", !0),
              setGravityX: e(n, "gravityX", 0),
              setGravityY: e(n, "gravityY", 0),
              setFrictionX: e(n, "frictionX", 0),
              setFrictionY: e(n, "frictionY", 0),
              setMaxVelocityX: e(n, "maxVelocityX", 1e4),
              setMaxVelocityY: e(n, "maxVelocityY", 1e4),
              setVelocityX: e(n, "velocityX", 0),
              setVelocityY: e(n, "velocityY", 0),
              setAngularVelocity: e(n, "angularVelocity", 0),
              setAngularAcceleration: e(n, "angularAcceleration", 0),
              setAngularDrag: e(n, "angularDrag", 0),
              setMass: e(n, "mass", 1),
              setImmovable: e(n, "immovable", !1),
            };
            b.call(this, g, m, n);
            this.type = "PhysicsGroup";
          },
          createCallbackHandler: function (f) {
            f.body || this.world.enableBody(f, k.DYNAMIC_BODY);
            f = f.body;
            for (var g in this.defaults) f[g](this.defaults[g]);
          },
          removeCallbackHandler: function (f) {
            f.body && this.world.disableBody(f);
          },
          setVelocity: function (f, g, m) {
            void 0 === m && (m = 0);
            for (var n = this.getChildren(), q = 0; q < n.length; q++)
              n[q].body.velocity.set(f + q * m, g + q * m);
            return this;
          },
          setVelocityX: function (f, g) {
            void 0 === g && (g = 0);
            for (var m = this.getChildren(), n = 0; n < m.length; n++)
              m[n].body.velocity.x = f + n * g;
            return this;
          },
          setVelocityY: function (f, g) {
            void 0 === g && (g = 0);
            for (var m = this.getChildren(), n = 0; n < m.length; n++)
              m[n].body.velocity.y = f + n * g;
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(157);
        t = a(0);
        var k = a(62),
          e = a(2),
          b = a(113),
          c = a(7);
        a = new t({
          Extends: b,
          initialize: function (f, g, m, n) {
            m || n
              ? c(m)
                ? ((n = m),
                  (m = null),
                  (n.internalCreateCallback = this.createCallbackHandler),
                  (n.internalRemoveCallback = this.removeCallbackHandler),
                  (n.createMultipleCallback =
                    this.createMultipleCallbackHandler),
                  (n.classType = e(n, "classType", d)))
                : Array.isArray(m) && c(m[0])
                ? ((n = m),
                  (m = null),
                  n.forEach(function (q) {
                    q.internalCreateCallback = this.createCallbackHandler;
                    q.internalRemoveCallback = this.removeCallbackHandler;
                    q.createMultipleCallback =
                      this.createMultipleCallbackHandler;
                    q.classType = e(q, "classType", d);
                  }))
                : (n = {
                    internalCreateCallback: this.createCallbackHandler,
                    internalRemoveCallback: this.removeCallbackHandler,
                  })
              : (n = {
                  internalCreateCallback: this.createCallbackHandler,
                  internalRemoveCallback: this.removeCallbackHandler,
                  createMultipleCallback: this.createMultipleCallbackHandler,
                  classType: d,
                });
            this.world = f;
            this.physicsType = k.STATIC_BODY;
            b.call(this, g, m, n);
            this.type = "StaticPhysicsGroup";
          },
          createCallbackHandler: function (f) {
            f.body || this.world.enableBody(f, k.STATIC_BODY);
          },
          removeCallbackHandler: function (f) {
            f.body && this.world.disableBody(f);
          },
          createMultipleCallbackHandler: function () {
            this.refresh();
          },
          refresh: function () {
            for (var f = this.children.entries, g = 0; g < f.length; g++)
              f[g].body.reset();
            return this;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(350),
          k = a(527),
          e = a(18);
        t = a(0);
        var b = a(528),
          c = a(62),
          f = a(50),
          g = a(9),
          m = a(245),
          n = a(124),
          q = a(354),
          r = a(355),
          u = a(246),
          v = a(247),
          x = a(529),
          y = a(6),
          z = a(14),
          A = a(211),
          B = a(530),
          D = a(10),
          E = a(531),
          C = a(532),
          F = a(537),
          G = a(538),
          H = a(149),
          K = a(539),
          I = a(248),
          M = a(25),
          N = a(3),
          P = a(68);
        a = new t({
          Extends: g,
          initialize: function (J, L) {
            g.call(this);
            this.scene = J;
            this.bodies = new H();
            this.staticBodies = new H();
            this.pendingDestroy = new H();
            this.colliders = new A();
            this.gravity = new N(y(L, "gravity.x", 0), y(L, "gravity.y", 0));
            this.bounds = new D(
              y(L, "x", 0),
              y(L, "y", 0),
              y(L, "width", J.sys.scale.width),
              y(L, "height", J.sys.scale.height)
            );
            this.checkCollision = {
              up: y(L, "checkCollision.up", !0),
              down: y(L, "checkCollision.down", !0),
              left: y(L, "checkCollision.left", !0),
              right: y(L, "checkCollision.right", !0),
            };
            this.fps = y(L, "fps", 60);
            this.fixedStep = y(L, "fixedStep", !0);
            this._elapsed = 0;
            this._frameTime = 1 / this.fps;
            this._frameTimeMS = 1e3 * this._frameTime;
            this.stepsLastFrame = 0;
            this.timeScale = y(L, "timeScale", 1);
            this.OVERLAP_BIAS = y(L, "overlapBias", 4);
            this.TILE_BIAS = y(L, "tileBias", 16);
            this.forceX = y(L, "forceX", !1);
            this.isPaused = y(L, "isPaused", !1);
            this._total = 0;
            this.drawDebug = y(L, "debug", !1);
            this.debugGraphic;
            this.defaults = {
              debugShowBody: y(L, "debugShowBody", !0),
              debugShowStaticBody: y(L, "debugShowStaticBody", !0),
              debugShowVelocity: y(L, "debugShowVelocity", !0),
              bodyDebugColor: y(L, "debugBodyColor", 16711935),
              staticBodyDebugColor: y(L, "debugStaticBodyColor", 255),
              velocityDebugColor: y(L, "debugVelocityColor", 65280),
            };
            this.maxEntries = y(L, "maxEntries", 16);
            this.useTree = y(L, "useTree", !0);
            this.tree = new E(this.maxEntries);
            this.staticTree = new E(this.maxEntries);
            this.treeMinMax = {
              minX: 0,
              minY: 0,
              maxX: 0,
              maxY: 0,
            };
            this._tempMatrix = new M();
            this._tempMatrix2 = new M();
            this.drawDebug && this.createDebugGraphic();
          },
          enable: function (J, L) {
            void 0 === L && (L = c.DYNAMIC_BODY);
            Array.isArray(J) || (J = [J]);
            for (var O = 0; O < J.length; O++) {
              var Q = J[O];
              if (Q.isParent) {
                Q = Q.getChildren();
                for (var S = 0; S < Q.length; S++) {
                  var R = Q[S];
                  R.isParent ? this.enable(R, L) : this.enableBody(R, L);
                }
              } else this.enableBody(Q, L);
            }
          },
          enableBody: function (J, L) {
            void 0 === L && (L = c.DYNAMIC_BODY);
            J.body ||
              (L === c.DYNAMIC_BODY
                ? (J.body = new k(this, J))
                : L === c.STATIC_BODY && (J.body = new K(this, J)));
            this.add(J.body);
            return J;
          },
          add: function (J) {
            J.physicsType === c.DYNAMIC_BODY
              ? this.bodies.set(J)
              : J.physicsType === c.STATIC_BODY &&
                (this.staticBodies.set(J), this.staticTree.insert(J));
            J.enable = !0;
            return J;
          },
          disable: function (J) {
            Array.isArray(J) || (J = [J]);
            for (var L = 0; L < J.length; L++) {
              var O = J[L];
              if (O.isParent) {
                O = O.getChildren();
                for (var Q = 0; Q < O.length; Q++) {
                  var S = O[Q];
                  S.isParent ? this.disable(S) : this.disableBody(S.body);
                }
              } else this.disableBody(O.body);
            }
          },
          disableBody: function (J) {
            this.remove(J);
            J.enable = !1;
          },
          remove: function (J) {
            J.physicsType === c.DYNAMIC_BODY
              ? (this.tree.remove(J), this.bodies.delete(J))
              : J.physicsType === c.STATIC_BODY &&
                (this.staticBodies.delete(J), this.staticTree.remove(J));
          },
          createDebugGraphic: function () {
            var J = this.scene.sys.add.graphics({
              x: 0,
              y: 0,
            });
            J.setDepth(Number.MAX_VALUE);
            this.debugGraphic = J;
            this.drawDebug = !0;
            return J;
          },
          setBounds: function (J, L, O, Q, S, R, T, U) {
            this.bounds.setTo(J, L, O, Q);
            void 0 !== S && this.setBoundsCollision(S, R, T, U);
            return this;
          },
          setBoundsCollision: function (J, L, O, Q) {
            void 0 === J && (J = !0);
            void 0 === L && (L = !0);
            void 0 === O && (O = !0);
            void 0 === Q && (Q = !0);
            this.checkCollision.left = J;
            this.checkCollision.right = L;
            this.checkCollision.up = O;
            this.checkCollision.down = Q;
            return this;
          },
          pause: function () {
            this.isPaused = !0;
            this.emit(m.PAUSE);
            return this;
          },
          resume: function () {
            this.isPaused = !1;
            this.emit(m.RESUME);
            return this;
          },
          addCollider: function (J, L, O, Q, S) {
            void 0 === O && (O = null);
            void 0 === Q && (Q = null);
            void 0 === S && (S = O);
            J = new b(this, !1, J, L, O, Q, S);
            this.colliders.add(J);
            return J;
          },
          addOverlap: function (J, L, O, Q, S) {
            void 0 === O && (O = null);
            void 0 === Q && (Q = null);
            void 0 === S && (S = O);
            J = new b(this, !0, J, L, O, Q, S);
            this.colliders.add(J);
            return J;
          },
          removeCollider: function (J) {
            this.colliders.remove(J);
            return this;
          },
          setFPS: function (J) {
            this.fps = J;
            this._frameTime = 1 / this.fps;
            this._frameTimeMS = 1e3 * this._frameTime;
            return this;
          },
          update: function (J, L) {
            if (!this.isPaused && 0 !== this.bodies.size) {
              J = this._frameTime;
              var O = this._frameTimeMS * this.timeScale;
              this._elapsed += L;
              var Q = this.bodies.entries,
                S = this._elapsed >= O;
              this.fixedStep ||
                ((J = 0.001 * L), (S = !0), (this._elapsed = 0));
              for (L = 0; L < Q.length; L++) {
                var R = Q[L];
                R.enable && R.preUpdate(S, J);
              }
              if (S) {
                this._elapsed -= O;
                this.stepsLastFrame = 1;
                this.useTree && (this.tree.clear(), this.tree.load(Q));
                Q = this.colliders.update();
                for (L = 0; L < Q.length; L++)
                  (S = Q[L]), S.active && S.update();
                this.emit(m.WORLD_STEP, J);
              }
              for (; this._elapsed >= O; ) (this._elapsed -= O), this.step(J);
            }
          },
          step: function (J) {
            var L,
              O = this.bodies.entries,
              Q = O.length;
            for (L = 0; L < Q; L++) {
              var S = O[L];
              S.enable && S.update(J);
            }
            this.useTree && (this.tree.clear(), this.tree.load(O));
            S = this.colliders.update();
            for (L = 0; L < S.length; L++) (O = S[L]), O.active && O.update();
            this.emit(m.WORLD_STEP, J);
            this.stepsLastFrame++;
          },
          postUpdate: function () {
            var J,
              L = this.bodies.entries,
              O = L.length,
              Q = this.bodies,
              S = this.staticBodies;
            if (this.stepsLastFrame)
              for (J = this.stepsLastFrame = 0; J < O; J++) {
                var R = L[J];
                R.enable && R.postUpdate();
              }
            if (this.drawDebug) {
              var T = this.debugGraphic;
              T.clear();
              for (J = 0; J < O; J++)
                (R = L[J]), R.willDrawDebug() && R.drawDebug(T);
              L = S.entries;
              O = L.length;
              for (J = 0; J < O; J++)
                (R = L[J]), R.willDrawDebug() && R.drawDebug(T);
            }
            T = this.pendingDestroy;
            if (0 < T.size) {
              var U = this.tree,
                V = this.staticTree;
              L = T.entries;
              O = L.length;
              for (J = 0; J < O; J++)
                (R = L[J]),
                  R.physicsType === c.DYNAMIC_BODY
                    ? (U.remove(R), Q.delete(R))
                    : R.physicsType === c.STATIC_BODY &&
                      (V.remove(R), S.delete(R)),
                  (R.world = void 0),
                  (R.gameObject = void 0);
              T.clear();
            }
          },
          updateMotion: function (J, L) {
            J.allowRotation && this.computeAngularVelocity(J, L);
            this.computeVelocity(J, L);
          },
          computeAngularVelocity: function (J, L) {
            var O = J.angularVelocity,
              Q = J.angularAcceleration,
              S = J.angularDrag,
              R = J.maxAngular;
            Q
              ? (O += Q * L)
              : J.allowDrag &&
                S &&
                ((S *= L),
                (O = q(O - S, 0, 0.1) ? O - S : r(O + S, 0, 0.1) ? O + S : 0));
            O = e(O, -R, R);
            J.angularVelocity += O - J.angularVelocity;
            J.rotation += J.angularVelocity * L;
          },
          computeVelocity: function (J, L) {
            var O = J.velocity.x,
              Q = J.acceleration.x,
              S = J.drag.x,
              R = J.maxVelocity.x,
              T = J.velocity.y,
              U = J.acceleration.y,
              V = J.drag.y,
              X = J.maxVelocity.y,
              W = J.speed,
              Z = J.maxSpeed,
              aa = J.allowDrag,
              Y = J.useDamping;
            J.allowGravity &&
              ((O += (this.gravity.x + J.gravity.x) * L),
              (T += (this.gravity.y + J.gravity.y) * L));
            Q
              ? (O += Q * L)
              : aa &&
                S &&
                (Y
                  ? ((S = Math.pow(S, L)),
                    (O *= S),
                    (W = Math.sqrt(O * O + T * T)),
                    n(W, 0, 0.001) && (O = 0))
                  : ((S *= L),
                    (O = q(O - S, 0, 0.01)
                      ? O - S
                      : r(O + S, 0, 0.01)
                      ? O + S
                      : 0)));
            U
              ? (T += U * L)
              : aa &&
                V &&
                (Y
                  ? ((V = Math.pow(V, L)),
                    (T *= V),
                    (W = Math.sqrt(O * O + T * T)),
                    n(W, 0, 0.001) && (T = 0))
                  : ((V *= L),
                    (T = q(T - V, 0, 0.01)
                      ? T - V
                      : r(T + V, 0, 0.01)
                      ? T + V
                      : 0)));
            O = e(O, -R, R);
            T = e(T, -X, X);
            J.velocity.set(O, T);
            -1 < Z && W > Z && (J.velocity.normalize().scale(Z), (W = Z));
            J.speed = W;
          },
          separate: function (J, L, O, Q, S, R) {
            if (
              (!R && !J.enable) ||
              !L.enable ||
              J.checkCollision.none ||
              L.checkCollision.none ||
              !this.intersects(J, L) ||
              (O && !1 === O.call(Q, J.gameObject, L.gameObject))
            )
              return !1;
            if (J.isCircle && L.isCircle) return this.separateCircle(J, L, S);
            if (J.isCircle !== L.isCircle) {
              O = J.isCircle ? L : J;
              Q = O.x;
              R = O.right;
              var T = O.bottom,
                U = (J.isCircle ? J : L).center;
              if (U.y < O.y || U.y > T)
                if (U.x < Q || U.x > R) return this.separateCircle(J, L, S);
            }
            Q = O = !1;
            S
              ? ((O = F(J, L, S, this.OVERLAP_BIAS)),
                (Q = G(J, L, S, this.OVERLAP_BIAS)))
              : this.forceX ||
                Math.abs(this.gravity.y + J.gravity.y) <
                  Math.abs(this.gravity.x + J.gravity.x)
              ? ((O = F(J, L, S, this.OVERLAP_BIAS)),
                this.intersects(J, L) && (Q = G(J, L, S, this.OVERLAP_BIAS)))
              : ((Q = G(J, L, S, this.OVERLAP_BIAS)),
                this.intersects(J, L) && (O = F(J, L, S, this.OVERLAP_BIAS)));
            (O = O || Q) &&
              (S
                ? (J.onOverlap || L.onOverlap) &&
                  this.emit(m.OVERLAP, J.gameObject, L.gameObject, J, L)
                : (J.onCollide || L.onCollide) &&
                  this.emit(m.COLLIDE, J.gameObject, L.gameObject, J, L));
            return O;
          },
          separateCircle: function (J, L, O, Q) {
            u(J, L, !1, Q);
            v(J, L, !1, Q);
            Q = 0;
            if (J.isCircle !== L.isCircle) {
              var S = L.isCircle ? J.position.x : L.position.x,
                R = L.isCircle ? J.position.y : L.position.y,
                T = L.isCircle ? J.right : L.right,
                U = L.isCircle ? J.bottom : L.bottom,
                V = J.isCircle ? J.center.x : L.center.x,
                X = J.isCircle ? J.center.y : L.center.y,
                W = J.isCircle ? J.halfWidth : L.halfWidth;
              X < R
                ? V < S
                  ? (Q = f(V, X, S, R) - W)
                  : V > T && (Q = f(V, X, T, R) - W)
                : X > U &&
                  (V < S
                    ? (Q = f(V, X, S, U) - W)
                    : V > T && (Q = f(V, X, T, U) - W));
              Q *= -1;
            } else
              Q =
                J.halfWidth +
                L.halfWidth -
                f(J.center.x, J.center.y, L.center.x, L.center.y);
            J.overlapR = Q;
            L.overlapR = Q;
            if (
              O ||
              0 === Q ||
              (J.immovable && L.immovable) ||
              J.customSeparateX ||
              L.customSeparateX
            )
              return (
                0 !== Q &&
                  (J.onOverlap || L.onOverlap) &&
                  this.emit(m.OVERLAP, J.gameObject, L.gameObject, J, L),
                0 !== Q
              );
            S = Math.sqrt(
              Math.pow(J.center.x - L.center.x, 2) +
                Math.pow(J.center.y - L.center.y, 2)
            );
            O = (L.center.x - J.center.x) / S || 0;
            S = (L.center.y - J.center.y) / S || 0;
            R =
              (2 *
                (J.velocity.x * O +
                  J.velocity.y * S -
                  L.velocity.x * O -
                  L.velocity.y * S)) /
              (J.mass + L.mass);
            if (J.immovable || L.immovable) R *= 2;
            J.immovable ||
              ((J.velocity.x -= (R / J.mass) * O),
              (J.velocity.y -= (R / J.mass) * S));
            L.immovable ||
              ((L.velocity.x += (R / L.mass) * O),
              (L.velocity.y += (R / L.mass) * S));
            J.immovable || L.immovable || (Q /= 2);
            S = d(J.center, L.center);
            O = (Q + z.EPSILON) * Math.cos(S);
            Q = (Q + z.EPSILON) * Math.sin(S);
            J.immovable || ((J.x -= O), (J.y -= Q), J.updateCenter());
            L.immovable || ((L.x += O), (L.y += Q), L.updateCenter());
            J.velocity.x *= J.bounce.x;
            J.velocity.y *= J.bounce.y;
            L.velocity.x *= L.bounce.x;
            L.velocity.y *= L.bounce.y;
            (J.onCollide || L.onCollide) &&
              this.emit(m.COLLIDE, J.gameObject, L.gameObject, J, L);
            return !0;
          },
          intersects: function (J, L) {
            return J === L
              ? !1
              : J.isCircle || L.isCircle
              ? J.isCircle
                ? L.isCircle
                  ? f(J.center.x, J.center.y, L.center.x, L.center.y) <=
                    J.halfWidth + L.halfWidth
                  : this.circleBodyIntersects(J, L)
                : this.circleBodyIntersects(L, J)
              : !(
                  J.right <= L.position.x ||
                  J.bottom <= L.position.y ||
                  J.position.x >= L.right ||
                  J.position.y >= L.bottom
                );
          },
          circleBodyIntersects: function (J, L) {
            var O = e(J.center.x, L.left, L.right);
            L = e(J.center.y, L.top, L.bottom);
            return (
              (J.center.x - O) * (J.center.x - O) +
                (J.center.y - L) * (J.center.y - L) <=
              J.halfWidth * J.halfWidth
            );
          },
          overlap: function (J, L, O, Q, S) {
            void 0 === O && (O = null);
            void 0 === Q && (Q = null);
            void 0 === S && (S = O);
            return this.collideObjects(J, L, O, Q, S, !0);
          },
          collide: function (J, L, O, Q, S) {
            void 0 === O && (O = null);
            void 0 === Q && (Q = null);
            void 0 === S && (S = O);
            return this.collideObjects(J, L, O, Q, S, !1);
          },
          collideObjects: function (J, L, O, Q, S, R) {
            J.isParent && void 0 === J.physicsType && (J = J.children.entries);
            L &&
              L.isParent &&
              void 0 === L.physicsType &&
              (L = L.children.entries);
            var T = Array.isArray(J);
            var U = Array.isArray(L);
            this._total = 0;
            if (T || U)
              if (!T && U)
                for (T = 0; T < L.length; T++)
                  this.collideHandler(J, L[T], O, Q, S, R);
              else if (T && !U)
                if (L)
                  for (T = 0; T < J.length; T++)
                    this.collideHandler(J[T], L, O, Q, S, R);
                else
                  for (T = 0; T < J.length; T++)
                    for (L = J[T], U = T + 1; U < J.length; U++)
                      T !== U && this.collideHandler(L, J[U], O, Q, S, R);
              else
                for (T = 0; T < J.length; T++)
                  for (U = 0; U < L.length; U++)
                    this.collideHandler(J[T], L[U], O, Q, S, R);
            else this.collideHandler(J, L, O, Q, S, R);
            return 0 < this._total;
          },
          collideHandler: function (J, L, O, Q, S, R) {
            if (void 0 === L && J.isParent)
              return this.collideGroupVsGroup(J, J, O, Q, S, R);
            if (!J || !L) return !1;
            if (J.body) {
              if (L.body) return this.collideSpriteVsSprite(J, L, O, Q, S, R);
              if (L.isParent)
                return this.collideSpriteVsGroup(J, L, O, Q, S, R);
              if (L.isTilemap)
                return this.collideSpriteVsTilemapLayer(J, L, O, Q, S, R);
            } else if (J.isParent) {
              if (L.body) return this.collideSpriteVsGroup(L, J, O, Q, S, R);
              if (L.isParent) return this.collideGroupVsGroup(J, L, O, Q, S, R);
              if (L.isTilemap)
                return this.collideGroupVsTilemapLayer(J, L, O, Q, S, R);
            } else if (J.isTilemap) {
              if (L.body)
                return this.collideSpriteVsTilemapLayer(L, J, O, Q, S, R);
              if (L.isParent)
                return this.collideGroupVsTilemapLayer(L, J, O, Q, S, R);
            }
          },
          collideSpriteVsSprite: function (J, L, O, Q, S, R) {
            if (!J.body || !L.body) return !1;
            this.separate(J.body, L.body, Q, S, R) &&
              (O && O.call(S, J, L), this._total++);
            return !0;
          },
          collideSpriteVsGroup: function (J, L, O, Q, S, R) {
            var T = J.body;
            if (0 !== L.length && T && T.enable && !T.checkCollision.none)
              if (this.useTree || L.physicsType === c.STATIC_BODY) {
                J = this.treeMinMax;
                J.minX = T.left;
                J.minY = T.top;
                J.maxX = T.right;
                J.maxY = T.bottom;
                var U =
                  L.physicsType === c.DYNAMIC_BODY
                    ? this.tree.search(J)
                    : this.staticTree.search(J);
                var V = U.length;
                for (J = 0; J < V; J++) {
                  var X = U[J];
                  T !== X &&
                    X.enable &&
                    !X.checkCollision.none &&
                    L.contains(X.gameObject) &&
                    this.separate(T, X, Q, S, R, !0) &&
                    (O && O.call(S, T.gameObject, X.gameObject), this._total++);
                }
              } else
                for (
                  U = L.getChildren(),
                    L = L.children.entries.indexOf(J),
                    V = U.length,
                    J = 0;
                  J < V;
                  J++
                )
                  (X = U[J].body) &&
                    J !== L &&
                    X.enable &&
                    this.separate(T, X, Q, S, R) &&
                    (O && O.call(S, T.gameObject, X.gameObject), this._total++);
          },
          collideGroupVsTilemapLayer: function (J, L, O, Q, S, R) {
            J = J.getChildren();
            if (0 === J.length) return !1;
            for (var T = !1, U = 0; U < J.length; U++)
              J[U].body &&
                this.collideSpriteVsTilemapLayer(J[U], L, O, Q, S, R) &&
                (T = !0);
            return T;
          },
          collideTiles: function (J, L, O, Q, S) {
            return J.body.enable && 0 !== L.length
              ? this.collideSpriteVsTilesHandler(J, L, O, Q, S, !1, !1)
              : !1;
          },
          overlapTiles: function (J, L, O, Q, S) {
            return J.body.enable && 0 !== L.length
              ? this.collideSpriteVsTilesHandler(J, L, O, Q, S, !0, !1)
              : !1;
          },
          collideSpriteVsTilemapLayer: function (J, L, O, Q, S, R) {
            var T = J.body;
            if (!T.enable || T.checkCollision.none) return !1;
            var U = T.position.x,
              V = T.position.y,
              X = T.width;
            T = T.height;
            var W = L.layer;
            if (W.tileWidth > W.baseTileWidth) {
              var Z = (W.tileWidth - W.baseTileWidth) * L.scaleX;
              U -= Z;
              X += Z;
            }
            W.tileHeight > W.baseTileHeight &&
              (T += (W.tileHeight - W.baseTileHeight) * L.scaleY);
            L = x(U, V, X, T, null, L.scene.cameras.main, L.layer);
            return 0 === L.length
              ? !1
              : this.collideSpriteVsTilesHandler(J, L, O, Q, S, R, !0);
          },
          collideSpriteVsTilesHandler: function (J, L, O, Q, S, R, T) {
            for (
              var U = J.body,
                V,
                X = {
                  left: 0,
                  right: 0,
                  top: 0,
                  bottom: 0,
                },
                W,
                Z = !1,
                aa = 0;
              aa < L.length;
              aa++
            ) {
              V = L[aa];
              W = V.tilemapLayer;
              var Y = W.tileToWorldXY(V.x, V.y);
              X.left = Y.x;
              X.top = Y.y;
              V.baseHeight !== V.height &&
                (X.top -= (V.height - V.baseHeight) * W.scaleY);
              X.right = X.left + V.width * W.scaleX;
              X.bottom = X.top + V.height * W.scaleY;
              I(X, U) &&
                (!Q || Q.call(S, J, V)) &&
                B(V, J) &&
                (R || C(aa, U, V, X, W, this.TILE_BIAS, T)) &&
                (this._total++,
                (Z = !0),
                O && O.call(S, J, V),
                R && U.onOverlap
                  ? this.emit(m.TILE_OVERLAP, J, V, U)
                  : U.onCollide && this.emit(m.TILE_COLLIDE, J, V, U));
            }
            return Z;
          },
          collideGroupVsGroup: function (J, L, O, Q, S, R) {
            if (0 !== J.length && 0 !== L.length) {
              J = J.getChildren();
              for (var T = 0; T < J.length; T++)
                this.collideSpriteVsGroup(J[T], L, O, Q, S, R);
            }
          },
          wrap: function (J, L) {
            J.body
              ? this.wrapObject(J, L)
              : J.getChildren
              ? this.wrapArray(J.getChildren(), L)
              : Array.isArray(J)
              ? this.wrapArray(J, L)
              : this.wrapObject(J, L);
          },
          wrapArray: function (J, L) {
            for (var O = 0; O < J.length; O++) this.wrapObject(J[O], L);
          },
          wrapObject: function (J, L) {
            void 0 === L && (L = 0);
            J.x = P(J.x, this.bounds.left - L, this.bounds.right + L);
            J.y = P(J.y, this.bounds.top - L, this.bounds.bottom + L);
          },
          shutdown: function () {
            this.tree.clear();
            this.staticTree.clear();
            this.bodies.clear();
            this.staticBodies.clear();
            this.colliders.destroy();
            this.removeAllListeners();
          },
          destroy: function () {
            this.shutdown();
            this.scene = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(62),
          k = a(245),
          e = a(196),
          b = a(10),
          c = a(57),
          f = a(3);
        a = new t({
          initialize: function (g, m) {
            var n = m.displayWidth ? m.displayWidth : 64,
              q = m.displayHeight ? m.displayHeight : 64;
            this.world = g;
            this.gameObject = m;
            this.transform = {
              x: m.x,
              y: m.y,
              rotation: m.angle,
              scaleX: m.scaleX,
              scaleY: m.scaleY,
              displayOriginX: m.displayOriginX,
              displayOriginY: m.displayOriginY,
            };
            this.debugShowBody = g.defaults.debugShowBody;
            this.debugShowVelocity = g.defaults.debugShowVelocity;
            this.debugBodyColor = g.defaults.bodyDebugColor;
            this.enable = !0;
            this.isCircle = !1;
            this.radius = 0;
            this.offset = new f();
            this.position = new f(
              m.x - m.scaleX * m.displayOriginX,
              m.y - m.scaleY * m.displayOriginY
            );
            this.prev = this.position.clone();
            this.prevFrame = this.position.clone();
            this.allowRotation = !0;
            this.preRotation = this.rotation = m.angle;
            this.width = n;
            this.height = q;
            this.sourceWidth = n;
            this.sourceHeight = q;
            m.frame &&
              ((this.sourceWidth = m.frame.realWidth),
              (this.sourceHeight = m.frame.realHeight));
            this.halfWidth = Math.abs(n / 2);
            this.halfHeight = Math.abs(q / 2);
            this.center = new f(
              this.position.x + this.halfWidth,
              this.position.y + this.halfHeight
            );
            this.velocity = new f();
            this.newVelocity = new f();
            this.deltaMax = new f();
            this.acceleration = new f();
            this.allowDrag = !0;
            this.drag = new f();
            this.allowGravity = !0;
            this.gravity = new f();
            this.bounce = new f();
            this.worldBounce = null;
            this.customBoundsRectangle = g.bounds;
            this.onOverlap = this.onCollide = this.onWorldBounds = !1;
            this.maxVelocity = new f(1e4, 1e4);
            this.maxSpeed = -1;
            this.friction = new f(1, 0);
            this.useDamping = !1;
            this.angularDrag =
              this.angularAcceleration =
              this.angularVelocity =
                0;
            this.maxAngular = 1e3;
            this.mass = 1;
            this.speed = this.angle = 0;
            this.facing = d.FACING_NONE;
            this.immovable = !1;
            this.moves = this.pushable = !0;
            this.customSeparateY = this.customSeparateX = !1;
            this.overlapR = this.overlapY = this.overlapX = 0;
            this.collideWorldBounds = this.embedded = !1;
            this.checkCollision = {
              none: !1,
              up: !0,
              down: !0,
              left: !0,
              right: !0,
            };
            this.touching = {
              none: !0,
              up: !1,
              down: !1,
              left: !1,
              right: !1,
            };
            this.wasTouching = {
              none: !0,
              up: !1,
              down: !1,
              left: !1,
              right: !1,
            };
            this.blocked = {
              none: !0,
              up: !1,
              down: !1,
              left: !1,
              right: !1,
            };
            this.syncBounds = !1;
            this.physicsType = d.DYNAMIC_BODY;
            this._sx = m.scaleX;
            this._sy = m.scaleY;
            this._ty = this._tx = this._dy = this._dx = 0;
            this._bounds = new b();
          },
          updateBounds: function () {
            var g = this.gameObject,
              m = this.transform;
            if (g.parentContainer) {
              var n = g.getWorldTransformMatrix(
                this.world._tempMatrix,
                this.world._tempMatrix2
              );
              m.x = n.tx;
              m.y = n.ty;
              m.rotation = e(n.rotation);
              m.scaleX = n.scaleX;
              m.scaleY = n.scaleY;
            } else
              (m.x = g.x),
                (m.y = g.y),
                (m.rotation = g.angle),
                (m.scaleX = g.scaleX),
                (m.scaleY = g.scaleY);
            m.displayOriginX = g.displayOriginX;
            m.displayOriginY = g.displayOriginY;
            n = !1;
            if (this.syncBounds)
              (m = g.getBounds(this._bounds)),
                (this.width = m.width),
                (this.height = m.height),
                (n = !0);
            else if (
              ((g = Math.abs(m.scaleX)),
              (m = Math.abs(m.scaleY)),
              this._sx !== g || this._sy !== m)
            )
              (this.width = this.sourceWidth * g),
                (this.height = this.sourceHeight * m),
                (this._sx = g),
                (this._sy = m),
                (n = !0);
            n &&
              ((this.halfWidth = Math.floor(this.width / 2)),
              (this.halfHeight = Math.floor(this.height / 2)),
              this.updateCenter());
          },
          updateCenter: function () {
            this.center.set(
              this.position.x + this.halfWidth,
              this.position.y + this.halfHeight
            );
          },
          updateFromGameObject: function () {
            this.updateBounds();
            var g = this.transform;
            this.position.x =
              g.x + g.scaleX * (this.offset.x - g.displayOriginX);
            this.position.y =
              g.y + g.scaleY * (this.offset.y - g.displayOriginY);
            this.updateCenter();
          },
          resetFlags: function (g) {
            void 0 === g && (g = !1);
            var m = this.wasTouching,
              n = this.touching,
              q = this.blocked;
            g
              ? ((m.none = !0),
                (m.up = !1),
                (m.down = !1),
                (m.left = !1),
                (m.right = !1))
              : ((m.none = n.none),
                (m.up = n.up),
                (m.down = n.down),
                (m.left = n.left),
                (m.right = n.right));
            n.none = !0;
            n.up = !1;
            n.down = !1;
            n.left = !1;
            n.right = !1;
            q.none = !0;
            q.up = !1;
            q.down = !1;
            q.left = !1;
            q.right = !1;
            this.overlapY = this.overlapX = this.overlapR = 0;
            this.embedded = !1;
          },
          preUpdate: function (g, m) {
            g && this.resetFlags();
            this.updateFromGameObject();
            this.preRotation = this.rotation = this.transform.rotation;
            this.moves &&
              ((this.prev.x = this.position.x),
              (this.prev.y = this.position.y),
              (this.prevFrame.x = this.position.x),
              (this.prevFrame.y = this.position.y));
            g && this.update(m);
          },
          update: function (g) {
            this.prev.x = this.position.x;
            this.prev.y = this.position.y;
            if (this.moves) {
              this.world.updateMotion(this, g);
              var m = this.velocity.x,
                n = this.velocity.y;
              this.newVelocity.set(m * g, n * g);
              this.position.add(this.newVelocity);
              this.updateCenter();
              this.angle = Math.atan2(n, m);
              this.speed = Math.sqrt(m * m + n * n);
              this.collideWorldBounds &&
                this.checkWorldBounds() &&
                this.onWorldBounds &&
                this.world.emit(
                  k.WORLD_BOUNDS,
                  this,
                  this.blocked.up,
                  this.blocked.down,
                  this.blocked.left,
                  this.blocked.right
                );
            }
            this._dx = this.position.x - this.prev.x;
            this._dy = this.position.y - this.prev.y;
          },
          postUpdate: function () {
            var g = this.position.x - this.prevFrame.x,
              m = this.position.y - this.prevFrame.y;
            if (this.moves) {
              var n = this.deltaMax.x,
                q = this.deltaMax.y;
              0 !== n &&
                0 !== g &&
                (0 > g && g < -n ? (g = -n) : 0 < g && g > n && (g = n));
              0 !== q &&
                0 !== m &&
                (0 > m && m < -q ? (m = -q) : 0 < m && m > q && (m = q));
              this.gameObject.x += g;
              this.gameObject.y += m;
            }
            0 > g
              ? (this.facing = d.FACING_LEFT)
              : 0 < g && (this.facing = d.FACING_RIGHT);
            0 > m
              ? (this.facing = d.FACING_UP)
              : 0 < m && (this.facing = d.FACING_DOWN);
            this.allowRotation && (this.gameObject.angle += this.deltaZ());
            this._tx = g;
            this._ty = m;
          },
          setBoundsRectangle: function (g) {
            this.customBoundsRectangle = g ? g : this.world.bounds;
            return this;
          },
          checkWorldBounds: function () {
            var g = this.position,
              m = this.customBoundsRectangle,
              n = this.world.checkCollision,
              q = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
              r = this.worldBounce ? -this.worldBounce.y : -this.bounce.y,
              u = !1;
            g.x < m.x && n.left
              ? ((g.x = m.x),
                (this.velocity.x *= q),
                (u = this.blocked.left = !0))
              : this.right > m.right &&
                n.right &&
                ((g.x = m.right - this.width),
                (this.velocity.x *= q),
                (u = this.blocked.right = !0));
            g.y < m.y && n.up
              ? ((g.y = m.y),
                (this.velocity.y *= r),
                (u = this.blocked.up = !0))
              : this.bottom > m.bottom &&
                n.down &&
                ((g.y = m.bottom - this.height),
                (this.velocity.y *= r),
                (u = this.blocked.down = !0));
            u && ((this.blocked.none = !1), this.updateCenter());
            return u;
          },
          setOffset: function (g, m) {
            void 0 === m && (m = g);
            this.offset.set(g, m);
            return this;
          },
          setSize: function (g, m, n) {
            void 0 === n && (n = !0);
            var q = this.gameObject;
            !g && q.frame && (g = q.frame.realWidth);
            !m && q.frame && (m = q.frame.realHeight);
            this.sourceWidth = g;
            this.sourceHeight = m;
            this.width = this.sourceWidth * this._sx;
            this.height = this.sourceHeight * this._sy;
            this.halfWidth = Math.floor(this.width / 2);
            this.halfHeight = Math.floor(this.height / 2);
            this.updateCenter();
            n &&
              q.getCenter &&
              this.offset.set((q.width - g) / 2, (q.height - m) / 2);
            this.isCircle = !1;
            this.radius = 0;
            return this;
          },
          setCircle: function (g, m, n) {
            void 0 === m && (m = this.offset.x);
            void 0 === n && (n = this.offset.y);
            0 < g
              ? ((this.isCircle = !0),
                (this.radius = g),
                (this.sourceWidth = 2 * g),
                (this.sourceHeight = 2 * g),
                (this.width = this.sourceWidth * this._sx),
                (this.height = this.sourceHeight * this._sy),
                (this.halfWidth = Math.floor(this.width / 2)),
                (this.halfHeight = Math.floor(this.height / 2)),
                this.offset.set(m, n),
                this.updateCenter())
              : (this.isCircle = !1);
            return this;
          },
          reset: function (g, m) {
            this.stop();
            var n = this.gameObject;
            n.setPosition(g, m);
            n.getTopLeft
              ? n.getTopLeft(this.position)
              : this.position.set(g, m);
            this.prev.copy(this.position);
            this.prevFrame.copy(this.position);
            this.preRotation = this.rotation = n.angle;
            this.updateBounds();
            this.updateCenter();
            this.resetFlags(!0);
          },
          stop: function () {
            this.velocity.set(0);
            this.acceleration.set(0);
            this.angularAcceleration = this.angularVelocity = this.speed = 0;
            return this;
          },
          getBounds: function (g) {
            g.x = this.x;
            g.y = this.y;
            g.right = this.right;
            g.bottom = this.bottom;
            return g;
          },
          hitTest: function (g, m) {
            return this.isCircle
              ? 0 < this.radius &&
                g >= this.left &&
                g <= this.right &&
                m >= this.top &&
                m <= this.bottom
                ? (this.center.x - g) * (this.center.x - g) +
                    (this.center.y - m) * (this.center.y - m) <=
                  this.radius * this.radius
                : !1
              : c(this, g, m);
          },
          onFloor: function () {
            return this.blocked.down;
          },
          onCeiling: function () {
            return this.blocked.up;
          },
          onWall: function () {
            return this.blocked.left || this.blocked.right;
          },
          deltaAbsX: function () {
            return 0 < this._dx ? this._dx : -this._dx;
          },
          deltaAbsY: function () {
            return 0 < this._dy ? this._dy : -this._dy;
          },
          deltaX: function () {
            return this._dx;
          },
          deltaY: function () {
            return this._dy;
          },
          deltaXFinal: function () {
            return this._tx;
          },
          deltaYFinal: function () {
            return this._ty;
          },
          deltaZ: function () {
            return this.rotation - this.preRotation;
          },
          destroy: function () {
            this.enable = !1;
            this.world && this.world.pendingDestroy.set(this);
          },
          drawDebug: function (g) {
            var m = this.position,
              n = m.x + this.halfWidth,
              q = m.y + this.halfHeight;
            this.debugShowBody &&
              (g.lineStyle(g.defaultStrokeWidth, this.debugBodyColor),
              this.isCircle
                ? g.strokeCircle(n, q, this.width / 2)
                : (this.checkCollision.up &&
                    g.lineBetween(m.x, m.y, m.x + this.width, m.y),
                  this.checkCollision.right &&
                    g.lineBetween(
                      m.x + this.width,
                      m.y,
                      m.x + this.width,
                      m.y + this.height
                    ),
                  this.checkCollision.down &&
                    g.lineBetween(
                      m.x,
                      m.y + this.height,
                      m.x + this.width,
                      m.y + this.height
                    ),
                  this.checkCollision.left &&
                    g.lineBetween(m.x, m.y, m.x, m.y + this.height)));
            this.debugShowVelocity &&
              (g.lineStyle(
                g.defaultStrokeWidth,
                this.world.defaults.velocityDebugColor,
                1
              ),
              g.lineBetween(
                n,
                q,
                n + this.velocity.x / 2,
                q + this.velocity.y / 2
              ));
          },
          willDrawDebug: function () {
            return this.debugShowBody || this.debugShowVelocity;
          },
          setCollideWorldBounds: function (g, m, n, q) {
            void 0 === g && (g = !0);
            this.collideWorldBounds = g;
            g = void 0 !== m;
            var r = void 0 !== n;
            if (g || r)
              this.worldBounce || (this.worldBounce = new f()),
                g && (this.worldBounce.x = m),
                r && (this.worldBounce.y = n);
            void 0 !== q && (this.onWorldBounds = q);
            return this;
          },
          setVelocity: function (g, m) {
            this.velocity.set(g, m);
            g = this.velocity.x;
            m = this.velocity.y;
            this.speed = Math.sqrt(g * g + m * m);
            return this;
          },
          setVelocityX: function (g) {
            this.velocity.x = g;
            var m = this.velocity.y;
            this.speed = Math.sqrt(g * g + m * m);
            return this;
          },
          setVelocityY: function (g) {
            this.velocity.y = g;
            var m = this.velocity.x;
            this.speed = Math.sqrt(m * m + g * g);
            return this;
          },
          setMaxVelocity: function (g, m) {
            this.maxVelocity.set(g, m);
            return this;
          },
          setMaxVelocityX: function (g) {
            this.maxVelocity.x = g;
            return this;
          },
          setMaxVelocityY: function (g) {
            this.maxVelocity.y = g;
            return this;
          },
          setMaxSpeed: function (g) {
            this.maxSpeed = g;
            return this;
          },
          setBounce: function (g, m) {
            this.bounce.set(g, m);
            return this;
          },
          setBounceX: function (g) {
            this.bounce.x = g;
            return this;
          },
          setBounceY: function (g) {
            this.bounce.y = g;
            return this;
          },
          setAcceleration: function (g, m) {
            this.acceleration.set(g, m);
            return this;
          },
          setAccelerationX: function (g) {
            this.acceleration.x = g;
            return this;
          },
          setAccelerationY: function (g) {
            this.acceleration.y = g;
            return this;
          },
          setAllowDrag: function (g) {
            void 0 === g && (g = !0);
            this.allowDrag = g;
            return this;
          },
          setAllowGravity: function (g) {
            void 0 === g && (g = !0);
            this.allowGravity = g;
            return this;
          },
          setAllowRotation: function (g) {
            void 0 === g && (g = !0);
            this.allowRotation = g;
            return this;
          },
          setDrag: function (g, m) {
            this.drag.set(g, m);
            return this;
          },
          setDamping: function (g) {
            this.useDamping = g;
            return this;
          },
          setDragX: function (g) {
            this.drag.x = g;
            return this;
          },
          setDragY: function (g) {
            this.drag.y = g;
            return this;
          },
          setGravity: function (g, m) {
            this.gravity.set(g, m);
            return this;
          },
          setGravityX: function (g) {
            this.gravity.x = g;
            return this;
          },
          setGravityY: function (g) {
            this.gravity.y = g;
            return this;
          },
          setFriction: function (g, m) {
            this.friction.set(g, m);
            return this;
          },
          setFrictionX: function (g) {
            this.friction.x = g;
            return this;
          },
          setFrictionY: function (g) {
            this.friction.y = g;
            return this;
          },
          setAngularVelocity: function (g) {
            this.angularVelocity = g;
            return this;
          },
          setAngularAcceleration: function (g) {
            this.angularAcceleration = g;
            return this;
          },
          setAngularDrag: function (g) {
            this.angularDrag = g;
            return this;
          },
          setMass: function (g) {
            this.mass = g;
            return this;
          },
          setImmovable: function (g) {
            void 0 === g && (g = !0);
            this.immovable = g;
            return this;
          },
          setEnable: function (g) {
            void 0 === g && (g = !0);
            this.enable = g;
            return this;
          },
          processX: function (g, m, n, q) {
            this.x += g;
            this.updateCenter();
            null !== m && (this.velocity.x = m);
            g = this.blocked;
            n && (g.left = !0);
            q && (g.right = !0);
          },
          processY: function (g, m, n, q) {
            this.y += g;
            this.updateCenter();
            null !== m && (this.velocity.y = m);
            g = this.blocked;
            n && (g.up = !0);
            q && (g.down = !0);
          },
          x: {
            get: function () {
              return this.position.x;
            },
            set: function (g) {
              this.position.x = g;
            },
          },
          y: {
            get: function () {
              return this.position.y;
            },
            set: function (g) {
              this.position.y = g;
            },
          },
          left: {
            get: function () {
              return this.position.x;
            },
          },
          right: {
            get: function () {
              return this.position.x + this.width;
            },
          },
          top: {
            get: function () {
              return this.position.y;
            },
          },
          bottom: {
            get: function () {
              return this.position.y + this.height;
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = new (a(0))({
          initialize: function (d, k, e, b, c, f, g) {
            this.world = d;
            this.name = "";
            this.active = !0;
            this.overlapOnly = k;
            this.object1 = e;
            this.object2 = b;
            this.collideCallback = c;
            this.processCallback = f;
            this.callbackContext = g;
          },
          setName: function (d) {
            this.name = d;
            return this;
          },
          update: function () {
            this.world.collideObjects(
              this.object1,
              this.object2,
              this.collideCallback,
              this.processCallback,
              this.callbackContext,
              this.overlapOnly
            );
          },
          destroy: function () {
            this.world.removeCollider(this);
            this.active = !1;
            this.callbackContext =
              this.processCallback =
              this.collideCallback =
              this.object2 =
              this.object1 =
              this.world =
                null;
          },
        });
        h.exports = t;
      },
      function (h, t, a) {
        var d = a(26);
        t = a(3);
        var k = new t(),
          e = new t();
        h.exports = function (b, c, f, g, m, n, q) {
          var r = q.tilemapLayer.tilemap._convert.WorldToTileXY;
          r(b, c, !0, k, n, q);
          var u = k.x,
            v = k.y;
          r(b + f, c + g, !1, e, n, q);
          return d(u, v, Math.ceil(e.x) - u, Math.ceil(e.y) - v, m, q);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return a.collisionCallback
            ? !a.collisionCallback.call(a.collisionCallbackContext, d, a)
            : a.layer.callbacks[a.index]
            ? !a.layer.callbacks[a.index].callback.call(
                a.layer.callbacks[a.index].callbackContext,
                d,
                a
              )
            : !0;
        };
      },
      function (h, t, a) {
        function d(x) {
          if (!(this instanceof d)) return new d(x);
          this._maxEntries = Math.max(4, x || 9);
          this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries));
          this.clear();
        }

        function k(x, y) {
          e(x, 0, x.children.length, y, x);
        }

        function e(x, y, z, A, B) {
          B || (B = r(null));
          B.minX = Infinity;
          B.minY = Infinity;
          B.maxX = -Infinity;
          B.maxY = -Infinity;
          for (var D; y < z; y++) (D = x.children[y]), b(B, x.leaf ? A(D) : D);
          return B;
        }

        function b(x, y) {
          x.minX = Math.min(x.minX, y.minX);
          x.minY = Math.min(x.minY, y.minY);
          x.maxX = Math.max(x.maxX, y.maxX);
          x.maxY = Math.max(x.maxY, y.maxY);
          return x;
        }

        function c(x, y) {
          return x.minX - y.minX;
        }

        function f(x, y) {
          return x.minY - y.minY;
        }

        function g(x) {
          return (x.maxX - x.minX) * (x.maxY - x.minY);
        }

        function m(x) {
          return x.maxX - x.minX + (x.maxY - x.minY);
        }

        function n(x, y) {
          return (
            x.minX <= y.minX &&
            x.minY <= y.minY &&
            y.maxX <= x.maxX &&
            y.maxY <= x.maxY
          );
        }

        function q(x, y) {
          return (
            y.minX <= x.maxX &&
            y.minY <= x.maxY &&
            y.maxX >= x.minX &&
            y.maxY >= x.minY
          );
        }

        function r(x) {
          return {
            children: x,
            height: 1,
            leaf: !0,
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity,
          };
        }

        function u(x, y, z, A, B) {
          for (var D = [y, z], E; D.length; )
            (z = D.pop()),
              (y = D.pop()),
              z - y <= A ||
                ((E = y + Math.ceil((z - y) / A / 2) * A),
                v(x, E, y, z, B),
                D.push(y, E, E, z));
        }
        var v = a(436);
        d.prototype = {
          all: function () {
            return this._all(this.data, []);
          },
          search: function (x) {
            var y = this.data,
              z = [],
              A = this.toBBox;
            if (!q(x, y)) return z;
            for (var B = [], D, E, C, F; y; ) {
              D = 0;
              for (E = y.children.length; D < E; D++)
                (C = y.children[D]),
                  (F = y.leaf ? A(C) : C),
                  q(x, F) &&
                    (y.leaf
                      ? z.push(C)
                      : n(x, F)
                      ? this._all(C, z)
                      : B.push(C));
              y = B.pop();
            }
            return z;
          },
          collides: function (x) {
            var y = this.data,
              z = this.toBBox;
            if (!q(x, y)) return !1;
            for (var A = [], B, D, E, C; y; ) {
              B = 0;
              for (D = y.children.length; B < D; B++)
                if (((E = y.children[B]), (C = y.leaf ? z(E) : E), q(x, C))) {
                  if (y.leaf || n(x, C)) return !0;
                  A.push(E);
                }
              y = A.pop();
            }
            return !1;
          },
          load: function (x) {
            if (!x || !x.length) return this;
            if (x.length < this._minEntries) {
              for (var y = 0, z = x.length; y < z; y++) this.insert(x[y]);
              return this;
            }
            x = this._build(x.slice(), 0, x.length - 1, 0);
            this.data.children.length
              ? this.data.height === x.height
                ? this._splitRoot(this.data, x)
                : (this.data.height < x.height &&
                    ((y = this.data), (this.data = x), (x = y)),
                  this._insert(x, this.data.height - x.height - 1, !0))
              : (this.data = x);
            return this;
          },
          insert: function (x) {
            x && this._insert(x, this.data.height - 1);
            return this;
          },
          clear: function () {
            this.data = r([]);
            return this;
          },
          remove: function (x, y) {
            if (!x) return this;
            for (
              var z = this.data, A = this.toBBox(x), B = [], D = [], E, C, F, G;
              z || B.length;

            ) {
              z ||
                ((z = B.pop()), (C = B[B.length - 1]), (E = D.pop()), (G = !0));
              if (z.leaf) {
                a: {
                  F = x;
                  var H = z.children,
                    K = y;
                  if (K) {
                    for (var I = 0; I < H.length; I++)
                      if (K(F, H[I])) {
                        F = I;
                        break a;
                      }
                    F = -1;
                  } else F = H.indexOf(F);
                }
                if (-1 !== F) {
                  z.children.splice(F, 1);
                  B.push(z);
                  this._condense(B);
                  break;
                }
              }
              G || z.leaf || !n(z, A)
                ? C
                  ? (E++, (z = C.children[E]), (G = !1))
                  : (z = null)
                : (B.push(z), D.push(E), (E = 0), (C = z), (z = z.children[0]));
            }
            return this;
          },
          toBBox: function (x) {
            return x;
          },
          compareMinX: c,
          compareMinY: f,
          toJSON: function () {
            return this.data;
          },
          fromJSON: function (x) {
            this.data = x;
            return this;
          },
          _all: function (x, y) {
            for (var z = []; x; )
              x.leaf
                ? y.push.apply(y, x.children)
                : z.push.apply(z, x.children),
                (x = z.pop());
            return y;
          },
          _build: function (x, y, z, A) {
            var B = z - y + 1,
              D = this._maxEntries;
            if (B <= D) {
              var E = r(x.slice(y, z + 1));
              k(E, this.toBBox);
              return E;
            }
            A ||
              ((A = Math.ceil(Math.log(B) / Math.log(D))),
              (D = Math.ceil(B / Math.pow(D, A - 1))));
            E = r([]);
            E.leaf = !1;
            E.height = A;
            B = Math.ceil(B / D);
            D = B * Math.ceil(Math.sqrt(D));
            var C;
            for (u(x, y, z, D, this.compareMinX); y <= z; y += D) {
              var F = Math.min(y + D - 1, z);
              u(x, y, F, B, this.compareMinY);
              for (C = y; C <= F; C += B) {
                var G = Math.min(C + B - 1, F);
                E.children.push(this._build(x, C, G, A - 1));
              }
            }
            k(E, this.toBBox);
            return E;
          },
          _chooseSubtree: function (x, y, z, A) {
            for (var B, D, E, C, F, G, H, K; ; ) {
              A.push(y);
              if (y.leaf || A.length - 1 === z) break;
              H = K = Infinity;
              B = 0;
              for (D = y.children.length; B < D; B++)
                (E = y.children[B]),
                  (F = g(E)),
                  (G =
                    (Math.max(E.maxX, x.maxX) - Math.min(E.minX, x.minX)) *
                      (Math.max(E.maxY, x.maxY) - Math.min(E.minY, x.minY)) -
                    F),
                  G < K
                    ? ((K = G), (H = F < H ? F : H), (C = E))
                    : G === K && F < H && ((H = F), (C = E));
              y = C || y.children[0];
            }
            return y;
          },
          _insert: function (x, y, z) {
            var A = this.toBBox;
            z = z ? x : A(x);
            A = [];
            var B = this._chooseSubtree(z, this.data, y, A);
            B.children.push(x);
            for (b(B, z); 0 <= y; )
              if (A[y].children.length > this._maxEntries)
                this._split(A, y), y--;
              else break;
            this._adjustParentBBoxes(z, A, y);
          },
          _split: function (x, y) {
            var z = x[y],
              A = z.children.length,
              B = this._minEntries;
            this._chooseSplitAxis(z, B, A);
            A = this._chooseSplitIndex(z, B, A);
            A = r(z.children.splice(A, z.children.length - A));
            A.height = z.height;
            A.leaf = z.leaf;
            k(z, this.toBBox);
            k(A, this.toBBox);
            y ? x[y - 1].children.push(A) : this._splitRoot(z, A);
          },
          _splitRoot: function (x, y) {
            this.data = r([x, y]);
            this.data.height = x.height + 1;
            this.data.leaf = !1;
            k(this.data, this.toBBox);
          },
          _chooseSplitIndex: function (x, y, z) {
            var A, B;
            var D = (B = Infinity);
            for (A = y; A <= z - y; A++) {
              var E = e(x, 0, A, this.toBBox);
              var C = e(x, A, z, this.toBBox);
              var F =
                Math.max(
                  0,
                  Math.min(E.maxX, C.maxX) - Math.max(E.minX, C.minX)
                ) *
                Math.max(
                  0,
                  Math.min(E.maxY, C.maxY) - Math.max(E.minY, C.minY)
                );
              E = g(E) + g(C);
              if (F < D) {
                D = F;
                var G = A;
                B = E < B ? E : B;
              } else F === D && E < B && ((B = E), (G = A));
            }
            return G;
          },
          _chooseSplitAxis: function (x, y, z) {
            var A = x.leaf ? this.compareMinX : c,
              B = x.leaf ? this.compareMinY : f,
              D = this._allDistMargin(x, y, z, A);
            y = this._allDistMargin(x, y, z, B);
            D < y && x.children.sort(A);
          },
          _allDistMargin: function (x, y, z, A) {
            x.children.sort(A);
            A = this.toBBox;
            var B = e(x, 0, y, A),
              D = e(x, z - y, z, A),
              E = m(B) + m(D),
              C;
            for (C = y; C < z - y; C++) {
              var F = x.children[C];
              b(B, x.leaf ? A(F) : F);
              E += m(B);
            }
            for (C = z - y - 1; C >= y; C--)
              (F = x.children[C]), b(D, x.leaf ? A(F) : F), (E += m(D));
            return E;
          },
          _adjustParentBBoxes: function (x, y, z) {
            for (; 0 <= z; z--) b(y[z], x);
          },
          _condense: function (x) {
            for (var y = x.length - 1, z; 0 <= y; y--)
              0 === x[y].children.length
                ? 0 < y
                  ? ((z = x[y - 1].children), z.splice(z.indexOf(x[y]), 1))
                  : this.clear()
                : k(x[y], this.toBBox);
          },
          compareMinX: function (x, y) {
            return x.left - y.left;
          },
          compareMinY: function (x, y) {
            return x.top - y.top;
          },
          toBBox: function (x) {
            return {
              minX: x.left,
              minY: x.top,
              maxX: x.right,
              maxY: x.bottom,
            };
          },
        };
        h.exports = d;
      },
      function (h, t, a) {
        var d = a(533),
          k = a(535),
          e = a(248);
        h.exports = function (b, c, f, g, m, n, q) {
          b = g.left;
          m = g.top;
          var r = g.right,
            u = g.bottom,
            v = f.faceLeft || f.faceRight,
            x = f.faceTop || f.faceBottom;
          q || (x = v = !0);
          if (!v && !x) return !1;
          var y = 0,
            z = 0,
            A = 0,
            B = 1;
          c.deltaAbsX() > c.deltaAbsY()
            ? (A = -1)
            : c.deltaAbsX() < c.deltaAbsY() && (B = -1);
          0 !== c.deltaX() &&
            0 !== c.deltaY() &&
            v &&
            x &&
            ((A = Math.min(Math.abs(c.position.x - r), Math.abs(c.right - b))),
            (B = Math.min(Math.abs(c.position.y - u), Math.abs(c.bottom - m))));
          if (A < B) {
            if (v && ((y = d(c, f, b, r, n, q)), 0 !== y && !e(g, c)))
              return !0;
            x && (z = k(c, f, m, u, n, q));
          } else {
            if (x && ((z = k(c, f, m, u, n, q)), 0 !== z && !e(g, c)))
              return !0;
            v && (y = d(c, f, b, r, n, q));
          }
          return 0 !== y || 0 !== z;
        };
      },
      function (h, t, a) {
        var d = a(534);
        h.exports = function (k, e, b, c, f, g) {
          var m = 0,
            n = e.faceLeft,
            q = e.faceRight,
            r = e.collideLeft;
          e = e.collideRight;
          g || (e = r = q = n = !0);
          0 > k.deltaX() && e && k.checkCollision.left
            ? q && k.x < c && ((m = k.x - c), m < -f && (m = 0))
            : 0 < k.deltaX() &&
              r &&
              k.checkCollision.right &&
              n &&
              k.right > b &&
              ((m = k.right - b), m > f && (m = 0));
          0 !== m && (k.customSeparateX ? (k.overlapX = m) : d(k, m));
          return m;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          0 > d
            ? ((a.blocked.none = !1), (a.blocked.left = !0))
            : 0 < d && ((a.blocked.none = !1), (a.blocked.right = !0));
          a.position.x -= d;
          a.velocity.x = 0 === a.bounce.x ? 0 : -a.velocity.x * a.bounce.x;
        };
      },
      function (h, t, a) {
        var d = a(536);
        h.exports = function (k, e, b, c, f, g) {
          var m = 0,
            n = e.faceTop,
            q = e.faceBottom,
            r = e.collideUp;
          e = e.collideDown;
          g || (e = r = q = n = !0);
          0 > k.deltaY() && e && k.checkCollision.up
            ? q && k.y < c && ((m = k.y - c), m < -f && (m = 0))
            : 0 < k.deltaY() &&
              r &&
              k.checkCollision.down &&
              n &&
              k.bottom > b &&
              ((m = k.bottom - b), m > f && (m = 0));
          0 !== m && (k.customSeparateY ? (k.overlapY = m) : d(k, m));
          return m;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          0 > d
            ? ((a.blocked.none = !1), (a.blocked.up = !0))
            : 0 < d && ((a.blocked.none = !1), (a.blocked.down = !0));
          a.position.y -= d;
          a.velocity.y = 0 === a.bounce.y ? 0 : -a.velocity.y * a.bounce.y;
        };
      },
      function (h, t, a) {
        var d = a(246),
          k = a(1389);
        h.exports = function (e, b, c, f) {
          var g = d(e, b, c, f);
          f = e.immovable;
          var m = b.immovable;
          if (
            c ||
            0 === g ||
            (f && m) ||
            e.customSeparateX ||
            b.customSeparateX
          )
            return 0 !== g || (e.embedded && b.embedded);
          e = k.Set(e, b, g);
          if (f || m) f ? k.RunImmovableBody1(e) : m && k.RunImmovableBody2(e);
          else return 0 < e ? !0 : k.Check();
          return !0;
        };
      },
      function (h, t, a) {
        var d = a(247),
          k = a(1390);
        h.exports = function (e, b, c, f) {
          var g = d(e, b, c, f);
          f = e.immovable;
          var m = b.immovable;
          if (
            c ||
            0 === g ||
            (f && m) ||
            e.customSeparateY ||
            b.customSeparateY
          )
            return 0 !== g || (e.embedded && b.embedded);
          e = k.Set(e, b, g);
          if (f || m) f ? k.RunImmovableBody1(e) : m && k.RunImmovableBody2(e);
          else return 0 < e ? !0 : k.Check();
          return !0;
        };
      },
      function (h, t, a) {
        var d = a(66);
        t = a(0);
        var k = a(62),
          e = a(57),
          b = a(3);
        a = new t({
          initialize: function (c, f) {
            var g = f.displayWidth ? f.displayWidth : 64,
              m = f.displayHeight ? f.displayHeight : 64;
            this.world = c;
            this.gameObject = f;
            this.debugShowBody = c.defaults.debugShowStaticBody;
            this.debugBodyColor = c.defaults.staticBodyDebugColor;
            this.enable = !0;
            this.isCircle = !1;
            this.radius = 0;
            this.offset = new b();
            this.position = new b(f.x - g * f.originX, f.y - m * f.originY);
            this.width = g;
            this.height = m;
            this.halfWidth = Math.abs(this.width / 2);
            this.halfHeight = Math.abs(this.height / 2);
            this.center = new b(
              this.position.x + this.halfWidth,
              this.position.y + this.halfHeight
            );
            this.velocity = b.ZERO;
            this.allowGravity = !1;
            this.bounce = this.gravity = b.ZERO;
            this.onOverlap = this.onCollide = this.onWorldBounds = !1;
            this.mass = 1;
            this.immovable = !0;
            this.customSeparateY = this.customSeparateX = this.pushable = !1;
            this.overlapR = this.overlapY = this.overlapX = 0;
            this.collideWorldBounds = this.embedded = !1;
            this.checkCollision = {
              none: !1,
              up: !0,
              down: !0,
              left: !0,
              right: !0,
            };
            this.touching = {
              none: !0,
              up: !1,
              down: !1,
              left: !1,
              right: !1,
            };
            this.wasTouching = {
              none: !0,
              up: !1,
              down: !1,
              left: !1,
              right: !1,
            };
            this.blocked = {
              none: !0,
              up: !1,
              down: !1,
              left: !1,
              right: !1,
            };
            this.physicsType = k.STATIC_BODY;
            this._dy = this._dx = 0;
          },
          setGameObject: function (c, f) {
            c &&
              c !== this.gameObject &&
              ((this.gameObject.body = null),
              (c.body = this),
              (this.gameObject = c));
            f && this.updateFromGameObject();
            return this;
          },
          updateFromGameObject: function () {
            this.world.staticTree.remove(this);
            var c = this.gameObject;
            c.getTopLeft(this.position);
            this.width = c.displayWidth;
            this.height = c.displayHeight;
            this.halfWidth = Math.abs(this.width / 2);
            this.halfHeight = Math.abs(this.height / 2);
            this.center.set(
              this.position.x + this.halfWidth,
              this.position.y + this.halfHeight
            );
            this.world.staticTree.insert(this);
            return this;
          },
          setOffset: function (c, f) {
            void 0 === f && (f = c);
            this.world.staticTree.remove(this);
            this.position.x -= this.offset.x;
            this.position.y -= this.offset.y;
            this.offset.set(c, f);
            this.position.x += this.offset.x;
            this.position.y += this.offset.y;
            this.updateCenter();
            this.world.staticTree.insert(this);
            return this;
          },
          setSize: function (c, f, g) {
            void 0 === g && (g = !0);
            var m = this.gameObject;
            !c && m.frame && (c = m.frame.realWidth);
            !f && m.frame && (f = m.frame.realHeight);
            this.world.staticTree.remove(this);
            this.width = c;
            this.height = f;
            this.halfWidth = Math.floor(c / 2);
            this.halfHeight = Math.floor(f / 2);
            g &&
              m.getCenter &&
              ((c = m.displayWidth / 2),
              (m = m.displayHeight / 2),
              (this.position.x -= this.offset.x),
              (this.position.y -= this.offset.y),
              this.offset.set(c - this.halfWidth, m - this.halfHeight),
              (this.position.x += this.offset.x),
              (this.position.y += this.offset.y));
            this.updateCenter();
            this.isCircle = !1;
            this.radius = 0;
            this.world.staticTree.insert(this);
            return this;
          },
          setCircle: function (c, f, g) {
            void 0 === f && (f = this.offset.x);
            void 0 === g && (g = this.offset.y);
            0 < c
              ? (this.world.staticTree.remove(this),
                (this.isCircle = !0),
                (this.radius = c),
                (this.width = 2 * c),
                (this.height = 2 * c),
                (this.halfWidth = Math.floor(this.width / 2)),
                (this.halfHeight = Math.floor(this.height / 2)),
                this.offset.set(f, g),
                this.updateCenter(),
                this.world.staticTree.insert(this))
              : (this.isCircle = !1);
            return this;
          },
          updateCenter: function () {
            this.center.set(
              this.position.x + this.halfWidth,
              this.position.y + this.halfHeight
            );
          },
          reset: function (c, f) {
            var g = this.gameObject;
            void 0 === c && (c = g.x);
            void 0 === f && (f = g.y);
            this.world.staticTree.remove(this);
            g.setPosition(c, f);
            g.getTopLeft(this.position);
            this.updateCenter();
            this.world.staticTree.insert(this);
          },
          stop: function () {
            return this;
          },
          getBounds: function (c) {
            c.x = this.x;
            c.y = this.y;
            c.right = this.right;
            c.bottom = this.bottom;
            return c;
          },
          hitTest: function (c, f) {
            return this.isCircle ? d(this, c, f) : e(this, c, f);
          },
          postUpdate: function () {},
          deltaAbsX: function () {
            return 0;
          },
          deltaAbsY: function () {
            return 0;
          },
          deltaX: function () {
            return 0;
          },
          deltaY: function () {
            return 0;
          },
          deltaZ: function () {
            return 0;
          },
          destroy: function () {
            this.enable = !1;
            this.world.pendingDestroy.set(this);
          },
          drawDebug: function (c) {
            var f = this.position,
              g = f.x + this.halfWidth,
              m = f.y + this.halfHeight;
            this.debugShowBody &&
              (c.lineStyle(c.defaultStrokeWidth, this.debugBodyColor, 1),
              this.isCircle
                ? c.strokeCircle(g, m, this.width / 2)
                : c.strokeRect(f.x, f.y, this.width, this.height));
          },
          willDrawDebug: function () {
            return this.debugShowBody;
          },
          setMass: function (c) {
            0 >= c && (c = 0.1);
            this.mass = c;
            return this;
          },
          x: {
            get: function () {
              return this.position.x;
            },
            set: function (c) {
              this.world.staticTree.remove(this);
              this.position.x = c;
              this.world.staticTree.insert(this);
            },
          },
          y: {
            get: function () {
              return this.position.y;
            },
            set: function (c) {
              this.world.staticTree.remove(this);
              this.position.y = c;
              this.world.staticTree.insert(this);
            },
          },
          left: {
            get: function () {
              return this.position.x;
            },
          },
          right: {
            get: function () {
              return this.position.x + this.width;
            },
          },
          top: {
            get: function () {
              return this.position.y;
            },
          },
          bottom: {
            get: function () {
              return this.position.y + this.height;
            },
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = new (a(0))({
          initialize: function (d) {
            this.pluginManager = d;
            this.game = d.game;
          },
          init: function () {},
          start: function () {},
          stop: function () {},
          destroy: function () {
            this.systems = this.scene = this.game = this.pluginManager = null;
          },
        });
        h.exports = t;
      },
      function (h, t, a) {
        var d = new (a(3))();
        h.exports = function (k, e, b, c) {
          var f = b.tilemapLayer,
            g = f.cullPaddingX,
            m = f.cullPaddingY;
          k = f.tilemap.tileToWorldXY(k, e, d, c, f);
          return (
            k.x > c.worldView.x + f.scaleX * b.tileWidth * (-g - 0.5) &&
            k.x < c.worldView.right + f.scaleX * b.tileWidth * (g - 0.5) &&
            k.y > c.worldView.y + f.scaleY * b.tileHeight * (-m - 1) &&
            k.y < c.worldView.bottom + f.scaleY * b.tileHeight * (m - 0.5)
          );
        };
      },
      function (h, t, a) {
        var d = a(26);
        h.exports = function (k, e, b, c, f, g, m) {
          b = d(b, c, f, g, null, m);
          for (c = 0; c < b.length; c++)
            b[c] && b[c].index === k && (b[c].index = e);
        };
      },
      function (h, t, a) {
        t = a(10);
        var d = a(139),
          k = a(76),
          e = new t();
        h.exports = function (b, c) {
          var f = b.tilemapLayer.tilemap;
          b = b.tilemapLayer;
          var g = Math.floor(f.tileWidth * b.scaleX),
            m = Math.floor(f.tileHeight * b.scaleY);
          f = k(c.worldView.x - b.x, g, 0, !0) - b.cullPaddingX;
          g = d(c.worldView.right - b.x, g, 0, !0) + b.cullPaddingX;
          var n = k(c.worldView.y - b.y, m, 0, !0) - b.cullPaddingY;
          c = d(c.worldView.bottom - b.y, m, 0, !0) + b.cullPaddingY;
          return e.setTo(f, n, g - f, c - n);
        };
      },
      function (h, t, a) {
        var d = a(543),
          k = a(159);
        h.exports = function (e, b, c, f) {
          void 0 === c && (c = []);
          void 0 === f && (f = 0);
          c.length = 0;
          var g = e.tilemapLayer;
          b = d(e, b);
          if (g.skipCull || 1 !== g.scrollFactorX || 1 !== g.scrollFactorY)
            (b.left = 0),
              (b.right = e.width),
              (b.top = 0),
              (b.bottom = e.height);
          k(e, b, f, c);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(546),
          k = a(159);
        h.exports = function (e, b, c, f) {
          void 0 === c && (c = []);
          void 0 === f && (f = 0);
          c.length = 0;
          var g = e.tilemapLayer;
          g.skipCull ||
            1 !== g.scrollFactorX ||
            1 !== g.scrollFactorY ||
            ((b = d(e, b)), k(e, b, f, c));
          return c;
        };
      },
      function (h, t, a) {
        var d = a(139),
          k = a(76);
        h.exports = function (e, b) {
          var c = e.tilemapLayer.tilemap,
            f = e.tilemapLayer,
            g = Math.floor(c.tileWidth * f.scaleX);
          e = e.hexSideLength;
          e = (Math.floor(c.tileHeight * f.scaleY) - e) / 2 + e;
          c = k(b.worldView.x - f.x, g, 0, !0) - f.cullPaddingX;
          g = d(b.worldView.right - f.x, g, 0, !0) + f.cullPaddingX;
          var m = k(b.worldView.y - f.y, e, 0, !0) - f.cullPaddingY;
          b = d(b.worldView.bottom - f.y, e, 0, !0) + f.cullPaddingY;
          return {
            left: c,
            right: g,
            top: m,
            bottom: b,
          };
        };
      },
      function (h, t, a) {
        var d = a(541);
        h.exports = function (k, e, b, c) {
          void 0 === b && (b = []);
          void 0 === c && (c = 0);
          b.length = 0;
          var f = k.tilemapLayer,
            g = k.data,
            m = k.width,
            n = k.height;
          if (!f.skipCull) {
            var q, r;
            if (0 === c)
              for (q = 0; q < n; q++)
                for (c = 0; g[q] && c < m; c++)
                  d(c, q, k, e) &&
                    (r = g[q][c]) &&
                    -1 !== r.index &&
                    r.visible &&
                    0 !== r.alpha &&
                    b.push(r);
            else if (1 === c)
              for (q = 0; q < n; q++)
                for (c = m; g[q] && 0 <= c; c--)
                  d(c, q, k, e) &&
                    (r = g[q][c]) &&
                    -1 !== r.index &&
                    r.visible &&
                    0 !== r.alpha &&
                    b.push(r);
            else if (2 === c)
              for (q = n; 0 <= q; q--)
                for (c = 0; g[q] && c < m; c++)
                  d(c, q, k, e) &&
                    (r = g[q][c]) &&
                    -1 !== r.index &&
                    r.visible &&
                    0 !== r.alpha &&
                    b.push(r);
            else if (3 === c)
              for (q = n; 0 <= q; q--)
                for (c = m; g[q] && 0 <= c; c--)
                  d(c, q, k, e) &&
                    (r = g[q][c]) &&
                    -1 !== r.index &&
                    r.visible &&
                    0 !== r.alpha &&
                    b.push(r);
          }
          f.tilesDrawn = b.length;
          f.tilesTotal = m * n;
          return b;
        };
      },
      function (h, t, a) {
        var d = a(549),
          k = a(159);
        h.exports = function (e, b, c, f) {
          void 0 === c && (c = []);
          void 0 === f && (f = 0);
          c.length = 0;
          var g = e.tilemapLayer;
          g.skipCull ||
            1 !== g.scrollFactorX ||
            1 !== g.scrollFactorY ||
            ((b = d(e, b)), k(e, b, f, c));
          return c;
        };
      },
      function (h, t, a) {
        var d = a(139),
          k = a(76);
        h.exports = function (e, b) {
          var c = e.tilemapLayer.tilemap;
          e = e.tilemapLayer;
          var f = Math.floor(c.tileWidth * e.scaleX),
            g = Math.floor(c.tileHeight * e.scaleY);
          c = k(b.worldView.x - e.x, f, 0, !0) - e.cullPaddingX;
          f = d(b.worldView.right - e.x, f, 0, !0) + e.cullPaddingX;
          var m = k(b.worldView.y - e.y, g / 2, 0, !0) - e.cullPaddingY;
          b = d(b.worldView.bottom - e.y, g / 2, 0, !0) + e.cullPaddingY;
          return {
            left: c,
            right: f,
            top: m,
            bottom: b,
          };
        };
      },
      function (h, t, a) {
        var d = a(3);
        h.exports = function (k, e, b, c, f) {
          b || (b = new d());
          var g = f.baseTileWidth,
            m = f.baseTileHeight,
            n = f.tilemapLayer,
            q = 0,
            r = 0;
          n &&
            (c || (c = n.scene.cameras.main),
            (q = n.x + c.scrollX * (1 - n.scrollFactorX)),
            (g *= n.scaleX),
            (r = n.y + c.scrollY * (1 - n.scrollFactorY)),
            (m *= n.scaleY));
          c = f.hexSideLength;
          return b.set(
            q + k * g + (e % 2) * (g / 2),
            r + e * ((m - c) / 2 + c)
          );
        };
      },
      function (h, t, a) {
        var d = a(3);
        h.exports = function (k, e, b, c, f) {
          b || (b = new d());
          var g = f.baseTileWidth,
            m = f.baseTileHeight;
          f = f.tilemapLayer;
          var n = 0,
            q = 0;
          f &&
            (c || (c = f.scene.cameras.main),
            (n = f.x + c.scrollX * (1 - f.scrollFactorX)),
            (g *= f.scaleX),
            (q = f.y + c.scrollY * (1 - f.scrollFactorY)),
            (m *= f.scaleY));
          return b.set(n + (g / 2) * (k - e), q + (m / 2) * (k + e));
        };
      },
      function (h, t, a) {
        var d = a(3);
        h.exports = function (k, e, b, c, f) {
          b || (b = new d());
          var g = f.baseTileWidth,
            m = f.baseTileHeight;
          f = f.tilemapLayer;
          var n = 0,
            q = 0;
          f &&
            (c || (c = f.scene.cameras.main),
            (n = f.x + c.scrollX * (1 - f.scrollFactorX)),
            (g *= f.scaleX),
            (q = f.y + c.scrollY * (1 - f.scrollFactorY)),
            (m *= f.scaleY));
          return b.set(n + k * g + (e % 2) * (g / 2), q + (m / 2) * e);
        };
      },
      function (h, t, a) {
        var d = a(253),
          k = a(254),
          e = a(3);
        h.exports = function (b, c, f, g, m) {
          f || (f = new e(0, 0));
          f.x = d(b, g, m);
          f.y = k(c, g, m);
          return f;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          var e = k.baseTileHeight,
            b = k.tilemapLayer;
          k = 0;
          b &&
            (void 0 === d && (d = b.scene.cameras.main),
            (k = b.y + d.scrollY * (1 - b.scrollFactorY)),
            (e *= b.scaleY));
          d = b.tilemap.hexSideLength;
          return k + a * ((e - d) / 2 + d);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          var e = k.baseTileHeight;
          k = k.tilemapLayer;
          var b = 0;
          k &&
            (void 0 === d && (d = k.scene.cameras.main),
            (b = k.y + d.scrollY * (1 - k.scrollFactorY)),
            (e *= k.scaleY));
          return b + (e / 2) * a;
        };
      },
      function (h, t, a) {
        var d = a(3);
        h.exports = function (k, e, b, c, f, g) {
          c || (c = new d());
          var m = g.baseTileWidth,
            n = g.baseTileHeight,
            q = g.tilemapLayer;
          q &&
            (f || (f = q.scene.cameras.main),
            (e -= q.y + f.scrollY * (1 - q.scrollFactorY)),
            (n *= q.scaleY),
            (k -= q.x + f.scrollX * (1 - q.scrollFactorX)),
            (m *= q.scaleX));
          f = g.hexSideLength;
          n = (n - f) / 2 + f;
          e = b ? Math.floor(e / n) : e / n;
          return c.set(
            b
              ? Math.floor((k - (e % 2) * 0.5 * m) / m)
              : (k - (e % 2) * 0.5 * m) / m,
            e
          );
        };
      },
      function (h, t, a) {
        var d = a(3);
        h.exports = function (k, e, b, c, f, g) {
          c || (c = new d());
          var m = g.baseTileWidth,
            n = g.baseTileHeight;
          if ((g = g.tilemapLayer))
            f || (f = g.scene.cameras.main),
              (e -= g.y + f.scrollY * (1 - g.scrollFactorY)),
              (n *= g.scaleY),
              (k -= g.x + f.scrollX * (1 - g.scrollFactorX)),
              (m *= g.scaleX);
          return c.set(
            b
              ? Math.floor((k / (m / 2) + e / (n / 2)) / 2)
              : (k / (m / 2) + e / (n / 2)) / 2,
            b
              ? Math.floor((e / (n / 2) - k / (m / 2)) / 2)
              : (e / (n / 2) - k / (m / 2)) / 2
          );
        };
      },
      function (h, t, a) {
        var d = a(3);
        h.exports = function (k, e, b, c, f, g) {
          c || (c = new d());
          var m = g.baseTileWidth,
            n = g.baseTileHeight;
          if ((g = g.tilemapLayer))
            f || (f = g.scene.cameras.main),
              (e -= g.y + f.scrollY * (1 - g.scrollFactorY)),
              (n *= g.scaleY),
              (k -= g.x + f.scrollX * (1 - g.scrollFactorX)),
              (m *= g.scaleX);
          e = b ? Math.floor(e / (n / 2)) : e / (n / 2);
          return c.set(
            b
              ? Math.floor((k + (e % 2) * 0.5 * m) / m)
              : (k + (e % 2) * 0.5 * m) / m,
            e
          );
        };
      },
      function (h, t, a) {
        var d = a(255),
          k = a(256),
          e = a(3);
        h.exports = function (b, c, f, g, m, n) {
          void 0 === f && (f = !0);
          g || (g = new e(0, 0));
          g.x = d(b, f, m, n);
          g.y = k(c, f, m, n);
          return g;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          var b = e.baseTileHeight,
            c = e.tilemapLayer;
          c &&
            (k || (k = c.scene.cameras.main),
            (a -= c.y + k.scrollY * (1 - c.scrollFactorY)),
            (b *= c.scaleY));
          k = e.hexSideLength;
          b = (b - k) / 2 + k;
          return d ? Math.floor(a / b) : a / b;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          var b = e.baseTileHeight;
          if ((e = e.tilemapLayer))
            k || (k = e.scene.cameras.main),
              (a -= e.y + k.scrollY * (1 - e.scrollFactorY)),
              (b *= e.scaleY);
          return d ? Math.floor(a / (b / 2)) : a / (b / 2);
        };
      },
      function (h, t, a) {
        var d = a(119);
        h.exports = function (k, e, b) {
          return d(k, e, b)
            ? ((k = b.data[e][k]), null !== k && -1 < k.index)
            : !1;
        };
      },
      function (h, t, a) {
        var d = a(85),
          k = a(119),
          e = a(252);
        h.exports = function (b, c, f, g, m) {
          void 0 === f && (f = !0);
          void 0 === g && (g = !0);
          if (!k(b, c, m)) return null;
          var n = m.data[c][b];
          if (n)
            m.data[c][b] = f
              ? null
              : new d(m, -1, b, c, m.tileWidth, m.tileHeight);
          else return null;
          g && n && n.collides && e(b, c, m);
          return n;
        };
      },
      function (h, t, a) {
        var d = a(40),
          k = a(259),
          e = a(565),
          b = a(566),
          c = a(577);
        h.exports = function (f, g, m, n, q, r) {
          switch (g) {
            case d.ARRAY_2D:
              f = k(f, m, n, q, r);
              break;
            case d.CSV:
              f = e(f, m, n, q, r);
              break;
            case d.TILED_JSON:
              f = b(f, m, r);
              break;
            case d.WELTMEISTER:
              f = c(f, m, r);
              break;
            default:
              console.warn("Unrecognized tilemap data format: " + g),
                (f = null);
          }
          return f;
        };
      },
      function (h, t, a) {
        var d = a(40),
          k = a(259);
        h.exports = function (e, b, c, f, g) {
          b = b
            .trim()
            .split("\n")
            .map(function (m) {
              return m.split(",");
            });
          e = k(e, b, c, f, g);
          e.format = d.CSV;
          return e;
        };
      },
      function (h, t, a) {
        var d = a(567),
          k = a(568),
          e = a(29),
          b = a(40),
          c = a(258),
          f = a(121),
          g = a(569),
          m = a(570),
          n = a(573),
          q = a(575);
        h.exports = function (r, u, v) {
          r = new f({
            width: u.width,
            height: u.height,
            name: r,
            tileWidth: u.tilewidth,
            tileHeight: u.tileheight,
            orientation: c(u.orientation),
            format: b.TILED_JSON,
            version: u.version,
            properties: u.properties,
            renderOrder: u.renderorder,
            infinite: u.infinite,
          });
          r.orientation === e.HEXAGONAL && (r.hexSideLength = u.hexsidelength);
          r.layers = n(u, v);
          r.images = g(u);
          v = q(u);
          r.tilesets = v.tilesets;
          r.imageCollections = v.imageCollections;
          r.objects = m(u);
          r.tiles = k(r);
          d(r);
          return r;
        };
      },
      function (h, t, a) {
        var d = a(17);
        h.exports = function (k) {
          for (var e, b, c, f, g = 0; g < k.layers.length; g++) {
            e = k.layers[g];
            for (var m = 0; m < e.data.length; m++) {
              f = e.data[m];
              for (var n = 0; n < f.length; n++)
                (b = f[n]),
                  null === b ||
                    0 > b.index ||
                    ((c = k.tiles[b.index][2]),
                    (c = k.tilesets[c]),
                    (b.width = c.tileWidth),
                    (b.height = c.tileHeight),
                    c.tileProperties &&
                      c.tileProperties[b.index - c.firstgid] &&
                      (b.properties = d(
                        b.properties,
                        c.tileProperties[b.index - c.firstgid]
                      )));
            }
          }
        };
      },
      function (h, t, a) {
        var d = a(122);
        h.exports = function (k) {
          var e,
            b = [];
          for (e = 0; e < k.imageCollections.length; e++)
            for (
              var c = k.imageCollections[e], f = c.images, g = 0;
              g < f.length;
              g++
            ) {
              var m = f[g];
              m = new d(m.image, m.gid, c.imageWidth, c.imageHeight, 0, 0);
              m.updateTileData(c.imageWidth, c.imageHeight);
              k.tilesets.push(m);
            }
          for (e = 0; e < k.tilesets.length; e++) {
            m = k.tilesets[e];
            f = c = m.tileMargin;
            for (
              var n = (g = 0), q = 0, r = m.firstgid;
              r < m.firstgid + m.total;
              r++
            ) {
              b[r] = [c, f, e];
              c += m.tileWidth + m.tileSpacing;
              g++;
              if (g === m.total) break;
              n++;
              if (
                n === m.columns &&
                ((c = m.tileMargin),
                (f += m.tileHeight + m.tileSpacing),
                (n = 0),
                q++,
                q === m.rows)
              )
                break;
            }
          }
          return b;
        };
      },
      function (h, t, a) {
        var d = a(2),
          k = a(161);
        h.exports = function (e) {
          for (
            var b = [], c = [], f = k(e);
            f.i < f.layers.length || 0 < c.length;

          )
            if (f.i >= f.layers.length) {
              if (1 > c.length) {
                console.warn(
                  "TilemapParser.parseTiledJSON - Invalid layer group hierarchy"
                );
                break;
              }
              f = c.pop();
            } else {
              var g = f.layers[f.i];
              f.i++;
              if ("imagelayer" !== g.type)
                "group" === g.type && ((g = k(e, g, f)), c.push(f), (f = g));
              else {
                var m = d(g, "offsetx", 0) + d(g, "startx", 0),
                  n = d(g, "offsety", 0) + d(g, "starty", 0);
                b.push({
                  name: f.name + g.name,
                  image: g.image,
                  x: f.x + m + g.x,
                  y: f.y + n + g.y,
                  alpha: f.opacity * g.opacity,
                  visible: f.visible && g.visible,
                  properties: d(g, "properties", {}),
                });
              }
            }
          return b;
        };
      },
      function (h, t, a) {
        var d = a(2),
          k = a(260),
          e = a(572),
          b = a(161);
        h.exports = function (c) {
          for (
            var f = [], g = [], m = b(c);
            m.i < m.layers.length || 0 < g.length;

          )
            if (m.i >= m.layers.length) {
              if (1 > g.length) {
                console.warn(
                  "TilemapParser.parseTiledJSON - Invalid layer group hierarchy"
                );
                break;
              }
              m = g.pop();
            } else {
              var n = m.layers[m.i];
              m.i++;
              n.opacity *= m.opacity;
              n.visible = m.visible && n.visible;
              if ("objectgroup" !== n.type) {
                if ("group" === n.type) {
                  var q = b(c, n, m);
                  g.push(m);
                  m = q;
                }
              } else {
                n.name = m.name + n.name;
                var r = m.x + d(n, "startx", 0) + d(n, "offsetx", 0),
                  u = m.y + d(n, "starty", 0) + d(n, "offsety", 0);
                q = [];
                for (var v = 0; v < n.objects.length; v++) {
                  var x = k(n.objects[v], r, u);
                  q.push(x);
                }
                n = new e(n);
                n.objects = q;
                f.push(n);
              }
            }
          return f;
        };
      },
      function (h, t, a) {
        var d = a(126);
        h.exports = function (k, e) {
          for (var b = {}, c = 0; c < e.length; c++) {
            var f = e[c];
            d(k, f) && (b[f] = k[f]);
          }
          return b;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(2);
        a = new t({
          initialize: function (k) {
            void 0 === k && (k = {});
            this.name = d(k, "name", "object layer");
            this.opacity = d(k, "opacity", 1);
            this.properties = d(k, "properties", {});
            this.propertyTypes = d(k, "propertytypes", {});
            this.type = d(k, "type", "objectgroup");
            this.visible = d(k, "visible", !0);
            this.objects = d(k, "objects", []);
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(574),
          k = a(29),
          e = a(161),
          b = a(258),
          c = a(2),
          f = a(120),
          g = a(261),
          m = a(85);
        h.exports = function (n, q) {
          for (
            var r = c(n, "infinite", !1), u = [], v = [], x = e(n);
            x.i < x.layers.length || 0 < v.length;

          )
            if (x.i >= x.layers.length) {
              if (1 > v.length) {
                console.warn(
                  "TilemapParser.parseTiledJSON - Invalid layer group hierarchy"
                );
                break;
              }
              x = v.pop();
            } else {
              var y = x.layers[x.i];
              x.i++;
              if ("tilelayer" !== y.type)
                "group" === y.type && ((y = e(n, y, x)), v.push(x), (x = y));
              else if (y.compression)
                console.warn(
                  "TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" +
                    y.name +
                    "'"
                );
              else {
                if (y.encoding && "base64" === y.encoding) {
                  if (y.chunks)
                    for (var z = 0; z < y.chunks.length; z++)
                      y.chunks[z].data = d(y.chunks[z].data);
                  y.data && (y.data = d(y.data));
                  delete y.encoding;
                }
                var A = [],
                  B = 0;
                if (r) {
                  var D = c(y, "startx", 0) + y.x,
                    E = c(y, "starty", 0) + y.y;
                  z = new f({
                    name: x.name + y.name,
                    x: x.x + c(y, "offsetx", 0) + D * n.tilewidth,
                    y: x.y + c(y, "offsety", 0) + E * n.tileheight,
                    width: y.width,
                    height: y.height,
                    tileWidth: n.tilewidth,
                    tileHeight: n.tileheight,
                    alpha: x.opacity * y.opacity,
                    visible: x.visible && y.visible,
                    properties: c(y, "properties", []),
                    orientation: b(n.orientation),
                  });
                  z.orientation === k.HEXAGONAL &&
                    (z.hexSideLength = n.hexsidelength);
                  for (var C = 0; C < y.height; C++) {
                    A.push([null]);
                    for (var F = 0; F < y.width; F++) A[C][F] = null;
                  }
                  C = 0;
                  for (F = y.chunks.length; C < F; C++)
                    for (
                      var G = y.chunks[C],
                        H = G.x - D,
                        K = G.y - E,
                        I = 0,
                        M = 0,
                        N = G.data.length;
                      M < N;
                      M++
                    ) {
                      var P = B + H,
                        J = I + K;
                      var L = g(G.data[M]);
                      if (0 < L.gid) {
                        var O = new m(
                          z,
                          L.gid,
                          P,
                          J,
                          n.tilewidth,
                          n.tileheight
                        );
                        O.rotation = L.rotation;
                        O.flipX = L.flipped;
                        A[J][P] = O;
                      } else
                        (L = q
                          ? null
                          : new m(z, -1, P, J, n.tilewidth, n.tileheight)),
                          (A[J][P] = L);
                      B++;
                      B === G.width && (I++, (B = 0));
                    }
                } else
                  for (
                    z = new f({
                      name: x.name + y.name,
                      x: x.x + c(y, "offsetx", 0) + y.x,
                      y: x.y + c(y, "offsety", 0) + y.y,
                      width: y.width,
                      height: y.height,
                      tileWidth: n.tilewidth,
                      tileHeight: n.tileheight,
                      alpha: x.opacity * y.opacity,
                      visible: x.visible && y.visible,
                      properties: c(y, "properties", []),
                      orientation: b(n.orientation),
                    }),
                      z.orientation === k.HEXAGONAL &&
                        (z.hexSideLength = n.hexsidelength),
                      D = [],
                      E = 0,
                      F = y.data.length;
                    E < F;
                    E++
                  )
                    (L = g(y.data[E])),
                      0 < L.gid
                        ? ((O = new m(
                            z,
                            L.gid,
                            B,
                            A.length,
                            n.tilewidth,
                            n.tileheight
                          )),
                          (O.rotation = L.rotation),
                          (O.flipX = L.flipped),
                          D.push(O))
                        : ((L = q
                            ? null
                            : new m(
                                z,
                                -1,
                                B,
                                A.length,
                                n.tilewidth,
                                n.tileheight
                              )),
                          D.push(L)),
                      B++,
                      B === y.width && (A.push(D), (B = 0), (D = []));
                z.data = A;
                u.push(z);
              }
            }
          return u;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          a = window.atob(a);
          for (var d = a.length, k = Array(d / 4), e = 0; e < d; e += 4)
            k[e / 4] =
              (a.charCodeAt(e) |
                (a.charCodeAt(e + 1) << 8) |
                (a.charCodeAt(e + 2) << 16) |
                (a.charCodeAt(e + 3) << 24)) >>>
              0;
          return k;
        };
      },
      function (h, t, a) {
        var d = a(122),
          k = a(576),
          e = a(260),
          b = a(1453);
        h.exports = function (c) {
          for (
            var f = [], g = [], m = null, n, q = 0;
            q < c.tilesets.length;
            q++
          ) {
            var r = c.tilesets[q];
            if (r.source)
              console.warn(
                "External tilesets unsupported. Use Embed Tileset and re-export"
              );
            else if (r.image) {
              var u = new d(
                r.name,
                r.firstgid,
                r.tilewidth,
                r.tileheight,
                r.margin,
                r.spacing
              );
              if (1 < c.version) {
                var v = void 0,
                  x = void 0;
                if (Array.isArray(r.tiles)) {
                  v = v || {};
                  x = x || {};
                  for (var y = 0; y < r.tiles.length; y++) {
                    var z = r.tiles[y];
                    if (z.properties) {
                      var A = {};
                      z.properties.forEach(function (D) {
                        A[D.name] = D.value;
                      });
                      x[z.id] = A;
                    }
                    if (
                      z.objectgroup &&
                      (((v[z.id] || (v[z.id] = {})).objectgroup =
                        z.objectgroup),
                      z.objectgroup.objects)
                    ) {
                      var B = z.objectgroup.objects.map(function (D) {
                        return e(D);
                      });
                      v[z.id].objectgroup.objects = B;
                    }
                    z.animation &&
                      ((v[z.id] || (v[z.id] = {})).animation = z.animation);
                    z.type && ((v[z.id] || (v[z.id] = {})).type = z.type);
                  }
                }
                Array.isArray(r.wangsets) &&
                  ((v = v || {}), (x = x || {}), b(r.wangsets, v));
                v && ((u.tileData = v), (u.tileProperties = x));
              } else if (
                (r.tileproperties && (u.tileProperties = r.tileproperties),
                r.tiles)
              )
                for (n in ((u.tileData = r.tiles), u.tileData))
                  (y = u.tileData[n].objectgroup) &&
                    y.objects &&
                    ((y = y.objects.map(function (D) {
                      return e(D);
                    })),
                    (u.tileData[n].objectgroup.objects = y));
              u.updateTileData(r.imagewidth, r.imageheight);
              f.push(u);
            } else {
              u = new k(
                r.name,
                r.firstgid,
                r.tilewidth,
                r.tileheight,
                r.margin,
                r.spacing,
                r.properties
              );
              for (y = v = 0; y < r.tiles.length; y++)
                (z = r.tiles[y]),
                  (x = z.image),
                  (z = parseInt(z.id, 10)),
                  u.addImage(r.firstgid + z, x),
                  (v = Math.max(z, v));
              u.maxId = v;
              g.push(u);
            }
            m && (m.lastgid = r.firstgid - 1);
            m = r;
          }
          return {
            tilesets: f,
            imageCollections: g,
          };
        };
      },
      function (h, t, a) {
        t = new (a(0))({
          initialize: function (d, k, e, b, c, f, g) {
            if (void 0 === e || 0 >= e) e = 32;
            if (void 0 === b || 0 >= b) b = 32;
            void 0 === c && (c = 0);
            void 0 === f && (f = 0);
            this.name = d;
            this.firstgid = k | 0;
            this.imageWidth = e | 0;
            this.imageHeight = b | 0;
            this.imageMargin = c | 0;
            this.imageSpacing = f | 0;
            this.properties = g || {};
            this.images = [];
            this.total = 0;
          },
          containsImageIndex: function (d) {
            return d >= this.firstgid && d < this.firstgid + this.total;
          },
          addImage: function (d, k) {
            this.images.push({
              gid: d,
              image: k,
            });
            this.total++;
            return this;
          },
        });
        h.exports = t;
      },
      function (h, t, a) {
        var d = a(40),
          k = a(121),
          e = a(578),
          b = a(579);
        h.exports = function (c, f, g) {
          if (0 === f.layer.length)
            return (
              console.warn("No layers found in the Weltmeister map: " + c), null
            );
          for (var m = 0, n = 0, q = 0; q < f.layer.length; q++)
            f.layer[q].width > m && (m = f.layer[q].width),
              f.layer[q].height > n && (n = f.layer[q].height);
          c = new k({
            width: m,
            height: n,
            name: c,
            tileWidth: f.layer[0].tilesize,
            tileHeight: f.layer[0].tilesize,
            format: d.WELTMEISTER,
          });
          c.layers = e(f, g);
          c.tilesets = b(f);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(120),
          k = a(85);
        h.exports = function (e, b) {
          for (var c = [], f = 0; f < e.layer.length; f++) {
            for (
              var g = e.layer[f],
                m = new d({
                  name: g.name,
                  width: g.width,
                  height: g.height,
                  tileWidth: g.tilesize,
                  tileHeight: g.tilesize,
                  visible: 1 === g.visible,
                }),
                n = [],
                q = [],
                r = 0;
              r < g.data.length;
              r++
            ) {
              for (var u = 0; u < g.data[r].length; u++) {
                var v = g.data[r][u] - 1;
                v =
                  -1 < v
                    ? new k(m, v, u, r, g.tilesize, g.tilesize)
                    : b
                    ? null
                    : new k(m, -1, u, r, g.tilesize, g.tilesize);
                n.push(v);
              }
              q.push(n);
              n = [];
            }
            m.data = q;
            c.push(m);
          }
          return c;
        };
      },
      function (h, t, a) {
        var d = a(122);
        h.exports = function (k) {
          for (var e = [], b = [], c = 0; c < k.layer.length; c++) {
            var f = k.layer[c],
              g = f.tilesetName;
            "" !== g &&
              -1 === b.indexOf(g) &&
              (b.push(g), e.push(new d(g, 0, f.tilesize, f.tilesize, 0, 0)));
          }
          return e;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(36),
          k = a(40),
          e = a(2),
          b = a(120),
          c = a(29),
          f = a(362),
          g = a(74),
          m = a(73),
          n = a(85),
          q = a(251),
          r = a(581),
          u = a(122);
        a = new t({
          initialize: function (v, x) {
            this.scene = v;
            this.tileWidth = x.tileWidth;
            this.tileHeight = x.tileHeight;
            this.width = x.width;
            this.height = x.height;
            this.orientation = x.orientation;
            this.renderOrder = x.renderOrder;
            this.format = x.format;
            this.version = x.version;
            this.properties = x.properties;
            this.widthInPixels = x.widthInPixels;
            this.heightInPixels = x.heightInPixels;
            this.imageCollections = x.imageCollections;
            this.images = x.images;
            this.layers = x.layers;
            this.tilesets = x.tilesets;
            this.objects = x.objects;
            this.currentLayerIndex = 0;
            this.hexSideLength = x.hexSideLength;
            v = this.orientation;
            this._convert = {
              WorldToTileXY: q.GetWorldToTileXYFunction(v),
              WorldToTileX: q.GetWorldToTileXFunction(v),
              WorldToTileY: q.GetWorldToTileYFunction(v),
              TileToWorldXY: q.GetTileToWorldXYFunction(v),
              TileToWorldX: q.GetTileToWorldXFunction(v),
              TileToWorldY: q.GetTileToWorldYFunction(v),
            };
          },
          createBlankDynamicLayer: function (v, x, y, z, A, B, D, E) {
            console.warn(
              "createBlankDynamicLayer is deprecated. Use createBlankLayer"
            );
            return this.createBlankLayer(v, x, y, z, A, B, D, E);
          },
          createDynamicLayer: function (v, x, y, z) {
            console.warn("createDynamicLayer is deprecated. Use createLayer");
            return this.createLayer(v, x, y, z);
          },
          createStaticLayer: function (v, x, y, z) {
            console.warn("createStaticLayer is deprecated. Use createLayer");
            return this.createLayer(v, x, y, z);
          },
          setRenderOrder: function (v) {
            var x = ["right-down", "left-down", "right-up", "left-up"];
            "number" === typeof v && (v = x[v]);
            -1 < x.indexOf(v) && (this.renderOrder = v);
            return this;
          },
          addTilesetImage: function (v, x, y, z, A, B, D) {
            if (void 0 === v) return null;
            if (void 0 === x || null === x) x = v;
            if (!this.scene.sys.textures.exists(x))
              return console.warn("Invalid Tileset Image: " + x), null;
            x = this.scene.sys.textures.get(x);
            var E = this.getTilesetIndex(v);
            if (null === E && this.format === k.TILED_JSON)
              return console.warn("No data found for Tileset: " + v), null;
            if ((E = this.tilesets[E]))
              return E.setTileSize(y, z), E.setSpacing(A, B), E.setImage(x), E;
            void 0 === y && (y = this.tileWidth);
            void 0 === z && (z = this.tileHeight);
            void 0 === A && (A = 0);
            void 0 === B && (B = 0);
            void 0 === D && (D = 0);
            E = new u(v, D, y, z, A, B);
            E.setImage(x);
            this.tilesets.push(E);
            return E;
          },
          copy: function (v, x, y, z, A, B, D, E) {
            E = this.getLayer(E);
            return null !== E ? (q.Copy(v, x, y, z, A, B, D, E), this) : null;
          },
          createBlankLayer: function (v, x, y, z, A, B, D, E) {
            void 0 === y && (y = 0);
            void 0 === z && (z = 0);
            void 0 === A && (A = this.width);
            void 0 === B && (B = this.height);
            void 0 === D && (D = this.tileWidth);
            void 0 === E && (E = this.tileHeight);
            if (null !== this.getLayerIndex(v))
              return console.warn("Invalid Tilemap Layer ID: " + v), null;
            v = new b({
              name: v,
              tileWidth: D,
              tileHeight: E,
              width: A,
              height: B,
              orientation: this.orientation,
            });
            for (var C, F = 0; F < B; F++) {
              C = [];
              for (var G = 0; G < A; G++)
                C.push(
                  new n(v, -1, G, F, D, E, this.tileWidth, this.tileHeight)
                );
              v.data.push(C);
            }
            this.layers.push(v);
            this.currentLayerIndex = this.layers.length - 1;
            x = new r(this.scene, this, this.currentLayerIndex, x, y, z);
            x.setRenderOrder(this.renderOrder);
            this.scene.sys.displayList.add(x);
            return x;
          },
          createLayer: function (v, x, y, z) {
            var A = this.getLayerIndex(v);
            if (null === A)
              return (
                console.warn("Invalid Tilemap Layer ID: " + v),
                "string" === typeof v &&
                  console.warn(
                    "Valid tilelayer names:\n\t" +
                      this.getTileLayerNames().join(",\n\t")
                  ),
                null
              );
            var B = this.layers[A];
            if (B.tilemapLayer)
              return console.warn("Tilemap Layer ID already exists:" + v), null;
            this.currentLayerIndex = A;
            void 0 === y && (y = B.x);
            void 0 === z && (z = B.y);
            v = new r(this.scene, this, A, x, y, z);
            v.setRenderOrder(this.renderOrder);
            this.scene.sys.displayList.add(v);
            return v;
          },
          createFromObjects: function (v, x) {
            var y = [],
              z = this.getObjectLayer(v);
            if (!z)
              return (
                console.warn(
                  "createFromObjects: Invalid objectLayerName given: " + v
                ),
                y
              );
            Array.isArray(x) || (x = [x]);
            v = z.objects;
            for (z = 0; z < x.length; z++) {
              for (
                var A = x[z],
                  B = e(A, "id", null),
                  D = e(A, "gid", null),
                  E = e(A, "name", null),
                  C,
                  F = [],
                  G = 0;
                G < v.length;
                G++
              )
                (C = v[G]),
                  ((null === B && null === D && null === E) ||
                    (null !== B && C.id === B) ||
                    (null !== D && C.gid === D) ||
                    (null !== E && C.name === E)) &&
                    F.push(C);
              B = e(A, "classType", m);
              D = e(A, "scene", this.scene);
              E = e(A, "container", null);
              G = e(A, "key", null);
              A = e(A, "frame", null);
              for (var H = 0; H < F.length; H++) {
                C = F[H];
                var K = new B(D);
                K.setName(C.name);
                K.setPosition(C.x, C.y);
                K.setTexture(G, A);
                C.width && (K.displayWidth = C.width);
                C.height && (K.displayHeight = C.height);
                var I = {
                  x: K.originX * C.width,
                  y: (K.originY - 1) * C.height,
                };
                if (C.rotation) {
                  var M = d(C.rotation);
                  f(I, M);
                  K.rotation = M;
                }
                K.x += I.x;
                K.y += I.y;
                (void 0 === C.flippedHorizontal &&
                  void 0 === C.flippedVertical) ||
                  K.setFlip(C.flippedHorizontal, C.flippedVertical);
                C.visible || (K.visible = !1);
                if (Array.isArray(C.properties))
                  C.properties.forEach(function (P) {
                    var J = P.name;
                    void 0 !== K[J] ? (K[J] = P.value) : K.setData(J, P.value);
                  });
                else
                  for (var N in C.properties)
                    void 0 !== K[N]
                      ? (K[N] = C.properties[N])
                      : K.setData(N, C.properties[N]);
                E ? E.add(K) : D.add.existing(K);
                y.push(K);
              }
            }
            return y;
          },
          createFromTiles: function (v, x, y, z, A, B) {
            B = this.getLayer(B);
            return null === B ? null : q.CreateFromTiles(v, x, y, z, A, B);
          },
          fill: function (v, x, y, z, A, B, D) {
            void 0 === B && (B = !0);
            D = this.getLayer(D);
            if (null === D) return null;
            q.Fill(v, x, y, z, A, B, D);
            return this;
          },
          filterObjects: function (v, x, y) {
            if ("string" === typeof v) {
              var z = v;
              v = this.getObjectLayer(v);
              if (!v)
                return (
                  console.warn("No object layer found with the name: " + z),
                  null
                );
            }
            return v.objects.filter(x, y);
          },
          filterTiles: function (v, x, y, z, A, B, D, E) {
            E = this.getLayer(E);
            return null === E ? null : q.FilterTiles(v, x, y, z, A, B, D, E);
          },
          findByIndex: function (v, x, y, z) {
            z = this.getLayer(z);
            return null === z ? null : q.FindByIndex(v, x, y, z);
          },
          findObject: function (v, x, y) {
            if ("string" === typeof v) {
              var z = v;
              v = this.getObjectLayer(v);
              if (!v)
                return (
                  console.warn("No object layer found with the name: " + z),
                  null
                );
            }
            return v.objects.find(x, y) || null;
          },
          findTile: function (v, x, y, z, A, B, D, E) {
            E = this.getLayer(E);
            return null === E ? null : q.FindTile(v, x, y, z, A, B, D, E);
          },
          forEachTile: function (v, x, y, z, A, B, D, E) {
            E = this.getLayer(E);
            if (null === E) return null;
            q.ForEachTile(v, x, y, z, A, B, D, E);
            return this;
          },
          getImageIndex: function (v) {
            return this.getIndex(this.images, v);
          },
          getImageLayerNames: function () {
            return this.images && Array.isArray(this.images)
              ? this.images.map(function (v) {
                  return v.name;
                })
              : [];
          },
          getIndex: function (v, x) {
            for (var y = 0; y < v.length; y++) if (v[y].name === x) return y;
            return null;
          },
          getLayer: function (v) {
            v = this.getLayerIndex(v);
            return null !== v ? this.layers[v] : null;
          },
          getObjectLayer: function (v) {
            v = this.getIndex(this.objects, v);
            return null !== v ? this.objects[v] : null;
          },
          getObjectLayerNames: function () {
            return this.objects && Array.isArray(this.objects)
              ? this.objects.map(function (v) {
                  return v.name;
                })
              : [];
          },
          getLayerIndex: function (v) {
            return void 0 === v
              ? this.currentLayerIndex
              : "string" === typeof v
              ? this.getLayerIndexByName(v)
              : "number" === typeof v && v < this.layers.length
              ? v
              : v instanceof r
              ? v.layerIndex
              : null;
          },
          getLayerIndexByName: function (v) {
            return this.getIndex(this.layers, v);
          },
          getTileAt: function (v, x, y, z) {
            z = this.getLayer(z);
            return null === z ? null : q.GetTileAt(v, x, y, z);
          },
          getTileAtWorldXY: function (v, x, y, z, A) {
            A = this.getLayer(A);
            return null === A ? null : q.GetTileAtWorldXY(v, x, y, z, A);
          },
          getTileLayerNames: function () {
            return this.layers && Array.isArray(this.layers)
              ? this.layers.map(function (v) {
                  return v.name;
                })
              : [];
          },
          getTilesWithin: function (v, x, y, z, A, B) {
            B = this.getLayer(B);
            return null === B ? null : q.GetTilesWithin(v, x, y, z, A, B);
          },
          getTilesWithinShape: function (v, x, y, z) {
            z = this.getLayer(z);
            return null === z ? null : q.GetTilesWithinShape(v, x, y, z);
          },
          getTilesWithinWorldXY: function (v, x, y, z, A, B, D) {
            D = this.getLayer(D);
            return null === D
              ? null
              : q.GetTilesWithinWorldXY(v, x, y, z, A, B, D);
          },
          getTileset: function (v) {
            v = this.getIndex(this.tilesets, v);
            return null !== v ? this.tilesets[v] : null;
          },
          getTilesetIndex: function (v) {
            return this.getIndex(this.tilesets, v);
          },
          hasTileAt: function (v, x, y) {
            y = this.getLayer(y);
            return null === y ? null : q.HasTileAt(v, x, y);
          },
          hasTileAtWorldXY: function (v, x, y, z) {
            z = this.getLayer(z);
            return null === z ? null : q.HasTileAtWorldXY(v, x, y, z);
          },
          layer: {
            get: function () {
              return this.layers[this.currentLayerIndex];
            },
            set: function (v) {
              this.setLayer(v);
            },
          },
          putTileAt: function (v, x, y, z, A) {
            void 0 === z && (z = !0);
            A = this.getLayer(A);
            return null === A ? null : q.PutTileAt(v, x, y, z, A);
          },
          putTileAtWorldXY: function (v, x, y, z, A, B) {
            void 0 === z && (z = !0);
            B = this.getLayer(B);
            return null === B ? null : q.PutTileAtWorldXY(v, x, y, z, A, B);
          },
          putTilesAt: function (v, x, y, z, A) {
            void 0 === z && (z = !0);
            A = this.getLayer(A);
            if (null === A) return null;
            q.PutTilesAt(v, x, y, z, A);
            return this;
          },
          randomize: function (v, x, y, z, A, B) {
            B = this.getLayer(B);
            if (null === B) return null;
            q.Randomize(v, x, y, z, A, B);
            return this;
          },
          calculateFacesAt: function (v, x, y) {
            y = this.getLayer(y);
            if (null === y) return null;
            q.CalculateFacesAt(v, x, y);
            return this;
          },
          calculateFacesWithin: function (v, x, y, z, A) {
            A = this.getLayer(A);
            if (null === A) return null;
            q.CalculateFacesWithin(v, x, y, z, A);
            return this;
          },
          removeLayer: function (v) {
            v = this.getLayerIndex(v);
            if (null !== v) {
              g(this.layers, v);
              for (var x = v; x < this.layers.length; x++)
                this.layers[x].tilemapLayer &&
                  this.layers[x].tilemapLayer.layerIndex--;
              this.currentLayerIndex === v && (this.currentLayerIndex = 0);
              return this;
            }
            return null;
          },
          destroyLayer: function (v) {
            var x = this.getLayerIndex(v);
            return null !== x
              ? ((v = this.layers[x]),
                v.destroy(),
                g(this.layers, x),
                this.currentLayerIndex === x && (this.currentLayerIndex = 0),
                this)
              : null;
          },
          removeAllLayers: function () {
            for (var v = this.layers, x = 0; x < v.length; x++)
              v[x].tilemapLayer && v[x].tilemapLayer.destroy(!1);
            this.currentLayerIndex = v.length = 0;
            return this;
          },
          removeTile: function (v, x, y) {
            void 0 === x && (x = -1);
            void 0 === y && (y = !0);
            var z = [];
            Array.isArray(v) || (v = [v]);
            for (var A = 0; A < v.length; A++) {
              var B = v[A];
              z.push(this.removeTileAt(B.x, B.y, !0, y, B.tilemapLayer));
              -1 < x && this.putTileAt(x, B.x, B.y, y, B.tilemapLayer);
            }
            return z;
          },
          removeTileAt: function (v, x, y, z, A) {
            void 0 === y && (y = !0);
            void 0 === z && (z = !0);
            A = this.getLayer(A);
            return null === A ? null : q.RemoveTileAt(v, x, y, z, A);
          },
          removeTileAtWorldXY: function (v, x, y, z, A, B) {
            void 0 === y && (y = !0);
            void 0 === z && (z = !0);
            B = this.getLayer(B);
            return null === B ? null : q.RemoveTileAtWorldXY(v, x, y, z, A, B);
          },
          renderDebug: function (v, x, y) {
            y = this.getLayer(y);
            if (null === y) return null;
            this.orientation === c.ORTHOGONAL && q.RenderDebug(v, x, y);
            return this;
          },
          renderDebugFull: function (v, x) {
            for (var y = this.layers, z = 0; z < y.length; z++)
              q.RenderDebug(v, x, y[z]);
            return this;
          },
          replaceByIndex: function (v, x, y, z, A, B, D) {
            D = this.getLayer(D);
            if (null === D) return null;
            q.ReplaceByIndex(v, x, y, z, A, B, D);
            return this;
          },
          setCollision: function (v, x, y, z, A) {
            void 0 === x && (x = !0);
            void 0 === y && (y = !0);
            void 0 === A && (A = !0);
            z = this.getLayer(z);
            if (null === z) return null;
            q.SetCollision(v, x, y, z, A);
            return this;
          },
          setCollisionBetween: function (v, x, y, z, A) {
            void 0 === y && (y = !0);
            void 0 === z && (z = !0);
            A = this.getLayer(A);
            if (null === A) return null;
            q.SetCollisionBetween(v, x, y, z, A);
            return this;
          },
          setCollisionByProperty: function (v, x, y, z) {
            void 0 === x && (x = !0);
            void 0 === y && (y = !0);
            z = this.getLayer(z);
            if (null === z) return null;
            q.SetCollisionByProperty(v, x, y, z);
            return this;
          },
          setCollisionByExclusion: function (v, x, y, z) {
            void 0 === x && (x = !0);
            void 0 === y && (y = !0);
            z = this.getLayer(z);
            if (null === z) return null;
            q.SetCollisionByExclusion(v, x, y, z);
            return this;
          },
          setCollisionFromCollisionGroup: function (v, x, y) {
            void 0 === v && (v = !0);
            void 0 === x && (x = !0);
            y = this.getLayer(y);
            if (null === y) return null;
            q.SetCollisionFromCollisionGroup(v, x, y);
            return this;
          },
          setTileIndexCallback: function (v, x, y, z) {
            z = this.getLayer(z);
            if (null === z) return null;
            q.SetTileIndexCallback(v, x, y, z);
            return this;
          },
          setTileLocationCallback: function (v, x, y, z, A, B, D) {
            D = this.getLayer(D);
            if (null === D) return null;
            q.SetTileLocationCallback(v, x, y, z, A, B, D);
            return this;
          },
          setLayer: function (v) {
            v = this.getLayerIndex(v);
            null !== v && (this.currentLayerIndex = v);
            return this;
          },
          setBaseTileSize: function (v, x) {
            this.tileWidth = v;
            this.tileHeight = x;
            this.widthInPixels = this.width * v;
            this.heightInPixels = this.height * x;
            for (var y = 0; y < this.layers.length; y++) {
              this.layers[y].baseTileWidth = v;
              this.layers[y].baseTileHeight = x;
              for (
                var z = this.layers[y].data,
                  A = this.layers[y].width,
                  B = this.layers[y].height,
                  D = 0;
                D < B;
                D++
              )
                for (var E = 0; E < A; E++) {
                  var C = z[D][E];
                  null !== C && C.setSize(void 0, void 0, v, x);
                }
            }
            return this;
          },
          setLayerTileSize: function (v, x, y) {
            y = this.getLayer(y);
            if (null === y) return this;
            y.tileWidth = v;
            y.tileHeight = x;
            var z = y.data,
              A = y.width;
            y = y.height;
            for (var B = 0; B < y; B++)
              for (var D = 0; D < A; D++) {
                var E = z[B][D];
                null !== E && E.setSize(v, x);
              }
            return this;
          },
          shuffle: function (v, x, y, z, A) {
            A = this.getLayer(A);
            if (null === A) return null;
            q.Shuffle(v, x, y, z, A);
            return this;
          },
          swapByIndex: function (v, x, y, z, A, B, D) {
            D = this.getLayer(D);
            if (null === D) return null;
            q.SwapByIndex(v, x, y, z, A, B, D);
            return this;
          },
          tileToWorldX: function (v, x, y) {
            y = this.getLayer(y);
            return null === y ? null : this._convert.TileToWorldX(v, x, y);
          },
          tileToWorldY: function (v, x, y) {
            y = this.getLayer(y);
            return null === y ? null : this._convert.TileToWorldY(v, x, y);
          },
          tileToWorldXY: function (v, x, y, z, A) {
            A = this.getLayer(A);
            return null === A
              ? null
              : this._convert.TileToWorldXY(v, x, y, z, A);
          },
          weightedRandomize: function (v, x, y, z, A, B) {
            B = this.getLayer(B);
            if (null === B) return null;
            q.WeightedRandomize(x, y, z, A, v, B);
            return this;
          },
          worldToTileX: function (v, x, y, z) {
            z = this.getLayer(z);
            return null === z ? null : this._convert.WorldToTileX(v, x, y, z);
          },
          worldToTileY: function (v, x, y, z) {
            z = this.getLayer(z);
            return null === z ? null : this._convert.WorldToTileY(v, x, y, z);
          },
          worldToTileXY: function (v, x, y, z, A, B) {
            B = this.getLayer(B);
            return null === B
              ? null
              : this._convert.WorldToTileXY(v, x, y, z, A, B);
          },
          destroy: function () {
            this.removeAllLayers();
            this.tilesets.length = 0;
            this.objects.length = 0;
            this.scene = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(11),
          k = a(15),
          e = a(251);
        a = a(1456);
        a = new t({
          Extends: k,
          Mixins: [
            d.Alpha,
            d.BlendMode,
            d.ComputedSize,
            d.Depth,
            d.Flip,
            d.GetBounds,
            d.Origin,
            d.Pipeline,
            d.Transform,
            d.Visible,
            d.ScrollFactor,
            a,
          ],
          initialize: function (b, c, f, g, m, n) {
            k.call(this, b, "TilemapLayer");
            this.isTilemap = !0;
            this.tilemap = c;
            this.layerIndex = f;
            this.layer = c.layers[f];
            this.layer.tilemapLayer = this;
            this.tileset = [];
            this.tilesDrawn = 0;
            this.tilesTotal = this.layer.width * this.layer.height;
            this.culledTiles = [];
            this.skipCull = !1;
            this.cullPaddingY = this.cullPaddingX = 1;
            this.cullCallback = e.GetCullTilesFunction(this.layer.orientation);
            this._renderOrder = 0;
            this.gidMap = [];
            this.setTilesets(g);
            this.setAlpha(this.layer.alpha);
            this.setPosition(m, n);
            this.setOrigin();
            this.setSize(
              c.tileWidth * this.layer.width,
              c.tileHeight * this.layer.height
            );
            this.initPipeline();
          },
          setTilesets: function (b) {
            var c = [],
              f = [],
              g = this.tilemap;
            Array.isArray(b) || (b = [b]);
            for (var m = 0; m < b.length; m++) {
              var n = b[m];
              "string" === typeof n && (n = g.getTileset(n));
              if (n) {
                f.push(n);
                for (var q = n.firstgid, r = 0; r < n.total; r++) c[q + r] = n;
              }
            }
            this.gidMap = c;
            this.tileset = f;
          },
          setRenderOrder: function (b) {
            var c = ["right-down", "left-down", "right-up", "left-up"];
            "string" === typeof b && (b = c.indexOf(b));
            0 <= b && 4 > b && (this._renderOrder = b);
            return this;
          },
          calculateFacesAt: function (b, c) {
            e.CalculateFacesAt(b, c, this.layer);
            return this;
          },
          calculateFacesWithin: function (b, c, f, g) {
            e.CalculateFacesWithin(b, c, f, g, this.layer);
            return this;
          },
          createFromTiles: function (b, c, f, g, m) {
            return e.CreateFromTiles(b, c, f, g, m, this.layer);
          },
          cull: function (b) {
            return this.cullCallback(
              this.layer,
              b,
              this.culledTiles,
              this._renderOrder
            );
          },
          copy: function (b, c, f, g, m, n, q) {
            e.Copy(b, c, f, g, m, n, q, this.layer);
            return this;
          },
          fill: function (b, c, f, g, m, n) {
            e.Fill(b, c, f, g, m, n, this.layer);
            return this;
          },
          filterTiles: function (b, c, f, g, m, n, q) {
            return e.FilterTiles(b, c, f, g, m, n, q, this.layer);
          },
          findByIndex: function (b, c, f) {
            return e.FindByIndex(b, c, f, this.layer);
          },
          findTile: function (b, c, f, g, m, n, q) {
            return e.FindTile(b, c, f, g, m, n, q, this.layer);
          },
          forEachTile: function (b, c, f, g, m, n, q) {
            e.ForEachTile(b, c, f, g, m, n, q, this.layer);
            return this;
          },
          getTileAt: function (b, c, f) {
            return e.GetTileAt(b, c, f, this.layer);
          },
          getTileAtWorldXY: function (b, c, f, g) {
            return e.GetTileAtWorldXY(b, c, f, g, this.layer);
          },
          getTilesWithin: function (b, c, f, g, m) {
            return e.GetTilesWithin(b, c, f, g, m, this.layer);
          },
          getTilesWithinShape: function (b, c, f) {
            return e.GetTilesWithinShape(b, c, f, this.layer);
          },
          getTilesWithinWorldXY: function (b, c, f, g, m, n) {
            return e.GetTilesWithinWorldXY(b, c, f, g, m, n, this.layer);
          },
          hasTileAt: function (b, c) {
            return e.HasTileAt(b, c, this.layer);
          },
          hasTileAtWorldXY: function (b, c, f) {
            return e.HasTileAtWorldXY(b, c, f, this.layer);
          },
          putTileAt: function (b, c, f, g) {
            return e.PutTileAt(b, c, f, g, this.layer);
          },
          putTileAtWorldXY: function (b, c, f, g, m) {
            return e.PutTileAtWorldXY(b, c, f, g, m, this.layer);
          },
          putTilesAt: function (b, c, f, g) {
            e.PutTilesAt(b, c, f, g, this.layer);
            return this;
          },
          randomize: function (b, c, f, g, m) {
            e.Randomize(b, c, f, g, m, this.layer);
            return this;
          },
          removeTileAt: function (b, c, f, g) {
            return e.RemoveTileAt(b, c, f, g, this.layer);
          },
          removeTileAtWorldXY: function (b, c, f, g, m) {
            return e.RemoveTileAtWorldXY(b, c, f, g, m, this.layer);
          },
          renderDebug: function (b, c) {
            e.RenderDebug(b, c, this.layer);
            return this;
          },
          replaceByIndex: function (b, c, f, g, m, n) {
            e.ReplaceByIndex(b, c, f, g, m, n, this.layer);
            return this;
          },
          setSkipCull: function (b) {
            void 0 === b && (b = !0);
            this.skipCull = b;
            return this;
          },
          setCullPadding: function (b, c) {
            void 0 === b && (b = 1);
            void 0 === c && (c = 1);
            this.cullPaddingX = b;
            this.cullPaddingY = c;
            return this;
          },
          setCollision: function (b, c, f, g) {
            e.SetCollision(b, c, f, this.layer, g);
            return this;
          },
          setCollisionBetween: function (b, c, f, g) {
            e.SetCollisionBetween(b, c, f, g, this.layer);
            return this;
          },
          setCollisionByProperty: function (b, c, f) {
            e.SetCollisionByProperty(b, c, f, this.layer);
            return this;
          },
          setCollisionByExclusion: function (b, c, f) {
            e.SetCollisionByExclusion(b, c, f, this.layer);
            return this;
          },
          setCollisionFromCollisionGroup: function (b, c) {
            e.SetCollisionFromCollisionGroup(b, c, this.layer);
            return this;
          },
          setTileIndexCallback: function (b, c, f) {
            e.SetTileIndexCallback(b, c, f, this.layer);
            return this;
          },
          setTileLocationCallback: function (b, c, f, g, m, n) {
            e.SetTileLocationCallback(b, c, f, g, m, n, this.layer);
            return this;
          },
          shuffle: function (b, c, f, g) {
            e.Shuffle(b, c, f, g, this.layer);
            return this;
          },
          swapByIndex: function (b, c, f, g, m, n) {
            e.SwapByIndex(b, c, f, g, m, n, this.layer);
            return this;
          },
          tileToWorldX: function (b, c) {
            return this.tilemap.tileToWorldX(b, c, this);
          },
          tileToWorldY: function (b, c) {
            return this.tilemap.tileToWorldY(b, c, this);
          },
          tileToWorldXY: function (b, c, f, g) {
            return this.tilemap.tileToWorldXY(b, c, f, g, this);
          },
          weightedRandomize: function (b, c, f, g, m) {
            e.WeightedRandomize(c, f, g, m, b, this.layer);
            return this;
          },
          worldToTileX: function (b, c, f) {
            return this.tilemap.worldToTileX(b, c, f, this);
          },
          worldToTileY: function (b, c, f) {
            return this.tilemap.worldToTileY(b, c, f, this);
          },
          worldToTileXY: function (b, c, f, g, m) {
            return this.tilemap.worldToTileXY(b, c, f, g, m, this);
          },
          destroy: function (b) {
            void 0 === b && (b = !0);
            this.tilemap &&
              (this.layer.tilemapLayer === this &&
                (this.layer.tilemapLayer = void 0),
              b && this.tilemap.removeLayer(this),
              (this.layer = this.tilemap = void 0),
              (this.culledTiles.length = 0),
              (this.cullCallback = null),
              (this.gidMap = []),
              (this.tileset = []),
              k.prototype.destroy.call(this));
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(2);
        a = new t({
          initialize: function (k) {
            this.repeatCount = this.repeat = this.delay = 0;
            this.loop = !1;
            this.callback;
            this.callbackScope;
            this.args;
            this.timeScale = 1;
            this.elapsed = this.startAt = 0;
            this.hasDispatched = this.paused = !1;
            this.reset(k);
          },
          reset: function (k) {
            this.delay = d(k, "delay", 0);
            this.repeat = d(k, "repeat", 0);
            this.loop = d(k, "loop", !1);
            this.callback = d(k, "callback", void 0);
            this.callbackScope = d(k, "callbackScope", this.callback);
            this.args = d(k, "args", []);
            this.timeScale = d(k, "timeScale", 1);
            this.startAt = d(k, "startAt", 0);
            this.paused = d(k, "paused", !1);
            this.elapsed = this.startAt;
            this.hasDispatched = !1;
            this.repeatCount =
              -1 === this.repeat || this.loop ? 999999999999 : this.repeat;
            return this;
          },
          getProgress: function () {
            return this.elapsed / this.delay;
          },
          getOverallProgress: function () {
            return 0 < this.repeat
              ? (this.elapsed + this.delay * (this.repeat - this.repeatCount)) /
                  (this.delay + this.delay * this.repeat)
              : this.getProgress();
          },
          getRepeatCount: function () {
            return this.repeatCount;
          },
          getElapsed: function () {
            return this.elapsed;
          },
          getElapsedSeconds: function () {
            return 0.001 * this.elapsed;
          },
          getRemaining: function () {
            return this.delay - this.elapsed;
          },
          getRemainingSeconds: function () {
            return 0.001 * this.getRemaining();
          },
          getOverallRemaining: function () {
            return this.delay * (1 + this.repeatCount) - this.elapsed;
          },
          getOverallRemainingSeconds: function () {
            return 0.001 * this.getOverallRemaining();
          },
          remove: function (k) {
            void 0 === k && (k = !1);
            this.elapsed = this.delay;
            this.hasDispatched = !k;
            this.repeatCount = 0;
          },
          destroy: function () {
            this.callbackScope = this.callback = void 0;
            this.args = [];
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(1465);
        h.exports = function (k) {
          var e,
            b = [];
          if (k.hasOwnProperty("props"))
            for (e in k.props)
              "_" !== e.substr(0, 1) &&
                b.push({
                  key: e,
                  value: k.props[e],
                });
          else
            for (e in k)
              -1 === d.indexOf(e) &&
                "_" !== e.substr(0, 1) &&
                b.push({
                  key: e,
                  value: k[e],
                });
          return b;
        };
      },
      function (h, t, a) {
        var d = a(6);
        h.exports = function (k) {
          k = d(k, "tweens", null);
          if (null === k) return [];
          "function" === typeof k && (k = k.call());
          Array.isArray(k) || (k = [k]);
          return k;
        };
      },
      function (h, t, a) {
        var d = a(265),
          k = a(13),
          e = a(99),
          b = a(80),
          c = a(162),
          f = a(6),
          g = a(264),
          m = a(266),
          n = a(268);
        h.exports = function (q, r, u) {
          void 0 === u && (u = d);
          var v = f(r, "from", 0),
            x = f(r, "to", 1),
            y = [
              {
                value: v,
              },
            ],
            z = c(r, "delay", u.delay),
            A = c(r, "duration", u.duration),
            B = f(r, "easeParams", u.easeParams);
          B = b(f(r, "ease", u.ease), B);
          var D = c(r, "hold", u.hold),
            E = c(r, "repeat", u.repeat),
            C = c(r, "repeatDelay", u.repeatDelay),
            F = e(r, "yoyo", u.yoyo);
          u = [];
          var G = g("value", x);
          z = n(
            y[0],
            0,
            "value",
            G.getEnd,
            G.getStart,
            G.getActive,
            B,
            z,
            A,
            F,
            D,
            E,
            C,
            !1,
            !1
          );
          z.start = v;
          z.current = v;
          z.to = x;
          u.push(z);
          q = new m(q, u, y);
          q.offset = k(r, "offset", null);
          q.completeDelay = k(r, "completeDelay", 0);
          q.loop = Math.round(k(r, "loop", 0));
          q.loopDelay = Math.round(k(r, "loopDelay", 0));
          q.paused = e(r, "paused", !1);
          q.useFrames = e(r, "useFrames", !1);
          v = f(r, "callbackScope", q);
          x = [q, null];
          y = m.TYPES;
          for (z = 0; z < y.length; z++)
            if (((A = y[z]), (B = f(r, A, !1))))
              (D = f(r, A + "Scope", v)),
                (E = f(r, A + "Params", [])),
                q.setCallback(A, B, x.concat(E), D);
          return q;
        };
      },
      function (h, t, a) {
        var d = a(80),
          k = a(6),
          e = a(14);
        h.exports = function (b, c) {
          void 0 === c && (c = {});
          var f = k(c, "start", 0),
            g = k(c, "ease", null),
            m = k(c, "grid", null),
            n = k(c, "from", 0),
            q = "first" === n,
            r = "center" === n,
            u = "last" === n,
            v = "number" === typeof n,
            x = Array.isArray(b),
            y = x ? parseFloat(b[0]) : parseFloat(b),
            z = x ? parseFloat(b[1]) : 0,
            A = Math.max(y, z);
          x && (f += y);
          if (m) {
            var B = m[0],
              D = m[1],
              E = (c = b = 0),
              C = 0,
              F = [];
            u
              ? ((b = B - 1), (c = D - 1))
              : v
              ? ((b = n % B), (c = Math.floor(n / B)))
              : r && ((b = (B - 1) / 2), (c = (D - 1) / 2));
            for (var G = e.MIN_SAFE_INTEGER, H = 0; H < D; H++) {
              F[H] = [];
              for (var K = 0; K < B; K++)
                (E = b - K),
                  (C = c - H),
                  (E = Math.sqrt(E * E + C * C)),
                  E > G && (G = E),
                  (F[H][K] = E);
            }
          }
          var I = g ? d(g) : null;
          return m
            ? function (M, N, P, J) {
                M = 0;
                N = J % B;
                J = Math.floor(J / B);
                0 <= N && N < B && 0 <= J && J < D && (M = F[J][N]);
                x
                  ? ((J = z - y),
                    (J = I ? (M / G) * J * I(M / G) : (M / G) * J))
                  : (J = I ? M * y * I(M / G) : M * y);
                return J + f;
              }
            : function (M, N, P, J, L) {
                L--;
                var O;
                q
                  ? (O = J)
                  : r
                  ? (O = Math.abs(L / 2 - J))
                  : u
                  ? (O = L - J)
                  : v && (O = Math.abs(n - J));
                x
                  ? ((M = r ? ((z - y) / L) * 2 * O : ((z - y) / L) * O),
                    (L = I ? M * I(O / L) : M))
                  : (L = I ? L * A * I(O / L) : O * y);
                return L + f;
              };
        };
      },
      function (h, t, a) {
        var d = a(77),
          k = a(265),
          e = a(13),
          b = a(99),
          c = a(80),
          f = a(162),
          g = a(263),
          m = a(584),
          n = a(6),
          q = a(588),
          r = a(163);
        h.exports = function (u, v) {
          u = new q(u);
          u.completeDelay = e(v, "completeDelay", 0);
          u.loop = Math.round(e(v, "loop", 0));
          u.loopDelay = Math.round(e(v, "loopDelay", 0));
          u.paused = b(v, "paused", !1);
          u.useFrames = b(v, "useFrames", !1);
          var x = n(v, "callbackScope", u),
            y = [u],
            z = n(v, "onStart", !1);
          if (z) {
            var A = n(v, "onStartScope", x),
              B = n(v, "onStartParams", []);
            u.setCallback("onStart", z, y.concat(B), A);
          }
          if ((z = n(v, "onUpdate", !1)))
            (A = n(v, "onUpdateScope", x)),
              (B = n(v, "onUpdateParams", [])),
              u.setCallback("onUpdate", z, y.concat(B), A);
          if ((z = n(v, "onLoop", !1)))
            (A = n(v, "onLoopScope", x)),
              (B = n(v, "onLoopParams", [])),
              u.setCallback("onLoop", z, y.concat(B), A);
          if ((z = n(v, "onYoyo", !1)))
            (A = n(v, "onYoyoScope", x)),
              (B = n(v, "onYoyoParams", [])),
              u.setCallback("onYoyo", z, y.concat(null, B), A);
          if ((z = n(v, "onComplete", !1)))
            (x = n(v, "onCompleteScope", x)),
              (A = n(v, "onCompleteParams", [])),
              u.setCallback("onComplete", z, y.concat(A), x);
          y = m(v);
          if (0 === y.length) return (u.paused = !0), u;
          x = d(k);
          x.targets = g(v);
          z = e(v, "totalDuration", 0);
          x.duration =
            0 < z ? Math.floor(z / y.length) : f(v, "duration", x.duration);
          x.delay = f(v, "delay", x.delay);
          x.easeParams = n(v, "easeParams", x.easeParams);
          x.ease = c(n(v, "ease", x.ease), x.easeParams);
          x.hold = f(v, "hold", x.hold);
          x.repeat = f(v, "repeat", x.repeat);
          x.repeatDelay = f(v, "repeatDelay", x.repeatDelay);
          x.yoyo = b(v, "yoyo", x.yoyo);
          x.flipX = b(v, "flipX", x.flipX);
          x.flipY = b(v, "flipY", x.flipY);
          for (v = 0; v < y.length; v++) u.queue(r(u, y[v], x));
          return u;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(9),
          k = a(267),
          e = a(163),
          b = a(100),
          c = new t({
            Extends: d,
            initialize: function (f) {
              d.call(this);
              this.manager = f;
              this.isTimeline = !0;
              this.data = [];
              this.totalData = 0;
              this.useFrames = !1;
              this.timeScale = 1;
              this.countdown =
                this.completeDelay =
                this.loopCounter =
                this.loopDelay =
                this.loop =
                  0;
              this._pausedState = this.state = b.PENDING_ADD;
              this.paused = !1;
              this.totalProgress =
                this.totalDuration =
                this.progress =
                this.duration =
                this.totalElapsed =
                this.elapsed =
                  0;
              this.callbacks = {
                onComplete: null,
                onLoop: null,
                onStart: null,
                onUpdate: null,
                onYoyo: null,
              };
              this.callbackScope;
            },
            dispatchTimelineEvent: function (f, g) {
              this.emit(f, this);
              g && g.func.apply(g.scope, g.params);
            },
            setTimeScale: function (f) {
              this.timeScale = f;
              return this;
            },
            getTimeScale: function () {
              return this.timeScale;
            },
            isPlaying: function () {
              return this.state === b.ACTIVE;
            },
            add: function (f) {
              return this.queue(e(this, f));
            },
            queue: function (f) {
              this.isPlaying() ||
                ((f.parent = this),
                (f.parentIsTimeline = !0),
                this.data.push(f),
                (this.totalData = this.data.length));
              return this;
            },
            hasOffset: function (f) {
              return null !== f.offset;
            },
            isOffsetAbsolute: function (f) {
              return "number" === typeof f;
            },
            isOffsetRelative: function (f) {
              return "string" === typeof f &&
                ((f = f[0]), "-" === f || "+" === f)
                ? !0
                : !1;
            },
            getRelativeOffset: function (f, g) {
              var m = f[0];
              f = parseFloat(f.substr(2));
              switch (m) {
                case "+":
                  g += f;
                  break;
                case "-":
                  g -= f;
              }
              return Math.max(0, g);
            },
            calcDuration: function () {
              for (var f = 0, g = 0, m = 0, n = 0; n < this.totalData; n++) {
                var q = this.data[n];
                q.init();
                this.hasOffset(q)
                  ? this.isOffsetAbsolute(q.offset)
                    ? ((q.calculatedOffset = q.offset),
                      0 === q.offset && (m = 0))
                    : this.isOffsetRelative(q.offset) &&
                      (q.calculatedOffset = this.getRelativeOffset(q.offset, f))
                  : (q.calculatedOffset = m);
                f = q.totalDuration + q.calculatedOffset;
                g += q.totalDuration;
                m += q.totalDuration;
              }
              this.duration = g;
              this.loopCounter = -1 === this.loop ? 999999999999 : this.loop;
              this.totalDuration =
                0 < this.loopCounter
                  ? this.duration +
                    this.completeDelay +
                    (this.duration + this.loopDelay) * this.loopCounter
                  : this.duration + this.completeDelay;
            },
            init: function () {
              this.calcDuration();
              this.totalProgress = this.progress = 0;
              return this.paused ? ((this.state = b.PAUSED), !1) : !0;
            },
            resetTweens: function (f) {
              for (var g = 0; g < this.totalData; g++) this.data[g].play(f);
            },
            setCallback: function (f, g, m, n) {
              -1 !== c.TYPES.indexOf(f) &&
                (this.callbacks[f] = {
                  func: g,
                  scope: n,
                  params: m,
                });
              return this;
            },
            makeActive: function (f) {
              return this.manager.makeActive(f);
            },
            play: function () {
              this.state !== b.ACTIVE &&
                (this.paused
                  ? ((this.paused = !1), this.manager.makeActive(this))
                  : (this.resetTweens(!1),
                    (this.state = b.ACTIVE),
                    this.dispatchTimelineEvent(
                      k.TIMELINE_START,
                      this.callbacks.onStart
                    )));
            },
            nextState: function () {
              0 < this.loopCounter
                ? ((this.progress = this.elapsed = 0),
                  this.loopCounter--,
                  this.resetTweens(!0),
                  0 < this.loopDelay
                    ? ((this.countdown = this.loopDelay),
                      (this.state = b.LOOP_DELAY))
                    : ((this.state = b.ACTIVE),
                      this.dispatchTimelineEvent(
                        k.TIMELINE_LOOP,
                        this.callbacks.onLoop
                      )))
                : 0 < this.completeDelay
                ? ((this.state = b.COMPLETE_DELAY),
                  (this.countdown = this.completeDelay))
                : ((this.state = b.PENDING_REMOVE),
                  this.dispatchTimelineEvent(
                    k.TIMELINE_COMPLETE,
                    this.callbacks.onComplete
                  ));
            },
            update: function (f, g) {
              if (this.state !== b.PAUSED) {
                this.useFrames && (g = 1 * this.manager.timeScale);
                g *= this.timeScale;
                this.elapsed += g;
                this.progress = Math.min(this.elapsed / this.duration, 1);
                this.totalElapsed += g;
                this.totalProgress = Math.min(
                  this.totalElapsed / this.totalDuration,
                  1
                );
                switch (this.state) {
                  case b.ACTIVE:
                    for (var m = this.totalData, n = 0; n < this.totalData; n++)
                      this.data[n].update(f, g) && m--;
                    this.dispatchTimelineEvent(
                      k.TIMELINE_UPDATE,
                      this.callbacks.onUpdate
                    );
                    0 === m && this.nextState();
                    break;
                  case b.LOOP_DELAY:
                    this.countdown -= g;
                    0 >= this.countdown &&
                      ((this.state = b.ACTIVE),
                      this.dispatchTimelineEvent(
                        k.TIMELINE_LOOP,
                        this.callbacks.onLoop
                      ));
                    break;
                  case b.COMPLETE_DELAY:
                    (this.countdown -= g),
                      0 >= this.countdown &&
                        ((this.state = b.PENDING_REMOVE),
                        this.dispatchTimelineEvent(
                          k.TIMELINE_COMPLETE,
                          this.callbacks.onComplete
                        ));
                }
                return this.state === b.PENDING_REMOVE;
              }
            },
            stop: function () {
              this.state = b.PENDING_REMOVE;
            },
            pause: function () {
              if (this.state !== b.PAUSED)
                return (
                  (this.paused = !0),
                  (this._pausedState = this.state),
                  (this.state = b.PAUSED),
                  this.emit(k.TIMELINE_PAUSE, this),
                  this
                );
            },
            resume: function () {
              this.state === b.PAUSED &&
                ((this.paused = !1),
                (this.state = this._pausedState),
                this.emit(k.TIMELINE_RESUME, this));
              return this;
            },
            hasTarget: function (f) {
              for (var g = 0; g < this.data.length; g++)
                if (this.data[g].hasTarget(f)) return !0;
              return !1;
            },
            destroy: function () {
              for (var f = 0; f < this.data.length; f++) this.data[f].stop();
            },
          });
        c.TYPES = ["onStart", "onUpdate", "onLoop", "onComplete", "onYoyo"];
        h.exports = c;
      },
      function (h, t, a) {
        var d = a(86),
          k = a(41),
          e = a(32),
          b = a(2),
          c = a(64);
        h.exports = {
          parseBody: function (f, g, m, n) {
            void 0 === n && (n = {});
            for (var q = b(m, "fixtures", []), r = [], u = 0; u < q.length; u++)
              for (var v = this.parseFixture(q[u]), x = 0; x < v.length; x++)
                r.push(v[x]);
            m = e.clone(m, !0);
            e.extend(m, n, !0);
            delete m.fixtures;
            delete m.type;
            n = k.create(m);
            k.setParts(n, r);
            k.setPosition(n, {
              x: f,
              y: g,
            });
            return n;
          },
          parseFixture: function (f) {
            var g = e.extend({}, !1, f);
            delete g.circle;
            delete g.vertices;
            if (f.circle) {
              var m = b(f.circle, "x");
              var n = b(f.circle, "y");
              f = b(f.circle, "radius");
              m = [d.circle(m, n, f, g)];
            } else f.vertices && (m = this.parseVertices(f.vertices, g));
            return m;
          },
          parseVertices: function (f, g) {
            void 0 === g && (g = {});
            for (var m = [], n = 0; n < f.length; n++)
              c.clockwiseSort(f[n]),
                m.push(
                  k.create(
                    e.extend(
                      {
                        position: c.centre(f[n]),
                        vertices: f[n],
                      },
                      g
                    )
                  )
                );
            return d.flagCoincidentParts(m);
          },
        };
      },
      function (h, t, a) {
        var d = a(86),
          k = a(41);
        h.exports = {
          parseBody: function (e, b, c, f) {
            void 0 === f && (f = {});
            var g = c.vertices;
            if (1 === g.length)
              (f.vertices = g[0]),
                (f = k.create(f)),
                d.flagCoincidentParts(f.parts);
            else {
              for (var m = [], n = 0; n < g.length; n++) {
                var q = k.create({
                  vertices: g[n],
                });
                m.push(q);
              }
              d.flagCoincidentParts(m);
              f.parts = m;
              f = k.create(f);
            }
            f.label = c.label;
            k.setPosition(f, {
              x: e,
              y: b,
            });
            return f;
          },
        };
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(118),
          e = a(128),
          b = a(32),
          c = a(41),
          f = a(86);
        (function () {
          d.stack = function (g, m, n, q, r, u, v) {
            for (
              var x = k.create({
                  label: "Stack",
                }),
                y = g,
                z,
                A = 0,
                B = 0;
              B < q;
              B++
            ) {
              for (var D = 0, E = 0; E < n; E++) {
                var C = v(y, m, E, B, z, A);
                C
                  ? ((y = C.bounds.max.y - C.bounds.min.y),
                    (z = C.bounds.max.x - C.bounds.min.x),
                    y > D && (D = y),
                    c.translate(C, {
                      x: 0.5 * z,
                      y: 0.5 * y,
                    }),
                    (y = C.bounds.max.x + r),
                    k.addBody(x, C),
                    (z = C),
                    (A += 1))
                  : (y += r);
              }
              m += D + u;
              y = g;
            }
            return x;
          };
          d.chain = function (g, m, n, q, r, u) {
            for (var v = g.bodies, x = 1; x < v.length; x++) {
              var y = v[x - 1],
                z = v[x];
              y = b.extend(
                {
                  bodyA: y,
                  pointA: {
                    x: (y.bounds.max.x - y.bounds.min.x) * m,
                    y: (y.bounds.max.y - y.bounds.min.y) * n,
                  },
                  bodyB: z,
                  pointB: {
                    x: (z.bounds.max.x - z.bounds.min.x) * q,
                    y: (z.bounds.max.y - z.bounds.min.y) * r,
                  },
                },
                u
              );
              k.addConstraint(g, e.create(y));
            }
            g.label += " Chain";
            return g;
          };
          d.mesh = function (g, m, n, q, r) {
            var u = g.bodies,
              v,
              x;
            for (v = 0; v < n; v++) {
              for (x = 1; x < m; x++) {
                var y = u[x - 1 + v * m];
                var z = u[x + v * m];
                k.addConstraint(
                  g,
                  e.create(
                    b.extend(
                      {
                        bodyA: y,
                        bodyB: z,
                      },
                      r
                    )
                  )
                );
              }
              if (0 < v)
                for (x = 0; x < m; x++)
                  (y = u[x + (v - 1) * m]),
                    (z = u[x + v * m]),
                    k.addConstraint(
                      g,
                      e.create(
                        b.extend(
                          {
                            bodyA: y,
                            bodyB: z,
                          },
                          r
                        )
                      )
                    ),
                    q &&
                      0 < x &&
                      ((y = u[x - 1 + (v - 1) * m]),
                      k.addConstraint(
                        g,
                        e.create(
                          b.extend(
                            {
                              bodyA: y,
                              bodyB: z,
                            },
                            r
                          )
                        )
                      )),
                    q &&
                      x < m - 1 &&
                      ((y = u[x + 1 + (v - 1) * m]),
                      k.addConstraint(
                        g,
                        e.create(
                          b.extend(
                            {
                              bodyA: y,
                              bodyB: z,
                            },
                            r
                          )
                        )
                      ));
            }
            g.label += " Mesh";
            return g;
          };
          d.pyramid = function (g, m, n, q, r, u, v) {
            return d.stack(g, m, n, q, r, u, function (x, y, z, A, B, D) {
              var E = Math.min(q, Math.ceil(n / 2));
              x = B ? B.bounds.max.x - B.bounds.min.x : 0;
              if (!(A > E || ((A = E - A), (E = n - 1 - A), z < A || z > E)))
                return (
                  1 === D &&
                    c.translate(B, {
                      x: (z + (1 === n % 2 ? 1 : -1)) * x,
                      y: 0,
                    }),
                  v(g + (B ? z * x : 0) + z * r, y, z, A, B, D)
                );
            });
          };
          d.newtonsCradle = function (g, m, n, q, r) {
            for (
              var u = k.create({
                  label: "Newtons Cradle",
                }),
                v = 0;
              v < n;
              v++
            ) {
              var x = f.circle(g + 1.9 * v * q, m + r, q, {
                  inertia: Infinity,
                  restitution: 1,
                  friction: 0,
                  frictionAir: 1e-4,
                  slop: 1,
                }),
                y = e.create({
                  pointA: {
                    x: g + 1.9 * v * q,
                    y: m,
                  },
                  bodyB: x,
                });
              k.addBody(u, x);
              k.addConstraint(u, y);
            }
            return u;
          };
          d.car = function (g, m, n, q, r) {
            var u = c.nextGroup(!0),
              v = 0.5 * -n + 20,
              x = 0.5 * n - 20,
              y = k.create({
                label: "Car",
              });
            n = f.rectangle(g, m, n, q, {
              collisionFilter: {
                group: u,
              },
              chamfer: {
                radius: 0.5 * q,
              },
              density: 2e-4,
            });
            q = f.circle(g + v, m + 0, r, {
              collisionFilter: {
                group: u,
              },
              friction: 0.8,
            });
            g = f.circle(g + x, m + 0, r, {
              collisionFilter: {
                group: u,
              },
              friction: 0.8,
            });
            v = e.create({
              bodyB: n,
              pointB: {
                x: v,
                y: 0,
              },
              bodyA: q,
              stiffness: 1,
              length: 0,
            });
            x = e.create({
              bodyB: n,
              pointB: {
                x,
                y: 0,
              },
              bodyA: g,
              stiffness: 1,
              length: 0,
            });
            k.addBody(y, n);
            k.addBody(y, q);
            k.addBody(y, g);
            k.addConstraint(y, v);
            k.addConstraint(y, x);
            return y;
          };
          d.softBody = function (g, m, n, q, r, u, v, x, y, z) {
            y = b.extend(
              {
                inertia: Infinity,
              },
              y
            );
            z = b.extend(
              {
                stiffness: 0.2,
                render: {
                  type: "line",
                  anchors: !1,
                },
              },
              z
            );
            g = d.stack(g, m, n, q, r, u, function (A, B) {
              return f.circle(A, B, x, y);
            });
            d.mesh(g, n, q, v, z);
            g.label = "Soft Body";
            return g;
          };
        })();
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        a(84);
        var k = a(32);
        (function () {
          d.pathToVertices = function (e, b) {
            "undefined" === typeof window ||
              "SVGPathSeg" in window ||
              k.warn(
                "Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required."
              );
            var c,
              f,
              g,
              m = [],
              n,
              q,
              r = 0,
              u = 0,
              v = 0;
            b = b || 15;
            var x = function (D, E, C) {
                C = 1 === C % 2 && 1 < C;
                if (!g || D != g.x || E != g.y) {
                  g && C ? ((n = g.x), (q = g.y)) : (q = n = 0);
                  var F = {
                    x: n + D,
                    y: q + E,
                  };
                  if (C || !g) g = F;
                  m.push(F);
                  u = n + D;
                  v = q + E;
                }
              },
              y = function (D) {
                var E = D.pathSegTypeAsLetter.toUpperCase();
                if ("Z" !== E) {
                  switch (E) {
                    case "M":
                    case "L":
                    case "T":
                    case "C":
                    case "S":
                    case "Q":
                      u = D.x;
                      v = D.y;
                      break;
                    case "H":
                      u = D.x;
                      break;
                    case "V":
                      v = D.y;
                  }
                  x(u, v, D.pathSegType);
                }
              };
            d._svgPathToAbsolute(e);
            var z = e.getTotalLength();
            var A = [];
            for (c = 0; c < e.pathSegList.numberOfItems; c += 1)
              A.push(e.pathSegList.getItem(c));
            for (f = A.concat(); r < z; ) {
              c = e.getPathSegAtLength(r);
              c = A[c];
              if (c != B) {
                for (; f.length && f[0] != c; ) y(f.shift());
                var B = c;
              }
              switch (c.pathSegTypeAsLetter.toUpperCase()) {
                case "C":
                case "T":
                case "S":
                case "Q":
                case "A":
                  (c = e.getPointAtLength(r)), x(c.x, c.y, 0);
              }
              r += b;
            }
            c = 0;
            for (e = f.length; c < e; ++c) y(f[c]);
            return m;
          };
          d._svgPathToAbsolute = function (e) {
            for (
              var b,
                c,
                f,
                g,
                m,
                n,
                q = e.pathSegList,
                r = 0,
                u = 0,
                v = q.numberOfItems,
                x = 0;
              x < v;
              ++x
            ) {
              var y = q.getItem(x),
                z = y.pathSegTypeAsLetter;
              if (/[MLHVCSQTA]/.test(z))
                "x" in y && (r = y.x), "y" in y && (u = y.y);
              else
                switch (
                  ("x1" in y && (f = r + y.x1),
                  "x2" in y && (m = r + y.x2),
                  "y1" in y && (g = u + y.y1),
                  "y2" in y && (n = u + y.y2),
                  "x" in y && (r += y.x),
                  "y" in y && (u += y.y),
                  z)
                ) {
                  case "m":
                    q.replaceItem(e.createSVGPathSegMovetoAbs(r, u), x);
                    break;
                  case "l":
                    q.replaceItem(e.createSVGPathSegLinetoAbs(r, u), x);
                    break;
                  case "h":
                    q.replaceItem(e.createSVGPathSegLinetoHorizontalAbs(r), x);
                    break;
                  case "v":
                    q.replaceItem(e.createSVGPathSegLinetoVerticalAbs(u), x);
                    break;
                  case "c":
                    q.replaceItem(
                      e.createSVGPathSegCurvetoCubicAbs(r, u, f, g, m, n),
                      x
                    );
                    break;
                  case "s":
                    q.replaceItem(
                      e.createSVGPathSegCurvetoCubicSmoothAbs(r, u, m, n),
                      x
                    );
                    break;
                  case "q":
                    q.replaceItem(
                      e.createSVGPathSegCurvetoQuadraticAbs(r, u, f, g),
                      x
                    );
                    break;
                  case "t":
                    q.replaceItem(
                      e.createSVGPathSegCurvetoQuadraticSmoothAbs(r, u),
                      x
                    );
                    break;
                  case "a":
                    q.replaceItem(
                      e.createSVGPathSegArcAbs(
                        r,
                        u,
                        y.r1,
                        y.r2,
                        y.angle,
                        y.largeArcFlag,
                        y.sweepFlag
                      ),
                      x
                    );
                    break;
                  case "z":
                  case "Z":
                    (r = b), (u = c);
                }
              if ("M" == z || "m" == z) (b = r), (c = u);
            }
          };
        })();
      },
      function (h, t, a) {
        var d = a(86),
          k = a(41);
        t = a(0);
        var e = a(249),
          b = a(9),
          c = a(2),
          f = a(126),
          g = a(64);
        a = new t({
          Extends: b,
          Mixins: [
            e.Bounce,
            e.Collision,
            e.Friction,
            e.Gravity,
            e.Mass,
            e.Sensor,
            e.Sleep,
            e.Static,
          ],
          initialize: function (m, n, q) {
            b.call(this);
            this.tile = n;
            this.world = m;
            n.physics.matterBody && n.physics.matterBody.destroy();
            n.physics.matterBody = this;
            m = c(q, "body", null);
            var r = c(q, "addToWorld", !0);
            m
              ? this.setBody(m, r)
              : ((n = n.getCollisionGroup()),
                0 < c(n, "objects", []).length
                  ? this.setFromTileCollision(q)
                  : this.setFromTileRectangle(q));
          },
          setFromTileRectangle: function (m) {
            void 0 === m && (m = {});
            f(m, "isStatic") || (m.isStatic = !0);
            f(m, "addToWorld") || (m.addToWorld = !0);
            var n = this.tile.getBounds();
            n = d.rectangle(
              n.x + n.width / 2,
              n.y + n.height / 2,
              n.width,
              n.height,
              m
            );
            this.setBody(n, m.addToWorld);
            return this;
          },
          setFromTileCollision: function (m) {
            void 0 === m && (m = {});
            f(m, "isStatic") || (m.isStatic = !0);
            f(m, "addToWorld") || (m.addToWorld = !0);
            var n = this.tile.tilemapLayer.scaleX,
              q = this.tile.tilemapLayer.scaleY,
              r = this.tile.getLeft(),
              u = this.tile.getTop(),
              v = this.tile.getCollisionGroup();
            v = c(v, "objects", []);
            for (var x = [], y = 0; y < v.length; y++) {
              var z = v[y],
                A = r + z.x * n,
                B = u + z.y * q,
                D = z.width * n,
                E = z.height * q,
                C = null;
              if (z.rectangle) C = d.rectangle(A + D / 2, B + E / 2, D, E, m);
              else if (z.ellipse) C = d.circle(A + D / 2, B + E / 2, D / 2, m);
              else if (z.polygon || z.polyline)
                (z = (z.polygon ? z.polygon : z.polyline).map(function (F) {
                  return {
                    x: F.x * n,
                    y: F.y * q,
                  };
                })),
                  (z = g.create(z)),
                  (D = g.centre(z)),
                  (A += D.x),
                  (B += D.y),
                  (C = d.fromVertices(A, B, z, m));
              C && x.push(C);
            }
            1 === x.length
              ? this.setBody(x[0], m.addToWorld)
              : 1 < x.length &&
                ((m.parts = x), this.setBody(k.create(m), m.addToWorld));
            return this;
          },
          setBody: function (m, n) {
            void 0 === n && (n = !0);
            this.body && this.removeBody();
            this.body = m;
            this.body.gameObject = this;
            n && this.world.add(this.body);
            return this;
          },
          removeBody: function () {
            this.body &&
              (this.world.remove(this.body),
              (this.body = this.body.gameObject = void 0));
            return this;
          },
          destroy: function () {
            this.removeBody();
            this.tile.physics.matterBody = void 0;
            this.removeAllListeners();
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(1399);
        t.Body = a(41);
        t.Composite = a(118);
        t.World = a(596);
        t.Detector = a(273);
        t.Grid = a(597);
        t.Pairs = a(598);
        t.Pair = a(250);
        t.Query = a(1400);
        t.Resolver = a(599);
        t.SAT = a(274);
        t.Constraint = a(128);
        t.Common = a(32);
        t.Engine = a(1401);
        t.Events = a(166);
        t.Sleeping = a(165);
        t.Plugin = a(595);
        t.Bodies = a(86);
        t.Composites = a(591);
        t.Axes = a(271);
        t.Bounds = a(84);
        t.Svg = a(592);
        t.Vector = a(83);
        t.Vertices = a(64);
        t.World.add = t.Composite.add;
        t.World.remove = t.Composite.remove;
        t.World.addComposite = t.Composite.addComposite;
        t.World.addBody = t.Composite.addBody;
        t.World.addConstraint = t.Composite.addConstraint;
        t.World.clear = t.Composite.clear;
        h.exports = t;
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(32);
        (function () {
          d._registry = {};
          d.register = function (e) {
            d.isPlugin(e) ||
              k.warn(
                "Plugin.register:",
                d.toString(e),
                "does not implement all required fields."
              );
            if (e.name in d._registry) {
              var b = d._registry[e.name],
                c = d.versionParse(e.version).number,
                f = d.versionParse(b.version).number;
              c > f
                ? (k.warn(
                    "Plugin.register:",
                    d.toString(b),
                    "was upgraded to",
                    d.toString(e)
                  ),
                  (d._registry[e.name] = e))
                : c < f
                ? k.warn(
                    "Plugin.register:",
                    d.toString(b),
                    "can not be downgraded to",
                    d.toString(e)
                  )
                : e !== b &&
                  k.warn(
                    "Plugin.register:",
                    d.toString(e),
                    "is already registered to different plugin object"
                  );
            } else d._registry[e.name] = e;
            return e;
          };
          d.resolve = function (e) {
            return d._registry[d.dependencyParse(e).name];
          };
          d.toString = function (e) {
            return "string" === typeof e
              ? e
              : (e.name || "anonymous") +
                  "@" +
                  (e.version || e.range || "0.0.0");
          };
          d.isPlugin = function (e) {
            return e && e.name && e.version && e.install;
          };
          d.isUsed = function (e, b) {
            return -1 < e.used.indexOf(b);
          };
          d.isFor = function (e, b) {
            var c = e.for && d.dependencyParse(e.for);
            return (
              !e.for ||
              (b.name === c.name && d.versionSatisfies(b.version, c.range))
            );
          };
          d.use = function (e, b) {
            e.uses = (e.uses || []).concat(b || []);
            if (0 === e.uses.length)
              k.warn(
                "Plugin.use:",
                d.toString(e),
                "does not specify any dependencies to install."
              );
            else {
              b = d.dependencies(e);
              b = k.topologicalSort(b);
              for (var c = [], f = 0; f < b.length; f += 1)
                if (b[f] !== e.name) {
                  var g = d.resolve(b[f]);
                  g
                    ? d.isUsed(e, g.name) ||
                      (d.isFor(g, e) ||
                        (k.warn(
                          "Plugin.use:",
                          d.toString(g),
                          "is for",
                          g.for,
                          "but installed on",
                          d.toString(e) + "."
                        ),
                        (g._warned = !0)),
                      g.install
                        ? g.install(e)
                        : (k.warn(
                            "Plugin.use:",
                            d.toString(g),
                            "does not specify an install function."
                          ),
                          (g._warned = !0)),
                      g._warned
                        ? (c.push("\ud83d\udd36 " + d.toString(g)),
                          delete g._warned)
                        : c.push("\u2705 " + d.toString(g)),
                      e.used.push(g.name))
                    : c.push("\u274c " + b[f]);
                }
              0 < c.length && !g.silent && k.info(c.join("  "));
            }
          };
          d.dependencies = function (e, b) {
            var c = d.dependencyParse(e),
              f = c.name;
            b = b || {};
            if (!(f in b)) {
              e = d.resolve(e) || e;
              b[f] = k.map(e.uses || [], function (m) {
                d.isPlugin(m) && d.register(m);
                var n = d.dependencyParse(m),
                  q = d.resolve(m);
                q && !d.versionSatisfies(q.version, n.range)
                  ? (k.warn(
                      "Plugin.dependencies:",
                      d.toString(q),
                      "does not satisfy",
                      d.toString(n),
                      "used by",
                      d.toString(c) + "."
                    ),
                    (q._warned = !0),
                    (e._warned = !0))
                  : q ||
                    (k.warn(
                      "Plugin.dependencies:",
                      d.toString(m),
                      "used by",
                      d.toString(c),
                      "could not be resolved."
                    ),
                    (e._warned = !0));
                return n.name;
              });
              for (var g = 0; g < b[f].length; g += 1)
                d.dependencies(b[f][g], b);
              return b;
            }
          };
          d.dependencyParse = function (e) {
            return k.isString(e)
              ? (/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/.test(
                  e
                ) ||
                  k.warn(
                    "Plugin.dependencyParse:",
                    e,
                    "is not a valid dependency string."
                  ),
                {
                  name: e.split("@")[0],
                  range: e.split("@")[1] || "*",
                })
              : {
                  name: e.name,
                  range: e.range || e.version,
                };
          };
          d.versionParse = function (e) {
            /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/.test(e) ||
              k.warn(
                "Plugin.versionParse:",
                e,
                "is not a valid version or range."
              );
            var b = e.split("-");
            e = b[0];
            var c = isNaN(Number(e[0])),
              f = c ? e.substr(1) : e,
              g = k.map(f.split("."), function (m) {
                return Number(m);
              });
            return {
              isRange: c,
              version: f,
              range: e,
              operator: c ? e[0] : "",
              parts: g,
              prerelease: b[1],
              number: 1e8 * g[0] + 1e4 * g[1] + g[2],
            };
          };
          d.versionSatisfies = function (e, b) {
            b = b || "*";
            var c = d.versionParse(b),
              f = c.parts,
              g = d.versionParse(e),
              m = g.parts;
            if (c.isRange) {
              if ("*" === c.operator || "*" === e) return !0;
              if ("~" === c.operator)
                return m[0] === f[0] && m[1] === f[1] && m[2] >= f[2];
              if ("^" === c.operator)
                return 0 < f[0]
                  ? m[0] === f[0] && g.number >= c.number
                  : 0 < f[1]
                  ? m[1] === f[1] && m[2] >= f[2]
                  : m[2] === f[2];
            }
            return e === b || "*" === e;
          };
        })();
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(118);
        a(128);
        var e = a(32);
        (function () {
          d.create = function (b) {
            var c = k.create();
            return e.extend(
              c,
              {
                label: "World",
                gravity: {
                  x: 0,
                  y: 1,
                  scale: 0.001,
                },
                bounds: {
                  min: {
                    x: -Infinity,
                    y: -Infinity,
                  },
                  max: {
                    x: Infinity,
                    y: Infinity,
                  },
                },
              },
              b
            );
          };
        })();
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(250),
          e = a(273),
          b = a(32);
        (function () {
          d.create = function (c) {
            return b.extend(
              {
                controller: d,
                detector: e.collisions,
                buckets: {},
                pairs: {},
                pairsList: [],
                bucketWidth: 48,
                bucketHeight: 48,
              },
              c
            );
          };
          d.update = function (c, f, g, m) {
            var n,
              q = g.world,
              r = c.buckets;
            var u = !1;
            var v = g.metrics;
            for (g = v.broadphaseTests = 0; g < f.length; g++) {
              var x = f[g];
              if (
                !(
                  (x.isSleeping && !m) ||
                  x.bounds.max.x < q.bounds.min.x ||
                  x.bounds.min.x > q.bounds.max.x ||
                  x.bounds.max.y < q.bounds.min.y ||
                  x.bounds.min.y > q.bounds.max.y
                )
              ) {
                var y = d._getRegion(c, x);
                if (!x.region || y.id !== x.region.id || m) {
                  v.broadphaseTests += 1;
                  if (!x.region || m) x.region = y;
                  var z = d._regionUnion(y, x.region);
                  for (u = z.startCol; u <= z.endCol; u++)
                    for (n = z.startRow; n <= z.endRow; n++) {
                      var A = d._getBucketId(u, n);
                      var B = r[A];
                      var D =
                          u >= y.startCol &&
                          u <= y.endCol &&
                          n >= y.startRow &&
                          n <= y.endRow,
                        E =
                          u >= x.region.startCol &&
                          u <= x.region.endCol &&
                          n >= x.region.startRow &&
                          n <= x.region.endRow;
                      !D && E && E && B && d._bucketRemoveBody(c, B, x);
                      if (x.region === y || (D && !E) || m)
                        B || (B = d._createBucket(r, A)),
                          d._bucketAddBody(c, B, x);
                    }
                  x.region = y;
                  u = !0;
                }
              }
            }
            u && (c.pairsList = d._createActivePairsList(c));
          };
          d.clear = function (c) {
            c.buckets = {};
            c.pairs = {};
            c.pairsList = [];
          };
          d._regionUnion = function (c, f) {
            return d._createRegion(
              Math.min(c.startCol, f.startCol),
              Math.max(c.endCol, f.endCol),
              Math.min(c.startRow, f.startRow),
              Math.max(c.endRow, f.endRow)
            );
          };
          d._getRegion = function (c, f) {
            f = f.bounds;
            return d._createRegion(
              Math.floor(f.min.x / c.bucketWidth),
              Math.floor(f.max.x / c.bucketWidth),
              Math.floor(f.min.y / c.bucketHeight),
              Math.floor(f.max.y / c.bucketHeight)
            );
          };
          d._createRegion = function (c, f, g, m) {
            return {
              id: c + "," + f + "," + g + "," + m,
              startCol: c,
              endCol: f,
              startRow: g,
              endRow: m,
            };
          };
          d._getBucketId = function (c, f) {
            return "C" + c + "R" + f;
          };
          d._createBucket = function (c, f) {
            return (c[f] = []);
          };
          d._bucketAddBody = function (c, f, g) {
            for (var m = 0; m < f.length; m++) {
              var n = f[m];
              if (!(g.id === n.id || (g.isStatic && n.isStatic))) {
                var q = k.id(g, n),
                  r = c.pairs[q];
                r ? (r[2] += 1) : (c.pairs[q] = [g, n, 1]);
              }
            }
            f.push(g);
          };
          d._bucketRemoveBody = function (c, f, g) {
            f.splice(f.indexOf(g), 1);
            for (var m = 0; m < f.length; m++) {
              var n = k.id(g, f[m]);
              (n = c.pairs[n]) && --n[2];
            }
          };
          d._createActivePairsList = function (c) {
            var f = [];
            var g = b.keys(c.pairs);
            for (var m = 0; m < g.length; m++) {
              var n = c.pairs[g[m]];
              0 < n[2] ? f.push(n) : delete c.pairs[g[m]];
            }
            return f;
          };
        })();
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(250),
          e = a(32);
        (function () {
          d._pairMaxIdleLife = 1e3;
          d.create = function (b) {
            return e.extend(
              {
                table: {},
                list: [],
                collisionStart: [],
                collisionActive: [],
                collisionEnd: [],
              },
              b
            );
          };
          d.update = function (b, c, f) {
            var g = b.list,
              m = b.table,
              n = b.collisionStart,
              q = b.collisionEnd;
            b = b.collisionActive;
            var r, u;
            n.length = 0;
            q.length = 0;
            for (u = b.length = 0; u < g.length; u++) g[u].confirmedActive = !1;
            for (u = 0; u < c.length; u++) {
              var v = c[u];
              if (v.collided) {
                var x = k.id(v.bodyA, v.bodyB);
                (r = m[x])
                  ? (r.isActive ? b.push(r) : n.push(r),
                    k.update(r, v, f),
                    (r.confirmedActive = !0))
                  : ((r = k.create(v, f)), (m[x] = r), n.push(r), g.push(r));
              }
            }
            for (u = 0; u < g.length; u++)
              (r = g[u]),
                r.isActive &&
                  !r.confirmedActive &&
                  (k.setActive(r, !1, f), q.push(r));
          };
          d.removeOld = function (b, c) {
            var f = b.list;
            b = b.table;
            var g = [],
              m;
            for (m = 0; m < f.length; m++) {
              var n = f[m];
              var q = n.collision;
              q.bodyA.isSleeping || q.bodyB.isSleeping
                ? (n.timeUpdated = c)
                : c - n.timeUpdated > d._pairMaxIdleLife && g.push(m);
            }
            for (m = 0; m < g.length; m++)
              (c = g[m] - m), (n = f[c]), delete b[n.id], f.splice(c, 1);
          };
          d.clear = function (b) {
            b.table = {};
            b.list.length = 0;
            b.collisionStart.length = 0;
            b.collisionActive.length = 0;
            b.collisionEnd.length = 0;
            return b;
          };
        })();
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(64),
          e = a(83),
          b = a(32),
          c = a(84);
        (function () {
          d._restingThresh = 4;
          d._restingThreshTangent = 6;
          d._positionDampen = 0.9;
          d._positionWarming = 0.8;
          d._frictionNormalMultiplier = 5;
          d.preSolvePosition = function (f) {
            var g;
            for (g = 0; g < f.length; g++) {
              var m = f[g];
              if (m.isActive) {
                var n = m.activeContacts.length;
                m.collision.parentA.totalContacts += n;
                m.collision.parentB.totalContacts += n;
              }
            }
          };
          d.solvePosition = function (f, g, m) {
            var n = m * d._positionDampen;
            for (m = 0; m < g.length; m++) {
              var q = g[m];
              q.previousPositionImpulse.x = q.positionImpulse.x;
              q.previousPositionImpulse.y = q.positionImpulse.y;
            }
            for (m = 0; m < f.length; m++) {
              var r = f[m];
              if (r.isActive && !r.isSensor) {
                var u = r.collision;
                g = u.parentA;
                q = u.parentB;
                var v = u.normal;
                var x = g.previousPositionImpulse;
                var y = q.previousPositionImpulse;
                var z = u.penetration;
                u = y.x - x.x + z.x;
                y = y.y - x.y + z.y;
                x = v.x;
                v = v.y;
                u = x * u + v * y;
                r.separation = u;
                u = (u - r.slop) * n;
                if (g.isStatic || q.isStatic) u *= 2;
                g.isStatic ||
                  g.isSleeping ||
                  ((r = u / g.totalContacts),
                  (g.positionImpulse.x += x * r),
                  (g.positionImpulse.y += v * r));
                q.isStatic ||
                  q.isSleeping ||
                  ((r = u / q.totalContacts),
                  (q.positionImpulse.x -= x * r),
                  (q.positionImpulse.y -= v * r));
              }
            }
          };
          d.postSolvePosition = function (f) {
            for (var g = 0; g < f.length; g++) {
              var m = f[g];
              m.totalContacts = 0;
              if (0 !== m.positionImpulse.x || 0 !== m.positionImpulse.y) {
                for (var n = 0; n < m.parts.length; n++) {
                  var q = m.parts[n];
                  k.translate(q.vertices, m.positionImpulse);
                  c.update(q.bounds, q.vertices, m.velocity);
                  q.position.x += m.positionImpulse.x;
                  q.position.y += m.positionImpulse.y;
                }
                m.positionPrev.x += m.positionImpulse.x;
                m.positionPrev.y += m.positionImpulse.y;
                0 > e.dot(m.positionImpulse, m.velocity)
                  ? ((m.positionImpulse.x = 0), (m.positionImpulse.y = 0))
                  : ((m.positionImpulse.x *= d._positionWarming),
                    (m.positionImpulse.y *= d._positionWarming));
              }
            }
          };
          d.preSolveVelocity = function (f) {
            var g,
              m = e._temp[0],
              n = e._temp[1];
            for (g = 0; g < f.length; g++) {
              var q = f[g];
              if (q.isActive && !q.isSensor) {
                var r = q.activeContacts;
                var u = q.collision;
                q = u.parentA;
                var v = u.parentB;
                var x = u.normal;
                var y = u.tangent;
                for (u = 0; u < r.length; u++) {
                  var z = r[u];
                  var A = z.vertex;
                  var B = z.normalImpulse;
                  z = z.tangentImpulse;
                  if (0 !== B || 0 !== z)
                    (m.x = x.x * B + y.x * z),
                      (m.y = x.y * B + y.y * z),
                      q.isStatic ||
                        q.isSleeping ||
                        ((B = e.sub(A, q.position, n)),
                        (q.positionPrev.x += m.x * q.inverseMass),
                        (q.positionPrev.y += m.y * q.inverseMass),
                        (q.anglePrev += e.cross(B, m) * q.inverseInertia)),
                      v.isStatic ||
                        v.isSleeping ||
                        ((B = e.sub(A, v.position, n)),
                        (v.positionPrev.x -= m.x * v.inverseMass),
                        (v.positionPrev.y -= m.y * v.inverseMass),
                        (v.anglePrev -= e.cross(B, m) * v.inverseInertia));
                }
              }
            }
          };
          d.solveVelocity = function (f, g) {
            g *= g;
            for (
              var m = e._temp[0],
                n = e._temp[1],
                q = e._temp[2],
                r = e._temp[3],
                u = e._temp[4],
                v = e._temp[5],
                x = 0;
              x < f.length;
              x++
            ) {
              var y = f[x];
              if (y.isActive && !y.isSensor) {
                var z = y.collision,
                  A = z.parentA,
                  B = z.parentB,
                  D = z.normal;
                z = z.tangent;
                var E = y.activeContacts,
                  C = 1 / E.length;
                A.velocity.x = A.position.x - A.positionPrev.x;
                A.velocity.y = A.position.y - A.positionPrev.y;
                B.velocity.x = B.position.x - B.positionPrev.x;
                B.velocity.y = B.position.y - B.positionPrev.y;
                A.angularVelocity = A.angle - A.anglePrev;
                B.angularVelocity = B.angle - B.anglePrev;
                for (var F = 0; F < E.length; F++) {
                  var G = E[F],
                    H = G.vertex,
                    K = e.sub(H, A.position, n);
                  H = e.sub(H, B.position, q);
                  var I = e.add(
                      A.velocity,
                      e.mult(e.perp(K), A.angularVelocity),
                      r
                    ),
                    M = e.add(
                      B.velocity,
                      e.mult(e.perp(H), B.angularVelocity),
                      u
                    );
                  I = e.sub(I, M, v);
                  var N = e.dot(D, I),
                    P = e.dot(z, I),
                    J = Math.abs(P),
                    L = b.sign(P);
                  I = (1 + y.restitution) * N;
                  var O =
                    b.clamp(y.separation + N, 0, 1) *
                    d._frictionNormalMultiplier;
                  M = P;
                  var Q = Infinity;
                  J > y.friction * y.frictionStatic * O * g &&
                    ((Q = J), (M = b.clamp(y.friction * L * g, -Q, Q)));
                  J = e.cross(K, D);
                  L = e.cross(H, D);
                  J =
                    C /
                    (A.inverseMass +
                      B.inverseMass +
                      A.inverseInertia * J * J +
                      B.inverseInertia * L * L);
                  I *= J;
                  M *= J;
                  0 > N && N * N > d._restingThresh * g
                    ? (G.normalImpulse = 0)
                    : ((N = G.normalImpulse),
                      (G.normalImpulse = Math.min(G.normalImpulse + I, 0)),
                      (I = G.normalImpulse - N));
                  P * P > d._restingThreshTangent * g
                    ? (G.tangentImpulse = 0)
                    : ((N = G.tangentImpulse),
                      (G.tangentImpulse = b.clamp(G.tangentImpulse + M, -Q, Q)),
                      (M = G.tangentImpulse - N));
                  m.x = D.x * I + z.x * M;
                  m.y = D.y * I + z.y * M;
                  A.isStatic ||
                    A.isSleeping ||
                    ((A.positionPrev.x += m.x * A.inverseMass),
                    (A.positionPrev.y += m.y * A.inverseMass),
                    (A.anglePrev += e.cross(K, m) * A.inverseInertia));
                  B.isStatic ||
                    B.isSleeping ||
                    ((B.positionPrev.x -= m.x * B.inverseMass),
                    (B.positionPrev.y -= m.y * B.inverseMass),
                    (B.anglePrev -= e.cross(H, m) * B.inverseInertia));
                }
              }
            }
          };
        })();
      },
      function (h, t) {
        t = (function () {
          return this;
        })();
        try {
          t = t || new Function("return this")();
        } catch (a) {
          "object" === typeof window && (t = window);
        }
        h.exports = t;
      },
      function (h, t, a) {
        var d = a(276);
        h.exports = function (k, e, b, c) {
          for (var f = k[0], g = 1; g < k.length; g++) {
            var m = k[g];
            d(m, f, e, b, c);
            f = m;
          }
          return k;
        };
      },
      function (h, t, a) {
        var d = a(46);
        h.exports = function (k, e, b, c, f) {
          return d(k, "angle", e, b, c, f);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          for (var e = 0; e < a.length; e++) d.call(k, a[e]);
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          for (void 0 === k && (k = 0); k < a.length; k++) {
            var e = a[k],
              b = !0,
              c;
            for (c in d) e[c] !== d[c] && (b = !1);
            if (b) return e;
          }
          return null;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          for (void 0 === k && (k = 0); k < a.length; k++) {
            var e = a[k],
              b = !0,
              c;
            for (c in d) e[c] !== d[c] && (b = !1);
            if (b) return e;
          }
          return null;
        };
      },
      function (h, t, a) {
        var d = a(289),
          k = a(123),
          e = a(2);
        t = a(1);
        var b = new (a(129))(
          {
            sys: {
              queueDepthSort: t,
              events: {
                once: t,
              },
            },
          },
          0,
          0,
          1,
          1
        );
        h.exports = function (c, f) {
          void 0 === f && (f = {});
          var g = f.hasOwnProperty("width"),
            m = f.hasOwnProperty("height"),
            n = e(f, "width", -1),
            q = e(f, "height", -1),
            r = e(f, "cellWidth", 1),
            u = e(f, "cellHeight", r),
            v = e(f, "position", k.TOP_LEFT),
            x = e(f, "x", 0);
          f = e(f, "y", 0);
          var y = 0,
            z = 0,
            A = n * r,
            B = q * u;
          b.setPosition(x, f);
          b.setSize(r, u);
          for (var D = 0; D < c.length; D++)
            if ((d(c[D], b, v), g && -1 === n)) b.x += r;
            else if (m && -1 === q) b.y += u;
            else if (m && !g) {
              if (
                ((z += u),
                (b.y += u),
                z === B && ((z = 0), (y += r), (b.y = f), (b.x += r), y === A))
              )
                break;
            } else if (
              ((y += r),
              (b.x += r),
              y === A && ((y = 0), (z += u), (b.x = x), (b.y += u), z === B))
            )
              break;
          return c;
        };
      },
      function (h, t, a) {
        var d = a(18);
        h.exports = {
          _alpha: 1,
          _alphaTL: 1,
          _alphaTR: 1,
          _alphaBL: 1,
          _alphaBR: 1,
          clearAlpha: function () {
            return this.setAlpha(1);
          },
          setAlpha: function (k, e, b, c) {
            void 0 === k && (k = 1);
            void 0 === e
              ? (this.alpha = k)
              : ((this._alphaTL = d(k, 0, 1)),
                (this._alphaTR = d(e, 0, 1)),
                (this._alphaBL = d(b, 0, 1)),
                (this._alphaBR = d(c, 0, 1)));
            return this;
          },
          alpha: {
            get: function () {
              return this._alpha;
            },
            set: function (k) {
              this._alphaBR =
                this._alphaBL =
                this._alphaTR =
                this._alphaTL =
                this._alpha =
                k =
                  d(k, 0, 1);
              this.renderFlags =
                0 === k ? this.renderFlags & -3 : this.renderFlags | 2;
            },
          },
          alphaTopLeft: {
            get: function () {
              return this._alphaTL;
            },
            set: function (k) {
              this._alphaTL = k = d(k, 0, 1);
              0 !== k && (this.renderFlags |= 2);
            },
          },
          alphaTopRight: {
            get: function () {
              return this._alphaTR;
            },
            set: function (k) {
              this._alphaTR = k = d(k, 0, 1);
              0 !== k && (this.renderFlags |= 2);
            },
          },
          alphaBottomLeft: {
            get: function () {
              return this._alphaBL;
            },
            set: function (k) {
              this._alphaBL = k = d(k, 0, 1);
              0 !== k && (this.renderFlags |= 2);
            },
          },
          alphaBottomRight: {
            get: function () {
              return this._alphaBR;
            },
            set: function (k) {
              this._alphaBR = k = d(k, 0, 1);
              0 !== k && (this.renderFlags |= 2);
            },
          },
        };
      },
      function (h, t) {
        h.exports = {
          width: 0,
          height: 0,
          displayWidth: {
            get: function () {
              return this.scaleX * this.width;
            },
            set: function (a) {
              this.scaleX = a / this.width;
            },
          },
          displayHeight: {
            get: function () {
              return this.scaleY * this.height;
            },
            set: function (a) {
              this.scaleY = a / this.height;
            },
          },
          setSize: function (a, d) {
            this.width = a;
            this.height = d;
            return this;
          },
          setDisplaySize: function (a, d) {
            this.displayWidth = a;
            this.displayHeight = d;
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          texture: null,
          frame: null,
          isCropped: !1,
          setCrop: function (a, d, k, e) {
            void 0 === a
              ? (this.isCropped = !1)
              : this.frame &&
                ("number" === typeof a
                  ? this.frame.setCropUVs(
                      this._crop,
                      a,
                      d,
                      k,
                      e,
                      this.flipX,
                      this.flipY
                    )
                  : this.frame.setCropUVs(
                      this._crop,
                      a.x,
                      a.y,
                      a.width,
                      a.height,
                      this.flipX,
                      this.flipY
                    ),
                (this.isCropped = !0));
            return this;
          },
          resetCropObject: function () {
            return {
              u0: 0,
              v0: 0,
              u1: 0,
              v1: 0,
              width: 0,
              height: 0,
              x: 0,
              y: 0,
              flipX: !1,
              flipY: !1,
              cx: 0,
              cy: 0,
              cw: 0,
              ch: 0,
            };
          },
        };
      },
      function (h, t) {
        h.exports = {
          flipX: !1,
          flipY: !1,
          toggleFlipX: function () {
            this.flipX = !this.flipX;
            return this;
          },
          toggleFlipY: function () {
            this.flipY = !this.flipY;
            return this;
          },
          setFlipX: function (a) {
            this.flipX = a;
            return this;
          },
          setFlipY: function (a) {
            this.flipY = a;
            return this;
          },
          setFlip: function (a, d) {
            this.flipX = a;
            this.flipY = d;
            return this;
          },
          resetFlip: function () {
            this.flipY = this.flipX = !1;
            return this;
          },
        };
      },
      function (h, t, a) {
        var d = a(10),
          k = a(308),
          e = a(3);
        h.exports = {
          prepareBoundsOutput: function (b, c) {
            void 0 === c && (c = !1);
            0 !== this.rotation && k(b, this.x, this.y, this.rotation);
            c &&
              this.parentContainer &&
              this.parentContainer
                .getBoundsTransformMatrix()
                .transformPoint(b.x, b.y, b);
            return b;
          },
          getCenter: function (b) {
            void 0 === b && (b = new e());
            b.x =
              this.x - this.displayWidth * this.originX + this.displayWidth / 2;
            b.y =
              this.y -
              this.displayHeight * this.originY +
              this.displayHeight / 2;
            return b;
          },
          getTopLeft: function (b, c) {
            b || (b = new e());
            b.x = this.x - this.displayWidth * this.originX;
            b.y = this.y - this.displayHeight * this.originY;
            return this.prepareBoundsOutput(b, c);
          },
          getTopCenter: function (b, c) {
            b || (b = new e());
            b.x =
              this.x - this.displayWidth * this.originX + this.displayWidth / 2;
            b.y = this.y - this.displayHeight * this.originY;
            return this.prepareBoundsOutput(b, c);
          },
          getTopRight: function (b, c) {
            b || (b = new e());
            b.x = this.x - this.displayWidth * this.originX + this.displayWidth;
            b.y = this.y - this.displayHeight * this.originY;
            return this.prepareBoundsOutput(b, c);
          },
          getLeftCenter: function (b, c) {
            b || (b = new e());
            b.x = this.x - this.displayWidth * this.originX;
            b.y =
              this.y -
              this.displayHeight * this.originY +
              this.displayHeight / 2;
            return this.prepareBoundsOutput(b, c);
          },
          getRightCenter: function (b, c) {
            b || (b = new e());
            b.x = this.x - this.displayWidth * this.originX + this.displayWidth;
            b.y =
              this.y -
              this.displayHeight * this.originY +
              this.displayHeight / 2;
            return this.prepareBoundsOutput(b, c);
          },
          getBottomLeft: function (b, c) {
            b || (b = new e());
            b.x = this.x - this.displayWidth * this.originX;
            b.y =
              this.y - this.displayHeight * this.originY + this.displayHeight;
            return this.prepareBoundsOutput(b, c);
          },
          getBottomCenter: function (b, c) {
            b || (b = new e());
            b.x =
              this.x - this.displayWidth * this.originX + this.displayWidth / 2;
            b.y =
              this.y - this.displayHeight * this.originY + this.displayHeight;
            return this.prepareBoundsOutput(b, c);
          },
          getBottomRight: function (b, c) {
            b || (b = new e());
            b.x = this.x - this.displayWidth * this.originX + this.displayWidth;
            b.y =
              this.y - this.displayHeight * this.originY + this.displayHeight;
            return this.prepareBoundsOutput(b, c);
          },
          getBounds: function (b) {
            void 0 === b && (b = new d());
            if (this.parentContainer) {
              var c = this.parentContainer.getBoundsTransformMatrix();
              this.getTopLeft(b);
              c.transformPoint(b.x, b.y, b);
              var f = b.x;
              var g = b.y;
              this.getTopRight(b);
              c.transformPoint(b.x, b.y, b);
              var m = b.x;
              var n = b.y;
              this.getBottomLeft(b);
              c.transformPoint(b.x, b.y, b);
              var q = b.x;
              var r = b.y;
              this.getBottomRight(b);
              c.transformPoint(b.x, b.y, b);
            } else
              this.getTopLeft(b),
                (f = b.x),
                (g = b.y),
                this.getTopRight(b),
                (m = b.x),
                (n = b.y),
                this.getBottomLeft(b),
                (q = b.x),
                (r = b.y),
                this.getBottomRight(b);
            c = b.x;
            var u = b.y;
            b.x = Math.min(f, m, q, c);
            b.y = Math.min(g, n, r, u);
            b.width = Math.max(f, m, q, c) - b.x;
            b.height = Math.max(g, n, r, u) - b.y;
            return b;
          },
        };
      },
      function (h, t) {
        h.exports = "blur";
      },
      function (h, t) {
        h.exports = "boot";
      },
      function (h, t) {
        h.exports = "contextlost";
      },
      function (h, t) {
        h.exports = "contextrestored";
      },
      function (h, t) {
        h.exports = "destroy";
      },
      function (h, t) {
        h.exports = "focus";
      },
      function (h, t) {
        h.exports = "hidden";
      },
      function (h, t) {
        h.exports = "pause";
      },
      function (h, t) {
        h.exports = "postrender";
      },
      function (h, t) {
        h.exports = "poststep";
      },
      function (h, t) {
        h.exports = "prerender";
      },
      function (h, t) {
        h.exports = "prestep";
      },
      function (h, t) {
        h.exports = "ready";
      },
      function (h, t) {
        h.exports = "resume";
      },
      function (h, t) {
        h.exports = "step";
      },
      function (h, t) {
        h.exports = "visible";
      },
      function (h, t) {
        h.exports = "postrender";
      },
      function (h, t) {
        h.exports = "prerender";
      },
      function (h, t) {
        h.exports = "render";
      },
      function (h, t) {
        h.exports = "resize";
      },
      function (h, t) {
        h.exports = {
          _originComponent: !0,
          originX: 0.5,
          originY: 0.5,
          _displayOriginX: 0,
          _displayOriginY: 0,
          displayOriginX: {
            get: function () {
              return this._displayOriginX;
            },
            set: function (a) {
              this._displayOriginX = a;
              this.originX = a / this.width;
            },
          },
          displayOriginY: {
            get: function () {
              return this._displayOriginY;
            },
            set: function (a) {
              this._displayOriginY = a;
              this.originY = a / this.height;
            },
          },
          setOrigin: function (a, d) {
            void 0 === a && (a = 0.5);
            void 0 === d && (d = a);
            this.originX = a;
            this.originY = d;
            return this.updateDisplayOrigin();
          },
          setOriginFromFrame: function () {
            if (this.frame && this.frame.customPivot)
              (this.originX = this.frame.pivotX),
                (this.originY = this.frame.pivotY);
            else return this.setOrigin();
            return this.updateDisplayOrigin();
          },
          setDisplayOrigin: function (a, d) {
            void 0 === a && (a = 0);
            void 0 === d && (d = a);
            this.displayOriginX = a;
            this.displayOriginY = d;
            return this;
          },
          updateDisplayOrigin: function () {
            this._displayOriginX = this.originX * this.width;
            this._displayOriginY = this.originY * this.height;
            return this;
          },
        };
      },
      function (h, t, a) {
        var d = a(36),
          k = a(99),
          e = a(6),
          b = a(100),
          c = a(3);
        h.exports = {
          path: null,
          rotateToPath: !1,
          pathRotationOffset: 0,
          pathOffset: null,
          pathVector: null,
          pathDelta: null,
          pathTween: null,
          pathConfig: null,
          _prevDirection: b.PLAYING_FORWARD,
          setPath: function (f, g) {
            void 0 === g && (g = this.pathConfig);
            var m = this.pathTween;
            m && m.isPlaying() && m.stop();
            this.path = f;
            g && this.startFollow(g);
            return this;
          },
          setRotateToPath: function (f, g) {
            void 0 === g && (g = 0);
            this.rotateToPath = f;
            this.pathRotationOffset = g;
            return this;
          },
          isFollowing: function () {
            var f = this.pathTween;
            return f && f.isPlaying();
          },
          startFollow: function (f, g) {
            void 0 === f && (f = {});
            void 0 === g && (g = 0);
            var m = this.pathTween;
            m && m.isPlaying() && m.stop();
            "number" === typeof f &&
              (f = {
                duration: f,
              });
            f.from = e(f, "from", 0);
            f.to = e(f, "to", 1);
            m = k(f, "positionOnPath", !1);
            this.rotateToPath = k(f, "rotateToPath", !1);
            this.pathRotationOffset = e(f, "rotationOffset", 0);
            var n = e(f, "startAt", g);
            n &&
              (f.onStart = function (q) {
                q = q.data[0];
                q.progress = n;
                q.elapsed = q.duration * n;
                var r = q.ease(q.progress);
                q.current = q.start + (q.end - q.start) * r;
                q.target[q.key] = q.current;
              });
            this.pathOffset || (this.pathOffset = new c(this.x, this.y));
            this.pathVector || (this.pathVector = new c());
            this.pathDelta || (this.pathDelta = new c());
            this.pathDelta.reset();
            this.pathTween = this.scene.sys.tweens.addCounter(f);
            this.path.getStartPoint(this.pathOffset);
            m && ((this.x = this.pathOffset.x), (this.y = this.pathOffset.y));
            this.pathOffset.x = this.x - this.pathOffset.x;
            this.pathOffset.y = this.y - this.pathOffset.y;
            this._prevDirection = b.PLAYING_FORWARD;
            this.rotateToPath &&
              ((g = this.path.getPoint(0.1)),
              (this.rotation =
                Math.atan2(g.y - this.y, g.x - this.x) +
                d(this.pathRotationOffset)));
            this.pathConfig = f;
            return this;
          },
          pauseFollow: function () {
            var f = this.pathTween;
            f && f.isPlaying() && f.pause();
            return this;
          },
          resumeFollow: function () {
            var f = this.pathTween;
            f && f.isPaused() && f.resume();
            return this;
          },
          stopFollow: function () {
            var f = this.pathTween;
            f && f.isPlaying() && f.stop();
            return this;
          },
          pathUpdate: function () {
            var f = this.pathTween;
            if (f) {
              var g = f.data[0],
                m = this.pathDelta,
                n = this.pathVector;
              m.copy(n).negate();
              if (g.state === b.COMPLETE)
                this.path.getPoint(1, n),
                  m.add(n),
                  n.add(this.pathOffset),
                  this.setPosition(n.x, n.y);
              else if (
                g.state === b.PLAYING_FORWARD ||
                g.state === b.PLAYING_BACKWARD
              )
                if (
                  (this.path.getPoint(f.getValue(), n),
                  m.add(n),
                  n.add(this.pathOffset),
                  (m = this.x),
                  (f = this.y),
                  this.setPosition(n.x, n.y),
                  (n = this.x - m),
                  (f = this.y - f),
                  0 !== n || 0 !== f)
                )
                  g.state !== this._prevDirection
                    ? (this._prevDirection = g.state)
                    : this.rotateToPath &&
                      (this.rotation =
                        Math.atan2(f, n) + d(this.pathRotationOffset));
            }
          },
        };
      },
      function (h, t) {
        h.exports = {
          _sizeComponent: !0,
          width: 0,
          height: 0,
          displayWidth: {
            get: function () {
              return Math.abs(this.scaleX * this.frame.realWidth);
            },
            set: function (a) {
              this.scaleX = a / this.frame.realWidth;
            },
          },
          displayHeight: {
            get: function () {
              return Math.abs(this.scaleY * this.frame.realHeight);
            },
            set: function (a) {
              this.scaleY = a / this.frame.realHeight;
            },
          },
          setSizeToFrame: function (a) {
            void 0 === a && (a = this.frame);
            this.width = a.realWidth;
            this.height = a.realHeight;
            return this;
          },
          setSize: function (a, d) {
            this.width = a;
            this.height = d;
            return this;
          },
          setDisplaySize: function (a, d) {
            this.displayWidth = a;
            this.displayHeight = d;
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          texture: null,
          frame: null,
          isCropped: !1,
          setTexture: function (a, d) {
            this.texture = this.scene.sys.textures.get(a);
            return this.setFrame(d);
          },
          setFrame: function (a, d, k) {
            void 0 === d && (d = !0);
            void 0 === k && (k = !0);
            this.frame = this.texture.get(a);
            this.renderFlags =
              this.frame.cutWidth && this.frame.cutHeight
                ? this.renderFlags | 8
                : this.renderFlags & -9;
            this._sizeComponent && d && this.setSizeToFrame();
            this._originComponent &&
              k &&
              (this.frame.customPivot
                ? this.setOrigin(this.frame.pivotX, this.frame.pivotY)
                : this.updateDisplayOrigin());
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          texture: null,
          frame: null,
          isCropped: !1,
          setCrop: function (a, d, k, e) {
            void 0 === a
              ? (this.isCropped = !1)
              : this.frame &&
                ("number" === typeof a
                  ? this.frame.setCropUVs(
                      this._crop,
                      a,
                      d,
                      k,
                      e,
                      this.flipX,
                      this.flipY
                    )
                  : this.frame.setCropUVs(
                      this._crop,
                      a.x,
                      a.y,
                      a.width,
                      a.height,
                      this.flipX,
                      this.flipY
                    ),
                (this.isCropped = !0));
            return this;
          },
          setTexture: function (a, d) {
            this.texture = this.scene.sys.textures.get(a);
            return this.setFrame(d);
          },
          setFrame: function (a, d, k) {
            void 0 === d && (d = !0);
            void 0 === k && (k = !0);
            this.frame = this.texture.get(a);
            this.renderFlags =
              this.frame.cutWidth && this.frame.cutHeight
                ? this.renderFlags | 8
                : this.renderFlags & -9;
            this._sizeComponent && d && this.setSizeToFrame();
            this._originComponent &&
              k &&
              (this.frame.customPivot
                ? this.setOrigin(this.frame.pivotX, this.frame.pivotY)
                : this.updateDisplayOrigin());
            this.isCropped &&
              this.frame.updateCropUVs(this._crop, this.flipX, this.flipY);
            return this;
          },
          resetCropObject: function () {
            return {
              u0: 0,
              v0: 0,
              u1: 0,
              v1: 0,
              width: 0,
              height: 0,
              x: 0,
              y: 0,
              flipX: !1,
              flipY: !1,
              cx: 0,
              cy: 0,
              cw: 0,
              ch: 0,
            };
          },
        };
      },
      function (h, t) {
        h.exports = {
          tintTopLeft: 16777215,
          tintTopRight: 16777215,
          tintBottomLeft: 16777215,
          tintBottomRight: 16777215,
          tintFill: !1,
          clearTint: function () {
            this.setTint(16777215);
            return this;
          },
          setTint: function (a, d, k, e) {
            void 0 === a && (a = 16777215);
            void 0 === d && (e = k = d = a);
            this.tintTopLeft = a;
            this.tintTopRight = d;
            this.tintBottomLeft = k;
            this.tintBottomRight = e;
            this.tintFill = !1;
            return this;
          },
          setTintFill: function (a, d, k, e) {
            this.setTint(a, d, k, e);
            this.tintFill = !0;
            return this;
          },
          tint: {
            set: function (a) {
              this.setTint(a, a, a, a);
            },
          },
          isTinted: {
            get: function () {
              return (
                this.tintFill ||
                16777215 !== this.tintTopLeft ||
                16777215 !== this.tintTopRight ||
                16777215 !== this.tintBottomLeft ||
                16777215 !== this.tintBottomRight
              );
            },
          },
        };
      },
      function (h, t) {
        h.exports = "changedata";
      },
      function (h, t) {
        h.exports = "changedata-";
      },
      function (h, t) {
        h.exports = "destroy";
      },
      function (h, t) {
        h.exports = "removedata";
      },
      function (h, t) {
        h.exports = "setdata";
      },
      function (h, t) {
        h.exports = "addedtoscene";
      },
      function (h, t) {
        h.exports = "destroy";
      },
      function (h, t) {
        h.exports = "removedfromscene";
      },
      function (h, t) {
        h.exports = "complete";
      },
      function (h, t) {
        h.exports = "created";
      },
      function (h, t) {
        h.exports = "error";
      },
      function (h, t) {
        h.exports = "loop";
      },
      function (h, t) {
        h.exports = "play";
      },
      function (h, t) {
        h.exports = "seeked";
      },
      function (h, t) {
        h.exports = "seeking";
      },
      function (h, t) {
        h.exports = "stop";
      },
      function (h, t) {
        h.exports = "timeout";
      },
      function (h, t) {
        h.exports = "unlocked";
      },
      function (h, t) {
        h.exports = "addedtoscene";
      },
      function (h, t) {
        h.exports = "boot";
      },
      function (h, t) {
        h.exports = "create";
      },
      function (h, t) {
        h.exports = "destroy";
      },
      function (h, t) {
        h.exports = "pause";
      },
      function (h, t) {
        h.exports = "postupdate";
      },
      function (h, t) {
        h.exports = "prerender";
      },
      function (h, t) {
        h.exports = "preupdate";
      },
      function (h, t) {
        h.exports = "ready";
      },
      function (h, t) {
        h.exports = "removedfromscene";
      },
      function (h, t) {
        h.exports = "render";
      },
      function (h, t) {
        h.exports = "resume";
      },
      function (h, t) {
        h.exports = "shutdown";
      },
      function (h, t) {
        h.exports = "sleep";
      },
      function (h, t) {
        h.exports = "start";
      },
      function (h, t) {
        h.exports = "transitioncomplete";
      },
      function (h, t) {
        h.exports = "transitioninit";
      },
      function (h, t) {
        h.exports = "transitionout";
      },
      function (h, t) {
        h.exports = "transitionstart";
      },
      function (h, t) {
        h.exports = "transitionwake";
      },
      function (h, t) {
        h.exports = "update";
      },
      function (h, t) {
        h.exports = "wake";
      },
      function (h, t, a) {
        var d = a(46);
        h.exports = function (k, e, b, c, f) {
          return d(k, "alpha", e, b, c, f);
        };
      },
      function (h, t, a) {
        var d = a(46);
        h.exports = function (k, e, b, c, f) {
          return d(k, "x", e, b, c, f);
        };
      },
      function (h, t, a) {
        var d = a(46);
        h.exports = function (k, e, b, c, f, g, m) {
          if (void 0 === b || null === b) b = e;
          d(k, "x", e, c, g, m);
          return d(k, "y", b, f, g, m);
        };
      },
      function (h, t, a) {
        var d = a(46);
        h.exports = function (k, e, b, c, f) {
          return d(k, "y", e, b, c, f);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          void 0 === k && (k = 0);
          void 0 === e && (e = 6.28);
          var b = k;
          k = (e - k) / a.length;
          for (e = 0; e < a.length; e++)
            (a[e].x = d.x + d.radius * Math.cos(b)),
              (a[e].y = d.y + d.radius * Math.sin(b)),
              (b += k);
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          void 0 === k && (k = 0);
          void 0 === e && (e = 6.28);
          var b = k;
          k = (e - k) / a.length;
          e = d.width / 2;
          for (var c = d.height / 2, f = 0; f < a.length; f++)
            (a[f].x = d.x + e * Math.cos(b)),
              (a[f].y = d.y + c * Math.sin(b)),
              (b += k);
          return a;
        };
      },
      function (h, t, a) {
        var d = a(172);
        h.exports = function (k, e) {
          e = d(e, k.length);
          for (var b = 0; b < k.length; b++) {
            var c = k[b],
              f = e[b];
            c.x = f.x;
            c.y = f.y;
          }
          return k;
        };
      },
      function (h, t, a) {
        var d = a(316),
          k = a(178),
          e = a(179);
        h.exports = function (b, c, f) {
          void 0 === f && (f = 0);
          c = d(c, !1, b.length);
          0 < f ? k(c, f) : 0 > f && e(c, Math.abs(f));
          for (f = 0; f < b.length; f++) (b[f].x = c[f].x), (b[f].y = c[f].y);
          return b;
        };
      },
      function (h, t, a) {
        var d = a(317);
        h.exports = function (k, e, b) {
          var c = d(
              {
                x1: e.x1,
                y1: e.y1,
                x2: e.x2,
                y2: e.y2,
              },
              b
            ),
            f = d(
              {
                x1: e.x2,
                y1: e.y2,
                x2: e.x3,
                y2: e.y3,
              },
              b
            );
          e = d(
            {
              x1: e.x3,
              y1: e.y3,
              x2: e.x1,
              y2: e.y1,
            },
            b
          );
          c.pop();
          f.pop();
          e.pop();
          c = c.concat(f, e);
          f = c.length / k.length;
          for (b = e = 0; b < k.length; b++) {
            var g = k[b],
              m = c[Math.floor(e)];
            g.x = m.x;
            g.y = m.y;
            e += f;
          }
          return k;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          for (var e = 0; e < a.length; e++) {
            var b = a[e];
            b.anims && b.anims.play(d, k);
          }
          return a;
        };
      },
      function (h, t, a) {
        var d = a(170);
        h.exports = function (k, e) {
          for (var b = 0; b < k.length; b++) d(e, k[b]);
          return k;
        };
      },
      function (h, t, a) {
        var d = a(180);
        h.exports = function (k, e) {
          for (var b = 0; b < k.length; b++) d(e, k[b]);
          return k;
        };
      },
      function (h, t, a) {
        var d = a(173);
        h.exports = function (k, e) {
          for (var b = 0; b < k.length; b++) d(e, k[b]);
          return k;
        };
      },
      function (h, t, a) {
        var d = a(174);
        h.exports = function (k, e) {
          for (var b = 0; b < k.length; b++) d(e, k[b]);
          return k;
        };
      },
      function (h, t, a) {
        var d = a(181);
        h.exports = function (k, e) {
          for (var b = 0; b < k.length; b++) d(e, k[b]);
          return k;
        };
      },
      function (h, t, a) {
        var d = a(46);
        h.exports = function (k, e, b, c, f) {
          return d(k, "rotation", e, b, c, f);
        };
      },
      function (h, t, a) {
        var d = a(182),
          k = a(50);
        h.exports = function (e, b, c) {
          var f = b.x;
          b = b.y;
          for (var g = 0; g < e.length; g++) {
            var m = e[g];
            d(m, f, b, c, Math.max(1, k(m.x, m.y, f, b)));
          }
          return e;
        };
      },
      function (h, t, a) {
        var d = a(182);
        h.exports = function (k, e, b, c) {
          var f = e.x;
          e = e.y;
          if (0 === c) return k;
          for (var g = 0; g < k.length; g++) d(k[g], f, e, b, c);
          return k;
        };
      },
      function (h, t, a) {
        var d = a(46);
        h.exports = function (k, e, b, c, f) {
          return d(k, "scaleX", e, b, c, f);
        };
      },
      function (h, t, a) {
        var d = a(46);
        h.exports = function (k, e, b, c, f, g, m) {
          if (void 0 === b || null === b) b = e;
          d(k, "scaleX", e, c, g, m);
          return d(k, "scaleY", b, f, g, m);
        };
      },
      function (h, t, a) {
        var d = a(46);
        h.exports = function (k, e, b, c, f) {
          return d(k, "scaleY", e, b, c, f);
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c, f) {
          return d(k, "alpha", e, b, c, f);
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c) {
          return d(k, "blendMode", e, 0, b, c);
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c, f) {
          return d(k, "depth", e, b, c, f);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          for (var e = 0; e < a.length; e++) a[e].setInteractive(d, k);
          return a;
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c, f, g, m) {
          if (void 0 === b || null === b) b = e;
          d(k, "originX", e, c, g, m);
          d(k, "originY", b, f, g, m);
          k.forEach(function (n) {
            n.updateDisplayOrigin();
          });
          return k;
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c, f) {
          return d(k, "rotation", e, b, c, f);
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c, f, g, m) {
          if (void 0 === b || null === b) b = e;
          d(k, "scaleX", e, c, g, m);
          return d(k, "scaleY", b, f, g, m);
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c, f) {
          return d(k, "scaleX", e, b, c, f);
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c, f) {
          return d(k, "scaleY", e, b, c, f);
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c, f, g, m) {
          if (void 0 === b || null === b) b = e;
          d(k, "scrollFactorX", e, c, g, m);
          return d(k, "scrollFactorY", b, f, g, m);
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c, f) {
          return d(k, "scrollFactorX", e, b, c, f);
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c, f) {
          return d(k, "scrollFactorY", e, b, c, f);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b) {
          for (var c = 0; c < a.length; c++) a[c].setTint(d, k, e, b);
          return a;
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c) {
          return d(k, "visible", e, 0, b, c);
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c, f) {
          return d(k, "x", e, b, c, f);
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c, f, g, m) {
          if (void 0 === b || null === b) b = e;
          d(k, "x", e, c, g, m);
          return d(k, "y", b, f, g, m);
        };
      },
      function (h, t, a) {
        var d = a(27);
        h.exports = function (k, e, b, c, f) {
          return d(k, "y", e, b, c, f);
        };
      },
      function (h, t, a) {
        var d = a(3);
        h.exports = function (k, e, b, c, f) {
          void 0 === c && (c = 0);
          void 0 === f && (f = new d());
          if (1 < k.length) {
            var g;
            if (0 === c) {
              var m = k.length - 1;
              c = k[m].x;
              var n = k[m].y;
              for (g = m - 1; 0 <= g; g--) {
                var q = k[g];
                var r = q.x;
                var u = q.y;
                q.x = c;
                q.y = n;
                c = r;
                n = u;
              }
              k[m].x = e;
              k[m].y = b;
            } else {
              c = k[0].x;
              n = k[0].y;
              for (g = 1; g < k.length; g++)
                (q = k[g]),
                  (r = q.x),
                  (u = q.y),
                  (q.x = c),
                  (q.y = n),
                  (c = r),
                  (n = u);
              k[0].x = e;
              k[0].y = b;
            }
          } else (c = k[0].x), (n = k[0].y), (k[0].x = e), (k[0].y = b);
          f.x = c;
          f.y = n;
          return f;
        };
      },
      function (h, t, a) {
        var d = a(131);
        h.exports = function (k) {
          return d(k);
        };
      },
      function (h, t, a) {
        var d = a(183);
        h.exports = function (k, e, b, c, f) {
          void 0 === f && (f = !1);
          var g = Math.abs(c - b) / k.length;
          if (f) for (f = 0; f < k.length; f++) k[f][e] += d(f * g, b, c);
          else for (f = 0; f < k.length; f++) k[f][e] = d(f * g, b, c);
          return k;
        };
      },
      function (h, t, a) {
        var d = a(184);
        h.exports = function (k, e, b, c, f) {
          void 0 === f && (f = !1);
          var g = Math.abs(c - b) / k.length;
          if (f) for (f = 0; f < k.length; f++) k[f][e] += d(f * g, b, c);
          else for (f = 0; f < k.length; f++) k[f][e] = d(f * g, b, c);
          return k;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b) {
          void 0 === b && (b = !1);
          e = Math.abs(e - k) / a.length;
          if (b) for (b = 0; b < a.length; b++) a[b][d] += b * e + k;
          else for (b = 0; b < a.length; b++) a[b][d] = b * e + k;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          for (var d = 0; d < a.length; d++) a[d].visible = !a[d].visible;
          return a;
        };
      },
      function (h, t, a) {
        var d = a(68);
        h.exports = function (k, e, b) {
          void 0 === b && (b = 0);
          for (var c = 0; c < k.length; c++) {
            var f = k[c];
            f.x = d(f.x, e.left - b, e.right + b);
            f.y = d(f.y, e.top - b, e.bottom + b);
          }
          return k;
        };
      },
      function (h, t, a) {
        h.exports = {
          Animation: a(185),
          AnimationFrame: a(319),
          AnimationManager: a(321),
          AnimationState: a(164),
          Events: a(132),
        };
      },
      function (h, t) {
        h.exports = "add";
      },
      function (h, t) {
        h.exports = "animationcomplete";
      },
      function (h, t) {
        h.exports = "animationcomplete-";
      },
      function (h, t) {
        h.exports = "animationrepeat";
      },
      function (h, t) {
        h.exports = "animationrestart";
      },
      function (h, t) {
        h.exports = "animationstart";
      },
      function (h, t) {
        h.exports = "animationstop";
      },
      function (h, t) {
        h.exports = "animationupdate";
      },
      function (h, t) {
        h.exports = "pauseall";
      },
      function (h, t) {
        h.exports = "remove";
      },
      function (h, t) {
        h.exports = "resumeall";
      },
      function (h, t, a) {
        h.exports = {
          BaseCache: a(323),
          CacheManager: a(325),
          Events: a(324),
        };
      },
      function (h, t) {
        h.exports = "add";
      },
      function (h, t) {
        h.exports = "remove";
      },
      function (h, t, a) {
        h.exports = {
          Controls: a(739),
          Scene2D: a(742),
        };
      },
      function (h, t, a) {
        h.exports = {
          FixedKeyControl: a(740),
          SmoothedKeyControl: a(741),
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(6);
        a = new t({
          initialize: function (k) {
            this.camera = d(k, "camera", null);
            this.left = d(k, "left", null);
            this.right = d(k, "right", null);
            this.up = d(k, "up", null);
            this.down = d(k, "down", null);
            this.zoomIn = d(k, "zoomIn", null);
            this.zoomOut = d(k, "zoomOut", null);
            this.zoomSpeed = d(k, "zoomSpeed", 0.01);
            this.minZoom = d(k, "minZoom", 0.001);
            this.maxZoom = d(k, "maxZoom", 1e3);
            this.speedY = this.speedX = 0;
            var e = d(k, "speed", null);
            "number" === typeof e
              ? (this.speedY = this.speedX = e)
              : ((this.speedX = d(k, "speed.x", 0)),
                (this.speedY = d(k, "speed.y", 0)));
            this._zoom = 0;
            this.active = null !== this.camera;
          },
          start: function () {
            this.active = null !== this.camera;
            return this;
          },
          stop: function () {
            this.active = !1;
            return this;
          },
          setCamera: function (k) {
            this.camera = k;
            return this;
          },
          update: function (k) {
            if (this.active) {
              void 0 === k && (k = 1);
              var e = this.camera;
              this.up && this.up.isDown
                ? (e.scrollY -= (this.speedY * k) | 0)
                : this.down &&
                  this.down.isDown &&
                  (e.scrollY += (this.speedY * k) | 0);
              this.left && this.left.isDown
                ? (e.scrollX -= (this.speedX * k) | 0)
                : this.right &&
                  this.right.isDown &&
                  (e.scrollX += (this.speedX * k) | 0);
              this.zoomIn && this.zoomIn.isDown
                ? ((e.zoom -= this.zoomSpeed),
                  e.zoom < this.minZoom && (e.zoom = this.minZoom))
                : this.zoomOut &&
                  this.zoomOut.isDown &&
                  ((e.zoom += this.zoomSpeed),
                  e.zoom > this.maxZoom && (e.zoom = this.maxZoom));
            }
          },
          destroy: function () {
            this.zoomOut =
              this.zoomIn =
              this.down =
              this.up =
              this.right =
              this.left =
              this.camera =
                null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(6);
        a = new t({
          initialize: function (k) {
            this.camera = d(k, "camera", null);
            this.left = d(k, "left", null);
            this.right = d(k, "right", null);
            this.up = d(k, "up", null);
            this.down = d(k, "down", null);
            this.zoomIn = d(k, "zoomIn", null);
            this.zoomOut = d(k, "zoomOut", null);
            this.zoomSpeed = d(k, "zoomSpeed", 0.01);
            this.minZoom = d(k, "minZoom", 0.001);
            this.maxZoom = d(k, "maxZoom", 1e3);
            this.accelY = this.accelX = 0;
            var e = d(k, "acceleration", null);
            "number" === typeof e
              ? (this.accelY = this.accelX = e)
              : ((this.accelX = d(k, "acceleration.x", 0)),
                (this.accelY = d(k, "acceleration.y", 0)));
            this.dragY = this.dragX = 0;
            e = d(k, "drag", null);
            "number" === typeof e
              ? (this.dragY = this.dragX = e)
              : ((this.dragX = d(k, "drag.x", 0)),
                (this.dragY = d(k, "drag.y", 0)));
            this.maxSpeedY = this.maxSpeedX = 0;
            e = d(k, "maxSpeed", null);
            "number" === typeof e
              ? (this.maxSpeedY = this.maxSpeedX = e)
              : ((this.maxSpeedX = d(k, "maxSpeed.x", 0)),
                (this.maxSpeedY = d(k, "maxSpeed.y", 0)));
            this._zoom = this._speedY = this._speedX = 0;
            this.active = null !== this.camera;
          },
          start: function () {
            this.active = null !== this.camera;
            return this;
          },
          stop: function () {
            this.active = !1;
            return this;
          },
          setCamera: function (k) {
            this.camera = k;
            return this;
          },
          update: function (k) {
            if (this.active) {
              void 0 === k && (k = 1);
              var e = this.camera;
              0 < this._speedX
                ? ((this._speedX -= this.dragX * k),
                  0 > this._speedX && (this._speedX = 0))
                : 0 > this._speedX &&
                  ((this._speedX += this.dragX * k),
                  0 < this._speedX && (this._speedX = 0));
              0 < this._speedY
                ? ((this._speedY -= this.dragY * k),
                  0 > this._speedY && (this._speedY = 0))
                : 0 > this._speedY &&
                  ((this._speedY += this.dragY * k),
                  0 < this._speedY && (this._speedY = 0));
              this.up && this.up.isDown
                ? ((this._speedY += this.accelY),
                  this._speedY > this.maxSpeedY &&
                    (this._speedY = this.maxSpeedY))
                : this.down &&
                  this.down.isDown &&
                  ((this._speedY -= this.accelY),
                  this._speedY < -this.maxSpeedY &&
                    (this._speedY = -this.maxSpeedY));
              this.left && this.left.isDown
                ? ((this._speedX += this.accelX),
                  this._speedX > this.maxSpeedX &&
                    (this._speedX = this.maxSpeedX))
                : this.right &&
                  this.right.isDown &&
                  ((this._speedX -= this.accelX),
                  this._speedX < -this.maxSpeedX &&
                    (this._speedX = -this.maxSpeedX));
              this._zoom =
                this.zoomIn && this.zoomIn.isDown
                  ? -this.zoomSpeed
                  : this.zoomOut && this.zoomOut.isDown
                  ? this.zoomSpeed
                  : 0;
              0 !== this._speedX && (e.scrollX -= (this._speedX * k) | 0);
              0 !== this._speedY && (e.scrollY -= (this._speedY * k) | 0);
              0 !== this._zoom &&
                ((e.zoom += this._zoom),
                e.zoom < this.minZoom
                  ? (e.zoom = this.minZoom)
                  : e.zoom > this.maxZoom && (e.zoom = this.maxZoom));
            }
          },
          destroy: function () {
            this.zoomOut =
              this.zoomIn =
              this.down =
              this.up =
              this.right =
              this.left =
              this.camera =
                null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          Camera: a(326),
          BaseCamera: a(133),
          CameraManager: a(799),
          Effects: a(333),
          Events: a(37),
        };
      },
      function (h, t) {
        h.exports = "cameradestroy";
      },
      function (h, t) {
        h.exports = "camerafadeincomplete";
      },
      function (h, t) {
        h.exports = "camerafadeinstart";
      },
      function (h, t) {
        h.exports = "camerafadeoutcomplete";
      },
      function (h, t) {
        h.exports = "camerafadeoutstart";
      },
      function (h, t) {
        h.exports = "cameraflashcomplete";
      },
      function (h, t) {
        h.exports = "cameraflashstart";
      },
      function (h, t) {
        h.exports = "followupdate";
      },
      function (h, t) {
        h.exports = "camerapancomplete";
      },
      function (h, t) {
        h.exports = "camerapanstart";
      },
      function (h, t) {
        h.exports = "postrender";
      },
      function (h, t) {
        h.exports = "prerender";
      },
      function (h, t) {
        h.exports = "camerarotatecomplete";
      },
      function (h, t) {
        h.exports = "camerarotatestart";
      },
      function (h, t) {
        h.exports = "camerashakecomplete";
      },
      function (h, t) {
        h.exports = "camerashakestart";
      },
      function (h, t) {
        h.exports = "camerazoomcomplete";
      },
      function (h, t) {
        h.exports = "camerazoomstart";
      },
      function (h, t, a) {
        var d = a(18);
        t = a(0);
        var k = a(37);
        a = new t({
          initialize: function (e) {
            this.camera = e;
            this.isComplete = this.isRunning = !1;
            this.direction = !0;
            this._elapsed =
              this.progress =
              this.alpha =
              this.blue =
              this.green =
              this.red =
              this.duration =
                0;
            this._onUpdate;
            this._onUpdateScope;
          },
          start: function (e, b, c, f, g, m, n, q) {
            void 0 === e && (e = !0);
            void 0 === b && (b = 1e3);
            void 0 === c && (c = 0);
            void 0 === f && (f = 0);
            void 0 === g && (g = 0);
            void 0 === m && (m = !1);
            void 0 === n && (n = null);
            void 0 === q && (q = this.camera.scene);
            if (!m && this.isRunning) return this.camera;
            this.isRunning = !0;
            this.isComplete = !1;
            this.duration = b;
            this.direction = e;
            this.progress = 0;
            this.red = c;
            this.green = f;
            this.blue = g;
            this.alpha = e ? Number.MIN_VALUE : 1;
            this._elapsed = 0;
            this._onUpdate = n;
            this._onUpdateScope = q;
            this.camera.emit(
              e ? k.FADE_OUT_START : k.FADE_IN_START,
              this.camera,
              this,
              b,
              c,
              f,
              g
            );
            return this.camera;
          },
          update: function (e, b) {
            this.isRunning &&
              ((this._elapsed += b),
              (this.progress = d(this._elapsed / this.duration, 0, 1)),
              this._onUpdate &&
                this._onUpdate.call(
                  this._onUpdateScope,
                  this.camera,
                  this.progress
                ),
              this._elapsed < this.duration
                ? (this.alpha = this.direction
                    ? this.progress
                    : 1 - this.progress)
                : ((this.alpha = this.direction ? 1 : 0),
                  this.effectComplete()));
          },
          postRenderCanvas: function (e) {
            if (!this.isRunning && !this.isComplete) return !1;
            var b = this.camera;
            e.fillStyle =
              "rgba(" +
              this.red +
              "," +
              this.green +
              "," +
              this.blue +
              "," +
              this.alpha +
              ")";
            e.fillRect(b.x, b.y, b.width, b.height);
            return !0;
          },
          postRenderWebGL: function (e, b) {
            if (!this.isRunning && !this.isComplete) return !1;
            var c = this.camera;
            e.drawFillRect(
              c.x,
              c.y,
              c.width,
              c.height,
              b(this.blue / 255, this.green / 255, this.red / 255, 1),
              this.alpha
            );
            return !0;
          },
          effectComplete: function () {
            this._onUpdateScope = this._onUpdate = null;
            this.isRunning = !1;
            this.isComplete = !0;
            this.camera.emit(
              this.direction ? k.FADE_OUT_COMPLETE : k.FADE_IN_COMPLETE,
              this.camera,
              this
            );
          },
          reset: function () {
            this.isComplete = this.isRunning = !1;
            this._onUpdateScope = this._onUpdate = null;
          },
          destroy: function () {
            this.reset();
            this.camera = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(18);
        t = a(0);
        var k = a(37);
        a = new t({
          initialize: function (e) {
            this.camera = e;
            this.isRunning = !1;
            this._elapsed =
              this.progress =
              this.alpha =
              this.blue =
              this.green =
              this.red =
              this.duration =
                0;
            this._onUpdate;
            this._onUpdateScope;
          },
          start: function (e, b, c, f, g, m, n) {
            void 0 === e && (e = 250);
            void 0 === b && (b = 255);
            void 0 === c && (c = 255);
            void 0 === f && (f = 255);
            void 0 === g && (g = !1);
            void 0 === m && (m = null);
            void 0 === n && (n = this.camera.scene);
            if (!g && this.isRunning) return this.camera;
            this.isRunning = !0;
            this.duration = e;
            this.progress = 0;
            this.red = b;
            this.green = c;
            this.blue = f;
            this.alpha = 1;
            this._elapsed = 0;
            this._onUpdate = m;
            this._onUpdateScope = n;
            this.camera.emit(k.FLASH_START, this.camera, this, e, b, c, f);
            return this.camera;
          },
          update: function (e, b) {
            this.isRunning &&
              ((this._elapsed += b),
              (this.progress = d(this._elapsed / this.duration, 0, 1)),
              this._onUpdate &&
                this._onUpdate.call(
                  this._onUpdateScope,
                  this.camera,
                  this.progress
                ),
              this._elapsed < this.duration
                ? (this.alpha = 1 - this.progress)
                : this.effectComplete());
          },
          postRenderCanvas: function (e) {
            if (!this.isRunning) return !1;
            var b = this.camera;
            e.fillStyle =
              "rgba(" +
              this.red +
              "," +
              this.green +
              "," +
              this.blue +
              "," +
              this.alpha +
              ")";
            e.fillRect(b.x, b.y, b.width, b.height);
            return !0;
          },
          postRenderWebGL: function (e, b) {
            if (!this.isRunning) return !1;
            var c = this.camera;
            e.drawFillRect(
              c.x,
              c.y,
              c.width,
              c.height,
              b(this.blue / 255, this.green / 255, this.red / 255, 1),
              this.alpha
            );
            return !0;
          },
          effectComplete: function () {
            this._onUpdateScope = this._onUpdate = null;
            this.isRunning = !1;
            this.camera.emit(k.FLASH_COMPLETE, this.camera, this);
          },
          reset: function () {
            this.isRunning = !1;
            this._onUpdateScope = this._onUpdate = null;
          },
          destroy: function () {
            this.reset();
            this.camera = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(18);
        t = a(0);
        var k = a(134),
          e = a(37),
          b = a(3);
        a = new t({
          initialize: function (c) {
            this.camera = c;
            this.isRunning = !1;
            this.duration = 0;
            this.source = new b();
            this.current = new b();
            this.destination = new b();
            this.ease;
            this._elapsed = this.progress = 0;
            this._onUpdate;
            this._onUpdateScope;
          },
          start: function (c, f, g, m, n, q, r) {
            void 0 === g && (g = 1e3);
            void 0 === m && (m = k.Linear);
            void 0 === n && (n = !1);
            void 0 === q && (q = null);
            void 0 === r && (r = this.camera.scene);
            var u = this.camera;
            if (!n && this.isRunning) return u;
            this.isRunning = !0;
            this.duration = g;
            this.progress = 0;
            this.source.set(u.scrollX, u.scrollY);
            this.destination.set(c, f);
            u.getScroll(c, f, this.current);
            "string" === typeof m && k.hasOwnProperty(m)
              ? (this.ease = k[m])
              : "function" === typeof m && (this.ease = m);
            this._elapsed = 0;
            this._onUpdate = q;
            this._onUpdateScope = r;
            this.camera.emit(e.PAN_START, this.camera, this, g, c, f);
            return u;
          },
          update: function (c, f) {
            if (this.isRunning)
              if (
                ((this._elapsed += f),
                (this.progress = c = d(this._elapsed / this.duration, 0, 1)),
                (f = this.camera),
                this._elapsed < this.duration)
              ) {
                var g = this.ease(c);
                f.getScroll(
                  this.destination.x,
                  this.destination.y,
                  this.current
                );
                var m = this.source.x + (this.current.x - this.source.x) * g;
                g = this.source.y + (this.current.y - this.source.y) * g;
                f.setScroll(m, g);
                this._onUpdate &&
                  this._onUpdate.call(this._onUpdateScope, f, c, m, g);
              } else
                f.centerOn(this.destination.x, this.destination.y),
                  this._onUpdate &&
                    this._onUpdate.call(
                      this._onUpdateScope,
                      f,
                      c,
                      f.scrollX,
                      f.scrollY
                    ),
                  this.effectComplete();
          },
          effectComplete: function () {
            this._onUpdateScope = this._onUpdate = null;
            this.isRunning = !1;
            this.camera.emit(e.PAN_COMPLETE, this.camera, this);
          },
          reset: function () {
            this.isRunning = !1;
            this._onUpdateScope = this._onUpdate = null;
          },
          destroy: function () {
            this.reset();
            this.destination = this.source = this.camera = null;
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = 1.70158);
          return a * a * ((d + 1) * a - d);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = 1.70158);
          return --a * a * ((d + 1) * a + d) + 1;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = 1.70158);
          d *= 1.525;
          return 1 > (a *= 2)
            ? 0.5 * a * a * ((d + 1) * a - d)
            : 0.5 * ((a -= 2) * a * ((d + 1) * a + d) + 2);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          a = 1 - a;
          return a < 1 / 2.75
            ? 1 - 7.5625 * a * a
            : a < 2 / 2.75
            ? 1 - (7.5625 * (a -= 1.5 / 2.75) * a + 0.75)
            : a < 2.5 / 2.75
            ? 1 - (7.5625 * (a -= 2.25 / 2.75) * a + 0.9375)
            : 1 - (7.5625 * (a -= 2.625 / 2.75) * a + 0.984375);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a < 1 / 2.75
            ? 7.5625 * a * a
            : a < 2 / 2.75
            ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75
            : a < 2.5 / 2.75
            ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375
            : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          var d = !1;
          0.5 > a ? ((a = 1 - 2 * a), (d = !0)) : (a = 2 * a - 1);
          a =
            a < 1 / 2.75
              ? 7.5625 * a * a
              : a < 2 / 2.75
              ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75
              : a < 2.5 / 2.75
              ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375
              : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
          return d ? 0.5 * (1 - a) : 0.5 * a + 0.5;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 1 - Math.sqrt(1 - a * a);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return Math.sqrt(1 - --a * a);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 1 > (a *= 2)
            ? -0.5 * (Math.sqrt(1 - a * a) - 1)
            : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a * a * a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return --a * a * a + 1;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 1 > (a *= 2) ? 0.5 * a * a * a : 0.5 * ((a -= 2) * a * a + 2);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          void 0 === d && (d = 0.1);
          void 0 === k && (k = 0.1);
          if (0 === a) return 0;
          if (1 === a) return 1;
          var e = k / 4;
          1 > d ? (d = 1) : (e = (k * Math.asin(1 / d)) / (2 * Math.PI));
          return -(
            d *
            Math.pow(2, 10 * --a) *
            Math.sin((2 * (a - e) * Math.PI) / k)
          );
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          void 0 === d && (d = 0.1);
          void 0 === k && (k = 0.1);
          if (0 === a) return 0;
          if (1 === a) return 1;
          var e = k / 4;
          1 > d ? (d = 1) : (e = (k * Math.asin(1 / d)) / (2 * Math.PI));
          return (
            d * Math.pow(2, -10 * a) * Math.sin((2 * (a - e) * Math.PI) / k) + 1
          );
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          void 0 === d && (d = 0.1);
          void 0 === k && (k = 0.1);
          if (0 === a) return 0;
          if (1 === a) return 1;
          var e = k / 4;
          1 > d ? (d = 1) : (e = (k * Math.asin(1 / d)) / (2 * Math.PI));
          return 1 > (a *= 2)
            ? -0.5 *
                d *
                Math.pow(2, 10 * --a) *
                Math.sin((2 * (a - e) * Math.PI) / k)
            : d *
                Math.pow(2, -10 * --a) *
                Math.sin((2 * (a - e) * Math.PI) / k) *
                0.5 +
                1;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return Math.pow(2, 10 * (a - 1)) - 0.001;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 1 - Math.pow(2, -10 * a);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 1 > (a *= 2)
            ? 0.5 * Math.pow(2, 10 * (a - 1))
            : 0.5 * (2 - Math.pow(2, -10 * (a - 1)));
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a * a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a * (2 - a);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 1 > (a *= 2) ? 0.5 * a * a : -0.5 * (--a * (a - 2) - 1);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a * a * a * a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 1 - --a * a * a * a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 1 > (a *= 2)
            ? 0.5 * a * a * a * a
            : -0.5 * ((a -= 2) * a * a * a - 2);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a * a * a * a * a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return --a * a * a * a * a + 1;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 1 > (a *= 2)
            ? 0.5 * a * a * a * a * a
            : 0.5 * ((a -= 2) * a * a * a * a + 2);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 0 === a ? 0 : 1 === a ? 1 : 1 - Math.cos((a * Math.PI) / 2);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 0 === a ? 0 : 1 === a ? 1 : Math.sin((a * Math.PI) / 2);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 0 === a ? 0 : 1 === a ? 1 : 0.5 * (1 - Math.cos(Math.PI * a));
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = 1);
          return 0 >= a ? 0 : 1 <= a ? 1 : (1 / d) * (((d * a) | 0) + 1);
        };
      },
      function (h, t, a) {
        var d = a(18);
        t = a(0);
        var k = a(37),
          e = a(3);
        a = new t({
          initialize: function (b) {
            this.camera = b;
            this.isRunning = !1;
            this.duration = 0;
            this.intensity = new e();
            this._offsetY = this._offsetX = this._elapsed = this.progress = 0;
            this._onUpdate;
            this._onUpdateScope;
          },
          start: function (b, c, f, g, m) {
            void 0 === b && (b = 100);
            void 0 === c && (c = 0.05);
            void 0 === f && (f = !1);
            void 0 === g && (g = null);
            void 0 === m && (m = this.camera.scene);
            if (!f && this.isRunning) return this.camera;
            this.isRunning = !0;
            this.duration = b;
            this.progress = 0;
            "number" === typeof c
              ? this.intensity.set(c)
              : this.intensity.set(c.x, c.y);
            this._offsetY = this._offsetX = this._elapsed = 0;
            this._onUpdate = g;
            this._onUpdateScope = m;
            this.camera.emit(k.SHAKE_START, this.camera, this, b, c);
            return this.camera;
          },
          preRender: function () {
            this.isRunning &&
              this.camera.matrix.translate(this._offsetX, this._offsetY);
          },
          update: function (b, c) {
            if (this.isRunning)
              if (
                ((this._elapsed += c),
                (this.progress = d(this._elapsed / this.duration, 0, 1)),
                this._onUpdate &&
                  this._onUpdate.call(
                    this._onUpdateScope,
                    this.camera,
                    this.progress
                  ),
                this._elapsed < this.duration)
              ) {
                b = this.intensity;
                c = this.camera.width;
                var f = this.camera.height,
                  g = this.camera.zoom;
                this._offsetX = (Math.random() * b.x * c * 2 - b.x * c) * g;
                this._offsetY = (Math.random() * b.y * f * 2 - b.y * f) * g;
                this.camera.roundPixels &&
                  ((this._offsetX = Math.round(this._offsetX)),
                  (this._offsetY = Math.round(this._offsetY)));
              } else this.effectComplete();
          },
          effectComplete: function () {
            this._offsetY = this._offsetX = 0;
            this._onUpdateScope = this._onUpdate = null;
            this.isRunning = !1;
            this.camera.emit(k.SHAKE_COMPLETE, this.camera, this);
          },
          reset: function () {
            this.isRunning = !1;
            this._offsetY = this._offsetX = 0;
            this._onUpdateScope = this._onUpdate = null;
          },
          destroy: function () {
            this.reset();
            this.intensity = this.camera = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(18);
        t = a(0);
        var k = a(37),
          e = a(134);
        a = new t({
          initialize: function (b) {
            this.camera = b;
            this.isRunning = !1;
            this.destination = this.current = this.source = this.duration = 0;
            this.ease;
            this._elapsed = this.progress = 0;
            this._onUpdate;
            this._onUpdateScope;
            this.clockwise = !0;
            this.shortestPath = !1;
          },
          start: function (b, c, f, g, m, n, q) {
            void 0 === f && (f = 1e3);
            void 0 === g && (g = e.Linear);
            void 0 === m && (m = !1);
            void 0 === n && (n = null);
            void 0 === q && (q = this.camera.scene);
            void 0 === c && (c = !1);
            this.shortestPath = c;
            c = b;
            0 > b
              ? ((c = -1 * b), (this.clockwise = !1))
              : (this.clockwise = !0);
            var r = (360 * Math.PI) / 180;
            c -= Math.floor(c / r) * r;
            b = this.camera;
            if (!m && this.isRunning) return b;
            this.isRunning = !0;
            this.duration = f;
            this.progress = 0;
            this.source = b.rotation;
            this.destination = c;
            "string" === typeof g && e.hasOwnProperty(g)
              ? (this.ease = e[g])
              : "function" === typeof g && (this.ease = g);
            this._elapsed = 0;
            this._onUpdate = n;
            this._onUpdateScope = q;
            this.shortestPath &&
              ((g =
                this.destination > this.source
                  ? Math.abs(this.destination - this.source)
                  : Math.abs(this.destination + r) - this.source),
              (m =
                this.source > this.destination
                  ? Math.abs(this.source - this.destination)
                  : Math.abs(this.source + r) - this.destination),
              g < m ? (this.clockwise = !0) : g > m && (this.clockwise = !1));
            this.camera.emit(k.ROTATE_START, this.camera, this, f, c);
            return b;
          },
          update: function (b, c) {
            if (this.isRunning)
              if (
                ((this._elapsed += c),
                (this.progress = b = d(this._elapsed / this.duration, 0, 1)),
                (c = this.camera),
                this._elapsed < this.duration)
              ) {
                var f = this.ease(b);
                this.current = c.rotation;
                var g = (360 * Math.PI) / 180;
                var m = this.destination,
                  n = this.current;
                !1 === this.clockwise &&
                  ((m = this.current), (n = this.destination));
                g = m >= n ? Math.abs(m - n) : Math.abs(m + g) - n;
                f = this.clockwise ? c.rotation + g * f : c.rotation - g * f;
                c.rotation = f;
                this._onUpdate &&
                  this._onUpdate.call(this._onUpdateScope, c, b, f);
              } else
                (c.rotation = this.destination),
                  this._onUpdate &&
                    this._onUpdate.call(
                      this._onUpdateScope,
                      c,
                      b,
                      this.destination
                    ),
                  this.effectComplete();
          },
          effectComplete: function () {
            this._onUpdateScope = this._onUpdate = null;
            this.isRunning = !1;
            this.camera.emit(k.ROTATE_COMPLETE, this.camera, this);
          },
          reset: function () {
            this.isRunning = !1;
            this._onUpdateScope = this._onUpdate = null;
          },
          destroy: function () {
            this.reset();
            this.destination = this.source = this.camera = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(18);
        t = a(0);
        var k = a(134),
          e = a(37);
        a = new t({
          initialize: function (b) {
            this.camera = b;
            this.isRunning = !1;
            this.duration = 0;
            this.destination = this.source = 1;
            this.ease;
            this._elapsed = this.progress = 0;
            this._onUpdate;
            this._onUpdateScope;
          },
          start: function (b, c, f, g, m, n) {
            void 0 === c && (c = 1e3);
            void 0 === f && (f = k.Linear);
            void 0 === g && (g = !1);
            void 0 === m && (m = null);
            void 0 === n && (n = this.camera.scene);
            var q = this.camera;
            if (!g && this.isRunning) return q;
            this.isRunning = !0;
            this.duration = c;
            this.progress = 0;
            this.source = q.zoom;
            this.destination = b;
            "string" === typeof f && k.hasOwnProperty(f)
              ? (this.ease = k[f])
              : "function" === typeof f && (this.ease = f);
            this._elapsed = 0;
            this._onUpdate = m;
            this._onUpdateScope = n;
            this.camera.emit(e.ZOOM_START, this.camera, this, c, b);
            return q;
          },
          update: function (b, c) {
            this.isRunning &&
              ((this._elapsed += c),
              (this.progress = d(this._elapsed / this.duration, 0, 1)),
              this._elapsed < this.duration
                ? ((this.camera.zoom =
                    this.source +
                    (this.destination - this.source) *
                      this.ease(this.progress)),
                  this._onUpdate &&
                    this._onUpdate.call(
                      this._onUpdateScope,
                      this.camera,
                      this.progress,
                      this.camera.zoom
                    ))
                : ((this.camera.zoom = this.destination),
                  this._onUpdate &&
                    this._onUpdate.call(
                      this._onUpdateScope,
                      this.camera,
                      this.progress,
                      this.destination
                    ),
                  this.effectComplete()));
          },
          effectComplete: function () {
            this._onUpdateScope = this._onUpdate = null;
            this.isRunning = !1;
            this.camera.emit(e.ZOOM_COMPLETE, this.camera, this);
          },
          reset: function () {
            this.isRunning = !1;
            this._onUpdateScope = this._onUpdate = null;
          },
          destroy: function () {
            this.reset();
            this.camera = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(326),
          k = a(0),
          e = a(2);
        t = a(24);
        var b = a(57),
          c = a(104),
          f = a(20);
        a = new k({
          initialize: function (g) {
            this.scene = g;
            this.systems = g.sys;
            this.roundPixels = g.sys.game.config.roundPixels;
            this.cameras = [];
            this.main;
            this.default;
            g.sys.events.once(f.BOOT, this.boot, this);
            g.sys.events.on(f.START, this.start, this);
          },
          boot: function () {
            var g = this.systems;
            g.settings.cameras ? this.fromJSON(g.settings.cameras) : this.add();
            this.main = this.cameras[0];
            this.default = new d(0, 0, g.scale.width, g.scale.height).setScene(
              this.scene
            );
            g.game.scale.on(c.RESIZE, this.onResize, this);
            this.systems.events.once(f.DESTROY, this.destroy, this);
          },
          start: function () {
            if (!this.main) {
              var g = this.systems;
              g.settings.cameras
                ? this.fromJSON(g.settings.cameras)
                : this.add();
              this.main = this.cameras[0];
            }
            g = this.systems.events;
            g.on(f.UPDATE, this.update, this);
            g.once(f.SHUTDOWN, this.shutdown, this);
          },
          add: function (g, m, n, q, r, u) {
            void 0 === g && (g = 0);
            void 0 === m && (m = 0);
            void 0 === n && (n = this.scene.sys.scale.width);
            void 0 === q && (q = this.scene.sys.scale.height);
            void 0 === r && (r = !1);
            void 0 === u && (u = "");
            g = new d(g, m, n, q);
            g.setName(u);
            g.setScene(this.scene);
            g.setRoundPixels(this.roundPixels);
            g.id = this.getNextID();
            this.cameras.push(g);
            r && (this.main = g);
            return g;
          },
          addExisting: function (g, m) {
            void 0 === m && (m = !1);
            return -1 === this.cameras.indexOf(g)
              ? ((g.id = this.getNextID()),
                g.setRoundPixels(this.roundPixels),
                this.cameras.push(g),
                m && (this.main = g),
                g)
              : null;
          },
          getNextID: function () {
            for (var g = this.cameras, m = 1, n = 0; 32 > n; n++) {
              for (var q = !1, r = 0; r < g.length; r++) {
                var u = g[r];
                u && u.id === m && (q = !0);
              }
              if (q) m <<= 1;
              else return m;
            }
            return 0;
          },
          getTotal: function (g) {
            void 0 === g && (g = !1);
            for (var m = 0, n = this.cameras, q = 0; q < n.length; q++) {
              var r = n[q];
              (!g || (g && r.visible)) && m++;
            }
            return m;
          },
          fromJSON: function (g) {
            Array.isArray(g) || (g = [g]);
            for (
              var m = this.scene.sys.scale.width,
                n = this.scene.sys.scale.height,
                q = 0;
              q < g.length;
              q++
            ) {
              var r = g[q],
                u = e(r, "x", 0),
                v = e(r, "y", 0),
                x = e(r, "width", m),
                y = e(r, "height", n);
              u = this.add(u, v, x, y);
              u.name = e(r, "name", "");
              u.zoom = e(r, "zoom", 1);
              u.rotation = e(r, "rotation", 0);
              u.scrollX = e(r, "scrollX", 0);
              u.scrollY = e(r, "scrollY", 0);
              u.roundPixels = e(r, "roundPixels", !1);
              u.visible = e(r, "visible", !0);
              (v = e(r, "backgroundColor", !1)) && u.setBackgroundColor(v);
              if ((y = e(r, "bounds", null)))
                (r = e(y, "x", 0)),
                  (v = e(y, "y", 0)),
                  (x = e(y, "width", m)),
                  (y = e(y, "height", n)),
                  u.setBounds(r, v, x, y);
            }
            return this;
          },
          getCamera: function (g) {
            for (var m = this.cameras, n = 0; n < m.length; n++)
              if (m[n].name === g) return m[n];
            return null;
          },
          getCamerasBelowPointer: function (g) {
            var m = this.cameras,
              n = g.x;
            g = g.y;
            for (var q = [], r = 0; r < m.length; r++) {
              var u = m[r];
              u.visible && u.inputEnabled && b(u, n, g) && q.unshift(u);
            }
            return q;
          },
          remove: function (g, m) {
            void 0 === m && (m = !0);
            Array.isArray(g) || (g = [g]);
            for (var n = 0, q = this.cameras, r = 0; r < g.length; r++) {
              var u = q.indexOf(g[r]);
              -1 !== u &&
                (m ? q[u].destroy() : (q[u].renderList = []),
                q.splice(u, 1),
                n++);
            }
            !this.main && q[0] && (this.main = q[0]);
            return n;
          },
          render: function (g, m) {
            for (
              var n = this.scene, q = this.cameras, r = 0;
              r < this.cameras.length;
              r++
            ) {
              var u = q[r];
              if (u.visible && 0 < u.alpha) {
                u.preRender();
                var v = this.getVisibleChildren(m.getChildren(), u);
                g.render(n, v, u);
              }
            }
          },
          getVisibleChildren: function (g, m) {
            for (var n = [], q = 0; q < g.length; q++) {
              var r = g[q];
              r.willRender(m) && n.push(r);
            }
            return n;
          },
          resetAll: function () {
            for (var g = 0; g < this.cameras.length; g++)
              this.cameras[g].destroy();
            this.cameras = [];
            return (this.main = this.add());
          },
          update: function (g, m) {
            for (var n = 0; n < this.cameras.length; n++)
              this.cameras[n].update(g, m);
          },
          onResize: function (g, m, n, q, r) {
            for (g = 0; g < this.cameras.length; g++)
              (n = this.cameras[g]),
                0 === n._x &&
                  0 === n._y &&
                  n._width === q &&
                  n._height === r &&
                  n.setSize(m.width, m.height);
          },
          resize: function (g, m) {
            for (var n = 0; n < this.cameras.length; n++)
              this.cameras[n].setSize(g, m);
          },
          shutdown: function () {
            this.main = void 0;
            for (var g = 0; g < this.cameras.length; g++)
              this.cameras[g].destroy();
            this.cameras = [];
            g = this.systems.events;
            g.off(f.UPDATE, this.update, this);
            g.off(f.SHUTDOWN, this.shutdown, this);
          },
          destroy: function () {
            this.shutdown();
            this.default.destroy();
            this.scene.sys.events.off(f.START, this.start, this);
            this.systems = this.scene = null;
          },
        });
        t.register("CameraManager", a, "cameras");
        h.exports = a;
      },
      function (h, t) {
        h.exports = "enterfullscreen";
      },
      function (h, t) {
        h.exports = "fullscreenfailed";
      },
      function (h, t) {
        h.exports = "fullscreenunsupported";
      },
      function (h, t) {
        h.exports = "leavefullscreen";
      },
      function (h, t) {
        h.exports = "orientationchange";
      },
      function (h, t) {
        h.exports = "resize";
      },
      function (h, t, a) {
        h.exports = {
          Config: a(346),
          CreateRenderer: a(366),
          DebugHeader: a(384),
          Events: a(22),
          TimeStep: a(385),
          VisibilityHandler: a(387),
        };
      },
      function (h, t) {
        function a() {
          throw Error("setTimeout has not been defined");
        }

        function d() {
          throw Error("clearTimeout has not been defined");
        }

        function k(x) {
          if (m === setTimeout) return setTimeout(x, 0);
          if ((m === a || !m) && setTimeout)
            return (m = setTimeout), setTimeout(x, 0);
          try {
            return m(x, 0);
          } catch (y) {
            try {
              return m.call(null, x, 0);
            } catch (z) {
              return m.call(this, x, 0);
            }
          }
        }

        function e(x) {
          if (n === clearTimeout) return clearTimeout(x);
          if ((n === d || !n) && clearTimeout)
            return (n = clearTimeout), clearTimeout(x);
          try {
            return n(x);
          } catch (y) {
            try {
              return n.call(null, x);
            } catch (z) {
              return n.call(this, x);
            }
          }
        }

        function b() {
          r &&
            u &&
            ((r = !1),
            u.length ? (q = u.concat(q)) : (v = -1),
            q.length && c());
        }

        function c() {
          if (!r) {
            var x = k(b);
            r = !0;
            for (var y = q.length; y; ) {
              u = q;
              for (q = []; ++v < y; ) u && u[v].run();
              v = -1;
              y = q.length;
            }
            u = null;
            r = !1;
            e(x);
          }
        }

        function f(x, y) {
          this.fun = x;
          this.array = y;
        }

        function g() {}
        h = h.exports = {};
        try {
          var m = "function" === typeof setTimeout ? setTimeout : a;
        } catch (x) {
          m = a;
        }
        try {
          var n = "function" === typeof clearTimeout ? clearTimeout : d;
        } catch (x) {
          n = d;
        }
        var q = [],
          r = !1,
          u,
          v = -1;
        h.nextTick = function (x) {
          var y = Array(arguments.length - 1);
          if (1 < arguments.length)
            for (var z = 1; z < arguments.length; z++) y[z - 1] = arguments[z];
          q.push(new f(x, y));
          1 !== q.length || r || k(c);
        };
        f.prototype.run = function () {
          this.fun.apply(null, this.array);
        };
        h.title = "browser";
        h.browser = !0;
        h.env = {};
        h.argv = [];
        h.version = "";
        h.versions = {};
        h.on = g;
        h.addListener = g;
        h.once = g;
        h.off = g;
        h.removeListener = g;
        h.removeAllListeners = g;
        h.emit = g;
        h.prependListener = g;
        h.prependOnceListener = g;
        h.listeners = function (x) {
          return [];
        };
        h.binding = function (x) {
          throw Error("process.binding is not supported");
        };
        h.cwd = function () {
          return "/";
        };
        h.chdir = function (x) {
          throw Error("process.chdir is not supported");
        };
        h.umask = function () {
          return 0;
        };
      },
      function (h, t, a) {
        t = a(136);
        a = {
          gamepads: !1,
          mspointer: !1,
          touch: !1,
          wheelEvent: null,
        };
        if ("function" !== typeof importScripts) {
          if (
            "ontouchstart" in document.documentElement ||
            (navigator.maxTouchPoints && 1 <= navigator.maxTouchPoints)
          )
            a.touch = !0;
          if (navigator.msPointerEnabled || navigator.pointerEnabled)
            a.mspointer = !0;
          navigator.getGamepads && (a.gamepads = !0);
          "onwheel" in window || (t.ie && "WheelEvent" in window)
            ? (a.wheelEvent = "wheel")
            : "onmousewheel" in window
            ? (a.wheelEvent = "mousewheel")
            : t.firefox &&
              "MouseScrollEvent" in window &&
              (a.wheelEvent = "DOMMouseScroll");
        }
        h.exports = a;
      },
      function (h, t, a) {
        t = a(136);
        a = {
          audioData: !1,
          dolby: !1,
          m4a: !1,
          mp3: !1,
          ogg: !1,
          opus: !1,
          wav: !1,
          webAudio: !1,
          webm: !1,
        };
        if ("function" !== typeof importScripts) {
          a.audioData = !!window.Audio;
          a.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
          var d = document.createElement("audio"),
            k = !!d.canPlayType;
          try {
            if (k) {
              d.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") &&
                (a.ogg = !0);
              if (
                d.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") ||
                d.canPlayType("audio/opus;").replace(/^no$/, "")
              )
                a.opus = !0;
              d.canPlayType("audio/mpeg;").replace(/^no$/, "") && (a.mp3 = !0);
              d.canPlayType("audio/wav").replace(/^no$/, "") && (a.wav = !0);
              if (
                d.canPlayType("audio/x-m4a;") ||
                d.canPlayType("audio/aac;").replace(/^no$/, "")
              )
                a.m4a = !0;
              d
                .canPlayType('audio/webm; codecs="vorbis"')
                .replace(/^no$/, "") && (a.webm = !0);
              if ("" !== d.canPlayType('audio/mp4;codecs="ec-3"'))
                if (t.edge) a.dolby = !0;
                else if (
                  t.safari &&
                  9 <= t.safariVersion &&
                  /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)
                ) {
                  var e = parseInt(RegExp.$1, 10),
                    b = parseInt(RegExp.$2, 10);
                  if ((10 === e && 11 <= b) || 10 < e) a.dolby = !0;
                }
            }
          } catch (c) {}
        }
        h.exports = a;
      },
      function (h, t) {
        t = {
          h264: !1,
          hls: !1,
          mp4: !1,
          ogg: !1,
          vp9: !1,
          webm: !1,
        };
        if ("function" !== typeof importScripts) {
          var a = document.createElement("video"),
            d = !!a.canPlayType;
          try {
            d &&
              (a
                .canPlayType('video/ogg; codecs="theora"')
                .replace(/^no$/, "") && (t.ogg = !0),
              a
                .canPlayType('video/mp4; codecs="avc1.42E01E"')
                .replace(/^no$/, "") && ((t.h264 = !0), (t.mp4 = !0)),
              a
                .canPlayType('video/webm; codecs="vp8, vorbis"')
                .replace(/^no$/, "") && (t.webm = !0),
              a.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") &&
                (t.vp9 = !0),
              a
                .canPlayType('application/x-mpegURL; codecs="avc1.42E01E"')
                .replace(/^no$/, "") && (t.hls = !0));
          } catch (k) {}
        }
        h.exports = t;
      },
      function (h, t) {
        var a = {
          available: !1,
          cancel: "",
          keyboard: !1,
          request: "",
        };
        h.exports = (function () {
          if ("function" === typeof importScripts) return a;
          var d,
            k =
              "requestFullscreen requestFullScreen webkitRequestFullscreen webkitRequestFullScreen msRequestFullscreen msRequestFullScreen mozRequestFullScreen mozRequestFullscreen".split(
                " "
              );
          for (d = 0; d < k.length; d++)
            if (document.documentElement[k[d]]) {
              a.available = !0;
              a.request = k[d];
              break;
            }
          k =
            "cancelFullScreen exitFullscreen webkitCancelFullScreen webkitExitFullscreen msCancelFullScreen msExitFullscreen mozCancelFullScreen mozExitFullscreen".split(
              " "
            );
          if (a.available)
            for (d = 0; d < k.length; d++)
              if (document[k[d]]) {
                a.cancel = k[d];
                break;
              }
          window.Element &&
            Element.ALLOW_KEYBOARD_INPUT &&
            !/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent) &&
            (a.keyboard = !0);
          Object.defineProperty(a, "active", {
            get: function () {
              return !!(
                document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.mozFullScreenElement ||
                document.msFullscreenElement
              );
            },
          });
          return a;
        })();
      },
      function (h, t, a) {
        h.exports = {
          Between: a(349),
          BetweenPoints: a(350),
          BetweenPointsY: a(813),
          BetweenY: a(814),
          CounterClockwise: a(815),
          Normalize: a(351),
          Random: a(816),
          RandomDegrees: a(817),
          Reverse: a(818),
          RotateTo: a(819),
          ShortestBetween: a(820),
          Wrap: a(269),
          WrapDegrees: a(270),
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return Math.atan2(d.x - a.x, d.y - a.y);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          return Math.atan2(k - a, e - d);
        };
      },
      function (h, t, a) {
        var d = a(14);
        h.exports = function (k) {
          k > Math.PI && (k -= d.PI2);
          return Math.abs((((k + d.TAU) % d.PI2) - d.PI2) % d.PI2);
        };
      },
      function (h, t, a) {
        var d = a(137);
        h.exports = function () {
          return d(-Math.PI, Math.PI);
        };
      },
      function (h, t, a) {
        var d = a(137);
        h.exports = function () {
          return d(-180, 180);
        };
      },
      function (h, t, a) {
        var d = a(351);
        h.exports = function (k) {
          return d(k + Math.PI);
        };
      },
      function (h, t, a) {
        var d = a(14);
        h.exports = function (k, e, b) {
          void 0 === b && (b = 0.05);
          if (k === e) return k;
          Math.abs(e - k) <= b || Math.abs(e - k) >= d.PI2 - b
            ? (k = e)
            : (Math.abs(e - k) > Math.PI && (e = e < k ? e + d.PI2 : e - d.PI2),
              e > k ? (k += b) : e < k && (k -= b));
          return k;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          a = d - a;
          return 0 === a ? 0 : a - 360 * Math.floor((a - -180) / 360);
        };
      },
      function (h, t, a) {
        h.exports = {
          Between: a(50),
          BetweenPoints: a(352),
          BetweenPointsSquared: a(822),
          Chebyshev: a(823),
          Power: a(824),
          Snake: a(825),
          Squared: a(353),
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          var k = a.x - d.x;
          a = a.y - d.y;
          return k * k + a * a;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          return Math.max(Math.abs(a - k), Math.abs(d - e));
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b) {
          void 0 === b && (b = 2);
          return Math.sqrt(Math.pow(k - a, b) + Math.pow(e - d, b));
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          return Math.abs(a - k) + Math.abs(d - e);
        };
      },
      function (h, t, a) {
        h.exports = {
          Back: a(334),
          Bounce: a(335),
          Circular: a(336),
          Cubic: a(337),
          Elastic: a(338),
          Expo: a(339),
          Linear: a(340),
          Quadratic: a(341),
          Quartic: a(342),
          Quintic: a(343),
          Sine: a(344),
          Stepped: a(345),
        };
      },
      function (h, t, a) {
        h.exports = {
          Ceil: a(828),
          Equal: a(124),
          Floor: a(829),
          GreaterThan: a(354),
          LessThan: a(355),
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = 1e-4);
          return Math.ceil(a - d);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = 1e-4);
          return Math.floor(a + d);
        };
      },
      function (h, t, a) {
        h.exports = {
          Bezier: a(831),
          CatmullRom: a(832),
          CubicBezier: a(358),
          Linear: a(833),
          QuadraticBezier: a(359),
          SmoothStep: a(360),
          SmootherStep: a(834),
        };
      },
      function (h, t, a) {
        var d = a(356);
        h.exports = function (k, e) {
          for (var b = 0, c = k.length - 1, f = 0; f <= c; f++)
            b += Math.pow(1 - e, c - f) * Math.pow(e, f) * k[f] * d(c, f);
          return b;
        };
      },
      function (h, t, a) {
        var d = a(194);
        h.exports = function (k, e) {
          var b = k.length - 1,
            c = b * e,
            f = Math.floor(c);
          return k[0] === k[b]
            ? (0 > e && (f = Math.floor((c = b * (1 + e)))),
              d(
                c - f,
                k[(f - 1 + b) % b],
                k[f],
                k[(f + 1) % b],
                k[(f + 2) % b]
              ))
            : 0 > e
            ? k[0] - (d(-c, k[0], k[0], k[1], k[1]) - k[0])
            : 1 < e
            ? k[b] - (d(c - b, k[b], k[b], k[b - 1], k[b - 1]) - k[b])
            : d(
                c - f,
                k[f ? f - 1 : 0],
                k[f],
                k[b < f + 1 ? b : f + 1],
                k[b < f + 2 ? b : f + 2]
              );
        };
      },
      function (h, t, a) {
        var d = a(135);
        h.exports = function (k, e) {
          var b = k.length - 1,
            c = b * e,
            f = Math.floor(c);
          return 0 > e
            ? d(k[0], k[1], c)
            : 1 < e
            ? d(k[b], k[b - 1], b - c)
            : d(k[f], k[f + 1 > b ? b : f + 1], c - f);
        };
      },
      function (h, t, a) {
        var d = a(183);
        h.exports = function (k, e, b) {
          return e + (b - e) * d(k, 0, 1);
        };
      },
      function (h, t, a) {
        h.exports = {
          GetNext: a(361),
          IsSize: a(138),
          IsValue: a(836),
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return 0 < a && 0 === (a & (a - 1));
        };
      },
      function (h, t, a) {
        h.exports = {
          Ceil: a(139),
          Floor: a(76),
          To: a(838),
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          void 0 === k && (k = 0);
          if (0 === d) return a;
          a = d * Math.round((a - k) / d);
          return e ? (k + a) / d : k + a;
        };
      },
      function (h, t, a) {
        t = new (a(0))({
          initialize: function (d) {
            void 0 === d && (d = [(Date.now() * Math.random()).toString()]);
            this.c = 1;
            this.n = this.s2 = this.s1 = this.s0 = 0;
            this.signs = [-1, 1];
            d && this.init(d);
          },
          rnd: function () {
            var d = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
            this.c = d | 0;
            this.s0 = this.s1;
            this.s1 = this.s2;
            return (this.s2 = d - this.c);
          },
          hash: function (d) {
            var k = this.n;
            d = d.toString();
            for (var e = 0; e < d.length; e++) {
              k += d.charCodeAt(e);
              var b = 0.02519603282416938 * k;
              k = b >>> 0;
              b -= k;
              b *= k;
              k = b >>> 0;
              b -= k;
              k += 4294967296 * b;
            }
            this.n = k;
            return 2.3283064365386963e-10 * (k >>> 0);
          },
          init: function (d) {
            "string" === typeof d ? this.state(d) : this.sow(d);
          },
          sow: function (d) {
            this.n = 4022871197;
            this.s0 = this.hash(" ");
            this.s1 = this.hash(" ");
            this.s2 = this.hash(" ");
            this.c = 1;
            if (d)
              for (var k = 0; k < d.length && null != d[k]; k++) {
                var e = d[k];
                this.s0 -= this.hash(e);
                this.s0 += ~~(0 > this.s0);
                this.s1 -= this.hash(e);
                this.s1 += ~~(0 > this.s1);
                this.s2 -= this.hash(e);
                this.s2 += ~~(0 > this.s2);
              }
          },
          integer: function () {
            return 4294967296 * this.rnd();
          },
          frac: function () {
            return (
              this.rnd() + 1.1102230246251565e-16 * ((2097152 * this.rnd()) | 0)
            );
          },
          real: function () {
            return this.integer() + this.frac();
          },
          integerInRange: function (d, k) {
            return Math.floor(this.realInRange(0, k - d + 1) + d);
          },
          between: function (d, k) {
            return Math.floor(this.realInRange(0, k - d + 1) + d);
          },
          realInRange: function (d, k) {
            return this.frac() * (k - d) + d;
          },
          normal: function () {
            return 1 - 2 * this.frac();
          },
          uuid: function () {
            var d, k;
            for (
              k = d = "";
              36 > d++;
              k +=
                ~d % 5 | ((3 * d) & 4)
                  ? (d ^ 15
                      ? 8 ^ (this.frac() * (d ^ 20 ? 16 : 4))
                      : 4
                    ).toString(16)
                  : "-"
            );
            return k;
          },
          pick: function (d) {
            return d[this.integerInRange(0, d.length - 1)];
          },
          sign: function () {
            return this.pick(this.signs);
          },
          weightedPick: function (d) {
            return d[~~(Math.pow(this.frac(), 2) * (d.length - 1) + 0.5)];
          },
          timestamp: function (d, k) {
            return this.realInRange(d || 9466848e5, k || 1577862e6);
          },
          angle: function () {
            return this.integerInRange(-180, 180);
          },
          rotation: function () {
            return this.realInRange(-3.1415926, 3.1415926);
          },
          state: function (d) {
            "string" === typeof d &&
              d.match(/^!rnd/) &&
              ((d = d.split(",")),
              (this.c = parseFloat(d[1])),
              (this.s0 = parseFloat(d[2])),
              (this.s1 = parseFloat(d[3])),
              (this.s2 = parseFloat(d[4])));
            return ["!rnd", this.c, this.s0, this.s1, this.s2].join();
          },
          shuffle: function (d) {
            for (var k = d.length - 1; 0 < k; k--) {
              var e = Math.floor(this.frac() * (k + 1)),
                b = d[e];
              d[e] = d[k];
              d[k] = b;
            }
            return d;
          },
        });
        h.exports = t;
      },
      function (h, t) {
        h.exports = function (a) {
          for (var d = 0, k = 0; k < a.length; k++) d += +a[k];
          return d / a.length;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          void 0 === d && (d = 0);
          void 0 === k && (k = 10);
          d = Math.pow(k, -d);
          return Math.ceil(a * d) / d;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return Math.abs(a - d);
        };
      },
      function (h, t, a) {
        var d = a(18);
        t = a(0);
        var k = a(69),
          e = a(1),
          b = new k();
        a = new t({
          initialize: function q(f, g, m, n) {
            void 0 === f && (f = 0);
            void 0 === g && (g = 0);
            void 0 === m && (m = 0);
            void 0 === n && (n = q.DefaultOrder);
            this._x = f;
            this._y = g;
            this._z = m;
            this._order = n;
            this.onChangeCallback = e;
          },
          x: {
            get: function () {
              return this._x;
            },
            set: function (f) {
              this._x = f;
              this.onChangeCallback(this);
            },
          },
          y: {
            get: function () {
              return this._y;
            },
            set: function (f) {
              this._y = f;
              this.onChangeCallback(this);
            },
          },
          z: {
            get: function () {
              return this._z;
            },
            set: function (f) {
              this._z = f;
              this.onChangeCallback(this);
            },
          },
          order: {
            get: function () {
              return this._order;
            },
            set: function (f) {
              this._order = f;
              this.onChangeCallback(this);
            },
          },
          set: function (f, g, m, n) {
            void 0 === n && (n = this._order);
            this._x = f;
            this._y = g;
            this._z = m;
            this._order = n;
            this.onChangeCallback(this);
            return this;
          },
          copy: function (f) {
            return this.set(f.x, f.y, f.z, f.order);
          },
          setFromQuaternion: function (f, g, m) {
            void 0 === g && (g = this._order);
            void 0 === m && (m = !1);
            b.fromQuat(f);
            return this.setFromRotationMatrix(b, g, m);
          },
          setFromRotationMatrix: function (f, g, m) {
            void 0 === g && (g = this._order);
            void 0 === m && (m = !1);
            var n = f.val;
            f = n[0];
            var q = n[4],
              r = n[8],
              u = n[1],
              v = n[5],
              x = n[9],
              y = n[2],
              z = n[6];
            n = n[10];
            var A = 0,
              B = 0,
              D = 0;
            switch (g) {
              case "XYZ":
                B = Math.asin(d(r, -1, 1));
                0.99999 > Math.abs(r)
                  ? ((A = Math.atan2(-x, n)), (D = Math.atan2(-q, f)))
                  : (A = Math.atan2(z, v));
                break;
              case "YXZ":
                A = Math.asin(-d(x, -1, 1));
                0.99999 > Math.abs(x)
                  ? ((B = Math.atan2(r, n)), (D = Math.atan2(u, v)))
                  : (B = Math.atan2(-y, f));
                break;
              case "ZXY":
                A = Math.asin(d(z, -1, 1));
                0.99999 > Math.abs(z)
                  ? ((B = Math.atan2(-y, n)), (D = Math.atan2(-q, v)))
                  : (D = Math.atan2(u, f));
                break;
              case "ZYX":
                B = Math.asin(-d(y, -1, 1));
                0.99999 > Math.abs(y)
                  ? ((A = Math.atan2(z, n)), (D = Math.atan2(u, f)))
                  : (D = Math.atan2(-q, v));
                break;
              case "YZX":
                D = Math.asin(d(u, -1, 1));
                0.99999 > Math.abs(u)
                  ? ((A = Math.atan2(-x, v)), (B = Math.atan2(-y, f)))
                  : (B = Math.atan2(r, n));
                break;
              case "XZY":
                (D = Math.asin(-d(q, -1, 1))),
                  0.99999 > Math.abs(q)
                    ? ((A = Math.atan2(z, v)), (B = Math.atan2(r, f)))
                    : (A = Math.atan2(-x, n));
            }
            this._x = A;
            this._y = B;
            this._z = D;
            this._order = g;
            if (m) this.onChangeCallback(this);
            return this;
          },
        });
        a.RotationOrders = "XYZ YXZ ZXY ZYX YZX XZY".split(" ");
        a.DefaultOrder = "XYZ";
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          void 0 === d && (d = 0);
          void 0 === k && (k = 10);
          d = Math.pow(k, -d);
          return Math.floor(a * d) / d;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return a / d / 1e3;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a == parseFloat(a) ? !(a % 2) : void 0;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a === parseFloat(a) ? !(a % 2) : void 0;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          return Math.min(a + d, k);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          var d = a.length;
          if (0 === d) return 0;
          a.sort(function (e, b) {
            return e - b;
          });
          var k = Math.floor(d / 2);
          return 0 === d % 2 ? (a[k] + a[k - 1]) / 2 : a[k];
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          return Math.max(a - d, k);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          void 0 === k && (k = d + 1);
          d = (a - d) / (k - d);
          1 < d
            ? void 0 !== e
              ? ((d = (e - a) / (e - k)), 0 > d && (d = 0))
              : (d = 1)
            : 0 > d && (d = 0);
          return d;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = 1);
          var k = 2 * Math.random() * Math.PI;
          a.x = Math.cos(k) * d;
          a.y = Math.sin(k) * d;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = 1);
          var k = 2 * Math.random() * Math.PI,
            e = 2 * Math.random() - 1,
            b = Math.sqrt(1 - e * e) * d;
          a.x = Math.cos(k) * b;
          a.y = Math.sin(k) * b;
          a.z = e * d;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = 1);
          a.x = (2 * Math.random() - 1) * d;
          a.y = (2 * Math.random() - 1) * d;
          a.z = (2 * Math.random() - 1) * d;
          a.w = (2 * Math.random() - 1) * d;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b) {
          a.x = d + b * Math.cos(e);
          a.y = k + b * Math.sin(e);
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          void 0 === d && (d = 0);
          void 0 === k && (k = 10);
          d = Math.pow(k, -d);
          return Math.round(a * d) / d;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          void 0 === d && (d = 1);
          void 0 === k && (k = 1);
          void 0 === e && (e = 1);
          e *= Math.PI / a;
          for (var b = [], c = [], f = 0; f < a; f++)
            (k -= d * e), (d += k * e), (b[f] = k), (c[f] = d);
          return {
            sin: c,
            cos: b,
            length: a,
          };
        };
      },
      function (h, t, a) {
        var d = a(3);
        h.exports = function (k, e, b, c) {
          void 0 === c && (c = new d());
          var f = 0,
            g = 0;
          0 < k &&
            k <= e * b &&
            (k > e - 1 ? ((g = Math.floor(k / e)), (f = k - g * e)) : (f = k));
          return c.set(f, g);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          return Math.abs(a - d) <= k;
        };
      },
      function (h, t, a) {
        t = a(39);
        var d = a(69);
        a = a(365);
        var k = new d(),
          e = new a(),
          b = new t();
        h.exports = function (c, f, g) {
          e.setAxisAngle(f, g);
          k.fromRotationTranslation(e, b.set(0, 0, 0));
          return c.transformMat4(k);
        };
      },
      function (h, t) {
        h.exports = "addtexture";
      },
      function (h, t) {
        h.exports = "onerror";
      },
      function (h, t) {
        h.exports = "onload";
      },
      function (h, t) {
        h.exports = "ready";
      },
      function (h, t) {
        h.exports = "removetexture";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_BITMAP_MASK_FS\n\nprecision mediump float;\n\nuniform vec2 uResolution;\nuniform sampler2D uMainSampler;\nuniform sampler2D uMaskSampler;\nuniform bool uInvertMaskAlpha;\n\nvoid main ()\n{\n    vec2 uv = gl_FragCoord.xy / uResolution;\n    vec4 mainColor = texture2D(uMainSampler, uv);\n    vec4 maskColor = texture2D(uMaskSampler, uv);\n    float alpha = mainColor.a;\n\n    if (!uInvertMaskAlpha)\n    {\n        alpha *= (maskColor.a);\n    }\n    else\n    {\n        alpha *= (1.0 - maskColor.a);\n    }\n\n    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);\n}\n";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_BITMAP_MASK_VS\n\nprecision mediump float;\n\nattribute vec2 inPosition;\n\nvoid main ()\n{\n    gl_Position = vec4(inPosition, 0.0, 1.0);\n}\n";
      },
      function (h, t) {
        h.exports = "pipelineafterflush";
      },
      function (h, t) {
        h.exports = "pipelinebeforeflush";
      },
      function (h, t) {
        h.exports = "pipelinebind";
      },
      function (h, t) {
        h.exports = "pipelineboot";
      },
      function (h, t) {
        h.exports = "pipelinedestroy";
      },
      function (h, t) {
        h.exports = "pipelinerebind";
      },
      function (h, t) {
        h.exports = "pipelineresize";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_GRAPHICS_FS\n\nprecision mediump float;\n\nvarying vec4 outColor;\n\nvoid main ()\n{\n    gl_FragColor = vec4(outColor.bgr * outColor.a, outColor.a);\n}\n";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_GRAPHICS_VS\n\nprecision mediump float;\n\nuniform mat4 uProjectionMatrix;\n\nattribute vec2 inPosition;\nattribute vec4 inColor;\n\nvarying vec4 outColor;\n\nvoid main ()\n{\n    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);\n\n    outColor = inColor;\n}\n";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_LIGHT_FS\n\nprecision mediump float;\n\nstruct Light\n{\n    vec2 position;\n    vec3 color;\n    float intensity;\n    float radius;\n};\n\nconst int kMaxLights = %LIGHT_COUNT%;\n\nuniform vec4 uCamera; /* x, y, rotation, zoom */\nuniform vec2 uResolution;\nuniform sampler2D uMainSampler;\nuniform sampler2D uNormSampler;\nuniform vec3 uAmbientLightColor;\nuniform Light uLights[kMaxLights];\nuniform mat3 uInverseRotationMatrix;\n\nvarying vec2 outTexCoord;\nvarying vec4 outTint;\n\nvoid main()\n{\n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.bgr * outTint.a, outTint.a);\n    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;\n    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));\n    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;\n\n    for (int index = 0; index < kMaxLights; ++index)\n    {\n        Light light = uLights[index];\n        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);\n        vec3 lightNormal = normalize(lightDir);\n        float distToSurf = length(lightDir) * uCamera.w;\n        float diffuseFactor = max(dot(normal, lightNormal), 0.0);\n        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;\n        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);\n        vec3 diffuse = light.color * diffuseFactor;\n        finalColor += (attenuation * diffuse) * light.intensity;\n    }\n\n    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);\n\n    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);\n}\n";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_MULTI_FS\n\nprecision mediump float;\n\nuniform sampler2D uMainSampler[%count%];\n\nvarying vec2 outTexCoord;\nvarying float outTexId;\nvarying float outTintEffect;\nvarying vec4 outTint;\n\nvoid main ()\n{\n    vec4 texture;\n\n    %forloop%\n\n    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);\n\n    //  Multiply texture tint\n    vec4 color = texture * texel;\n\n    if (outTintEffect == 1.0)\n    {\n        //  Solid color + texture alpha\n        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);\n    }\n    else if (outTintEffect == 2.0)\n    {\n        //  Solid color, no texture\n        color = texel;\n    }\n\n    gl_FragColor = color;\n}\n";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_MULTI_VS\n\nprecision mediump float;\n\nuniform mat4 uProjectionMatrix;\n\nattribute vec2 inPosition;\nattribute vec2 inTexCoord;\nattribute float inTexId;\nattribute float inTintEffect;\nattribute vec4 inTint;\n\nvarying vec2 outTexCoord;\nvarying float outTexId;\nvarying float outTintEffect;\nvarying vec4 outTint;\n\nvoid main ()\n{\n    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);\n\n    outTexCoord = inTexCoord;\n    outTexId = inTexId;\n    outTint = inTint;\n    outTintEffect = inTintEffect;\n}\n";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_POINTLIGHT_FS\n\nprecision mediump float;\n\nuniform vec2 uResolution;\nuniform float uCameraZoom;\n\nvarying vec4 lightPosition;\nvarying vec4 lightColor;\nvarying float lightRadius;\nvarying float lightAttenuation;\n\nvoid main ()\n{\n    vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);\n\n    float distToSurf = length(center - gl_FragCoord.xy);\n\n    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);\n\n    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);\n\n    vec4 color = vec4(intensity, intensity, intensity, 0.0) * lightColor;\n\n    gl_FragColor = vec4(color.rgb * lightColor.a, color.a);\n}\n";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_POINTLIGHT_VS\n\nprecision mediump float;\n\nuniform mat4 uProjectionMatrix;\n\nattribute vec2 inPosition;\nattribute vec2 inLightPosition;\nattribute vec4 inLightColor;\nattribute float inLightRadius;\nattribute float inLightAttenuation;\n\nvarying vec4 lightPosition;\nvarying vec4 lightColor;\nvarying float lightRadius;\nvarying float lightAttenuation;\n\nvoid main ()\n{\n    lightColor = inLightColor;\n    lightRadius = inLightRadius;\n    lightAttenuation = inLightAttenuation;\n    lightPosition = uProjectionMatrix * vec4(inLightPosition, 1.0, 1.0);\n\n    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);\n}\n";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_SINGLE_FS\n\nprecision mediump float;\n\nuniform sampler2D uMainSampler;\n\nvarying vec2 outTexCoord;\nvarying float outTintEffect;\nvarying vec4 outTint;\n\nvoid main ()\n{\n    vec4 texture = texture2D(uMainSampler, outTexCoord);\n    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);\n\n    //  Multiply texture tint\n    vec4 color = texture * texel;\n\n    if (outTintEffect == 1.0)\n    {\n        //  Solid color + texture alpha\n        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);\n    }\n    else if (outTintEffect == 2.0)\n    {\n        //  Solid color, no texture\n        color = texel;\n    }\n\n    gl_FragColor = color;\n}\n";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_SINGLE_VS\n\nprecision mediump float;\n\nuniform mat4 uProjectionMatrix;\n\nattribute vec2 inPosition;\nattribute vec2 inTexCoord;\nattribute float inTexId;\nattribute float inTintEffect;\nattribute vec4 inTint;\n\nvarying vec2 outTexCoord;\nvarying float outTintEffect;\nvarying vec4 outTint;\n\nvoid main ()\n{\n    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);\n\n    outTexCoord = inTexCoord;\n    outTint = inTint;\n    outTintEffect = inTintEffect;\n}\n";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_ADD_BLEND_FS\n\nprecision mediump float;\n\nuniform sampler2D uMainSampler1;\nuniform sampler2D uMainSampler2;\nuniform float uStrength;\n\nvarying vec2 outTexCoord;\n\nvoid main ()\n{\n    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);\n    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);\n\n    gl_FragColor = frame1 + frame2 * uStrength;\n}\n";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_COLORMATRIX_FS\n\nprecision mediump float;\n\nuniform sampler2D uMainSampler;\nuniform float uColorMatrix[20];\nuniform float uAlpha;\n\nvarying vec2 outTexCoord;\n\nvoid main ()\n{\n    vec4 c = texture2D(uMainSampler, outTexCoord);\n\n    if (uAlpha == 0.0)\n    {\n        gl_FragColor = c;\n\n        return;\n    }\n\n    if (c.a > 0.0)\n    {\n        c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (uColorMatrix[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMatrix[4];\n    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b) + (uColorMatrix[8] * c.a) + uColorMatrix[9];\n    result.b = (uColorMatrix[10] * c.r) + (uColorMatrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];\n    result.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMatrix[18] * c.a) + uColorMatrix[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_COPY_FS\n\nprecision mediump float;\n\nuniform sampler2D uMainSampler;\nuniform float uBrightness;\n\nvarying vec2 outTexCoord;\n\nvoid main ()\n{\n    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;\n}\n";
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_LINEAR_BLEND_FS\n\nprecision mediump float;\n\nuniform sampler2D uMainSampler1;\nuniform sampler2D uMainSampler2;\nuniform float uStrength;\n\nvarying vec2 outTexCoord;\n\nvoid main ()\n{\n    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);\n    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);\n\n    gl_FragColor = mix(frame1, frame2 * uStrength, 0.5);\n}\n";
      },
      function (h, t, a) {
        h.exports = {
          GenerateTexture: a(388),
          Palettes: a(889),
        };
      },
      function (h, t, a) {
        h.exports = {
          ARNE16: a(389),
          C64: a(890),
          CGA: a(891),
          JMP: a(892),
          MSX: a(893),
        };
      },
      function (h, t) {
        h.exports = {
          0: "#000",
          1: "#fff",
          2: "#8b4131",
          3: "#7bbdc5",
          4: "#8b41ac",
          5: "#6aac41",
          6: "#3931a4",
          7: "#d5de73",
          8: "#945a20",
          9: "#5a4100",
          A: "#bd736a",
          B: "#525252",
          C: "#838383",
          D: "#acee8b",
          E: "#7b73de",
          F: "#acacac",
        };
      },
      function (h, t) {
        h.exports = {
          0: "#000",
          1: "#2234d1",
          2: "#0c7e45",
          3: "#44aacc",
          4: "#8a3622",
          5: "#5c2e78",
          6: "#aa5c3d",
          7: "#b5b5b5",
          8: "#5e606e",
          9: "#4c81fb",
          A: "#6cd947",
          B: "#7be2f9",
          C: "#eb8a60",
          D: "#e23d69",
          E: "#ffd93f",
          F: "#fff",
        };
      },
      function (h, t) {
        h.exports = {
          0: "#000",
          1: "#191028",
          2: "#46af45",
          3: "#a1d685",
          4: "#453e78",
          5: "#7664fe",
          6: "#833129",
          7: "#9ec2e8",
          8: "#dc534b",
          9: "#e18d79",
          A: "#d6b97b",
          B: "#e9d8a1",
          C: "#216c4b",
          D: "#d365c8",
          E: "#afaab9",
          F: "#f5f4eb",
        };
      },
      function (h, t) {
        h.exports = {
          0: "#000",
          1: "#191028",
          2: "#46af45",
          3: "#a1d685",
          4: "#453e78",
          5: "#7664fe",
          6: "#833129",
          7: "#9ec2e8",
          8: "#dc534b",
          9: "#e18d79",
          A: "#d6b97b",
          B: "#e9d8a1",
          C: "#216c4b",
          D: "#d365c8",
          E: "#afaab9",
          F: "#fff",
        };
      },
      function (h, t, a) {
        h.exports = {
          Path: a(895),
          MoveTo: a(393),
          CubicBezier: a(390),
          Curve: a(94),
          Ellipse: a(391),
          Line: a(392),
          QuadraticBezier: a(394),
          Spline: a(395),
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(390),
          k = a(391),
          e = a(5),
          b = a(392),
          c = a(393),
          f = a(394),
          g = a(10),
          m = a(395),
          n = a(3),
          q = a(14),
          r = new t({
            initialize: function (u, v) {
              void 0 === u && (u = 0);
              void 0 === v && (v = 0);
              this.name = "";
              this.curves = [];
              this.cacheLengths = [];
              this.autoClose = !1;
              this.startPoint = new n();
              this._tmpVec2A = new n();
              this._tmpVec2B = new n();
              "object" === typeof u
                ? this.fromJSON(u)
                : this.startPoint.set(u, v);
            },
            add: function (u) {
              this.curves.push(u);
              return this;
            },
            circleTo: function (u, v, x) {
              void 0 === v && (v = !1);
              return this.ellipseTo(u, u, 0, 360, v, x);
            },
            closePath: function () {
              var u = this.curves[0].getPoint(0),
                v = this.curves[this.curves.length - 1].getPoint(1);
              u.equals(v) || this.curves.push(new b(v, u));
              return this;
            },
            cubicBezierTo: function (u, v, x, y, z, A) {
              var B = this.getEndPoint();
              u instanceof n
                ? ((y = u), (z = v), (u = x))
                : ((y = new n(x, y)), (z = new n(z, A)), (u = new n(u, v)));
              return this.add(new d(B, y, z, u));
            },
            quadraticBezierTo: function (u, v, x, y) {
              var z = this.getEndPoint();
              u instanceof n
                ? ((x = u), (u = v))
                : ((x = new n(x, y)), (u = new n(u, v)));
              return this.add(new f(z, x, u));
            },
            draw: function (u, v) {
              for (var x = 0; x < this.curves.length; x++) {
                var y = this.curves[x];
                y.active && y.draw(u, v);
              }
              return u;
            },
            ellipseTo: function (u, v, x, y, z, A) {
              u = new k(0, 0, u, v, x, y, z, A);
              v = this.getEndPoint(this._tmpVec2A);
              x = u.getStartPoint(this._tmpVec2B);
              v.subtract(x);
              u.x = v.x;
              u.y = v.y;
              return this.add(u);
            },
            fromJSON: function (u) {
              this.curves = [];
              this.cacheLengths = [];
              this.startPoint.set(u.x, u.y);
              this.autoClose = u.autoClose;
              for (var v = 0; v < u.curves.length; v++) {
                var x = u.curves[v];
                switch (x.type) {
                  case "LineCurve":
                    this.add(b.fromJSON(x));
                    break;
                  case "EllipseCurve":
                    this.add(k.fromJSON(x));
                    break;
                  case "SplineCurve":
                    this.add(m.fromJSON(x));
                    break;
                  case "CubicBezierCurve":
                    this.add(d.fromJSON(x));
                    break;
                  case "QuadraticBezierCurve":
                    this.add(f.fromJSON(x));
                }
              }
              return this;
            },
            getBounds: function (u, v) {
              void 0 === u && (u = new g());
              void 0 === v && (v = 16);
              u.x = Number.MAX_VALUE;
              u.y = Number.MAX_VALUE;
              for (
                var x = new g(),
                  y = q.MIN_SAFE_INTEGER,
                  z = q.MIN_SAFE_INTEGER,
                  A = 0;
                A < this.curves.length;
                A++
              ) {
                var B = this.curves[A];
                B.active &&
                  (B.getBounds(x, v),
                  (u.x = Math.min(u.x, x.x)),
                  (u.y = Math.min(u.y, x.y)),
                  (y = Math.max(y, x.right)),
                  (z = Math.max(z, x.bottom)));
              }
              u.right = y;
              u.bottom = z;
              return u;
            },
            getCurveLengths: function () {
              if (this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
              for (var u = [], v = 0, x = 0; x < this.curves.length; x++)
                (v += this.curves[x].getLength()), u.push(v);
              return (this.cacheLengths = u);
            },
            getEndPoint: function (u) {
              void 0 === u && (u = new n());
              0 < this.curves.length
                ? this.curves[this.curves.length - 1].getPoint(1, u)
                : u.copy(this.startPoint);
              return u;
            },
            getLength: function () {
              var u = this.getCurveLengths();
              return u[u.length - 1];
            },
            getPoint: function (u, v) {
              void 0 === v && (v = new n());
              var x = u * this.getLength(),
                y = this.getCurveLengths();
              for (u = 0; u < y.length; ) {
                if (y[u] >= x)
                  return (
                    (x = y[u] - x),
                    (u = this.curves[u]),
                    (y = u.getLength()),
                    u.getPointAt(0 === y ? 0 : 1 - x / y, v)
                  );
                u++;
              }
              return null;
            },
            getPoints: function (u) {
              void 0 === u && (u = 12);
              for (var v = [], x, y = 0; y < this.curves.length; y++) {
                var z = this.curves[y];
                if (z.active) {
                  var A = z.getResolution(u);
                  z = z.getPoints(A);
                  for (A = 0; A < z.length; A++) {
                    var B = z[A];
                    (x && x.equals(B)) || (v.push(B), (x = B));
                  }
                }
              }
              this.autoClose &&
                1 < v.length &&
                !v[v.length - 1].equals(v[0]) &&
                v.push(v[0]);
              return v;
            },
            getRandomPoint: function (u) {
              void 0 === u && (u = new n());
              return this.getPoint(Math.random(), u);
            },
            getSpacedPoints: function (u) {
              void 0 === u && (u = 40);
              for (var v = [], x = 0; x <= u; x++) v.push(this.getPoint(x / u));
              this.autoClose && v.push(v[0]);
              return v;
            },
            getStartPoint: function (u) {
              void 0 === u && (u = new n());
              return u.copy(this.startPoint);
            },
            getTangent: function (u, v) {
              void 0 === v && (v = new n());
              var x = u * this.getLength(),
                y = this.getCurveLengths();
              for (u = 0; u < y.length; ) {
                if (y[u] >= x)
                  return (
                    (x = y[u] - x),
                    (u = this.curves[u]),
                    (y = u.getLength()),
                    u.getTangentAt(0 === y ? 0 : 1 - x / y, v)
                  );
                u++;
              }
              return null;
            },
            lineTo: function (u, v) {
              u instanceof n
                ? this._tmpVec2B.copy(u)
                : this._tmpVec2B.set(u, v);
              u = this.getEndPoint(this._tmpVec2A);
              return this.add(
                new b([u.x, u.y, this._tmpVec2B.x, this._tmpVec2B.y])
              );
            },
            splineTo: function (u) {
              u.unshift(this.getEndPoint());
              return this.add(new m(u));
            },
            moveTo: function (u, v) {
              return u instanceof n
                ? this.add(new c(u.x, u.y))
                : this.add(new c(u, v));
            },
            toJSON: function () {
              for (var u = [], v = 0; v < this.curves.length; v++)
                u.push(this.curves[v].toJSON());
              return {
                type: "Path",
                x: this.startPoint.x,
                y: this.startPoint.y,
                autoClose: this.autoClose,
                curves: u,
              };
            },
            updateArcLengths: function () {
              this.cacheLengths = [];
              this.getCurveLengths();
            },
            destroy: function () {
              this.curves.length = 0;
              this.cacheLengths.length = 0;
              this.startPoint = void 0;
            },
          });
        e.register("path", function (u, v) {
          return new r(u, v);
        });
        h.exports = r;
      },
      function (h, t, a) {
        h.exports = {
          DataManager: a(101),
          DataManagerPlugin: a(897),
          Events: a(315),
        };
      },
      function (h, t, a) {
        var d = a(0),
          k = a(101);
        t = a(24);
        var e = a(20);
        a = new d({
          Extends: k,
          initialize: function (b) {
            k.call(this, b, b.sys.events);
            this.scene = b;
            this.systems = b.sys;
            b.sys.events.once(e.BOOT, this.boot, this);
            b.sys.events.on(e.START, this.start, this);
          },
          boot: function () {
            this.events = this.systems.events;
            this.events.once(e.DESTROY, this.destroy, this);
          },
          start: function () {
            this.events.once(e.SHUTDOWN, this.shutdown, this);
          },
          shutdown: function () {
            this.systems.events.off(e.SHUTDOWN, this.shutdown, this);
          },
          destroy: function () {
            k.prototype.destroy.call(this);
            this.events.off(e.START, this.start, this);
            this.systems = this.scene = null;
          },
        });
        t.register("DataManagerPlugin", a, "data");
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          Align: a(899),
          BaseShader: a(396),
          Bounds: a(902),
          Canvas: a(906),
          Color: a(397),
          ColorMatrix: a(198),
          Masks: a(916),
          RGB: a(200),
        };
      },
      function (h, t, a) {
        t = a(123);
        var d = a(17);
        a = {
          In: a(900),
          To: a(901),
        };
        a = d(!1, a, t);
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          BottomCenter: a(290),
          BottomLeft: a(291),
          BottomRight: a(292),
          Center: a(293),
          LeftCenter: a(295),
          QuickSet: a(289),
          RightCenter: a(296),
          TopCenter: a(297),
          TopLeft: a(298),
          TopRight: a(299),
        };
      },
      function (h, t, a) {
        h.exports = {
          BottomCenter: a(277),
          BottomLeft: a(278),
          BottomRight: a(279),
          LeftBottom: a(280),
          LeftCenter: a(281),
          LeftTop: a(282),
          QuickSet: a(276),
          RightBottom: a(283),
          RightCenter: a(284),
          RightTop: a(285),
          TopCenter: a(286),
          TopLeft: a(287),
          TopRight: a(288),
        };
      },
      function (h, t, a) {
        h.exports = {
          CenterOn: a(294),
          GetBottom: a(42),
          GetBounds: a(903),
          GetCenterX: a(87),
          GetCenterY: a(89),
          GetLeft: a(43),
          GetOffsetX: a(904),
          GetOffsetY: a(905),
          GetRight: a(44),
          GetTop: a(45),
          SetBottom: a(55),
          SetCenterX: a(88),
          SetCenterY: a(90),
          SetLeft: a(53),
          SetRight: a(54),
          SetTop: a(52),
        };
      },
      function (h, t, a) {
        var d = a(42),
          k = a(43),
          e = a(44),
          b = a(45);
        h.exports = function (c, f) {
          void 0 === f && (f = {});
          var g = k(c),
            m = b(c);
          f.x = g;
          f.y = m;
          f.width = e(c) - g;
          f.height = d(c) - m;
          return f;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a.width * a.originX;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a.height * a.originY;
        };
      },
      function (h, t, a) {
        h.exports = {
          CanvasInterpolation: a(367),
          CanvasPool: a(31),
          Smoothing: a(192),
          TouchAction: a(907),
          UserSelect: a(908),
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = "none");
          a.style.msTouchAction = d;
          a.style["ms-touch-action"] = d;
          a.style["touch-action"] = d;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = "none");
          ["-webkit-", "-khtml-", "-moz-", "-ms-", ""].forEach(function (k) {
            a.style[k + "user-select"] = d;
          });
          a.style["-webkit-touch-callout"] = d;
          a.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
          return a;
        };
      },
      function (h, t, a) {
        var d = a(103);
        h.exports = function (k) {
          void 0 === k && (k = 1024);
          var e = [],
            b,
            c = 255,
            f,
            g = 0;
          for (b = 0; 255 >= b; b++)
            e.push({
              r: c,
              g: b,
              b: g,
              color: d(c, b, g),
            });
          for (b = f = 255; 0 <= b; b--)
            e.push({
              r: b,
              g: f,
              b: g,
              color: d(b, f, g),
            });
          for (b = c = 0; 255 >= b; b++, f--)
            e.push({
              r: c,
              g: f,
              b,
              color: d(c, f, b),
            });
          f = 0;
          g = 255;
          for (b = 0; 255 >= b; b++, g--, c++)
            e.push({
              r: c,
              g: f,
              b: g,
              color: d(c, f, g),
            });
          if (1024 === k) return e;
          c = [];
          f = 0;
          g = 1024 / k;
          for (b = 0; b < k; b++) c.push(e[Math.floor(f)]), (f += g);
          return c;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          var d = {
            r: (a >> 16) & 255,
            g: (a >> 8) & 255,
            b: a & 255,
            a: 255,
          };
          16777215 < a && (d.a = a >>> 24);
          return d;
        };
      },
      function (h, t, a) {
        var d = a(38),
          k = a(399);
        h.exports = function (e, b, c) {
          var f = c,
            g = c,
            m = c;
          0 !== b &&
            ((b = 0.5 > c ? c * (1 + b) : c + b - c * b),
            (c = 2 * c - b),
            (f = k(c, b, e + 1 / 3)),
            (g = k(c, b, e)),
            (m = k(c, b, e - 1 / 3)));
          return new d().setGLTo(f, g, m, 1);
        };
      },
      function (h, t, a) {
        var d = a(188);
        h.exports = function (k, e) {
          void 0 === k && (k = 1);
          void 0 === e && (e = 1);
          for (var b = [], c = 0; 359 >= c; c++) b.push(d(c / 359, k, e));
          return b;
        };
      },
      function (h, t, a) {
        var d = a(135),
          k = function (e, b, c, f, g, m, n, q) {
            void 0 === n && (n = 100);
            void 0 === q && (q = 0);
            n = q / n;
            return {
              r: d(e, f, n),
              g: d(b, g, n),
              b: d(c, m, n),
            };
          };
        h.exports = {
          RGBWithRGB: k,
          ColorWithRGB: function (e, b, c, f, g, m) {
            void 0 === g && (g = 100);
            void 0 === m && (m = 0);
            return k(e.r, e.g, e.b, b, c, f, g, m);
          },
          ColorWithColor: function (e, b, c, f) {
            void 0 === c && (c = 100);
            void 0 === f && (f = 0);
            return k(e.r, e.g, e.b, b.r, b.g, b.b, c, f);
          },
        };
      },
      function (h, t, a) {
        var d = a(195),
          k = a(38);
        h.exports = function (e, b) {
          void 0 === e && (e = 0);
          void 0 === b && (b = 255);
          return new k(d(e, b), d(e, b), d(e, b));
        };
      },
      function (h, t, a) {
        var d = a(398);
        h.exports = function (k, e, b, c, f) {
          void 0 === c && (c = 255);
          void 0 === f && (f = "#");
          return "#" === f
            ? "#" +
                (16777216 + (k << 16) + (e << 8) + b).toString(16).slice(1, 7)
            : "0x" + d(c) + d(k) + d(e) + d(b);
        };
      },
      function (h, t, a) {
        h.exports = {
          BitmapMask: a(310),
          GeometryMask: a(311),
        };
      },
      function (h, t, a) {
        t = {
          AddToDOM: a(142),
          DOMContentLoaded: a(400),
          GetInnerHeight: a(401),
          GetScreenOrientation: a(402),
          GetTarget: a(407),
          ParseXML: a(408),
          RemoveFromDOM: a(202),
          RequestAnimationFrame: a(386),
        };
        h.exports = t;
      },
      function (h, t, a) {
        h.exports = {
          EventEmitter: a(919),
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(9);
        a = a(24);
        t = new t({
          Extends: d,
          initialize: function () {
            d.call(this);
          },
          shutdown: function () {
            this.removeAllListeners();
          },
          destroy: function () {
            this.removeAllListeners();
          },
        });
        a.register("EventEmitter", t, "events");
        h.exports = t;
      },
      function (h, t, a) {
        var d = a(142),
          k = a(321),
          e = a(325),
          b = a(31);
        t = a(0);
        var c = a(346),
          f = a(921),
          g = a(366),
          m = a(101),
          n = a(384),
          q = a(347),
          r = a(400),
          u = a(9),
          v = a(22),
          x = a(409),
          y = a(24),
          z = a(414),
          A = a(415),
          B = a(417),
          D = a(106),
          E = a(422),
          C = a(385),
          F = a(387),
          G = a(426);
        a = new t({
          initialize: function (H) {
            this.config = new c(H);
            this.context =
              this.canvas =
              this.domContainer =
              this.renderer =
                null;
            this.isRunning = this.isBooted = !1;
            this.events = new u();
            this.anims = new k(this);
            this.textures = new E(this);
            this.cache = new e(this);
            this.registry = new m(this);
            this.input = new x(this, this.config);
            this.scene = new B(this, this.config.sceneConfig);
            this.device = q;
            this.scale = new A(this, this.config);
            this.sound = null;
            this.sound = G.create(this);
            this.loop = new C(this, this.config.fps);
            this.plugins = new z(this, this.config);
            this.hasFocus =
              this.noReturn =
              this.removeCanvas =
              this.pendingDestroy =
                !1;
            r(this.boot.bind(this));
          },
          boot: function () {
            y.hasCore("EventEmitter")
              ? ((this.isBooted = !0),
                this.config.preBoot(this),
                this.scale.preBoot(),
                g(this),
                f(this),
                n(this),
                d(this.canvas, this.config.parent),
                this.textures.once(D.READY, this.texturesReady, this),
                this.events.emit(v.BOOT))
              : console.warn("Aborting. Core Plugins missing.");
          },
          texturesReady: function () {
            this.events.emit(v.READY);
            this.start();
          },
          start: function () {
            this.isRunning = !0;
            this.config.postBoot(this);
            this.renderer
              ? this.loop.start(this.step.bind(this))
              : this.loop.start(this.headlessStep.bind(this));
            F(this);
            var H = this.events;
            H.on(v.HIDDEN, this.onHidden, this);
            H.on(v.VISIBLE, this.onVisible, this);
            H.on(v.BLUR, this.onBlur, this);
            H.on(v.FOCUS, this.onFocus, this);
          },
          step: function (H, K) {
            if (this.pendingDestroy) return this.runDestroy();
            var I = this.events;
            I.emit(v.PRE_STEP, H, K);
            I.emit(v.STEP, H, K);
            this.scene.update(H, K);
            I.emit(v.POST_STEP, H, K);
            var M = this.renderer;
            M.preRender();
            I.emit(v.PRE_RENDER, M, H, K);
            this.scene.render(M);
            M.postRender();
            I.emit(v.POST_RENDER, M, H, K);
          },
          headlessStep: function (H, K) {
            if (this.pendingDestroy) return this.runDestroy();
            var I = this.events;
            I.emit(v.PRE_STEP, H, K);
            I.emit(v.STEP, H, K);
            this.scene.update(H, K);
            I.emit(v.POST_STEP, H, K);
            I.emit(v.PRE_RENDER);
            I.emit(v.POST_RENDER);
          },
          onHidden: function () {
            this.loop.pause();
            this.events.emit(v.PAUSE);
          },
          onVisible: function () {
            this.loop.resume();
            this.events.emit(v.RESUME);
          },
          onBlur: function () {
            this.hasFocus = !1;
            this.loop.blur();
          },
          onFocus: function () {
            this.hasFocus = !0;
            this.loop.focus();
          },
          getFrame: function () {
            return this.loop.frame;
          },
          getTime: function () {
            return this.loop.now;
          },
          destroy: function (H, K) {
            void 0 === K && (K = !1);
            this.pendingDestroy = !0;
            this.removeCanvas = H;
            this.noReturn = K;
          },
          runDestroy: function () {
            this.scene.destroy();
            this.events.emit(v.DESTROY);
            this.events.removeAllListeners();
            this.renderer && this.renderer.destroy();
            this.removeCanvas &&
              this.canvas &&
              (b.remove(this.canvas),
              this.canvas.parentNode &&
                this.canvas.parentNode.removeChild(this.canvas));
            this.domContainer &&
              this.domContainer.parentNode.removeChild(this.domContainer);
            this.loop.destroy();
            this.pendingDestroy = !1;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(142);
        h.exports = function (k) {
          var e = k.config;
          if (e.parent && e.domCreateContainer) {
            var b = document.createElement("div");
            b.style.cssText = [
              "display: block;",
              "width: " + k.scale.width + "px;",
              "height: " + k.scale.height + "px;",
              "padding: 0; margin: 0; position: absolute; overflow: hidden;",
              "pointer-events: " + e.domPointerEvents + ";",
              "transform: scale(1); transform-origin: left top;",
            ].join(" ");
            k.domContainer = b;
            d(b, e.parent);
          }
        };
      },
      function (h, t) {
        h.exports = "boot";
      },
      function (h, t) {
        h.exports = "destroy";
      },
      function (h, t) {
        h.exports = "dragend";
      },
      function (h, t) {
        h.exports = "dragenter";
      },
      function (h, t) {
        h.exports = "drag";
      },
      function (h, t) {
        h.exports = "dragleave";
      },
      function (h, t) {
        h.exports = "dragover";
      },
      function (h, t) {
        h.exports = "dragstart";
      },
      function (h, t) {
        h.exports = "drop";
      },
      function (h, t) {
        h.exports = "gameout";
      },
      function (h, t) {
        h.exports = "gameover";
      },
      function (h, t) {
        h.exports = "gameobjectdown";
      },
      function (h, t) {
        h.exports = "dragend";
      },
      function (h, t) {
        h.exports = "dragenter";
      },
      function (h, t) {
        h.exports = "drag";
      },
      function (h, t) {
        h.exports = "dragleave";
      },
      function (h, t) {
        h.exports = "dragover";
      },
      function (h, t) {
        h.exports = "dragstart";
      },
      function (h, t) {
        h.exports = "drop";
      },
      function (h, t) {
        h.exports = "gameobjectmove";
      },
      function (h, t) {
        h.exports = "gameobjectout";
      },
      function (h, t) {
        h.exports = "gameobjectover";
      },
      function (h, t) {
        h.exports = "pointerdown";
      },
      function (h, t) {
        h.exports = "pointermove";
      },
      function (h, t) {
        h.exports = "pointerout";
      },
      function (h, t) {
        h.exports = "pointerover";
      },
      function (h, t) {
        h.exports = "pointerup";
      },
      function (h, t) {
        h.exports = "wheel";
      },
      function (h, t) {
        h.exports = "gameobjectup";
      },
      function (h, t) {
        h.exports = "gameobjectwheel";
      },
      function (h, t) {
        h.exports = "boot";
      },
      function (h, t) {
        h.exports = "process";
      },
      function (h, t) {
        h.exports = "update";
      },
      function (h, t) {
        h.exports = "pointerdown";
      },
      function (h, t) {
        h.exports = "pointerdownoutside";
      },
      function (h, t) {
        h.exports = "pointermove";
      },
      function (h, t) {
        h.exports = "pointerout";
      },
      function (h, t) {
        h.exports = "pointerover";
      },
      function (h, t) {
        h.exports = "pointerup";
      },
      function (h, t) {
        h.exports = "pointerupoutside";
      },
      function (h, t) {
        h.exports = "wheel";
      },
      function (h, t) {
        h.exports = "pointerlockchange";
      },
      function (h, t) {
        h.exports = "preupdate";
      },
      function (h, t) {
        h.exports = "shutdown";
      },
      function (h, t) {
        h.exports = "start";
      },
      function (h, t) {
        h.exports = "update";
      },
      function (h, t) {
        h.exports = "addfile";
      },
      function (h, t) {
        h.exports = "complete";
      },
      function (h, t) {
        h.exports = "filecomplete";
      },
      function (h, t) {
        h.exports = "filecomplete-";
      },
      function (h, t) {
        h.exports = "loaderror";
      },
      function (h, t) {
        h.exports = "load";
      },
      function (h, t) {
        h.exports = "fileprogress";
      },
      function (h, t) {
        h.exports = "postprocess";
      },
      function (h, t) {
        h.exports = "progress";
      },
      function (h, t) {
        h.exports = "start";
      },
      function (h, t, a) {
        h.exports = {
          game: "game",
          renderer: "renderer",
          anims: "anims",
          cache: "cache",
          plugins: "plugins",
          registry: "registry",
          scale: "scale",
          sound: "sound",
          textures: "textures",
          events: "events",
          cameras: "cameras",
          add: "add",
          make: "make",
          scenePlugin: "scene",
          displayList: "children",
          lights: "lights",
          data: "data",
          input: "input",
          load: "load",
          time: "time",
          tweens: "tweens",
          arcadePhysics: "physics",
          impactPhysics: "impact",
          matterPhysics: "matter",
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          if (k.getElementsByTagName("TextureAtlas")) {
            var e = a.source[d];
            a.add("__BASE", d, 0, 0, e.width, e.height);
            k = k.getElementsByTagName("SubTexture");
            for (e = 0; e < k.length; e++) {
              var b = k[e].attributes;
              var c = b.name.value;
              var f = parseInt(b.x.value, 10),
                g = parseInt(b.y.value, 10),
                m = parseInt(b.width.value, 10),
                n = parseInt(b.height.value, 10);
              c = a.add(c, d, f, g, m, n);
              if (b.frameX) {
                f = Math.abs(parseInt(b.frameX.value, 10));
                g = Math.abs(parseInt(b.frameY.value, 10));
                var q = parseInt(b.frameWidth.value, 10);
                b = parseInt(b.frameHeight.value, 10);
                c.setTrim(m, n, f, g, q, b);
              }
            }
            return a;
          }
          console.warn("Invalid Texture Atlas XML given");
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          var k = a.source[d];
          a.add("__BASE", d, 0, 0, k.width, k.height);
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          var k = a.source[d];
          a.add("__BASE", d, 0, 0, k.width, k.height);
          return a;
        };
      },
      function (h, t, a) {
        var d = a(77);
        h.exports = function (k, e, b) {
          if (b.frames || b.textures) {
            var c = k.source[e];
            k.add("__BASE", e, 0, 0, c.width, c.height);
            c = Array.isArray(b.textures) ? b.textures[e].frames : b.frames;
            for (var f, g = 0; g < c.length; g++) {
              var m = c[g];
              f = k.add(
                m.filename,
                e,
                m.frame.x,
                m.frame.y,
                m.frame.w,
                m.frame.h
              );
              m.trimmed &&
                f.setTrim(
                  m.sourceSize.w,
                  m.sourceSize.h,
                  m.spriteSourceSize.x,
                  m.spriteSourceSize.y,
                  m.spriteSourceSize.w,
                  m.spriteSourceSize.h
                );
              m.rotated && ((f.rotated = !0), f.updateUVsInverted());
              var n = m.anchor || m.pivot;
              n && ((f.customPivot = !0), (f.pivotX = n.x), (f.pivotY = n.y));
              f.customData = d(m);
            }
            for (var q in b)
              "frames" !== q &&
                (Array.isArray(b[q])
                  ? (k.customData[q] = b[q].slice(0))
                  : (k.customData[q] = b[q]));
            return k;
          }
          console.warn("Invalid Texture Atlas JSON Array");
        };
      },
      function (h, t, a) {
        var d = a(77);
        h.exports = function (k, e, b) {
          if (b.frames) {
            var c = k.source[e];
            k.add("__BASE", e, 0, 0, c.width, c.height);
            c = b.frames;
            var f;
            for (f in c)
              if (c.hasOwnProperty(f)) {
                var g = c[f];
                var m = k.add(f, e, g.frame.x, g.frame.y, g.frame.w, g.frame.h);
                g.trimmed &&
                  m.setTrim(
                    g.sourceSize.w,
                    g.sourceSize.h,
                    g.spriteSourceSize.x,
                    g.spriteSourceSize.y,
                    g.spriteSourceSize.w,
                    g.spriteSourceSize.h
                  );
                g.rotated && ((m.rotated = !0), m.updateUVsInverted());
                var n = g.anchor || g.pivot;
                n && ((m.customPivot = !0), (m.pivotX = n.x), (m.pivotY = n.y));
                m.customData = d(g);
              }
            for (var q in b)
              "frames" !== q &&
                (Array.isArray(b[q])
                  ? (k.customData[q] = b[q].slice(0))
                  : (k.customData[q] = b[q]));
            return k;
          }
          console.warn(
            "Invalid Texture Atlas JSON Hash given, missing 'frames' Object"
          );
        };
      },
      function (h, t, a) {
        var d = a(2);
        h.exports = function (k, e, b, c, f, g, m) {
          var n = d(m, "frameWidth", null),
            q = d(m, "frameHeight", n);
          if (null === n)
            throw Error(
              "TextureManager.SpriteSheet: Invalid frameWidth given."
            );
          var r = k.source[e];
          k.add("__BASE", e, 0, 0, r.width, r.height);
          var u = d(m, "startFrame", 0),
            v = d(m, "endFrame", -1);
          r = d(m, "margin", 0);
          m = d(m, "spacing", 0);
          var x =
            Math.floor((f - r + m) / (n + m)) *
            Math.floor((g - r + m) / (q + m));
          0 === x &&
            console.warn(
              "SpriteSheet frame dimensions will result in zero frames for texture:",
              k.key
            );
          if (u > x || u < -x) u = 0;
          0 > u && (u = x + u);
          -1 !== v && (x = u + (v + 1));
          v = u = r;
          for (var y, z, A = 0; A < x; A++) {
            z = y = 0;
            var B = u + n,
              D = v + q;
            B > f && (y = B - f);
            D > g && (z = D - g);
            k.add(A, e, b + u, c + v, n - y, q - z);
            u += n + m;
            u + n > f && ((u = r), (v += q + m));
          }
          return k;
        };
      },
      function (h, t, a) {
        var d = a(2);
        h.exports = function (k, e, b) {
          var c = d(b, "frameWidth", null),
            f = d(b, "frameHeight", c);
          if (!c)
            throw Error(
              "TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given."
            );
          var g = k.source[0];
          k.add("__BASE", 0, 0, 0, g.width, g.height);
          d(b, "startFrame", 0);
          d(b, "endFrame", -1);
          g = d(b, "margin", 0);
          b = d(b, "spacing", 0);
          var m = e.cutX,
            n = e.cutY,
            q = e.realWidth,
            r = e.realHeight,
            u = Math.floor((q - g + b) / (c + b)),
            v = Math.floor((r - g + b) / (f + b)),
            x = e.x,
            y = c - x;
          q = c - (q - e.cutWidth - x);
          var z = e.y,
            A = f - z;
          r = f - (r - e.cutHeight - z);
          for (var B = g, D = g, E = 0, C = e.sourceIndex, F = 0; F < v; F++) {
            for (var G = 0 === F, H = F === v - 1, K = 0; K < u; K++) {
              var I = 0 === K,
                M = K === u - 1;
              e = k.add(E, C, m + B, n + D, c, f);
              if (I || G || M || H) {
                var N = I ? x : 0,
                  P = G ? z : 0,
                  J = 0,
                  L = 0;
                I && (J += c - y);
                M && (J += c - q);
                G && (L += f - A);
                H && (L += f - r);
                J = c - J;
                L = f - L;
                e.cutWidth = J;
                e.cutHeight = L;
                e.setTrim(c, f, N, P, J, L);
              }
              B += b;
              B = I ? B + y : M ? B + q : B + c;
              E++;
            }
            B = g;
            D += b;
            D = G ? D + A : H ? D + r : D + f;
          }
          return k;
        };
      },
      function (h, t) {
        var a = 0;
        h.exports = function (d, k, e) {
          var b = d.source[k];
          d.add("__BASE", k, 0, 0, b.width, b.height);
          a = b.height;
          e = e.split("\n");
          b = /^[ ]*(- )*(\w+)+[: ]+(.*)/;
          for (
            var c = "",
              f = "",
              g = {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
              },
              m = 0;
            m < e.length;
            m++
          ) {
            var n = e[m].match(b);
            if (n) {
              var q = n[2],
                r = n[3];
              "- " === n[1] &&
                (f !== c &&
                  (d.add(f, k, g.x, a - g.y - g.height, g.width, g.height),
                  (c = f)),
                (g = {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0,
                }));
              if ("name" === q) f = r;
              else
                switch (q) {
                  case "x":
                  case "y":
                  case "width":
                  case "height":
                    g[q] = parseInt(r, 10);
                }
            }
          }
          f !== c && d.add(f, k, g.x, a - g.y - g.height, g.width, g.height);
          return d;
        };
      },
      function (h, t) {
        h.exports = "complete";
      },
      function (h, t) {
        h.exports = "decoded";
      },
      function (h, t) {
        h.exports = "decodedall";
      },
      function (h, t) {
        h.exports = "destroy";
      },
      function (h, t) {
        h.exports = "detune";
      },
      function (h, t) {
        h.exports = "detune";
      },
      function (h, t) {
        h.exports = "mute";
      },
      function (h, t) {
        h.exports = "rate";
      },
      function (h, t) {
        h.exports = "volume";
      },
      function (h, t) {
        h.exports = "loop";
      },
      function (h, t) {
        h.exports = "looped";
      },
      function (h, t) {
        h.exports = "mute";
      },
      function (h, t) {
        h.exports = "pan";
      },
      function (h, t) {
        h.exports = "pauseall";
      },
      function (h, t) {
        h.exports = "pause";
      },
      function (h, t) {
        h.exports = "play";
      },
      function (h, t) {
        h.exports = "rate";
      },
      function (h, t) {
        h.exports = "resumeall";
      },
      function (h, t) {
        h.exports = "resume";
      },
      function (h, t) {
        h.exports = "seek";
      },
      function (h, t) {
        h.exports = "stopall";
      },
      function (h, t) {
        h.exports = "stop";
      },
      function (h, t) {
        h.exports = "unlocked";
      },
      function (h, t) {
        h.exports = "volume";
      },
      function (h, t, a) {
        t = {
          Events: a(75),
          DisplayList: a(1012),
          GameObjectCreator: a(16),
          GameObjectFactory: a(5),
          UpdateList: a(1040),
          Components: a(11),
          GetCalcMatrix: a(19),
          BuildGameObject: a(28),
          BuildGameObjectAnimation: a(439),
          GameObject: a(15),
          BitmapText: a(148),
          Blitter: a(213),
          Bob: a(440),
          Container: a(214),
          DOMElement: a(442),
          DynamicBitmapText: a(215),
          Extern: a(444),
          Graphics: a(216),
          Group: a(113),
          Image: a(125),
          Layer: a(219),
          Particles: a(1074),
          PathFollower: a(457),
          RenderTexture: a(221),
          RetroFont: a(1082),
          Rope: a(223),
          Sprite: a(73),
          Text: a(224),
          GetTextSize: a(458),
          MeasureText: a(460),
          TextStyle: a(459),
          TileSprite: a(225),
          Zone: a(129),
          Video: a(226),
          Shape: a(34),
          Arc: a(461),
          Curve: a(462),
          Ellipse: a(463),
          Grid: a(464),
          IsoBox: a(465),
          IsoTriangle: a(466),
          Line: a(467),
          Polygon: a(468),
          Rectangle: a(473),
          Star: a(474),
          Triangle: a(475),
          Factories: {
            Blitter: a(1130),
            Container: a(1131),
            DOMElement: a(1132),
            DynamicBitmapText: a(1133),
            Extern: a(1134),
            Graphics: a(1135),
            Group: a(1136),
            Image: a(1137),
            Layer: a(1138),
            Particles: a(1139),
            PathFollower: a(1140),
            RenderTexture: a(1141),
            Rope: a(1142),
            Sprite: a(1143),
            StaticBitmapText: a(1144),
            Text: a(1145),
            TileSprite: a(1146),
            Zone: a(1147),
            Video: a(1148),
            Arc: a(1149),
            Curve: a(1150),
            Ellipse: a(1151),
            Grid: a(1152),
            IsoBox: a(1153),
            IsoTriangle: a(1154),
            Line: a(1155),
            Polygon: a(1156),
            Rectangle: a(1157),
            Star: a(1158),
            Triangle: a(1159),
          },
          Creators: {
            Blitter: a(1160),
            Container: a(1161),
            DynamicBitmapText: a(1162),
            Graphics: a(1163),
            Group: a(1164),
            Image: a(1165),
            Layer: a(1166),
            Particles: a(1167),
            RenderTexture: a(1168),
            Rope: a(1169),
            Sprite: a(1170),
            StaticBitmapText: a(1171),
            Text: a(1172),
            TileSprite: a(1173),
            Zone: a(1174),
            Video: a(1175),
          },
        };
        t.Shader = a(229);
        t.Mesh = a(230);
        t.PointLight = a(150);
        t.Factories.Shader = a(1184);
        t.Factories.Mesh = a(1185);
        t.Factories.PointLight = a(1186);
        t.Creators.Shader = a(1187);
        t.Creators.Mesh = a(1188);
        t.Creators.PointLight = a(1189);
        t.Light = a(481);
        t.LightsManager = a(482);
        t.LightsPlugin = a(1190);
        h.exports = t;
      },
      function (h, t, a) {
        var d = a(0),
          k = a(110);
        t = a(24);
        var e = a(75),
          b = a(20),
          c = a(79);
        a = new d({
          Extends: k,
          initialize: function (f) {
            k.call(this, f);
            this.sortChildrenFlag = !1;
            this.scene = f;
            this.systems = f.sys;
            this.events = f.sys.events;
            this.addCallback = this.addChildCallback;
            this.removeCallback = this.removeChildCallback;
            this.events.once(b.BOOT, this.boot, this);
            this.events.on(b.START, this.start, this);
          },
          boot: function () {
            this.events.once(b.DESTROY, this.destroy, this);
          },
          addChildCallback: function (f) {
            f.displayList &&
              f.displayList !== this &&
              f.removeFromDisplayList();
            f.displayList ||
              (this.queueDepthSort(),
              (f.displayList = this),
              f.emit(e.ADDED_TO_SCENE, f, this.scene),
              this.events.emit(b.ADDED_TO_SCENE, f, this.scene));
          },
          removeChildCallback: function (f) {
            this.queueDepthSort();
            f.displayList = null;
            f.emit(e.REMOVED_FROM_SCENE, f, this.scene);
            this.events.emit(b.REMOVED_FROM_SCENE, f, this.scene);
          },
          start: function () {
            this.events.once(b.SHUTDOWN, this.shutdown, this);
          },
          queueDepthSort: function () {
            this.sortChildrenFlag = !0;
          },
          depthSort: function () {
            this.sortChildrenFlag &&
              (c(this.list, this.sortByDepth), (this.sortChildrenFlag = !1));
          },
          sortByDepth: function (f, g) {
            return f._depth - g._depth;
          },
          getChildren: function () {
            return this.list;
          },
          shutdown: function () {
            for (var f = this.list, g = f.length; g--; ) f[g].destroy(!0);
            f.length = 0;
            this.events.off(b.SHUTDOWN, this.shutdown, this);
          },
          destroy: function () {
            this.shutdown();
            this.events.off(b.START, this.start, this);
            this.events = this.systems = this.scene = null;
          },
        });
        t.register("DisplayList", a, "displayList");
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          CheckMatrix: a(209),
          MatrixToString: a(1014),
          ReverseColumns: a(1015),
          ReverseRows: a(1016),
          Rotate180: a(1017),
          RotateLeft: a(1018),
          RotateMatrix: a(147),
          RotateRight: a(1019),
          Translate: a(1020),
          TransposeMatrix: a(435),
        };
      },
      function (h, t, a) {
        var d = a(186),
          k = a(209);
        h.exports = function (e) {
          var b = "";
          if (!k(e)) return b;
          for (var c = 0; c < e.length; c++) {
            for (var f = 0; f < e[c].length; f++) {
              var g = e[c][f].toString();
              b = "undefined" !== g ? b + d(g, 2) : b + "?";
              f < e[c].length - 1 && (b += " |");
            }
            if (c < e.length - 1) {
              b += "\n";
              for (f = 0; f < e[c].length; f++)
                (b += "---"), f < e[c].length - 1 && (b += "+");
              b += "\n";
            }
          }
          return b;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a.reverse();
        };
      },
      function (h, t) {
        h.exports = function (a) {
          for (var d = 0; d < a.length; d++) a[d].reverse();
          return a;
        };
      },
      function (h, t, a) {
        var d = a(147);
        h.exports = function (k) {
          return d(k, 180);
        };
      },
      function (h, t, a) {
        var d = a(147);
        h.exports = function (k) {
          return d(k, 90);
        };
      },
      function (h, t, a) {
        var d = a(147);
        h.exports = function (k) {
          return d(k, -90);
        };
      },
      function (h, t, a) {
        var d = a(178),
          k = a(179);
        h.exports = function (e, b, c) {
          void 0 === b && (b = 0);
          void 0 === c && (c = 0);
          0 !== c && (0 > c ? d(e, Math.abs(c)) : k(e, c));
          if (0 !== b)
            for (c = 0; c < e.length; c++) {
              var f = e[c];
              0 > b ? d(f, Math.abs(b)) : k(f, b);
            }
          return e;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b) {
          void 0 === b && (b = a);
          if (0 < k) {
            var c = k - a.length;
            if (0 >= c) return null;
          }
          if (!Array.isArray(d))
            return -1 === a.indexOf(d)
              ? (a.push(d), e && e.call(b, d), d)
              : null;
          for (var f = d.length - 1; 0 <= f; )
            -1 !== a.indexOf(d[f]) && d.splice(f, 1), f--;
          f = d.length;
          if (0 === f) return null;
          0 < k && f > c && (d.splice(c), (f = c));
          for (k = 0; k < f; k++) (c = d[k]), a.push(c), e && e.call(b, c);
          return d;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b, c) {
          void 0 === k && (k = 0);
          void 0 === c && (c = a);
          if (0 < e) {
            var f = e - a.length;
            if (0 >= f) return null;
          }
          if (!Array.isArray(d))
            return -1 === a.indexOf(d)
              ? (a.splice(k, 0, d), b && b.call(c, d), d)
              : null;
          for (var g = d.length - 1; 0 <= g; )
            -1 !== a.indexOf(d[g]) && d.pop(), g--;
          g = d.length;
          if (0 === g) return null;
          0 < e && g > f && (d.splice(f), (g = f));
          for (e = g - 1; 0 <= e; e--)
            (f = d[e]), a.splice(k, 0, f), b && b.call(c, f);
          return d;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          var k = a.indexOf(d);
          -1 !== k && k < a.length && (a.splice(k, 1), a.push(d));
          return d;
        };
      },
      function (h, t, a) {
        var d = a(78);
        h.exports = function (k, e, b, c, f) {
          void 0 === c && (c = 0);
          void 0 === f && (f = k.length);
          var g = 0;
          if (d(k, c, f)) for (; c < f; c++) k[c][e] === b && g++;
          return g;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          var e,
            b = [null];
          for (e = 3; e < arguments.length; e++) b.push(arguments[e]);
          for (e = 0; e < a.length; e++) (b[0] = a[e]), d.apply(k, b);
          return a;
        };
      },
      function (h, t, a) {
        var d = a(78);
        h.exports = function (k, e, b, c, f) {
          void 0 === c && (c = 0);
          void 0 === f && (f = k.length);
          if (d(k, c, f)) {
            var g,
              m = [null];
            for (g = 5; g < arguments.length; g++) m.push(arguments[g]);
            for (g = c; g < f; g++) (m[0] = k[g]), e.apply(b, m);
          }
          return k;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          var k = a.indexOf(d);
          if (0 < k) {
            var e = a[k - 1],
              b = a.indexOf(e);
            a[k] = e;
            a[b] = d;
          }
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          var e = a.indexOf(d);
          if (-1 === e || 0 > k || k >= a.length)
            throw Error("Supplied index out of bounds");
          e !== k && (a.splice(e, 1), a.splice(k, 0, d));
          return d;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          var k = a.indexOf(d);
          if (-1 !== k && k < a.length - 1) {
            var e = a[k + 1],
              b = a.indexOf(e);
            a[k] = e;
            a[b] = d;
          }
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          if (d === k) return a;
          var e = a.indexOf(d);
          k = a.indexOf(k);
          if (0 > e || 0 > k)
            throw Error("Supplied items must be elements of the same array");
          if (e > k) return a;
          a.splice(e, 1);
          k === a.length - 1 ? a.push(d) : a.splice(k, 0, d);
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          if (d === k) return a;
          var e = a.indexOf(d);
          k = a.indexOf(k);
          if (0 > e || 0 > k)
            throw Error("Supplied items must be elements of the same array");
          if (e < k) return a;
          a.splice(e, 1);
          0 === k ? a.unshift(d) : a.splice(k, 0, d);
          return a;
        };
      },
      function (h, t, a) {
        var d = a(363);
        h.exports = function (k, e, b) {
          void 0 === k && (k = 0);
          void 0 === e && (e = null);
          void 0 === b && (b = 1);
          null === e && ((e = k), (k = 0));
          var c = [];
          e = Math.max(d((e - k) / (b || 1)), 0);
          for (var f = 0; f < e; f++) c.push(k), (k += b);
          return c;
        };
      },
      function (h, t, a) {
        var d = a(74);
        h.exports = function (k, e, b, c) {
          void 0 === c && (c = k);
          if (0 > e || e > k.length - 1) throw Error("Index out of bounds");
          k = d(k, e);
          b && b.call(c, k);
          return k;
        };
      },
      function (h, t, a) {
        var d = a(78);
        h.exports = function (k, e, b, c, f) {
          void 0 === e && (e = 0);
          void 0 === b && (b = k.length);
          void 0 === f && (f = k);
          if (d(k, e, b)) {
            k = k.splice(e, b - e);
            if (c) for (e = 0; e < k.length; e++) c.call(f, k[e]);
            return k;
          }
          return [];
        };
      },
      function (h, t, a) {
        var d = a(74);
        h.exports = function (k, e, b) {
          void 0 === e && (e = 0);
          void 0 === b && (b = k.length);
          return d(k, e + Math.floor(Math.random() * b));
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          d = a.indexOf(d);
          var e = a.indexOf(k);
          return -1 !== d && -1 === e ? ((a[d] = k), !0) : !1;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          var k = a.indexOf(d);
          -1 !== k && 0 < k && (a.splice(k, 1), a.unshift(d));
          return d;
        };
      },
      function (h, t, a) {
        var d = a(78);
        h.exports = function (k, e, b, c, f) {
          void 0 === c && (c = 0);
          void 0 === f && (f = k.length);
          if (d(k, c, f))
            for (; c < f; c++) {
              var g = k[c];
              g.hasOwnProperty(e) && (g[e] = b);
            }
          return k;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          if (d === k) return a;
          var e = a.indexOf(d),
            b = a.indexOf(k);
          if (0 > e || 0 > b)
            throw Error("Supplied items must be elements of the same array");
          a[e] = k;
          a[b] = d;
          return a;
        };
      },
      function (h, t, a) {
        var d = a(0),
          k = a(211);
        t = a(24);
        var e = a(20);
        a = new d({
          Extends: k,
          initialize: function (b) {
            k.call(this);
            this.checkQueue = !0;
            this.scene = b;
            this.systems = b.sys;
            b.sys.events.once(e.BOOT, this.boot, this);
            b.sys.events.on(e.START, this.start, this);
          },
          boot: function () {
            this.systems.events.once(e.DESTROY, this.destroy, this);
          },
          start: function () {
            var b = this.systems.events;
            b.on(e.PRE_UPDATE, this.update, this);
            b.on(e.UPDATE, this.sceneUpdate, this);
            b.once(e.SHUTDOWN, this.shutdown, this);
          },
          sceneUpdate: function (b, c) {
            for (var f = this._active, g = f.length, m = 0; m < g; m++) {
              var n = f[m];
              n.active && n.preUpdate.call(n, b, c);
            }
          },
          shutdown: function () {
            for (var b = this._active.length; b--; )
              this._active[b].destroy(!0);
            for (b = this._pending.length; b--; ) this._pending[b].destroy(!0);
            for (b = this._destroy.length; b--; ) this._destroy[b].destroy(!0);
            this._toProcess = 0;
            this._pending = [];
            this._active = [];
            this._destroy = [];
            this.removeAllListeners();
            b = this.systems.events;
            b.off(e.PRE_UPDATE, this.update, this);
            b.off(e.UPDATE, this.sceneUpdate, this);
            b.off(e.SHUTDOWN, this.shutdown, this);
          },
          destroy: function () {
            this.shutdown();
            this.systems.events.off(e.START, this.start, this);
            this.systems = this.scene = null;
          },
        });
        t.register("UpdateList", a, "updateList");
        h.exports = a;
      },
      function (h, t) {
        h.exports = "add";
      },
      function (h, t) {
        h.exports = "remove";
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          void 0 === k && (k = !1);
          if (void 0 === e)
            return (e = {
              local: {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
              },
              global: {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
              },
              lines: {
                shortest: 0,
                longest: 0,
                lengths: null,
                height: 0,
              },
              wrappedText: "",
              words: [],
              characters: [],
              scaleX: 0,
              scaleY: 0,
            });
          var b = a.text,
            c = b.length,
            f = a.maxWidth,
            g = a.wordWrapCharCode,
            m = Number.MAX_VALUE,
            n = Number.MAX_VALUE,
            q = 0,
            r = 0,
            u = a.fontData.chars,
            v = a.fontData.lineHeight,
            x = a.letterSpacing,
            y = 0,
            z = 0,
            A,
            B = a._align,
            D = a.fontSize / a.fontData.size,
            E = D * a.scaleX,
            C = D * a.scaleY,
            F = null,
            G = 0,
            H = [],
            K = Number.MAX_VALUE,
            I = 0,
            M = 0;
          var N = 0;
          var P,
            J = [],
            L = [],
            O = null;
          if (0 < f) {
            for (P = 0; P < c; P++) {
              var Q = b.charCodeAt(P);
              if (10 === Q)
                null !== O &&
                  (J.push({
                    word: O.word,
                    i: O.i,
                    x: O.x * E,
                    y: O.y * C,
                    w: O.w * E,
                    h: O.h * C,
                    cr: !0,
                  }),
                  (O = null)),
                  (y = 0),
                  (z += v),
                  (F = null);
              else if ((A = u[Q])) {
                if (null !== F) var S = A.kerning[G];
                Q === g
                  ? null !== O &&
                    (J.push({
                      word: O.word,
                      i: O.i,
                      x: O.x * E,
                      y: O.y * C,
                      w: O.w * E,
                      h: O.h * C,
                      cr: !1,
                    }),
                    (O = null))
                  : (null === O &&
                      (O = {
                        word: "",
                        i: P,
                        x: y,
                        y: z,
                        w: 0,
                        h: v,
                        cr: !1,
                      }),
                    (O.word = O.word.concat(b[P])),
                    (O.w += A.xOffset + A.xAdvance + (void 0 !== S ? S : 0)));
                y += A.xAdvance + x;
                F = A;
                G = Q;
              }
            }
            null !== O &&
              J.push({
                word: O.word,
                i: O.i,
                x: O.x * E,
                y: O.y * C,
                w: O.w * E,
                h: O.h * C,
                cr: !1,
              });
            z = y = 0;
            F = null;
            Q = G = 0;
            c = [];
            for (P = 0; P < J.length; P++) {
              A = J[P];
              O = A.x;
              S = A.x + A.w;
              if (R) {
                Q = O - (O - (R.x + R.w) + R.w);
                var R = null;
              }
              S -= Q;
              O - Q > f || S > f
                ? (c.push(A.i - 1),
                  A.cr
                    ? (c.push(A.i + A.word.length), (Q = 0), (R = null))
                    : (R = A))
                : A.cr && (c.push(A.i + A.word.length), (Q = 0), (R = null));
            }
            for (P = c.length - 1; 0 <= P; P--)
              (J = b),
                (b = c[P]),
                (b = J.substr(0, b) + "\n" + J.substr(b + 1));
            e.wrappedText = b;
            c = b.length;
            J = [];
            O = null;
          }
          for (P = f = 0; P < c; P++)
            if (((Q = b.charCodeAt(P)), 10 === Q))
              null !== O &&
                (J.push({
                  word: O.word,
                  i: O.i,
                  x: O.x * E,
                  y: O.y * C,
                  w: O.w * E,
                  h: O.h * C,
                }),
                (O = null)),
                (y = 0),
                (z += v),
                (F = null),
                (H[M] = N),
                N > I && (I = N),
                N < K && (K = N),
                M++,
                (N = 0);
            else if ((A = u[Q])) {
              N = y;
              R = z;
              if (null !== F) {
                var T = A.kerning[G];
                N += void 0 !== T ? T : 0;
              }
              m > N && (m = N);
              n > R && (n = R);
              N += A.xAdvance;
              F = R + v;
              q < N && (q = N);
              r < F && (r = F);
              F = A.xOffset + A.xAdvance + (void 0 !== T ? T : 0);
              Q === g
                ? null !== O &&
                  (J.push({
                    word: O.word,
                    i: O.i,
                    x: O.x * E,
                    y: O.y * C,
                    w: O.w * E,
                    h: O.h * C,
                  }),
                  (O = null))
                : (null === O &&
                    (O = {
                      word: "",
                      i: f,
                      x: y,
                      y: z,
                      w: 0,
                      h: v,
                    }),
                  (O.word = O.word.concat(b[P])),
                  (O.w += F));
              L.push({
                i: f,
                char: b[P],
                code: Q,
                x: (A.xOffset + y) * D,
                y: (A.yOffset + z) * D,
                w: A.width * D,
                h: A.height * D,
                t: z * D,
                r: N * D,
                b: v * D,
                line: M,
                glyph: A,
              });
              y += A.xAdvance + x;
              F = A;
              G = Q;
              N *= D;
              f++;
            }
          null !== O &&
            J.push({
              word: O.word,
              i: O.i,
              x: O.x * E,
              y: O.y * C,
              w: O.w * E,
              h: O.h * C,
            });
          H[M] = N;
          N > I && (I = N);
          N < K && (K = N);
          if (0 < B)
            for (g = 0; g < L.length; g++)
              (u = L[g]),
                1 === B
                  ? ((x = (I - H[u.line]) / 2), (u.x += x), (u.r += x))
                  : 2 === B && ((x = I - H[u.line]), (u.x += x), (u.r += x));
          B = e.local;
          g = e.global;
          u = e.lines;
          B.x = m * D;
          B.y = n * D;
          B.width = q * D;
          B.height = r * D;
          g.x = a.x - a._displayOriginX + m * E;
          g.y = a.y - a._displayOriginY + n * C;
          g.width = q * E;
          g.height = r * C;
          u.shortest = K;
          u.longest = I;
          u.lengths = H;
          d &&
            ((B.x = Math.ceil(B.x)),
            (B.y = Math.ceil(B.y)),
            (B.width = Math.ceil(B.width)),
            (B.height = Math.ceil(B.height)),
            (g.x = Math.ceil(g.x)),
            (g.y = Math.ceil(g.y)),
            (g.width = Math.ceil(g.width)),
            (g.height = Math.ceil(g.height)),
            (u.shortest = Math.ceil(K)),
            (u.longest = Math.ceil(I)));
          k &&
            ((a._displayOriginX = a.originX * B.width),
            (a._displayOriginY = a.originY * B.height),
            (g.x = a.x - a._displayOriginX * a.scaleX),
            (g.y = a.y - a._displayOriginY * a.scaleY),
            d && ((g.x = Math.ceil(g.x)), (g.y = Math.ceil(g.y))));
          e.words = J;
          e.characters = L;
          e.lines.height = v;
          e.scale = D;
          e.scaleX = a.scaleX;
          e.scaleY = a.scaleY;
          return e;
        };
      },
      function (h, t, a) {
        var d = a(212);
        h.exports = function (k, e, b, c, f, g, m) {
          var n = k.sys.textures.get(b),
            q = n.get(c);
          f = k.sys.cache.xml.get(f);
          return q && f
            ? ((g = d(f, q, g, m, n)),
              k.sys.cache.bitmapFont.add(e, {
                data: g,
                texture: b,
                frame: c,
                fromAtlas: !0,
              }),
              !0)
            : !1;
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1046);
        a = a(1048);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(1047),
          k = a(19),
          e = a(12);
        h.exports = function (b, c, f, g) {
          if (0 !== c._text.length) {
            f.addToRenderList(c);
            var m = b.pipelines.set(c.pipeline, c);
            g = k(c, f, g).calc;
            var n = f.roundPixels;
            f = f.alpha;
            var q = c.charColors,
              r = c.tintFill,
              u = e.getTintAppendFloatAlpha,
              v = u(c.tintTopLeft, f * c._alphaTL),
              x = u(c.tintTopRight, f * c._alphaTR),
              y = u(c.tintBottomLeft, f * c._alphaBL),
              z = u(c.tintBottomRight, f * c._alphaBR),
              A = c.frame.glTexture,
              B = m.setGameObject(c),
              D = c.getTextBounds(!1).characters,
              E = c.dropShadowX,
              C = c.dropShadowY;
            var F = 0 !== E || 0 !== C;
            b.pipelines.preBatch(c);
            if (F) {
              F = c.dropShadowColor;
              var G = c.dropShadowAlpha;
              var H = u(F, f * G * c._alphaTL),
                K = u(F, f * G * c._alphaTR),
                I = u(F, f * G * c._alphaBL),
                M = u(F, f * G * c._alphaBR);
              for (F = 0; F < D.length; F++) {
                G = D[F];
                var N = G.glyph;
                32 !== G.code &&
                  0 !== N.width &&
                  0 !== N.height &&
                  d(m, c, G, N, E, C, g, n, H, K, I, M, 1, A, B);
              }
            }
            for (F = 0; F < D.length; F++)
              (G = D[F]),
                (N = G.glyph),
                32 !== G.code &&
                  0 !== N.width &&
                  0 !== N.height &&
                  (q[G.i]
                    ? ((I = q[G.i]),
                      (E = I.tintEffect),
                      (C = u(I.tintTL, f * c._alphaTL)),
                      (H = u(I.tintTR, f * c._alphaTR)),
                      (K = u(I.tintBL, f * c._alphaBL)),
                      (I = u(I.tintBR, f * c._alphaBR)),
                      d(m, c, G, N, 0, 0, g, n, C, H, K, I, E, A, B))
                    : d(m, c, G, N, 0, 0, g, n, v, x, y, z, r, A, B));
            b.pipelines.postBatch(c);
          }
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b, c, f, g, m, n, q, r, u, v, x) {
          var y = k.x - d.displayOriginX + b;
          c = k.y - d.displayOriginY + c;
          b = y + k.w;
          var z = c + k.h;
          k = f.getXRound(y, c, g);
          var A = f.getYRound(y, c, g),
            B = f.getXRound(y, z, g);
          y = f.getYRound(y, z, g);
          var D = f.getXRound(b, z, g);
          z = f.getYRound(b, z, g);
          var E = f.getXRound(b, c, g);
          f = f.getYRound(b, c, g);
          a.batchQuad(
            d,
            k,
            A,
            B,
            y,
            D,
            z,
            E,
            f,
            e.u0,
            e.v0,
            e.u1,
            e.v1,
            m,
            n,
            q,
            r,
            u,
            v,
            x
          );
        };
      },
      function (h, t, a) {
        var d = a(30);
        h.exports = function (k, e, b, c) {
          var f = e._text,
            g = f.length,
            m = k.currentContext;
          if (0 !== g && d(k, m, e, b, c)) {
            b.addToRenderList(e);
            var n = e.fromAtlas ? e.frame : e.texture.frames.__BASE;
            k = e.fontData.chars;
            c = e.fontData.lineHeight;
            var q = e._letterSpacing,
              r = 0,
              u = 0,
              v = null,
              x = 0,
              y = n.source.image,
              z = n.cutX;
            n = n.cutY;
            var A = e._fontSize / e.fontData.size,
              B = e._align,
              D = 0,
              E = 0,
              C = e.getTextBounds(!1);
            0 < e.maxWidth && ((f = C.wrappedText), (g = f.length));
            C = e._bounds.lines;
            1 === B
              ? (E = (C.longest - C.lengths[0]) / 2)
              : 2 === B && (E = C.longest - C.lengths[0]);
            m.translate(-e.displayOriginX, -e.displayOriginY);
            for (var F = b.roundPixels, G = 0; G < g; G++)
              if (((e = f.charCodeAt(G)), 10 === e))
                D++,
                  1 === B
                    ? (E = (C.longest - C.lengths[D]) / 2)
                    : 2 === B && (E = C.longest - C.lengths[D]),
                  (r = 0),
                  (u += c),
                  (v = null);
              else if ((b = k[e])) {
                var H = z + b.x;
                var K = n + b.y;
                var I = b.width;
                var M = b.height;
                var N = b.xOffset + r;
                var P = b.yOffset + u;
                null !== v && ((v = b.kerning[x]), (N += void 0 !== v ? v : 0));
                N *= A;
                P *= A;
                N += E;
                r += b.xAdvance + q;
                v = b;
                x = e;
                0 !== I &&
                  0 !== M &&
                  32 !== e &&
                  (F && ((N = Math.round(N)), (P = Math.round(P))),
                  m.save(),
                  m.translate(N, P),
                  m.scale(A, A),
                  m.drawImage(y, H, K, I, M, 0, 0, I, M),
                  m.restore());
              }
            m.restore();
          }
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1050);
        a = a(1051);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        t = a(25);
        var d = a(12),
          k = new t();
        h.exports = function (e, b, c, f) {
          var g = b.getRenderList();
          if (0 !== g.length) {
            var m = c.alpha * b.alpha;
            if (0 !== m) {
              c.addToRenderList(b);
              var n = e.pipelines.set(this.pipeline, b),
                q = c.scrollX * b.scrollFactorX,
                r = c.scrollY * b.scrollFactorY,
                u = k.copyFrom(c.matrix);
              f && (u.multiplyWithOffset(f, -q, -r), (r = q = 0));
              f = b.x - q;
              r = b.y - r;
              q = -1;
              c = c.roundPixels;
              e.pipelines.preBatch(b);
              for (var v = 0; v < g.length; v++) {
                var x = g[v],
                  y = x.frame,
                  z = x.alpha * m;
                if (0 !== z) {
                  var A = y.width,
                    B = y.height,
                    D = f + x.x + y.x,
                    E = r + x.y + y.y;
                  x.flipX && ((A *= -1), (D += y.width));
                  x.flipY && ((B *= -1), (E += y.height));
                  A = D + A;
                  var C = E + B;
                  B = u.getX(D, E);
                  D = u.getY(D, E);
                  E = u.getX(A, C);
                  A = u.getY(A, C);
                  x = d.getTintAppendFloatAlpha(x.tint, z);
                  if (y.sourceIndex !== q) {
                    var F = n.setGameObject(b, y);
                    q = y.sourceIndex;
                  }
                  c &&
                    ((B = Math.round(B)),
                    (D = Math.round(D)),
                    (E = Math.round(E)),
                    (A = Math.round(A)));
                  n.batchQuad(
                    b,
                    B,
                    D,
                    B,
                    A,
                    E,
                    A,
                    E,
                    D,
                    y.u0,
                    y.v0,
                    y.u1,
                    y.v1,
                    x,
                    x,
                    x,
                    x,
                    !1,
                    y.glTexture,
                    F
                  ) && (q = -1);
                }
              }
              e.pipelines.postBatch(b);
            }
          }
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          var b = d.getRenderList();
          if (0 !== b.length) {
            var c = a.currentContext,
              f = k.alpha * d.alpha;
            if (0 !== f) {
              k.addToRenderList(d);
              c.globalCompositeOperation = a.blendModes[d.blendMode];
              c.imageSmoothingEnabled = !(
                !a.antialias || d.frame.source.scaleMode
              );
              a = d.x - k.scrollX * d.scrollFactorX;
              d = d.y - k.scrollY * d.scrollFactorY;
              c.save();
              e && e.copyToContext(c);
              k = k.roundPixels;
              for (e = 0; e < b.length; e++) {
                var g = b[e],
                  m = g.flipX || g.flipY,
                  n = g.frame,
                  q = n.canvasData,
                  r = n.x,
                  u = n.y,
                  v = 1,
                  x = 1,
                  y = g.alpha * f;
                0 !== y &&
                  ((c.globalAlpha = y),
                  m
                    ? (g.flipX && ((v = -1), (r -= q.width)),
                      g.flipY && ((x = -1), (u -= q.height)),
                      c.save(),
                      c.translate(g.x + a, g.y + d),
                      c.scale(v, x),
                      c.drawImage(
                        n.source.image,
                        q.x,
                        q.y,
                        q.width,
                        q.height,
                        r,
                        u,
                        q.width,
                        q.height
                      ),
                      c.restore())
                    : (k && ((r = Math.round(r)), (u = Math.round(u))),
                      c.drawImage(
                        n.source.image,
                        q.x,
                        q.y,
                        q.width,
                        q.height,
                        r + g.x + a,
                        u + g.y + d,
                        q.width,
                        q.height
                      )));
              }
              c.restore();
            }
          }
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1053);
        a = a(1054);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          k.addToRenderList(d);
          var b = d.list,
            c = b.length;
          if (0 !== c) {
            var f = d.localTransform;
            e
              ? (f.loadIdentity(),
                f.multiply(e),
                f.translate(d.x, d.y),
                f.rotate(d.rotation),
                f.scale(d.scaleX, d.scaleY))
              : f.applyITRS(d.x, d.y, d.rotation, d.scaleX, d.scaleY);
            a.pipelines.preBatch(d);
            (e = -1 !== d.blendMode) || a.setBlendMode(0);
            for (
              var g = d.alpha, m = d.scrollFactorX, n = d.scrollFactorY, q = 0;
              q < c;
              q++
            ) {
              var r = b[q];
              if (r.willRender(k)) {
                if (void 0 !== r.alphaTopLeft) {
                  var u = r.alphaTopLeft;
                  var v = r.alphaTopRight;
                  var x = r.alphaBottomLeft;
                  var y = r.alphaBottomRight;
                } else x = v = u = y = r.alpha;
                var z = r.scrollFactorX,
                  A = r.scrollFactorY;
                e ||
                  r.blendMode === a.currentBlendMode ||
                  a.setBlendMode(r.blendMode);
                var B = r.mask;
                B && B.preRenderWebGL(a, r, k);
                var D = r.type;
                D !== a.currentType && ((a.newType = !0), (a.currentType = D));
                a.nextTypeMatch =
                  q < c - 1 ? b[q + 1].type === a.currentType : !1;
                r.setScrollFactor(z * m, A * n);
                r.setAlpha(u * g, v * g, x * g, y * g);
                r.renderWebGL(a, r, k, f);
                r.setAlpha(u, v, x, y);
                r.setScrollFactor(z, A);
                B && B.postRenderWebGL(a, k);
                a.newType = !1;
              }
            }
            a.pipelines.postBatch(d);
          }
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          k.addToRenderList(d);
          var b = d.list;
          if (0 !== b.length) {
            var c = d.localTransform;
            e
              ? (c.loadIdentity(),
                c.multiply(e),
                c.translate(d.x, d.y),
                c.rotate(d.rotation),
                c.scale(d.scaleX, d.scaleY))
              : c.applyITRS(d.x, d.y, d.rotation, d.scaleX, d.scaleY);
            (e = -1 !== d.blendMode) || a.setBlendMode(0);
            var f = d._alpha,
              g = d.scrollFactorX,
              m = d.scrollFactorY;
            d.mask && d.mask.preRenderCanvas(a, null, k);
            for (var n = 0; n < b.length; n++) {
              var q = b[n];
              if (q.willRender(k)) {
                var r = q.alpha,
                  u = q.scrollFactorX,
                  v = q.scrollFactorY;
                e ||
                  q.blendMode === a.currentBlendMode ||
                  a.setBlendMode(q.blendMode);
                q.setScrollFactor(u * g, v * m);
                q.setAlpha(r * f);
                q.renderCanvas(a, q, k, c);
                q.setAlpha(r);
                q.setScrollFactor(u, v);
              }
            }
            d.mask && d.mask.postRenderCanvas(a);
          }
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(443);
        a = a(443);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t) {
        h.exports =
          "normal multiply multiply screen overlay darken lighten color-dodge color-burn hard-light soft-light difference exclusion hue saturation color luminosity".split(
            " "
          );
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1058);
        a = a(1059);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(19);
        t = a(25);
        var k = a(12),
          e = new t();
        h.exports = function (b, c, f, g) {
          var m = c.text,
            n = m.length;
          if (0 !== n) {
            f.addToRenderList(c);
            var q = b.pipelines.set(c.pipeline, c),
              r = d(c, f, g);
            g = r.sprite;
            r = r.calc;
            var u = 0 < c.cropWidth || 0 < c.cropHeight;
            u &&
              (q.flush(),
              b.pushScissor(
                r.tx,
                r.ty,
                c.cropWidth * r.scaleX,
                c.cropHeight * r.scaleY
              ));
            var v = c.frame.glTexture,
              x = c.tintFill,
              y = k.getTintAppendFloatAlpha(
                c.tintTopLeft,
                f.alpha * c._alphaTL
              ),
              z = k.getTintAppendFloatAlpha(
                c.tintTopRight,
                f.alpha * c._alphaTR
              ),
              A = k.getTintAppendFloatAlpha(
                c.tintBottomLeft,
                f.alpha * c._alphaBL
              ),
              B = k.getTintAppendFloatAlpha(
                c.tintBottomRight,
                f.alpha * c._alphaBR
              ),
              D = q.setGameObject(c),
              E = 0,
              C = 0,
              F = 0,
              G = c.letterSpacing,
              H,
              K = c.scrollX,
              I = c.scrollY,
              M = c.fontData,
              N = M.chars;
            M = M.lineHeight;
            var P = c._align,
              J = 0,
              L = 0,
              O = c.getTextBounds(!1);
            0 < c.maxWidth && ((m = O.wrappedText), (n = m.length));
            O = c._bounds.lines;
            1 === P
              ? (L = (O.longest - O.lengths[0]) / 2)
              : 2 === P && (L = O.longest - O.lengths[0]);
            var Q = f.roundPixels,
              S = c.displayCallback,
              R = c.callbackData;
            b.pipelines.preBatch(c);
            for (var T = 0; T < n; T++) {
              var U = m.charCodeAt(T);
              if (10 === U) {
                J++;
                1 === P
                  ? (L = (O.longest - O.lengths[J]) / 2)
                  : 2 === P && (L = O.longest - O.lengths[J]);
                E = 0;
                C += M;
                var V = null;
              } else if ((H = N[U])) {
                var X = H.width;
                var W = H.height;
                var Z = H.xOffset + E - K,
                  aa = H.yOffset + C - I;
                null !== V && ((V = H.kerning[F]), (Z += void 0 !== V ? V : 0));
                E += H.xAdvance + G;
                V = H;
                F = U;
                if (0 !== X && 0 !== W && 32 !== U) {
                  var Y = c.fontSize / c.fontData.size;
                  var ba = 0;
                  S &&
                    ((R.color = 0),
                    (R.tint.topLeft = y),
                    (R.tint.topRight = z),
                    (R.tint.bottomLeft = A),
                    (R.tint.bottomRight = B),
                    (R.index = T),
                    (R.charCode = U),
                    (R.x = Z),
                    (R.y = aa),
                    (R.scale = Y),
                    (R.rotation = ba),
                    (R.data = H.data),
                    (B = S(R)),
                    (Z = B.x),
                    (aa = B.y),
                    (Y = B.scale),
                    (ba = B.rotation),
                    B.color
                      ? (B = A = z = y = B.color)
                      : ((y = B.tint.topLeft),
                        (z = B.tint.topRight),
                        (A = B.tint.bottomLeft),
                        (B = B.tint.bottomRight)),
                    (y = k.getTintAppendFloatAlpha(y, f.alpha * c._alphaTL)),
                    (z = k.getTintAppendFloatAlpha(z, f.alpha * c._alphaTR)),
                    (A = k.getTintAppendFloatAlpha(A, f.alpha * c._alphaBL)),
                    (B = k.getTintAppendFloatAlpha(B, f.alpha * c._alphaBR)));
                  Z *= Y;
                  aa *= Y;
                  Z -= c.displayOriginX;
                  aa -= c.displayOriginY;
                  Z += L;
                  e.applyITRS(Z, aa, ba, Y, Y);
                  r.multiply(e, g);
                  Z = H.u0;
                  aa = H.v0;
                  U = H.u1;
                  H = H.v1;
                  var da = W;
                  W = g.e;
                  Y = g.f;
                  ba = da * g.c + g.e;
                  var ea = da * g.d + g.f,
                    fa = X * g.a + da * g.c + g.e;
                  da = X * g.b + da * g.d + g.f;
                  var ca = X * g.a + g.e;
                  X = X * g.b + g.f;
                  Q &&
                    ((W = Math.round(W)),
                    (Y = Math.round(Y)),
                    (ba = Math.round(ba)),
                    (ea = Math.round(ea)),
                    (fa = Math.round(fa)),
                    (da = Math.round(da)),
                    (ca = Math.round(ca)),
                    (X = Math.round(X)));
                  q.batchQuad(
                    c,
                    W,
                    Y,
                    ba,
                    ea,
                    fa,
                    da,
                    ca,
                    X,
                    Z,
                    aa,
                    U,
                    H,
                    y,
                    z,
                    A,
                    B,
                    x,
                    v,
                    D
                  );
                }
              }
            }
            u && (q.flush(), b.popScissor());
            b.pipelines.postBatch(c);
          }
        };
      },
      function (h, t, a) {
        var d = a(30);
        h.exports = function (k, e, b, c) {
          var f = e._text,
            g = f.length,
            m = k.currentContext;
          if (0 !== g && d(k, m, e, b, c)) {
            b.addToRenderList(e);
            var n = e.fromAtlas ? e.frame : e.texture.frames.__BASE;
            k = e.displayCallback;
            c = e.callbackData;
            var q = e.fontData.chars,
              r = e.fontData.lineHeight,
              u = e._letterSpacing,
              v = 0,
              x = 0,
              y,
              z = null,
              A = 0,
              B = e.frame.source.image,
              D = n.cutX;
            n = n.cutY;
            var E = e._fontSize / e.fontData.size,
              C = e._align,
              F = 0,
              G = 0;
            e.getTextBounds(!1);
            var H = e._bounds.lines;
            1 === C
              ? (G = (H.longest - H.lengths[0]) / 2)
              : 2 === C && (G = H.longest - H.lengths[0]);
            m.translate(-e.displayOriginX, -e.displayOriginY);
            var K = b.roundPixels;
            0 < e.cropWidth &&
              0 < e.cropHeight &&
              (m.beginPath(),
              m.rect(0, 0, e.cropWidth, e.cropHeight),
              m.clip());
            for (var I = 0; I < g; I++) {
              var M = E;
              var N = 0;
              b = f.charCodeAt(I);
              if (10 === b)
                F++,
                  1 === C
                    ? (G = (H.longest - H.lengths[F]) / 2)
                    : 2 === C && (G = H.longest - H.lengths[F]),
                  (v = 0),
                  (x += r),
                  (z = null);
              else if ((y = q[b])) {
                var P = D + y.x;
                var J = n + y.y;
                var L = y.width;
                var O = y.height;
                var Q = y.xOffset + v - e.scrollX;
                var S = y.yOffset + x - e.scrollY;
                null !== z && ((z = y.kerning[A]), (Q += void 0 !== z ? z : 0));
                k &&
                  ((c.index = I),
                  (c.charCode = b),
                  (c.x = Q),
                  (c.y = S),
                  (c.scale = M),
                  (c.rotation = N),
                  (c.data = y.data),
                  (z = k(c)),
                  (Q = z.x),
                  (S = z.y),
                  (M = z.scale),
                  (N = z.rotation));
                Q *= M;
                S *= M;
                Q += G;
                v += y.xAdvance + u;
                z = y;
                A = b;
                0 !== L &&
                  0 !== O &&
                  32 !== b &&
                  (K && ((Q = Math.round(Q)), (S = Math.round(S))),
                  m.save(),
                  m.translate(Q, S),
                  m.rotate(N),
                  m.scale(M, M),
                  m.drawImage(B, P, J, L, O, 0, 0, L, O),
                  m.restore());
              }
            }
            m.restore();
          }
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1061);
        a = a(1062);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(19);
        h.exports = function (k, e, b, c) {
          k.pipelines.clear();
          c = d(e, b, c).calc;
          e.render.call(e, k, b, c);
          k.pipelines.rebind();
        };
      },
      function (h, t) {},
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1064);
        a(448);
        a = a(448);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(217),
          k = a(19);
        t = a(25);
        var e = a(12),
          b = function (m, n, q) {
            this.x = m;
            this.y = n;
            this.width = q;
          },
          c = function (m, n, q) {
            this.points = [];
            this.pointsLength = 1;
            this.points[0] = new b(m, n, q);
          },
          f = [],
          g = new t();
        h.exports = function (m, n, q, r) {
          if (0 !== n.commandBuffer.length) {
            q.addToRenderList(n);
            var u = m.pipelines.set(n.pipeline, n);
            m.pipelines.preBatch(n);
            r = k(n, q, r).calc;
            var v = g.loadIdentity(),
              x = n.commandBuffer;
            q = q.alpha * n.alpha;
            for (
              var y = 1,
                z = u.fillTint,
                A = u.strokeTint,
                B,
                D,
                E = 2 * Math.PI,
                C,
                F = [],
                G = !0,
                H = null,
                K = e.getTintAppendFloatAlpha,
                I = 0;
              I < x.length;
              I++
            )
              switch (((C = x[I]), C)) {
                case d.BEGIN_PATH:
                  F.length = 0;
                  H = null;
                  G = !0;
                  break;
                case d.CLOSE_PATH:
                  G = !1;
                  H && H.points.length && H.points.push(H.points[0]);
                  break;
                case d.FILL_PATH:
                  for (C = 0; C < F.length; C++)
                    u.batchFillPath(F[C].points, v, r);
                  break;
                case d.STROKE_PATH:
                  for (C = 0; C < F.length; C++)
                    u.batchStrokePath(F[C].points, y, G, v, r);
                  break;
                case d.LINE_STYLE:
                  y = x[++I];
                  C = x[++I];
                  var M = x[++I] * q;
                  C = K(C, M);
                  A.TL = C;
                  A.TR = C;
                  A.BL = C;
                  A.BR = C;
                  break;
                case d.FILL_STYLE:
                  C = x[++I];
                  M = x[++I] * q;
                  C = K(C, M);
                  z.TL = C;
                  z.TR = C;
                  z.BL = C;
                  z.BR = C;
                  break;
                case d.GRADIENT_FILL_STYLE:
                  C = x[++I] * q;
                  M = x[++I] * q;
                  var N = x[++I] * q,
                    P = x[++I] * q;
                  z.TL = K(x[++I], C);
                  z.TR = K(x[++I], M);
                  z.BL = K(x[++I], N);
                  z.BR = K(x[++I], P);
                  break;
                case d.GRADIENT_LINE_STYLE:
                  y = x[++I];
                  C = x[++I] * q;
                  A.TL = K(x[++I], C);
                  A.TR = K(x[++I], C);
                  A.BL = K(x[++I], C);
                  A.BR = K(x[++I], C);
                  break;
                case d.ARC:
                  C = 0;
                  M = x[++I];
                  N = x[++I];
                  P = x[++I];
                  var J = x[++I],
                    L = x[++I];
                  B = x[++I];
                  var O = x[++I];
                  L -= J;
                  B
                    ? L < -E
                      ? (L = -E)
                      : 0 < L && (L = -E + (L % E))
                    : L > E
                    ? (L = E)
                    : 0 > L && (L = E + (L % E));
                  null === H &&
                    ((H = new c(M + Math.cos(J) * P, N + Math.sin(J) * P, y)),
                    F.push(H),
                    (C += 0.01));
                  for (; C < 1 + O; )
                    (D = L * C + J),
                      (B = M + Math.cos(D) * P),
                      (D = N + Math.sin(D) * P),
                      H.points.push(new b(B, D, y)),
                      (C += 0.01);
                  D = L + J;
                  B = M + Math.cos(D) * P;
                  D = N + Math.sin(D) * P;
                  H.points.push(new b(B, D, y));
                  break;
                case d.FILL_RECT:
                  u.batchFillRect(x[++I], x[++I], x[++I], x[++I], v, r);
                  break;
                case d.FILL_TRIANGLE:
                  u.batchFillTriangle(
                    x[++I],
                    x[++I],
                    x[++I],
                    x[++I],
                    x[++I],
                    x[++I],
                    v,
                    r
                  );
                  break;
                case d.STROKE_TRIANGLE:
                  u.batchStrokeTriangle(
                    x[++I],
                    x[++I],
                    x[++I],
                    x[++I],
                    x[++I],
                    x[++I],
                    y,
                    v,
                    r
                  );
                  break;
                case d.LINE_TO:
                  null !== H
                    ? H.points.push(new b(x[++I], x[++I], y))
                    : ((H = new c(x[++I], x[++I], y)), F.push(H));
                  break;
                case d.MOVE_TO:
                  H = new c(x[++I], x[++I], y);
                  F.push(H);
                  break;
                case d.SAVE:
                  f.push(v.copyToArray());
                  break;
                case d.RESTORE:
                  v.copyFromArray(f.pop());
                  break;
                case d.TRANSLATE:
                  M = x[++I];
                  N = x[++I];
                  v.translate(M, N);
                  break;
                case d.SCALE:
                  M = x[++I];
                  N = x[++I];
                  v.scale(M, N);
                  break;
                case d.ROTATE:
                  v.rotate(x[++I]);
              }
            m.pipelines.postBatch(n);
          }
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1066);
        a = a(1067);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          k.addToRenderList(d);
          d.pipeline.batchSprite(d, k, e);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          k.addToRenderList(d);
          a.batchSprite(d, d.frame, k, e);
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1069);
        a = a(1070);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          k.addToRenderList(d);
          this.pipeline.batchSprite(d, k, e);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          k.addToRenderList(d);
          a.batchSprite(d, d.frame, k, e);
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1072);
        a = a(1073);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          var e = d.list,
            b = e.length;
          if (0 !== b) {
            d.depthSort();
            a.pipelines.preBatch(d);
            var c = -1 !== d.blendMode;
            c || a.setBlendMode(0);
            for (var f = d.alpha, g = 0; g < b; g++) {
              var m = e[g];
              if (m.willRender(k)) {
                if (void 0 !== m.alphaTopLeft) {
                  var n = m.alphaTopLeft;
                  var q = m.alphaTopRight;
                  var r = m.alphaBottomLeft;
                  var u = m.alphaBottomRight;
                } else r = q = n = u = m.alpha;
                c ||
                  m.blendMode === a.currentBlendMode ||
                  a.setBlendMode(m.blendMode);
                var v = m.mask;
                v && v.preRenderWebGL(a, m, k);
                var x = m.type;
                x !== a.currentType && ((a.newType = !0), (a.currentType = x));
                a.nextTypeMatch =
                  g < b - 1 ? e[g + 1].type === a.currentType : !1;
                m.setAlpha(n * f, q * f, r * f, u * f);
                m.renderWebGL(a, m, k);
                m.setAlpha(n, q, r, u);
                v && v.postRenderWebGL(a, k);
                a.newType = !1;
              }
            }
            a.pipelines.postBatch(d);
          }
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          var e = d.list;
          if (0 !== e.length) {
            d.depthSort();
            var b = -1 !== d.blendMode;
            b || a.setBlendMode(0);
            var c = d._alpha;
            d.mask && d.mask.preRenderCanvas(a, null, k);
            for (var f = 0; f < e.length; f++) {
              var g = e[f];
              if (g.willRender(k)) {
                var m = g.alpha;
                b ||
                  g.blendMode === a.currentBlendMode ||
                  a.setBlendMode(g.blendMode);
                g.setAlpha(m * c);
                g.renderCanvas(a, g, k);
                g.setAlpha(m);
              }
            }
            d.mask && d.mask.postRenderCanvas(a);
          }
        };
      },
      function (h, t, a) {
        h.exports = {
          EmitterOp: a(449),
          GravityWell: a(450),
          Particle: a(451),
          ParticleEmitter: a(452),
          ParticleEmitterManager: a(220),
          Zones: a(1078),
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1076);
        a = a(1077);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        t = a(25);
        var d = a(12),
          k = new t(),
          e = new t(),
          b = new t(),
          c = new t();
        h.exports = function (f, g, m, n) {
          var q = g.emitters.list,
            r = q.length;
          if (0 !== r) {
            var u = f.pipelines.set(g.pipeline);
            n
              ? (c.loadIdentity(),
                c.multiply(n),
                c.translate(g.x, g.y),
                c.rotate(g.rotation),
                c.scale(g.scaleX, g.scaleY))
              : c.applyITRS(g.x, g.y, g.rotation, g.scaleX, g.scaleY);
            n = m.roundPixels;
            var v = g.defaultFrame.glTexture,
              x = d.getTintAppendFloatAlpha,
              y = u.setGameObject(g, g.defaultFrame);
            f.pipelines.preBatch(g);
            for (var z = 0; z < r; z++) {
              var A = q[z],
                B = A.alive,
                D = B.length;
              if (A.visible && 0 !== D) {
                m.addToRenderList(A);
                var E = A.scrollFactorX,
                  C = A.scrollFactorY;
                f.setBlendMode(A.blendMode);
                A.mask &&
                  (A.mask.preRenderWebGL(f, A, m), f.pipelines.set(g.pipeline));
                for (var F = 0; F < D; F++) {
                  var G = B[F],
                    H = G.alpha * m.alpha;
                  if (!(0 >= H)) {
                    b.applyITRS(G.x, G.y, G.rotation, G.scaleX, G.scaleY);
                    k.copyFrom(m.matrix);
                    k.multiplyWithOffset(c, -m.scrollX * E, -m.scrollY * C);
                    b.e = G.x;
                    b.f = G.y;
                    k.multiply(b, e);
                    var K = G.frame,
                      I = -K.halfWidth,
                      M = -K.halfHeight,
                      N = I + K.width,
                      P = M + K.height,
                      J = e.getXRound(I, M, n),
                      L = e.getYRound(I, M, n),
                      O = e.getXRound(I, P, n);
                    I = e.getYRound(I, P, n);
                    var Q = e.getXRound(N, P, n);
                    P = e.getYRound(N, P, n);
                    var S = e.getXRound(N, M, n);
                    M = e.getYRound(N, M, n);
                    G = x(G.tint, H);
                    u.batchQuad(
                      A,
                      J,
                      L,
                      O,
                      I,
                      Q,
                      P,
                      S,
                      M,
                      K.u0,
                      K.v0,
                      K.u1,
                      K.v1,
                      G,
                      G,
                      G,
                      G,
                      0,
                      v,
                      y
                    );
                  }
                }
                A.mask && A.mask.postRenderWebGL(f, m);
              }
            }
            f.pipelines.postBatch(g);
          }
        };
      },
      function (h, t, a) {
        t = a(25);
        var d = new t(),
          k = new t(),
          e = new t(),
          b = new t();
        h.exports = function (c, f, g, m) {
          var n = f.emitters.list,
            q = n.length;
          if (0 !== q) {
            var r = d.copyFrom(g.matrix);
            m
              ? (b.loadIdentity(),
                b.multiply(m),
                b.translate(f.x, f.y),
                b.rotate(f.rotation),
                b.scale(f.scaleX, f.scaleY))
              : b.applyITRS(f.x, f.y, f.rotation, f.scaleX, f.scaleY);
            f = c.currentContext;
            m = g.roundPixels;
            for (var u = 0; u < q; u++) {
              var v = n[u],
                x = v.alive,
                y = x.length;
              if (v.visible && 0 !== y) {
                g.addToRenderList(v);
                var z = v.scrollFactorX,
                  A = v.scrollFactorY;
                f.save();
                f.globalCompositeOperation = c.blendModes[v.blendMode];
                for (v = 0; v < y; v++) {
                  var B = x[v],
                    D = B.alpha * g.alpha;
                  if (!(0 >= D)) {
                    e.applyITRS(B.x, B.y, B.rotation, B.scaleX, B.scaleY);
                    r.copyFrom(g.matrix);
                    r.multiplyWithOffset(b, -g.scrollX * z, -g.scrollY * A);
                    e.e = B.x;
                    e.f = B.y;
                    r.multiply(e, k);
                    B = B.frame;
                    var E = B.canvasData,
                      C = -B.halfWidth,
                      F = -B.halfHeight;
                    f.globalAlpha = D;
                    f.save();
                    k.setToContext(f);
                    m && ((C = Math.round(C)), (F = Math.round(F)));
                    f.imageSmoothingEnabled = !(
                      !c.antialias || B.source.scaleMode
                    );
                    f.drawImage(
                      B.source.image,
                      E.x,
                      E.y,
                      E.width,
                      E.height,
                      C,
                      F,
                      E.width,
                      E.height
                    );
                    f.restore();
                  }
                }
                f.restore();
              }
            }
          }
        };
      },
      function (h, t, a) {
        h.exports = {
          DeathZone: a(453),
          EdgeZone: a(454),
          RandomZone: a(456),
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1080);
        a = a(1081);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(12);
        h.exports = function (k, e, b, c) {
          b.addToRenderList(e);
          var f = b.alpha,
            g = e.renderTarget,
            m = g.width,
            n = g.height,
            q = d.getTintAppendFloatAlpha,
            r = k.pipelines.set(e.pipeline),
            u = r.setTexture2D(g.texture);
          k.pipelines.preBatch(e);
          r.batchTexture(
            e,
            g.texture,
            m,
            n,
            e.x,
            e.y,
            m,
            n,
            e.scaleX,
            e.scaleY,
            e.rotation,
            e.flipX,
            !e.flipY,
            e.scrollFactorX,
            e.scrollFactorY,
            e.displayOriginX,
            e.displayOriginY,
            0,
            0,
            m,
            n,
            q(e.tintTopLeft, f * e._alphaTL),
            q(e.tintTopRight, f * e._alphaTR),
            q(e.tintBottomLeft, f * e._alphaBL),
            q(e.tintBottomRight, f * e._alphaBR),
            e.tintFill,
            0,
            0,
            b,
            c,
            !0,
            u
          );
          k.resetTextures();
          k.pipelines.postBatch(e);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          k.addToRenderList(d);
          a.batchSprite(d, d.frame, k, e);
        };
      },
      function (h, t, a) {
        t = a(1083);
        var d = a(17);
        a = {
          Parse: a(1084),
        };
        a = d(!1, a, t);
        h.exports = a;
      },
      function (h, t) {
        h.exports = {
          TEXT_SET1:
            " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
          TEXT_SET2:
            " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          TEXT_SET3: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ",
          TEXT_SET4: "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789",
          TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789",
          TEXT_SET6: "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ",
          TEXT_SET7: "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39",
          TEXT_SET8: "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          TEXT_SET9: "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!",
          TEXT_SET10: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          TEXT_SET11: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789",
        };
      },
      function (h, t, a) {
        var d = a(6);
        h.exports = function (k, e) {
          var b = e.width,
            c = e.height,
            f = Math.floor(b / 2),
            g = Math.floor(c / 2),
            m = d(e, "chars", "");
          if ("" !== m) {
            var n = d(e, "image", ""),
              q = k.sys.textures.getFrame(n);
            k = q.cutX;
            var r = q.cutY,
              u = q.source.width;
            q = q.source.height;
            var v = d(e, "offset.x", 0),
              x = d(e, "offset.y", 0),
              y = d(e, "spacing.x", 0),
              z = d(e, "spacing.y", 0),
              A = d(e, "lineSpacing", 0);
            e = d(e, "charsPerRow", null);
            null === e && ((e = u / b), e > m.length && (e = m.length));
            var B = v;
            A = {
              retroFont: !0,
              font: n,
              size: b,
              lineHeight: c + A,
              chars: {},
            };
            for (var D = 0, E = 0; E < m.length; E++) {
              var C = m.charCodeAt(E);
              A.chars[C] = {
                x: B,
                y: x,
                width: b,
                height: c,
                centerX: f,
                centerY: g,
                xOffset: 0,
                yOffset: 0,
                xAdvance: b,
                data: {},
                kerning: {},
                u0: (k + B) / u,
                v0: (r + x) / q,
                u1: (k + B + b) / u,
                v1: (r + x + c) / q,
              };
              D++;
              D === e ? ((D = 0), (B = v), (x += c + z)) : (B += b + y);
            }
            return {
              data: A,
              frame: null,
              texture: n,
            };
          }
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1086);
        a = a(1087);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(19),
          k = a(12);
        h.exports = function (e, b, c, f) {
          c.addToRenderList(b);
          var g = e.pipelines.set(b.pipeline, b);
          f = d(b, c, f).calc;
          var m = b.vertices,
            n = b.uv,
            q = b.colors,
            r = b.alphas,
            u = b.alpha,
            v = k.getTintAppendFloatAlpha,
            x = c.roundPixels,
            y = m.length,
            z = Math.floor(0.5 * y);
          g.flush();
          e.pipelines.preBatch(b);
          var A = g.setGameObject(b),
            B = g.vertexViewF32,
            D = g.vertexViewU32,
            E = g.vertexCount * g.currentShader.vertexComponentCount - 1,
            C = 0,
            F = b.tintFill;
          b.dirty && b.updateVertices();
          for (var G = b.debugCallback, H = [], K = 0; K < y; K += 2) {
            var I = m[K + 0],
              M = m[K + 1],
              N = I * f.a + M * f.c + f.e;
            I = I * f.b + M * f.d + f.f;
            x && ((N = Math.round(N)), (I = Math.round(I)));
            B[++E] = N;
            B[++E] = I;
            B[++E] = n[K + 0];
            B[++E] = n[K + 1];
            B[++E] = A;
            B[++E] = F;
            D[++E] = v(q[C], c.alpha * r[C] * u);
            C++;
            G && ((H[K + 0] = N), (H[K + 1] = I));
          }
          G && G.call(b, b, y, H);
          g.vertexCount += z;
          e.pipelines.postBatch(b);
        };
      },
      function (h, t) {
        h.exports = function () {};
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1089);
        a = a(1090);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(12);
        h.exports = function (k, e, b, c) {
          if (0 !== e.width && 0 !== e.height) {
            b.addToRenderList(e);
            var f = e.frame,
              g = f.width,
              m = f.height,
              n = d.getTintAppendFloatAlpha,
              q = k.pipelines.set(e.pipeline, e),
              r = q.setTexture2D(f.glTexture, e);
            k.pipelines.preBatch(e);
            q.batchTexture(
              e,
              f.glTexture,
              g,
              m,
              e.x,
              e.y,
              g / e.style.resolution,
              m / e.style.resolution,
              e.scaleX,
              e.scaleY,
              e.rotation,
              e.flipX,
              e.flipY,
              e.scrollFactorX,
              e.scrollFactorY,
              e.displayOriginX,
              e.displayOriginY,
              0,
              0,
              g,
              m,
              n(e.tintTopLeft, b.alpha * e._alphaTL),
              n(e.tintTopRight, b.alpha * e._alphaTR),
              n(e.tintBottomLeft, b.alpha * e._alphaBL),
              n(e.tintBottomRight, b.alpha * e._alphaBR),
              e.tintFill,
              0,
              0,
              b,
              c,
              !1,
              r
            );
            k.pipelines.postBatch(e);
          }
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          0 !== d.width &&
            0 !== d.height &&
            (k.addToRenderList(d), a.batchSprite(d, d.frame, k, e));
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1092);
        a = a(1093);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(12);
        h.exports = function (k, e, b, c) {
          e.updateCanvas();
          var f = e.width,
            g = e.height;
          if (0 !== f && 0 !== g) {
            b.addToRenderList(e);
            k.pipelines.preBatch(e);
            var m = d.getTintAppendFloatAlpha,
              n = k.pipelines.set(e.pipeline, e),
              q = n.setTexture2D(e.fillPattern, e);
            n.batchTexture(
              e,
              e.fillPattern,
              e.displayFrame.width * e.tileScaleX,
              e.displayFrame.height * e.tileScaleY,
              e.x,
              e.y,
              f,
              g,
              e.scaleX,
              e.scaleY,
              e.rotation,
              e.flipX,
              e.flipY,
              e.scrollFactorX,
              e.scrollFactorY,
              e.originX * f,
              e.originY * g,
              0,
              0,
              f,
              g,
              m(e.tintTopLeft, b.alpha * e._alphaTL),
              m(e.tintTopRight, b.alpha * e._alphaTR),
              m(e.tintBottomLeft, b.alpha * e._alphaBL),
              m(e.tintBottomRight, b.alpha * e._alphaBR),
              e.tintFill,
              (e.tilePositionX % e.displayFrame.width) / e.displayFrame.width,
              (e.tilePositionY % e.displayFrame.height) / e.displayFrame.height,
              b,
              c,
              !1,
              q
            );
            k.pipelines.postBatch(e);
          }
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          d.updateCanvas();
          k.addToRenderList(d);
          a.batchSprite(d, d.frame, k, e);
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1095);
        a = a(1096);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          d.videoTexture &&
            (k.addToRenderList(d), d.pipeline.batchSprite(d, k, e));
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          d.videoTexture &&
            (k.addToRenderList(d), a.batchSprite(d, d.frame, k, e));
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1098);
        a = a(1099);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(19),
          k = a(114),
          e = a(81);
        h.exports = function (b, c, f, g) {
          f.addToRenderList(c);
          var m = b.pipelines.set(c.pipeline);
          g = d(c, f, g);
          g = m.calcMatrix.copyFrom(g.calc);
          var n = c._displayOriginX,
            q = c._displayOriginY;
          f = f.alpha * c.alpha;
          b.pipelines.preBatch(c);
          c.isFilled && k(m, g, c, f, n, q);
          c.isStroked && e(m, c, f, n, q);
          b.pipelines.postBatch(c);
        };
      },
      function (h, t, a) {
        var d = a(36),
          k = a(48),
          e = a(60),
          b = a(30);
        h.exports = function (c, f, g, m) {
          g.addToRenderList(f);
          var n = c.currentContext;
          b(c, n, f, g, m) &&
            ((c = f.radius),
            n.beginPath(),
            n.arc(
              c - 2 * f.originX * c,
              c - 2 * f.originY * c,
              c,
              d(f._startAngle),
              d(f._endAngle),
              f.anticlockwise
            ),
            f.closePath && n.closePath(),
            f.isFilled && (k(n, f), n.fill()),
            f.isStroked && (e(n, f), n.stroke()),
            n.restore());
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1101);
        a = a(1102);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(114),
          k = a(19),
          e = a(81);
        h.exports = function (b, c, f, g) {
          f.addToRenderList(c);
          var m = b.pipelines.set(c.pipeline);
          g = k(c, f, g);
          g = m.calcMatrix.copyFrom(g.calc);
          var n = c._displayOriginX + c._curveBounds.x,
            q = c._displayOriginY + c._curveBounds.y;
          f = f.alpha * c.alpha;
          b.pipelines.preBatch(c);
          c.isFilled && d(m, g, c, f, n, q);
          c.isStroked && e(m, c, f, n, q);
          b.pipelines.postBatch(c);
        };
      },
      function (h, t, a) {
        var d = a(48),
          k = a(60),
          e = a(30);
        h.exports = function (b, c, f, g) {
          f.addToRenderList(c);
          var m = b.currentContext;
          if (e(b, m, c, f, g)) {
            b = c._displayOriginX + c._curveBounds.x;
            f = c._displayOriginY + c._curveBounds.y;
            g = c.pathData;
            var n = g.length - 1,
              q = g[0] - b,
              r = g[1] - f;
            m.beginPath();
            m.moveTo(q, r);
            c.closePath || (n -= 2);
            for (q = 2; q < n; q += 2) m.lineTo(g[q] - b, g[q + 1] - f);
            c.closePath && m.closePath();
            c.isFilled && (d(m, c), m.fill());
            c.isStroked && (k(m, c), m.stroke());
            m.restore();
          }
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1104);
        a = a(1105);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(114),
          k = a(19),
          e = a(81);
        h.exports = function (b, c, f, g) {
          f.addToRenderList(c);
          var m = b.pipelines.set(c.pipeline);
          g = k(c, f, g);
          g = m.calcMatrix.copyFrom(g.calc);
          var n = c._displayOriginX,
            q = c._displayOriginY;
          f = f.alpha * c.alpha;
          b.pipelines.preBatch(c);
          c.isFilled && d(m, g, c, f, n, q);
          c.isStroked && e(m, c, f, n, q);
          b.pipelines.postBatch(c);
        };
      },
      function (h, t, a) {
        var d = a(48),
          k = a(60),
          e = a(30);
        h.exports = function (b, c, f, g) {
          f.addToRenderList(c);
          var m = b.currentContext;
          if (e(b, m, c, f, g)) {
            b = c._displayOriginX;
            f = c._displayOriginY;
            g = c.pathData;
            var n = g.length - 1,
              q = g[0] - b,
              r = g[1] - f;
            m.beginPath();
            m.moveTo(q, r);
            c.closePath || (n -= 2);
            for (q = 2; q < n; q += 2) m.lineTo(g[q] - b, g[q + 1] - f);
            m.closePath();
            c.isFilled && (d(m, c), m.fill());
            c.isStroked && (k(m, c), m.stroke());
            m.restore();
          }
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1107);
        a = a(1108);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(19),
          k = a(12);
        h.exports = function (e, b, c, f) {
          c.addToRenderList(b);
          var g = e.pipelines.set(b.pipeline);
          f = d(b, c, f);
          g.calcMatrix
            .copyFrom(f.calc)
            .translate(-b._displayOriginX, -b._displayOriginY);
          var m = c.alpha * b.alpha;
          c = b.width;
          var n = b.height,
            q = b.cellWidth;
          f = b.cellHeight;
          var r = Math.ceil(c / q),
            u = Math.ceil(n / f),
            v = q,
            x = f,
            y = q - (r * q - c),
            z = f - (u * f - n);
          var A = b.showCells;
          var B = b.showAltCells,
            D = b.showOutline,
            E = 0;
          D && (v--, x--, y === q && y--, z === f && z--);
          e.pipelines.preBatch(b);
          if (A && 0 < b.fillAlpha) {
            A = g.fillTint;
            var C = k.getTintAppendFloatAlpha(b.fillColor, b.fillAlpha * m);
            A.TL = C;
            A.TR = C;
            A.BL = C;
            A.BR = C;
            for (C = 0; C < u; C++)
              for (B && (E = C % 2), A = 0; A < r; A++)
                if (B && E) E = 0;
                else {
                  E++;
                  var F = A < r - 1 ? v : y;
                  var G = C < u - 1 ? x : z;
                  g.batchFillRect(A * q, C * f, F, G);
                }
          }
          if (B && 0 < b.altFillAlpha)
            for (
              A = g.fillTint,
                C = k.getTintAppendFloatAlpha(
                  b.altFillColor,
                  b.altFillAlpha * m
                ),
                A.TL = C,
                A.TR = C,
                A.BL = C,
                A.BR = C,
                C = 0;
              C < u;
              C++
            )
              for (B && (E = C % 2), A = 0; A < r; A++)
                B && !E
                  ? (E = 1)
                  : ((E = 0),
                    (F = A < r - 1 ? v : y),
                    (G = C < u - 1 ? x : z),
                    g.batchFillRect(A * q, C * f, F, G));
          if (D && 0 < b.outlineFillAlpha) {
            v = g.strokeTint;
            m = k.getTintAppendFloatAlpha(
              b.outlineFillColor,
              b.outlineFillAlpha * m
            );
            v.TL = m;
            v.TR = m;
            v.BL = m;
            v.BR = m;
            for (A = 1; A < r; A++)
              (m = A * q), g.batchLine(m, 0, m, n, 1, 1, 1, 0, !1);
            for (C = 1; C < u; C++)
              (n = C * f), g.batchLine(0, n, c, n, 1, 1, 1, 0, !1);
          }
          e.pipelines.postBatch(b);
        };
      },
      function (h, t, a) {
        var d = a(48),
          k = a(60),
          e = a(30);
        h.exports = function (b, c, f, g) {
          f.addToRenderList(c);
          var m = b.currentContext;
          if (e(b, m, c, f, g)) {
            b = -c._displayOriginX;
            g = -c._displayOriginY;
            var n = f.alpha * c.alpha;
            f = c.width;
            var q = c.height,
              r = c.cellWidth,
              u = c.cellHeight,
              v = Math.ceil(f / r),
              x = Math.ceil(q / u),
              y = r,
              z = u,
              A = r - (v * r - f),
              B = u - (x * u - q),
              D = c.showCells,
              E = c.showAltCells,
              C = c.showOutline,
              F,
              G = 0;
            C && (y--, z--, A === r && A--, B === u && B--);
            if (D && 0 < c.fillAlpha)
              for (d(m, c), F = 0; F < x; F++)
                for (E && (G = F % 2), D = 0; D < v; D++)
                  if (E && G) G = 0;
                  else {
                    G++;
                    var H = D < v - 1 ? y : A;
                    var K = F < x - 1 ? z : B;
                    m.fillRect(b + D * r, g + F * u, H, K);
                  }
            if (E && 0 < c.altFillAlpha)
              for (
                d(m, c, c.altFillColor, c.altFillAlpha * n), F = 0;
                F < x;
                F++
              )
                for (E && (G = F % 2), D = 0; D < v; D++)
                  E && !G
                    ? (G = 1)
                    : ((G = 0),
                      (H = D < v - 1 ? y : A),
                      (K = F < x - 1 ? z : B),
                      m.fillRect(b + D * r, g + F * u, H, K));
            if (C && 0 < c.outlineFillAlpha) {
              k(m, c, c.outlineFillColor, c.outlineFillAlpha * n);
              for (D = 1; D < v; D++)
                (c = D * r),
                  m.beginPath(),
                  m.moveTo(c + b, g),
                  m.lineTo(c + b, q + g),
                  m.stroke();
              for (F = 1; F < x; F++)
                (c = F * u),
                  m.beginPath(),
                  m.moveTo(b, c + g),
                  m.lineTo(b + f, c + g),
                  m.stroke();
            }
            m.restore();
          }
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1110);
        a = a(1111);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(19),
          k = a(12);
        h.exports = function (e, b, c, f) {
          c.addToRenderList(b);
          var g = e.pipelines.set(b.pipeline);
          f = d(b, c, f);
          f = g.calcMatrix.copyFrom(f.calc);
          var m = b.width,
            n = b.height,
            q = m / 2;
          m /= b.projection;
          c = c.alpha * b.alpha;
          if (b.isFilled) {
            e.pipelines.preBatch(b);
            if (b.showTop) {
              var r = k.getTintAppendFloatAlpha(b.fillTop, c);
              var u = f.getX(-q, -n);
              var v = f.getY(-q, -n);
              var x = f.getX(0, -m - n);
              var y = f.getY(0, -m - n);
              var z = f.getX(q, -n);
              var A = f.getY(q, -n);
              var B = f.getX(0, m - n);
              var D = f.getY(0, m - n);
              g.batchQuad(b, u, v, x, y, z, A, B, D, 0, 0, 1, 1, r, r, r, r, 2);
            }
            b.showLeft &&
              ((r = k.getTintAppendFloatAlpha(b.fillLeft, c)),
              (u = f.getX(-q, 0)),
              (v = f.getY(-q, 0)),
              (x = f.getX(0, m)),
              (y = f.getY(0, m)),
              (z = f.getX(0, m - n)),
              (A = f.getY(0, m - n)),
              (B = f.getX(-q, -n)),
              (D = f.getY(-q, -n)),
              g.batchQuad(
                b,
                u,
                v,
                x,
                y,
                z,
                A,
                B,
                D,
                0,
                0,
                1,
                1,
                r,
                r,
                r,
                r,
                2
              ));
            b.showRight &&
              ((r = k.getTintAppendFloatAlpha(b.fillRight, c)),
              (u = f.getX(q, 0)),
              (v = f.getY(q, 0)),
              (x = f.getX(0, m)),
              (y = f.getY(0, m)),
              (z = f.getX(0, m - n)),
              (A = f.getY(0, m - n)),
              (B = f.getX(q, -n)),
              (D = f.getY(q, -n)),
              g.batchQuad(
                b,
                u,
                v,
                x,
                y,
                z,
                A,
                B,
                D,
                0,
                0,
                1,
                1,
                r,
                r,
                r,
                r,
                2
              ));
            e.pipelines.postBatch(b);
          }
        };
      },
      function (h, t, a) {
        var d = a(48),
          k = a(30);
        h.exports = function (e, b, c, f) {
          c.addToRenderList(b);
          var g = e.currentContext;
          k(e, g, b, c, f) &&
            b.isFilled &&
            ((f = b.width),
            (e = b.height),
            (c = f / 2),
            (f /= b.projection),
            b.showTop &&
              (d(g, b, b.fillTop),
              g.beginPath(),
              g.moveTo(-c, -e),
              g.lineTo(0, -f - e),
              g.lineTo(c, -e),
              g.lineTo(c, -1),
              g.lineTo(0, f - 1),
              g.lineTo(-c, -1),
              g.lineTo(-c, -e),
              g.fill()),
            b.showLeft &&
              (d(g, b, b.fillLeft),
              g.beginPath(),
              g.moveTo(-c, 0),
              g.lineTo(0, f),
              g.lineTo(0, f - e),
              g.lineTo(-c, -e),
              g.lineTo(-c, 0),
              g.fill()),
            b.showRight &&
              (d(g, b, b.fillRight),
              g.beginPath(),
              g.moveTo(c, 0),
              g.lineTo(0, f),
              g.lineTo(0, f - e),
              g.lineTo(c, -e),
              g.lineTo(c, 0),
              g.fill()),
            g.restore());
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1113);
        a = a(1114);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(19),
          k = a(12);
        h.exports = function (e, b, c, f) {
          c.addToRenderList(b);
          var g = e.pipelines.set(b.pipeline);
          f = d(b, c, f);
          f = g.calcMatrix.copyFrom(f.calc);
          var m = b.width,
            n = b.height,
            q = m / 2;
          m /= b.projection;
          var r = b.isReversed;
          c = c.alpha * b.alpha;
          if (b.isFilled) {
            e.pipelines.preBatch(b);
            if (b.showTop && r) {
              var u = k.getTintAppendFloatAlpha(b.fillTop, c);
              var v = f.getX(-q, -n);
              var x = f.getY(-q, -n);
              var y = f.getX(0, -m - n);
              var z = f.getY(0, -m - n);
              var A = f.getX(q, -n);
              var B = f.getY(q, -n);
              var D = f.getX(0, m - n),
                E = f.getY(0, m - n);
              g.batchQuad(b, v, x, y, z, A, B, D, E, 0, 0, 1, 1, u, u, u, u, 2);
            }
            b.showLeft &&
              ((u = k.getTintAppendFloatAlpha(b.fillLeft, c)),
              r
                ? ((v = f.getX(-q, -n)), (x = f.getY(-q, -n)))
                : ((v = f.getX(-q, 0)), (x = f.getY(-q, 0))),
              (y = f.getX(0, m)),
              (z = f.getY(0, m)),
              (A = f.getX(0, m - n)),
              (B = f.getY(0, m - n)),
              g.batchTri(b, v, x, y, z, A, B, 0, 0, 1, 1, u, u, u, 2));
            b.showRight &&
              ((u = k.getTintAppendFloatAlpha(b.fillRight, c)),
              r
                ? ((v = f.getX(q, -n)), (x = f.getY(q, -n)))
                : ((v = f.getX(q, 0)), (x = f.getY(q, 0))),
              (y = f.getX(0, m)),
              (z = f.getY(0, m)),
              (A = f.getX(0, m - n)),
              (B = f.getY(0, m - n)),
              g.batchTri(b, v, x, y, z, A, B, 0, 0, 1, 1, u, u, u, 2));
            e.pipelines.postBatch(b);
          }
        };
      },
      function (h, t, a) {
        var d = a(48),
          k = a(30);
        h.exports = function (e, b, c, f) {
          c.addToRenderList(b);
          var g = e.currentContext;
          if (k(e, g, b, c, f) && b.isFilled) {
            f = b.width;
            e = b.height;
            c = f / 2;
            f /= b.projection;
            var m = b.isReversed;
            b.showTop &&
              m &&
              (d(g, b, b.fillTop),
              g.beginPath(),
              g.moveTo(-c, -e),
              g.lineTo(0, -f - e),
              g.lineTo(c, -e),
              g.lineTo(0, f - e),
              g.fill());
            b.showLeft &&
              (d(g, b, b.fillLeft),
              g.beginPath(),
              m ? g.moveTo(-c, -e) : g.moveTo(-c, 0),
              g.lineTo(0, f),
              g.lineTo(0, f - e),
              g.fill());
            b.showRight &&
              (d(g, b, b.fillRight),
              g.beginPath(),
              m ? g.moveTo(c, -e) : g.moveTo(c, 0),
              g.lineTo(0, f),
              g.lineTo(0, f - e),
              g.fill());
            g.restore();
          }
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1116);
        a = a(1117);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(19),
          k = a(12);
        h.exports = function (e, b, c, f) {
          c.addToRenderList(b);
          var g = e.pipelines.set(b.pipeline);
          f = d(b, c, f);
          g.calcMatrix.copyFrom(f.calc);
          var m = b._displayOriginX,
            n = b._displayOriginY,
            q = c.alpha * b.alpha;
          e.pipelines.preBatch(b);
          b.isStroked &&
            ((c = g.strokeTint),
            (q = k.getTintAppendFloatAlpha(b.strokeColor, b.strokeAlpha * q)),
            (c.TL = q),
            (c.TR = q),
            (c.BL = q),
            (c.BR = q),
            g.batchLine(
              b.geom.x1 - m,
              b.geom.y1 - n,
              b.geom.x2 - m,
              b.geom.y2 - n,
              b._startWidth,
              b._endWidth,
              1,
              0,
              !1,
              f.sprite,
              f.camera
            ));
          e.pipelines.postBatch(b);
        };
      },
      function (h, t, a) {
        var d = a(60),
          k = a(30);
        h.exports = function (e, b, c, f) {
          c.addToRenderList(b);
          var g = e.currentContext;
          k(e, g, b, c, f) &&
            ((e = b._displayOriginX),
            (c = b._displayOriginY),
            b.isStroked &&
              (d(g, b),
              g.beginPath(),
              g.moveTo(b.geom.x1 - e, b.geom.y1 - c),
              g.lineTo(b.geom.x2 - e, b.geom.y2 - c),
              g.stroke()),
            g.restore());
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1119);
        a = a(1120);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(114),
          k = a(19),
          e = a(81);
        h.exports = function (b, c, f, g) {
          f.addToRenderList(c);
          var m = b.pipelines.set(c.pipeline);
          g = k(c, f, g);
          g = m.calcMatrix.copyFrom(g.calc);
          var n = c._displayOriginX,
            q = c._displayOriginY;
          f = f.alpha * c.alpha;
          b.pipelines.preBatch(c);
          c.isFilled && d(m, g, c, f, n, q);
          c.isStroked && e(m, c, f, n, q);
          b.pipelines.postBatch(c);
        };
      },
      function (h, t, a) {
        var d = a(48),
          k = a(60),
          e = a(30);
        h.exports = function (b, c, f, g) {
          f.addToRenderList(c);
          var m = b.currentContext;
          if (e(b, m, c, f, g)) {
            b = c._displayOriginX;
            f = c._displayOriginY;
            g = c.pathData;
            var n = g.length - 1,
              q = g[0] - b,
              r = g[1] - f;
            m.beginPath();
            m.moveTo(q, r);
            c.closePath || (n -= 2);
            for (q = 2; q < n; q += 2) m.lineTo(g[q] - b, g[q + 1] - f);
            m.closePath();
            c.isFilled && (d(m, c), m.fill());
            c.isStroked && (k(m, c), m.stroke());
            m.restore();
          }
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1122);
        a = a(1123);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(19),
          k = a(81),
          e = a(12);
        h.exports = function (b, c, f, g) {
          f.addToRenderList(c);
          var m = b.pipelines.set(c.pipeline);
          g = d(c, f, g);
          m.calcMatrix.copyFrom(g.calc);
          g = c._displayOriginX;
          var n = c._displayOriginY;
          f = f.alpha * c.alpha;
          b.pipelines.preBatch(c);
          if (c.isFilled) {
            var q = m.fillTint,
              r = e.getTintAppendFloatAlpha(c.fillColor, c.fillAlpha * f);
            q.TL = r;
            q.TR = r;
            q.BL = r;
            q.BR = r;
            m.batchFillRect(-g, -n, c.width, c.height);
          }
          c.isStroked && k(m, c, f, g, n);
          b.pipelines.postBatch(c);
        };
      },
      function (h, t, a) {
        var d = a(48),
          k = a(60),
          e = a(30);
        h.exports = function (b, c, f, g) {
          f.addToRenderList(c);
          var m = b.currentContext;
          e(b, m, c, f, g) &&
            ((b = c._displayOriginX),
            (f = c._displayOriginY),
            c.isFilled && (d(m, c), m.fillRect(-b, -f, c.width, c.height)),
            c.isStroked &&
              (k(m, c),
              m.beginPath(),
              m.rect(-b, -f, c.width, c.height),
              m.stroke()),
            m.restore());
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1125);
        a = a(1126);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(114),
          k = a(19),
          e = a(81);
        h.exports = function (b, c, f, g) {
          f.addToRenderList(c);
          var m = b.pipelines.set(c.pipeline);
          g = k(c, f, g);
          g = m.calcMatrix.copyFrom(g.calc);
          var n = c._displayOriginX,
            q = c._displayOriginY;
          f = f.alpha * c.alpha;
          b.pipelines.preBatch(c);
          c.isFilled && d(m, g, c, f, n, q);
          c.isStroked && e(m, c, f, n, q);
          b.pipelines.postBatch(c);
        };
      },
      function (h, t, a) {
        var d = a(48),
          k = a(60),
          e = a(30);
        h.exports = function (b, c, f, g) {
          f.addToRenderList(c);
          var m = b.currentContext;
          if (e(b, m, c, f, g)) {
            b = c._displayOriginX;
            f = c._displayOriginY;
            g = c.pathData;
            var n = g.length - 1,
              q = g[0] - b,
              r = g[1] - f;
            m.beginPath();
            m.moveTo(q, r);
            c.closePath || (n -= 2);
            for (q = 2; q < n; q += 2) m.lineTo(g[q] - b, g[q + 1] - f);
            m.closePath();
            c.isFilled && (d(m, c), m.fill());
            c.isStroked && (k(m, c), m.stroke());
            m.restore();
          }
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1128);
        a = a(1129);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(19),
          k = a(81),
          e = a(12);
        h.exports = function (b, c, f, g) {
          f.addToRenderList(c);
          var m = b.pipelines.set(c.pipeline);
          g = d(c, f, g);
          m.calcMatrix.copyFrom(g.calc);
          var n = c._displayOriginX,
            q = c._displayOriginY;
          f = f.alpha * c.alpha;
          b.pipelines.preBatch(c);
          if (c.isFilled) {
            var r = m.fillTint,
              u = e.getTintAppendFloatAlpha(c.fillColor, c.fillAlpha * f);
            r.TL = u;
            r.TR = u;
            r.BL = u;
            r.BR = u;
            m.batchFillTriangle(
              c.geom.x1 - n,
              c.geom.y1 - q,
              c.geom.x2 - n,
              c.geom.y2 - q,
              c.geom.x3 - n,
              c.geom.y3 - q,
              g.sprite,
              g.camera
            );
          }
          c.isStroked && k(m, c, f, n, q);
          b.pipelines.postBatch(c);
        };
      },
      function (h, t, a) {
        var d = a(48),
          k = a(60),
          e = a(30);
        h.exports = function (b, c, f, g) {
          f.addToRenderList(c);
          var m = b.currentContext;
          if (e(b, m, c, f, g)) {
            var n = c._displayOriginX,
              q = c._displayOriginY;
            b = c.geom.x1 - n;
            f = c.geom.y1 - q;
            g = c.geom.x2 - n;
            var r = c.geom.y2 - q;
            n = c.geom.x3 - n;
            q = c.geom.y3 - q;
            m.beginPath();
            m.moveTo(b, f);
            m.lineTo(g, r);
            m.lineTo(n, q);
            m.closePath();
            c.isFilled && (d(m, c), m.fill());
            c.isStroked && (k(m, c), m.stroke());
            m.restore();
          }
        };
      },
      function (h, t, a) {
        var d = a(213);
        a(5).register("blitter", function (k, e, b, c) {
          return this.displayList.add(new d(this.scene, k, e, b, c));
        });
      },
      function (h, t, a) {
        var d = a(214);
        a(5).register("container", function (k, e, b) {
          return this.displayList.add(new d(this.scene, k, e, b));
        });
      },
      function (h, t, a) {
        var d = a(442);
        a(5).register("dom", function (k, e, b, c, f) {
          k = new d(this.scene, k, e, b, c, f);
          this.displayList.add(k);
          return k;
        });
      },
      function (h, t, a) {
        var d = a(215);
        a(5).register("dynamicBitmapText", function (k, e, b, c, f) {
          return this.displayList.add(new d(this.scene, k, e, b, c, f));
        });
      },
      function (h, t, a) {
        var d = a(444);
        a(5).register("extern", function () {
          var k = new d(this.scene);
          this.displayList.add(k);
          return k;
        });
      },
      function (h, t, a) {
        var d = a(216);
        a(5).register("graphics", function (k) {
          return this.displayList.add(new d(this.scene, k));
        });
      },
      function (h, t, a) {
        var d = a(113);
        a(5).register("group", function (k, e) {
          return this.updateList.add(new d(this.scene, k, e));
        });
      },
      function (h, t, a) {
        var d = a(125);
        a(5).register("image", function (k, e, b, c) {
          return this.displayList.add(new d(this.scene, k, e, b, c));
        });
      },
      function (h, t, a) {
        var d = a(219);
        a(5).register("layer", function (k) {
          return this.displayList.add(new d(this.scene, k));
        });
      },
      function (h, t, a) {
        h = a(5);
        var d = a(220);
        h.register("particles", function (k, e, b) {
          return this.displayList.add(new d(this.scene, k, e, b));
        });
      },
      function (h, t, a) {
        h = a(5);
        var d = a(457);
        h.register("follower", function (k, e, b, c, f) {
          k = new d(this.scene, k, e, b, c, f);
          this.displayList.add(k);
          this.updateList.add(k);
          return k;
        });
      },
      function (h, t, a) {
        h = a(5);
        var d = a(221);
        h.register("renderTexture", function (k, e, b, c, f, g) {
          return this.displayList.add(new d(this.scene, k, e, b, c, f, g));
        });
      },
      function (h, t, a) {
        var d = a(223);
        a(5).register("rope", function (k, e, b, c, f, g, m, n) {
          return this.displayList.add(
            new d(this.scene, k, e, b, c, f, g, m, n)
          );
        });
      },
      function (h, t, a) {
        h = a(5);
        var d = a(73);
        h.register("sprite", function (k, e, b, c) {
          k = new d(this.scene, k, e, b, c);
          this.displayList.add(k);
          return k;
        });
      },
      function (h, t, a) {
        var d = a(148);
        a(5).register("bitmapText", function (k, e, b, c, f, g) {
          return this.displayList.add(new d(this.scene, k, e, b, c, f, g));
        });
      },
      function (h, t, a) {
        var d = a(224);
        a(5).register("text", function (k, e, b, c) {
          return this.displayList.add(new d(this.scene, k, e, b, c));
        });
      },
      function (h, t, a) {
        var d = a(225);
        a(5).register("tileSprite", function (k, e, b, c, f, g) {
          return this.displayList.add(new d(this.scene, k, e, b, c, f, g));
        });
      },
      function (h, t, a) {
        var d = a(129);
        a(5).register("zone", function (k, e, b, c) {
          return this.displayList.add(new d(this.scene, k, e, b, c));
        });
      },
      function (h, t, a) {
        var d = a(226);
        a(5).register("video", function (k, e, b) {
          return this.displayList.add(new d(this.scene, k, e, b));
        });
      },
      function (h, t, a) {
        var d = a(461);
        h = a(5);
        h.register("arc", function (k, e, b, c, f, g, m, n) {
          return this.displayList.add(
            new d(this.scene, k, e, b, c, f, g, m, n)
          );
        });
        h.register("circle", function (k, e, b, c, f) {
          return this.displayList.add(
            new d(this.scene, k, e, b, 0, 360, !1, c, f)
          );
        });
      },
      function (h, t, a) {
        h = a(5);
        var d = a(462);
        h.register("curve", function (k, e, b, c, f) {
          return this.displayList.add(new d(this.scene, k, e, b, c, f));
        });
      },
      function (h, t, a) {
        var d = a(463);
        a(5).register("ellipse", function (k, e, b, c, f, g) {
          return this.displayList.add(new d(this.scene, k, e, b, c, f, g));
        });
      },
      function (h, t, a) {
        h = a(5);
        var d = a(464);
        h.register("grid", function (k, e, b, c, f, g, m, n, q, r) {
          return this.displayList.add(
            new d(this.scene, k, e, b, c, f, g, m, n, q, r)
          );
        });
      },
      function (h, t, a) {
        h = a(5);
        var d = a(465);
        h.register("isobox", function (k, e, b, c, f, g, m) {
          return this.displayList.add(new d(this.scene, k, e, b, c, f, g, m));
        });
      },
      function (h, t, a) {
        h = a(5);
        var d = a(466);
        h.register("isotriangle", function (k, e, b, c, f, g, m, n) {
          return this.displayList.add(
            new d(this.scene, k, e, b, c, f, g, m, n)
          );
        });
      },
      function (h, t, a) {
        h = a(5);
        var d = a(467);
        h.register("line", function (k, e, b, c, f, g, m, n) {
          return this.displayList.add(
            new d(this.scene, k, e, b, c, f, g, m, n)
          );
        });
      },
      function (h, t, a) {
        h = a(5);
        var d = a(468);
        h.register("polygon", function (k, e, b, c, f) {
          return this.displayList.add(new d(this.scene, k, e, b, c, f));
        });
      },
      function (h, t, a) {
        h = a(5);
        var d = a(473);
        h.register("rectangle", function (k, e, b, c, f, g) {
          return this.displayList.add(new d(this.scene, k, e, b, c, f, g));
        });
      },
      function (h, t, a) {
        var d = a(474);
        a(5).register("star", function (k, e, b, c, f, g, m) {
          return this.displayList.add(new d(this.scene, k, e, b, c, f, g, m));
        });
      },
      function (h, t, a) {
        h = a(5);
        var d = a(475);
        h.register("triangle", function (k, e, b, c, f, g, m, n, q, r) {
          return this.displayList.add(
            new d(this.scene, k, e, b, c, f, g, m, n, q, r)
          );
        });
      },
      function (h, t, a) {
        var d = a(213),
          k = a(28);
        h = a(16);
        var e = a(13);
        h.register("blitter", function (b, c) {
          void 0 === b && (b = {});
          var f = e(b, "key", null),
            g = e(b, "frame", null);
          f = new d(this.scene, 0, 0, f, g);
          void 0 !== c && (b.add = c);
          k(this.scene, f, b);
          return f;
        });
      },
      function (h, t, a) {
        var d = a(28),
          k = a(214);
        h = a(16);
        var e = a(13);
        h.register("container", function (b, c) {
          void 0 === b && (b = {});
          var f = e(b, "x", 0),
            g = e(b, "y", 0),
            m = e(b, "children", null);
          f = new k(this.scene, f, g, m);
          void 0 !== c && (b.add = c);
          d(this.scene, f, b);
          return f;
        });
      },
      function (h, t, a) {
        var d = a(215),
          k = a(28);
        h = a(16);
        var e = a(13);
        h.register("dynamicBitmapText", function (b, c) {
          void 0 === b && (b = {});
          var f = e(b, "font", ""),
            g = e(b, "text", ""),
            m = e(b, "size", !1);
          f = new d(this.scene, 0, 0, f, g, m);
          void 0 !== c && (b.add = c);
          k(this.scene, f, b);
          return f;
        });
      },
      function (h, t, a) {
        h = a(16);
        var d = a(216);
        h.register("graphics", function (k, e) {
          void 0 === k && (k = {});
          void 0 !== e && (k.add = e);
          e = new d(this.scene, k);
          k.add && this.scene.sys.displayList.add(e);
          return e;
        });
      },
      function (h, t, a) {
        h = a(16);
        var d = a(113);
        h.register("group", function (k) {
          return new d(this.scene, null, k);
        });
      },
      function (h, t, a) {
        var d = a(28);
        h = a(16);
        var k = a(13),
          e = a(125);
        h.register("image", function (b, c) {
          void 0 === b && (b = {});
          var f = k(b, "key", null),
            g = k(b, "frame", null);
          f = new e(this.scene, 0, 0, f, g);
          void 0 !== c && (b.add = c);
          d(this.scene, f, b);
          return f;
        });
      },
      function (h, t, a) {
        var d = a(28),
          k = a(219);
        h = a(16);
        var e = a(13);
        h.register("layer", function (b, c) {
          void 0 === b && (b = {});
          var f = e(b, "children", null);
          f = new k(this.scene, f);
          void 0 !== c && (b.add = c);
          d(this.scene, f, b);
          return f;
        });
      },
      function (h, t, a) {
        h = a(16);
        var d = a(13),
          k = a(2),
          e = a(220);
        h.register("particles", function (b, c) {
          void 0 === b && (b = {});
          var f = d(b, "key", null),
            g = d(b, "frame", null),
            m = k(b, "emitters", null);
          f = new e(this.scene, f, g, m);
          void 0 !== c && (b.add = c);
          k(b, "add", !1) ? this.displayList.add(f) : this.updateList.add(f);
          return f;
        });
      },
      function (h, t, a) {
        var d = a(28);
        h = a(16);
        var k = a(13),
          e = a(221);
        h.register("renderTexture", function (b, c) {
          void 0 === b && (b = {});
          var f = k(b, "x", 0),
            g = k(b, "y", 0),
            m = k(b, "width", 32),
            n = k(b, "height", 32),
            q = k(b, "key", void 0),
            r = k(b, "frame", void 0);
          f = new e(this.scene, f, g, m, n, q, r);
          void 0 !== c && (b.add = c);
          d(this.scene, f, b);
          return f;
        });
      },
      function (h, t, a) {
        var d = a(28);
        h = a(16);
        var k = a(13),
          e = a(6),
          b = a(223);
        h.register("rope", function (c, f) {
          void 0 === c && (c = {});
          var g = k(c, "key", null),
            m = k(c, "frame", null),
            n = k(c, "horizontal", !0),
            q = e(c, "points", void 0),
            r = e(c, "colors", void 0),
            u = e(c, "alphas", void 0);
          g = new b(this.scene, 0, 0, g, m, q, n, r, u);
          void 0 !== f && (c.add = f);
          d(this.scene, g, c);
          c.add || this.updateList.add(g);
          return g;
        });
      },
      function (h, t, a) {
        var d = a(28),
          k = a(439);
        h = a(16);
        var e = a(13),
          b = a(73);
        h.register("sprite", function (c, f) {
          void 0 === c && (c = {});
          var g = e(c, "key", null),
            m = e(c, "frame", null);
          g = new b(this.scene, 0, 0, g, m);
          void 0 !== f && (c.add = f);
          d(this.scene, g, c);
          k(g, c);
          return g;
        });
      },
      function (h, t, a) {
        var d = a(148),
          k = a(28);
        h = a(16);
        var e = a(13),
          b = a(6);
        h.register("bitmapText", function (c, f) {
          void 0 === c && (c = {});
          var g = b(c, "font", ""),
            m = e(c, "text", ""),
            n = e(c, "size", !1),
            q = b(c, "align", 0);
          g = new d(this.scene, 0, 0, g, m, n, q);
          void 0 !== f && (c.add = f);
          k(this.scene, g, c);
          return g;
        });
      },
      function (h, t, a) {
        var d = a(28);
        h = a(16);
        var k = a(13),
          e = a(224);
        h.register("text", function (b, c) {
          void 0 === b && (b = {});
          var f = k(b, "text", ""),
            g = k(b, "style", null),
            m = k(b, "padding", null);
          null !== m && (g.padding = m);
          f = new e(this.scene, 0, 0, f, g);
          void 0 !== c && (b.add = c);
          d(this.scene, f, b);
          f.autoRound = k(b, "autoRound", !0);
          f.resolution = k(b, "resolution", 1);
          return f;
        });
      },
      function (h, t, a) {
        var d = a(28);
        h = a(16);
        var k = a(13),
          e = a(225);
        h.register("tileSprite", function (b, c) {
          void 0 === b && (b = {});
          var f = k(b, "x", 0),
            g = k(b, "y", 0),
            m = k(b, "width", 512),
            n = k(b, "height", 512),
            q = k(b, "key", ""),
            r = k(b, "frame", "");
          f = new e(this.scene, f, g, m, n, q, r);
          void 0 !== c && (b.add = c);
          d(this.scene, f, b);
          return f;
        });
      },
      function (h, t, a) {
        h = a(16);
        var d = a(13),
          k = a(129);
        h.register("zone", function (e) {
          var b = d(e, "x", 0),
            c = d(e, "y", 0),
            f = d(e, "width", 1);
          e = d(e, "height", f);
          return new k(this.scene, b, c, f, e);
        });
      },
      function (h, t, a) {
        var d = a(28);
        h = a(16);
        var k = a(13),
          e = a(226);
        h.register("video", function (b, c) {
          void 0 === b && (b = {});
          var f = k(b, "key", null);
          f = new e(this.scene, 0, 0, f);
          void 0 !== c && (b.add = c);
          d(this.scene, f, b);
          b.add || this.updateList.add(f);
          return f;
        });
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1177);
        a = a(1178);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(19);
        h.exports = function (k, e, b, c) {
          e.shader &&
            (b.addToRenderList(e),
            k.pipelines.clear(),
            e.renderToTexture
              ? e.load()
              : ((b = d(e, b, c).calc),
                (k.width === e._rendererWidth &&
                  k.height === e._rendererHeight) ||
                  e.projOrtho(0, k.width, k.height, 0),
                e.load(b.matrix)),
            e.flush(),
            k.pipelines.rebind());
        };
      },
      function (h, t) {
        h.exports = function () {};
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1180);
        a = a(1181);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(19);
        h.exports = function (k, e, b, c) {
          var f = e.faces,
            g = f.length;
          if (0 !== g) {
            b.addToRenderList(e);
            var m = k.pipelines.set(e.pipeline, e),
              n = d(e, b, c).calc;
            c = m.setGameObject(e);
            var q = m.vertexViewF32,
              r = m.vertexViewU32,
              u = m.vertexCount * m.currentShader.vertexComponentCount - 1,
              v = e.tintFill,
              x = [],
              y = e.debugCallback,
              z = n.a,
              A = n.b,
              B = n.c,
              D = n.d,
              E = n.e;
            n = n.f;
            var C = e.viewPosition.z,
              F = e.hideCCW,
              G = b.roundPixels,
              H = b.alpha * e.alpha,
              K = 0;
            k.pipelines.preBatch(e);
            for (var I = 0; I < g; I++) {
              var M = f[I];
              M.isInView(b, F, C, H, z, A, B, D, E, n, G) &&
                (m.shouldFlush(3) && (m.flush(), (u = 0)),
                (u = M.load(q, r, u, c, v)),
                K++,
                (m.vertexCount += 3),
                y && x.push(M));
            }
            e.totalFrame += K;
            y && y.call(e, e, x);
            k.pipelines.postBatch(e);
          }
        };
      },
      function (h, t) {
        h.exports = function () {};
      },
      function (h, t, a) {
        a(1);
        t = a(1);
        a = a(1183);
        h.exports = {
          renderWebGL: a,
          renderCanvas: t,
        };
      },
      function (h, t, a) {
        var d = a(19);
        h.exports = function (k, e, b, c) {
          b.addToRenderList(e);
          var f = k.pipelines.set(e.pipeline),
            g = d(e, b, c).calc,
            m = -e._radius,
            n = -e._radius,
            q = m + e.width,
            r = n + e.height;
          c = g.getX(0, 0);
          var u = g.getY(0, 0),
            v = g.getX(m, n),
            x = g.getY(m, n),
            y = g.getX(m, r);
          m = g.getY(m, r);
          var z = g.getX(q, r);
          r = g.getY(q, r);
          var A = g.getX(q, n);
          g = g.getY(q, n);
          k.pipelines.preBatch(e);
          f.batchPointLight(e, b, v, x, y, m, z, r, A, g, c, u);
          k.pipelines.postBatch(e);
        };
      },
      function (h, t, a) {
        var d = a(229);
        a(5).register("shader", function (k, e, b, c, f, g, m) {
          return this.displayList.add(new d(this.scene, k, e, b, c, f, g, m));
        });
      },
      function (h, t, a) {
        var d = a(230);
        a(5).register("mesh", function (k, e, b, c, f, g, m, n, q, r, u) {
          return this.displayList.add(
            new d(this.scene, k, e, b, c, f, g, m, n, q, r, u)
          );
        });
      },
      function (h, t, a) {
        h = a(5);
        var d = a(150);
        h.register("pointlight", function (k, e, b, c, f, g) {
          return this.displayList.add(new d(this.scene, k, e, b, c, f, g));
        });
      },
      function (h, t, a) {
        var d = a(28);
        h = a(16);
        var k = a(13),
          e = a(229);
        h.register("shader", function (b, c) {
          void 0 === b && (b = {});
          var f = k(b, "key", null),
            g = k(b, "x", 0),
            m = k(b, "y", 0),
            n = k(b, "width", 128),
            q = k(b, "height", 128);
          f = new e(this.scene, f, g, m, n, q);
          void 0 !== c && (b.add = c);
          d(this.scene, f, b);
          return f;
        });
      },
      function (h, t, a) {
        var d = a(28);
        h = a(16);
        var k = a(13),
          e = a(6),
          b = a(230);
        h.register("mesh", function (c, f) {
          void 0 === c && (c = {});
          var g = k(c, "key", null),
            m = k(c, "frame", null),
            n = e(c, "vertices", []),
            q = e(c, "uvs", []),
            r = e(c, "indicies", []),
            u = e(c, "containsZ", !1),
            v = e(c, "normals", []),
            x = e(c, "colors", 16777215),
            y = e(c, "alphas", 1);
          g = new b(this.scene, 0, 0, g, m, n, q, r, u, v, x, y);
          void 0 !== f && (c.add = f);
          d(this.scene, g, c);
          return g;
        });
      },
      function (h, t, a) {
        var d = a(28);
        h = a(16);
        var k = a(13),
          e = a(150);
        h.register("pointlight", function (b, c) {
          void 0 === b && (b = {});
          var f = k(b, "color", 16777215),
            g = k(b, "radius", 128),
            m = k(b, "intensity", 1),
            n = k(b, "attenuation", 0.1);
          f = new e(this.scene, 0, 0, f, g, m, n);
          void 0 !== c && (b.add = c);
          d(this.scene, f, b);
          return f;
        });
      },
      function (h, t, a) {
        var d = a(0),
          k = a(482);
        t = a(24);
        var e = a(20);
        a = new d({
          Extends: k,
          initialize: function (b) {
            this.scene = b;
            this.systems = b.sys;
            if (!b.sys.settings.isBooted)
              b.sys.events.once(e.BOOT, this.boot, this);
            k.call(this);
          },
          boot: function () {
            var b = this.systems.events;
            b.on(e.SHUTDOWN, this.shutdown, this);
            b.on(e.DESTROY, this.destroy, this);
          },
          destroy: function () {
            this.shutdown();
            this.systems = this.scene = void 0;
          },
        });
        t.register("LightsPlugin", a, "lights");
        h.exports = a;
      },
      function (h, t, a) {
        t = a(65);
        t.Area = a(1192);
        t.Circumference = a(302);
        t.CircumferencePoint = a(169);
        t.Clone = a(1193);
        t.Contains = a(66);
        t.ContainsPoint = a(1194);
        t.ContainsRect = a(1195);
        t.CopyFrom = a(1196);
        t.Equals = a(1197);
        t.GetBounds = a(1198);
        t.GetPoint = a(300);
        t.GetPoints = a(301);
        t.Offset = a(1199);
        t.OffsetPoint = a(1200);
        t.Random = a(170);
        h.exports = t;
      },
      function (h, t) {
        h.exports = function (a) {
          return 0 < a.radius ? Math.PI * a.radius * a.radius : 0;
        };
      },
      function (h, t, a) {
        var d = a(65);
        h.exports = function (k) {
          return new d(k.x, k.y, k.radius);
        };
      },
      function (h, t, a) {
        var d = a(66);
        h.exports = function (k, e) {
          return d(k, e.x, e.y);
        };
      },
      function (h, t, a) {
        var d = a(66);
        h.exports = function (k, e) {
          return (
            d(k, e.x, e.y) &&
            d(k, e.right, e.y) &&
            d(k, e.x, e.bottom) &&
            d(k, e.right, e.bottom)
          );
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return d.setTo(a.x, a.y, a.radius);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return a.x === d.x && a.y === d.y && a.radius === d.radius;
        };
      },
      function (h, t, a) {
        var d = a(10);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          e.x = k.left;
          e.y = k.top;
          e.width = k.diameter;
          e.height = k.diameter;
          return e;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          a.x += d;
          a.y += k;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          a.x += d.x;
          a.y += d.y;
          return a;
        };
      },
      function (h, t, a) {
        t = a(111);
        t.Area = a(1202);
        t.Circumference = a(447);
        t.CircumferencePoint = a(218);
        t.Clone = a(1203);
        t.Contains = a(112);
        t.ContainsPoint = a(1204);
        t.ContainsRect = a(1205);
        t.CopyFrom = a(1206);
        t.Equals = a(1207);
        t.GetBounds = a(1208);
        t.GetPoint = a(445);
        t.GetPoints = a(446);
        t.Offset = a(1209);
        t.OffsetPoint = a(1210);
        t.Random = a(180);
        h.exports = t;
      },
      function (h, t) {
        h.exports = function (a) {
          return a.isEmpty()
            ? 0
            : a.getMajorRadius() * a.getMinorRadius() * Math.PI;
        };
      },
      function (h, t, a) {
        var d = a(111);
        h.exports = function (k) {
          return new d(k.x, k.y, k.width, k.height);
        };
      },
      function (h, t, a) {
        var d = a(112);
        h.exports = function (k, e) {
          return d(k, e.x, e.y);
        };
      },
      function (h, t, a) {
        var d = a(112);
        h.exports = function (k, e) {
          return (
            d(k, e.x, e.y) &&
            d(k, e.right, e.y) &&
            d(k, e.x, e.bottom) &&
            d(k, e.right, e.bottom)
          );
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return d.setTo(a.x, a.y, a.width, a.height);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return (
            a.x === d.x &&
            a.y === d.y &&
            a.width === d.width &&
            a.height === d.height
          );
        };
      },
      function (h, t, a) {
        var d = a(10);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          e.x = k.left;
          e.y = k.top;
          e.width = k.width;
          e.height = k.height;
          return e;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          a.x += d;
          a.y += k;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          a.x += d.x;
          a.y += d.y;
          return a;
        };
      },
      function (h, t, a) {
        var d = a(4),
          k = a(231);
        h.exports = function (e, b, c) {
          void 0 === c && (c = []);
          if (k(e, b)) {
            var f = e.x,
              g = e.y,
              m = e.radius,
              n = b.x,
              q = b.y,
              r = b.radius;
            if (g === q)
              (f = (r * r - m * m - n * n + f * f) / (2 * (f - n))),
                (b = 1),
                (e = -2 * q),
                (g =
                  e * e - 4 * b * (n * n + f * f - 2 * n * f + q * q - r * r)),
                0 === g
                  ? c.push(new d(f, -e / (2 * b)))
                  : 0 < g &&
                    (c.push(new d(f, (-e + Math.sqrt(g)) / (2 * b))),
                    c.push(new d(f, (-e - Math.sqrt(g)) / (2 * b))));
            else {
              var u = (f - n) / (g - q);
              n =
                (r * r - m * m - n * n + f * f - q * q + g * g) / (2 * (g - q));
              b = u * u + 1;
              e = 2 * g * u - 2 * n * u - 2 * f;
              g = e * e - 4 * b * (f * f + g * g + n * n - m * m - 2 * g * n);
              0 === g
                ? ((f = -e / (2 * b)), c.push(new d(f, n - f * u)))
                : 0 < g &&
                  ((f = (-e + Math.sqrt(g)) / (2 * b)),
                  c.push(new d(f, n - f * u)),
                  (f = (-e - Math.sqrt(g)) / (2 * b)),
                  c.push(new d(f, n - f * u)));
            }
          }
          return c;
        };
      },
      function (h, t, a) {
        var d = a(232),
          k = a(151);
        h.exports = function (e, b, c) {
          void 0 === c && (c = []);
          if (k(e, b)) {
            var f = b.getLineA(),
              g = b.getLineB(),
              m = b.getLineC();
            b = b.getLineD();
            d(f, e, c);
            d(g, e, c);
            d(m, e, c);
            d(b, e, c);
          }
          return c;
        };
      },
      function (h, t, a) {
        function d(f, g, m, n, q) {
          c.setTo(g, m, g + Math.cos(f), m + Math.sin(f));
          (g = b(c, n)) && q.push(new e(g.x, g.y, f, g.w));
        }

        function k(f, g) {
          return f.z - g.z;
        }
        var e = a(140),
          b = a(487),
          c = new (a(47))();
        h.exports = function (f, g, m) {
          Array.isArray(m) || (m = [m]);
          for (var n = [], q = [], r = 0; r < m.length; r++)
            for (var u = m[r].points, v = 0; v < u.length; v++) {
              var x = Math.atan2(u[v].y - g, u[v].x - f);
              -1 === q.indexOf(x) &&
                (d(x, f, g, m, n),
                d(x - 1e-5, f, g, m, n),
                d(x + 1e-5, f, g, m, n),
                q.push(x));
            }
          return n.sort(k);
        };
      },
      function (h, t, a) {
        var d = a(10),
          k = a(152);
        h.exports = function (e, b, c) {
          void 0 === c && (c = new d());
          k(e, b) &&
            ((c.x = Math.max(e.x, b.x)),
            (c.y = Math.max(e.y, b.y)),
            (c.width = Math.min(e.right, b.right) - c.x),
            (c.height = Math.min(e.bottom, b.bottom) - c.y));
          return c;
        };
      },
      function (h, t, a) {
        var d = a(234),
          k = a(152);
        h.exports = function (e, b, c) {
          void 0 === c && (c = []);
          if (k(e, b)) {
            var f = e.getLineA(),
              g = e.getLineB(),
              m = e.getLineC();
            e = e.getLineD();
            d(f, b, c);
            d(g, b, c);
            d(m, b, c);
            d(e, b, c);
          }
          return c;
        };
      },
      function (h, t, a) {
        var d = a(489),
          k = a(234);
        h.exports = function (e, b, c) {
          void 0 === c && (c = []);
          if (d(e, b)) {
            var f = b.getLineA(),
              g = b.getLineB();
            b = b.getLineC();
            k(f, e, c);
            k(g, e, c);
            k(b, e, c);
          }
          return c;
        };
      },
      function (h, t, a) {
        var d = a(232),
          k = a(491);
        h.exports = function (e, b, c) {
          void 0 === c && (c = []);
          if (k(e, b)) {
            var f = e.getLineA(),
              g = e.getLineB();
            e = e.getLineC();
            d(f, b, c);
            d(g, b, c);
            d(e, b, c);
          }
          return c;
        };
      },
      function (h, t, a) {
        var d = a(494),
          k = a(492);
        h.exports = function (e, b, c) {
          void 0 === c && (c = []);
          if (d(e, b)) {
            var f = b.getLineA(),
              g = b.getLineB();
            b = b.getLineC();
            k(e, f, c);
            k(e, g, c);
            k(e, b, c);
          }
          return c;
        };
      },
      function (h, t, a) {
        var d = a(496);
        h.exports = function (k, e) {
          if (!d(k, e)) return !1;
          var b = Math.max(e.x1, e.x2),
            c = Math.min(e.y1, e.y2),
            f = Math.max(e.y1, e.y2);
          return (
            k.x >= Math.min(e.x1, e.x2) && k.x <= b && k.y >= c && k.y <= f
          );
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b, c) {
          void 0 === c && (c = 0);
          return !(
            d > a.right + c ||
            k < a.left - c ||
            e > a.bottom + c ||
            b < a.top - c
          );
        };
      },
      function (h, t, a) {
        t = a(47);
        t.Angle = a(97);
        t.BresenhamPoints = a(317);
        t.CenterOn = a(1222);
        t.Clone = a(1223);
        t.CopyFrom = a(1224);
        t.Equals = a(1225);
        t.Extend = a(1226);
        t.GetEasedPoints = a(1227);
        t.GetMidPoint = a(1228);
        t.GetNearestPoint = a(1229);
        t.GetNormal = a(1230);
        t.GetPoint = a(307);
        t.GetPoints = a(172);
        t.GetShortestDistance = a(1231);
        t.Height = a(1232);
        t.Length = a(67);
        t.NormalAngle = a(497);
        t.NormalX = a(1233);
        t.NormalY = a(1234);
        t.Offset = a(1235);
        t.PerpSlope = a(1236);
        t.Random = a(173);
        t.ReflectAngle = a(1237);
        t.Rotate = a(1238);
        t.RotateAroundPoint = a(1239);
        t.RotateAroundXY = a(236);
        t.SetToAngle = a(1240);
        t.Slope = a(1241);
        t.Width = a(1242);
        h.exports = t;
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          d -= (a.x1 + a.x2) / 2;
          k -= (a.y1 + a.y2) / 2;
          a.x1 += d;
          a.y1 += k;
          a.x2 += d;
          a.y2 += k;
          return a;
        };
      },
      function (h, t, a) {
        var d = a(47);
        h.exports = function (k) {
          return new d(k.x1, k.y1, k.x2, k.y2);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return d.setTo(a.x1, a.y1, a.x2, a.y2);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return (
            a.x1 === d.x1 && a.y1 === d.y1 && a.x2 === d.x2 && a.y2 === d.y2
          );
        };
      },
      function (h, t, a) {
        var d = a(67);
        h.exports = function (k, e, b) {
          void 0 === b && (b = e);
          var c = d(k),
            f = k.x2 - k.x1,
            g = k.y2 - k.y1;
          e && ((k.x1 -= (f / c) * e), (k.y1 -= (g / c) * e));
          b && ((k.x2 += (f / c) * b), (k.y2 += (g / c) * b));
          return k;
        };
      },
      function (h, t, a) {
        var d = a(352),
          k = a(80),
          e = a(4);
        h.exports = function (b, c, f, g, m) {
          void 0 === g && (g = 0);
          void 0 === m && (m = []);
          var n = [],
            q = b.x1,
            r = b.y1,
            u = b.x2 - q;
          b = b.y2 - r;
          c = k(c, m);
          var v = f - 1;
          for (f = 0; f < v; f++)
            (m = c(f / v)), n.push(new e(q + u * m, r + b * m));
          m = c(1);
          n.push(new e(q + u * m, r + b * m));
          if (0 < g) {
            q = n[0];
            r = [q];
            for (f = 1; f < n.length - 1; f++)
              (u = n[f]), d(q, u) >= g && (r.push(u), (q = u));
            n = n[n.length - 1];
            d(q, n) < g && r.pop();
            r.push(n);
            return r;
          }
          return n;
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          e.x = (k.x1 + k.x2) / 2;
          e.y = (k.y1 + k.y2) / 2;
          return e;
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e, b) {
          void 0 === b && (b = new d());
          var c = k.x1,
            f = k.y1,
            g = k.x2;
          k = k.y2;
          var m = (g - c) * (g - c) + (k - f) * (k - f);
          if (0 === m) return b;
          e = ((e.x - c) * (g - c) + (e.y - f) * (k - f)) / m;
          b.x = c + e * (g - c);
          b.y = f + e * (k - f);
          return b;
        };
      },
      function (h, t, a) {
        var d = a(14),
          k = a(97),
          e = a(4);
        h.exports = function (b, c) {
          void 0 === c && (c = new e());
          b = k(b) - d.TAU;
          c.x = Math.cos(b);
          c.y = Math.sin(b);
          return c;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          var k = a.x1,
            e = a.y1,
            b = a.x2;
          a = a.y2;
          var c = (b - k) * (b - k) + (a - e) * (a - e);
          return 0 === c
            ? !1
            : Math.abs(((e - d.y) * (b - k) - (k - d.x) * (a - e)) / c) *
                Math.sqrt(c);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return Math.abs(a.y1 - a.y2);
        };
      },
      function (h, t, a) {
        var d = a(14),
          k = a(97);
        h.exports = function (e) {
          return Math.cos(k(e) - d.TAU);
        };
      },
      function (h, t, a) {
        var d = a(14),
          k = a(97);
        h.exports = function (e) {
          return Math.sin(k(e) - d.TAU);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          a.x1 += d;
          a.y1 += k;
          a.x2 += d;
          a.y2 += k;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return -((a.x2 - a.x1) / (a.y2 - a.y1));
        };
      },
      function (h, t, a) {
        var d = a(97),
          k = a(497);
        h.exports = function (e, b) {
          return 2 * k(b) - Math.PI - d(e);
        };
      },
      function (h, t, a) {
        var d = a(236);
        h.exports = function (k, e) {
          return d(k, (k.x1 + k.x2) / 2, (k.y1 + k.y2) / 2, e);
        };
      },
      function (h, t, a) {
        var d = a(236);
        h.exports = function (k, e, b) {
          return d(k, e.x, e.y, b);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e, b) {
          a.x1 = d;
          a.y1 = k;
          a.x2 = d + Math.cos(e) * b;
          a.y2 = k + Math.sin(e) * b;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return (a.y2 - a.y1) / (a.x2 - a.x1);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return Math.abs(a.x1 - a.x2);
        };
      },
      function (h, t, a) {
        t = {
          Face: a(116),
          GenerateGridVerts: a(1244),
          GenerateObjVerts: a(480),
          GenerateVerts: a(479),
          ParseObj: a(498),
          ParseObjMaterial: a(499),
          RotateFace: a(1245),
          Vertex: a(117),
        };
        h.exports = t;
      },
      function (h, t, a) {
        var d = a(116),
          k = a(2);
        t = a(69);
        var e = a(39),
          b = a(117),
          c = new e(),
          f = new e(),
          g = new t();
        h.exports = function (m) {
          var n = k(m, "mesh"),
            q = k(m, "texture", null),
            r = k(m, "frame"),
            u = k(m, "width", 1),
            v = k(m, "height", u),
            x = k(m, "widthSegments", 1),
            y = k(m, "heightSegments", x),
            z = k(m, "x", 0),
            A = k(m, "y", 0),
            B = k(m, "z", 0),
            D = k(m, "rotateX", 0),
            E = k(m, "rotateY", 0),
            C = k(m, "rotateZ", 0),
            F = k(m, "zIsUp", !0),
            G = k(m, "isOrtho", n ? n.dirtyCache[11] : !1),
            H = k(m, "colors", [16777215]),
            K = k(m, "alphas", [1]),
            I = k(m, "tile", !1),
            M = k(m, "flipY", !1),
            N = k(m, "width", null);
          m = {
            faces: [],
            verts: [],
          };
          c.set(z, A, B);
          f.set(D, E, C);
          g.fromRotationXYTranslation(f, c, F);
          if (!q && n) q = n.texture;
          else if (n && "string" === typeof q) q = n.scene.sys.textures.get(q);
          else return m;
          B = q.get(r);
          !N &&
            G &&
            q &&
            n &&
            ((u = B.width / n.height), (v = B.height / n.height));
          D = u / 2;
          E = v / 2;
          x = Math.floor(x);
          y = Math.floor(y);
          q = x + 1;
          C = y + 1;
          F = u / x;
          N = v / y;
          v = [];
          u = [];
          G = 0;
          r = 1;
          z = 0;
          A = 1;
          B &&
            ((G = B.u0),
            (r = B.u1),
            M ? ((z = B.v1), (A = B.v0)) : ((z = B.v0), (A = B.v1)));
          var P = r - G,
            J = A - z;
          for (B = 0; B < C; B++) {
            var L = B * N - E;
            for (M = 0; M < q; M++)
              u.push(M * F - D, -L), v.push(G + (M / x) * P, z + (B / y) * J);
          }
          Array.isArray(H) || (H = [H]);
          Array.isArray(K) || (K = [K]);
          for (B = E = D = 0; B < y; B++)
            for (M = 0; M < x; M++) {
              P = 2 * (M + q * B);
              var O = 2 * (M + q * (B + 1)),
                Q = 2 * (M + 1 + q * (B + 1));
              C = 2 * (M + 1 + q * B);
              F = H[E];
              N = K[D];
              P = new b(u[P], u[P + 1], 0, v[P], v[P + 1], F, N).transformMat4(
                g
              );
              J = new b(u[O], u[O + 1], 0, v[O], v[O + 1], F, N).transformMat4(
                g
              );
              L = new b(u[C], u[C + 1], 0, v[C], v[C + 1], F, N).transformMat4(
                g
              );
              O = new b(u[O], u[O + 1], 0, v[O], v[O + 1], F, N).transformMat4(
                g
              );
              Q = new b(u[Q], u[Q + 1], 0, v[Q], v[Q + 1], F, N).transformMat4(
                g
              );
              C = new b(u[C], u[C + 1], 0, v[C], v[C + 1], F, N).transformMat4(
                g
              );
              I &&
                (P.setUVs(G, A),
                J.setUVs(G, z),
                L.setUVs(r, A),
                O.setUVs(G, z),
                Q.setUVs(r, z),
                C.setUVs(r, A));
              E++;
              E === H.length && (E = 0);
              D++;
              D === K.length && (D = 0);
              m.verts.push(P, J, L, O, Q, C);
              m.faces.push(new d(P, J, L), new d(O, Q, C));
            }
          n &&
            ((n.faces = n.faces.concat(m.faces)),
            (n.vertices = n.vertices.concat(m.verts)));
          return m;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          if (void 0 === k && void 0 === e) {
            var b = a.getInCenter();
            var c = b.x;
            b = b.y;
          }
          k = Math.cos(d);
          d = Math.sin(d);
          e = a.vertex1;
          var f = a.vertex2;
          a = a.vertex3;
          var g = e.x - c,
            m = e.y - b;
          e.set(g * k - m * d + c, g * d + m * k + b);
          g = f.x - c;
          m = f.y - b;
          f.set(g * k - m * d + c, g * d + m * k + b);
          g = a.x - c;
          m = a.y - b;
          a.set(g * k - m * d + c, g * d + m * k + b);
        };
      },
      function (h, t, a) {
        t = a(4);
        t.Ceil = a(1247);
        t.Clone = a(1248);
        t.CopyFrom = a(1249);
        t.Equals = a(1250);
        t.Floor = a(1251);
        t.GetCentroid = a(1252);
        t.GetMagnitude = a(500);
        t.GetMagnitudeSq = a(501);
        t.GetRectangleFromPoints = a(1253);
        t.Interpolate = a(1254);
        t.Invert = a(1255);
        t.Negative = a(1256);
        t.Project = a(1257);
        t.ProjectUnit = a(1258);
        t.SetMagnitude = a(1259);
        h.exports = t;
      },
      function (h, t) {
        h.exports = function (a) {
          return a.setTo(Math.ceil(a.x), Math.ceil(a.y));
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k) {
          return new d(k.x, k.y);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return d.setTo(a.x, a.y);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return a.x === d.x && a.y === d.y;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a.setTo(Math.floor(a.x), Math.floor(a.y));
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          if (!Array.isArray(k))
            throw Error("GetCentroid points argument must be an array");
          var b = k.length;
          if (1 > b) throw Error("GetCentroid points array must not be empty");
          if (1 === b) (e.x = k[0].x), (e.y = k[0].y);
          else {
            for (var c = 0; c < b; c++) (e.x += k[c].x), (e.y += k[c].y);
            e.x /= b;
            e.y /= b;
          }
          return e;
        };
      },
      function (h, t, a) {
        var d = a(10);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          for (
            var b = Number.NEGATIVE_INFINITY,
              c = Number.POSITIVE_INFINITY,
              f = Number.NEGATIVE_INFINITY,
              g = Number.POSITIVE_INFINITY,
              m = 0;
            m < k.length;
            m++
          ) {
            var n = k[m];
            n.x > b && (b = n.x);
            n.x < c && (c = n.x);
            n.y > f && (f = n.y);
            n.y < g && (g = n.y);
          }
          e.x = c;
          e.y = g;
          e.width = b - c;
          e.height = f - g;
          return e;
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e, b, c) {
          void 0 === b && (b = 0);
          void 0 === c && (c = new d());
          c.x = k.x + (e.x - k.x) * b;
          c.y = k.y + (e.y - k.y) * b;
          return c;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a.setTo(a.y, a.x);
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          return e.setTo(-k.x, -k.y);
        };
      },
      function (h, t, a) {
        var d = a(4),
          k = a(501);
        h.exports = function (e, b, c) {
          void 0 === c && (c = new d());
          e = (e.x * b.x + e.y * b.y) / k(b);
          0 !== e && ((c.x = e * b.x), (c.y = e * b.y));
          return c;
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e, b) {
          void 0 === b && (b = new d());
          k = k.x * e.x + k.y * e.y;
          0 !== k && ((b.x = k * e.x), (b.y = k * e.y));
          return b;
        };
      },
      function (h, t, a) {
        var d = a(500);
        h.exports = function (k, e) {
          if (0 !== k.x || 0 !== k.y) {
            var b = d(k);
            k.x /= b;
            k.y /= b;
          }
          k.x *= e;
          k.y *= e;
          return k;
        };
      },
      function (h, t, a) {
        t = a(227);
        t.Clone = a(1261);
        t.Contains = a(228);
        t.ContainsPoint = a(1262);
        t.Earcut = a(59);
        t.GetAABB = a(469);
        t.GetNumberArray = a(1263);
        t.GetPoints = a(470);
        t.Perimeter = a(471);
        t.Reverse = a(1264);
        t.Simplify = a(1265);
        t.Smooth = a(472);
        t.Translate = a(1266);
        h.exports = t;
      },
      function (h, t, a) {
        var d = a(227);
        h.exports = function (k) {
          return new d(k.points);
        };
      },
      function (h, t, a) {
        var d = a(228);
        h.exports = function (k, e) {
          return d(k, e.x, e.y);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = []);
          for (var k = 0; k < a.points.length; k++)
            d.push(a.points[k].x), d.push(a.points[k].y);
          return d;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          a.points.reverse();
          return a;
        };
      },
      function (h, t) {
        function a(d, k, e, b, c) {
          for (var f = b, g, m = k + 1; m < e; m++) {
            var n = d[m];
            var q = d[k],
              r = d[e],
              u = q.x;
            q = q.y;
            var v = r.x - u,
              x = r.y - q;
            if (0 !== v || 0 !== x) {
              var y = ((n.x - u) * v + (n.y - q) * x) / (v * v + x * x);
              1 < y
                ? ((u = r.x), (q = r.y))
                : 0 < y && ((u += v * y), (q += x * y));
            }
            v = n.x - u;
            x = n.y - q;
            n = v * v + x * x;
            n > f && ((g = m), (f = n));
          }
          f > b &&
            (1 < g - k && a(d, k, g, b, c),
            c.push(d[g]),
            1 < e - g && a(d, g, e, b, c));
        }
        h.exports = function (d, k, e) {
          void 0 === k && (k = 1);
          void 0 === e && (e = !1);
          var b = d.points;
          if (2 < b.length) {
            k *= k;
            if (!e) {
              e = b[0];
              for (var c = [e], f, g = 1, m = b.length; g < m; g++) {
                f = b[g];
                var n = f.x - e.x,
                  q = f.y - e.y;
                n * n + q * q > k && (c.push(f), (e = f));
              }
              e !== f && c.push(f);
              b = c;
            }
            f = d.setTo;
            e = b.length - 1;
            c = [b[0]];
            a(b, 0, e, k, c);
            c.push(b[e]);
            f.call(d, c);
          }
          return d;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          for (var e = a.points, b = 0; b < e.length; b++)
            (e[b].x += d), (e[b].y += k);
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a.width * a.height;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          a.x = Math.ceil(a.x);
          a.y = Math.ceil(a.y);
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          a.x = Math.ceil(a.x);
          a.y = Math.ceil(a.y);
          a.width = Math.ceil(a.width);
          a.height = Math.ceil(a.height);
          return a;
        };
      },
      function (h, t, a) {
        var d = a(10);
        h.exports = function (k) {
          return new d(k.x, k.y, k.width, k.height);
        };
      },
      function (h, t, a) {
        var d = a(57);
        h.exports = function (k, e) {
          return d(k, e.x, e.y);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return d.setTo(a.x, a.y, a.width, a.height);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return (
            a.x === d.x &&
            a.y === d.y &&
            a.width === d.width &&
            a.height === d.height
          );
        };
      },
      function (h, t, a) {
        var d = a(237);
        h.exports = function (k, e) {
          var b = d(k);
          b < d(e)
            ? k.setSize(e.height * b, e.height)
            : k.setSize(e.width, e.width / b);
          return k.setPosition(
            e.centerX - k.width / 2,
            e.centerY - k.height / 2
          );
        };
      },
      function (h, t, a) {
        var d = a(237);
        h.exports = function (k, e) {
          var b = d(k);
          b > d(e)
            ? k.setSize(e.height * b, e.height)
            : k.setSize(e.width, e.width / b);
          return k.setPosition(
            e.centerX - k.width / 2,
            e.centerY - k.height / 2
          );
        };
      },
      function (h, t) {
        h.exports = function (a) {
          a.x = Math.floor(a.x);
          a.y = Math.floor(a.y);
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          a.x = Math.floor(a.x);
          a.y = Math.floor(a.y);
          a.width = Math.floor(a.width);
          a.height = Math.floor(a.height);
          return a;
        };
      },
      function (h, t, a) {
        var d = a(10);
        h.exports = function (k, e, b, c, f) {
          void 0 === f && (f = new d());
          return f.setTo(
            Math.min(k, b),
            Math.min(e, c),
            Math.abs(k - b),
            Math.abs(e - c)
          );
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          e.x = k.centerX;
          e.y = k.centerY;
          return e;
        };
      },
      function (h, t, a) {
        var d = a(4);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          e.x = k.width;
          e.y = k.height;
          return e;
        };
      },
      function (h, t, a) {
        var d = a(190);
        h.exports = function (k, e, b) {
          var c = k.centerX,
            f = k.centerY;
          k.setSize(k.width + 2 * e, k.height + 2 * b);
          return d(k, c, f);
        };
      },
      function (h, t, a) {
        var d = a(10),
          k = a(152);
        h.exports = function (e, b, c) {
          void 0 === c && (c = new d());
          k(e, b)
            ? ((c.x = Math.max(e.x, b.x)),
              (c.y = Math.max(e.y, b.y)),
              (c.width = Math.min(e.right, b.right) - c.x),
              (c.height = Math.min(e.bottom, b.bottom) - c.y))
            : c.setEmpty();
          return c;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          for (
            var k = a.x, e = a.right, b = a.y, c = a.bottom, f = 0;
            f < d.length;
            f++
          )
            (k = Math.min(k, d[f].x)),
              (e = Math.max(e, d[f].x)),
              (b = Math.min(b, d[f].y)),
              (c = Math.max(c, d[f].y));
          a.x = k;
          a.y = b;
          a.width = e - k;
          a.height = c - b;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          var k = Math.min(a.x, d.x),
            e = Math.max(a.right, d.right);
          a.x = k;
          a.width = e - k;
          k = Math.min(a.y, d.y);
          d = Math.max(a.bottom, d.bottom);
          a.y = k;
          a.height = d - k;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          var e = Math.min(a.x, d);
          d = Math.max(a.right, d);
          a.x = e;
          a.width = d - e;
          e = Math.min(a.y, k);
          k = Math.max(a.bottom, k);
          a.y = e;
          a.height = k - e;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          a.x += d;
          a.y += k;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          a.x += d.x;
          a.y += d.y;
          return a;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return (
            a.x < d.right && a.right > d.x && a.y < d.bottom && a.bottom > d.y
          );
        };
      },
      function (h, t, a) {
        var d = a(4),
          k = a(36);
        h.exports = function (e, b, c) {
          void 0 === c && (c = new d());
          b = k(b);
          var f = Math.sin(b);
          b = Math.cos(b);
          var g = 0 < b ? e.width / 2 : e.width / -2,
            m = 0 < f ? e.height / 2 : e.height / -2;
          Math.abs(g * f) < Math.abs(m * b)
            ? (m = (g * f) / b)
            : (g = (m * b) / f);
          c.x = g + e.centerX;
          c.y = m + e.centerY;
          return c;
        };
      },
      function (h, t, a) {
        var d = a(195),
          k = a(503),
          e = a(4);
        h.exports = function (b, c, f) {
          void 0 === f && (f = new e());
          if (k(b, c))
            switch (d(0, 3)) {
              case 0:
                f.x = b.x + Math.random() * (c.right - b.x);
                f.y = b.y + Math.random() * (c.top - b.y);
                break;
              case 1:
                f.x = c.x + Math.random() * (b.right - c.x);
                f.y = c.bottom + Math.random() * (b.bottom - c.bottom);
                break;
              case 2:
                f.x = b.x + Math.random() * (c.x - b.x);
                f.y = c.y + Math.random() * (b.bottom - c.y);
                break;
              case 3:
                (f.x = c.right + Math.random() * (b.right - c.right)),
                  (f.y = b.y + Math.random() * (c.bottom - b.y));
            }
          return f;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return a.width === d.width && a.height === d.height;
        };
      },
      function (h, t) {
        h.exports = function (a, d, k) {
          void 0 === k && (k = d);
          a.width *= d;
          a.height *= k;
          return a;
        };
      },
      function (h, t, a) {
        t = a(82);
        t.Area = a(1294);
        t.BuildEquilateral = a(1295);
        t.BuildFromPolygon = a(1296);
        t.BuildRight = a(1297);
        t.CenterOn = a(1298);
        t.Centroid = a(504);
        t.CircumCenter = a(1299);
        t.CircumCircle = a(1300);
        t.Clone = a(1301);
        t.Contains = a(115);
        t.ContainsArray = a(235);
        t.ContainsPoint = a(1302);
        t.CopyFrom = a(1303);
        t.Decompose = a(495);
        t.Equals = a(1304);
        t.GetPoint = a(476);
        t.GetPoints = a(477);
        t.InCenter = a(506);
        t.Perimeter = a(1305);
        t.Offset = a(505);
        t.Random = a(181);
        t.Rotate = a(1306);
        t.RotateAroundPoint = a(1307);
        t.RotateAroundXY = a(238);
        h.exports = t;
      },
      function (h, t) {
        h.exports = function (a) {
          var d = a.x1,
            k = a.y1;
          return Math.abs(
            ((a.x3 - d) * (a.y2 - k) - (a.x2 - d) * (a.y3 - k)) / 2
          );
        };
      },
      function (h, t, a) {
        var d = a(82);
        h.exports = function (k, e, b) {
          var c = (Math.sqrt(3) / 2) * b;
          return new d(k, e, k + b / 2, e + c, k - b / 2, e + c);
        };
      },
      function (h, t, a) {
        var d = a(59),
          k = a(82);
        h.exports = function (e, b, c, f, g) {
          void 0 === b && (b = null);
          void 0 === c && (c = 1);
          void 0 === f && (f = 1);
          void 0 === g && (g = []);
          b = d(e, b);
          for (var m, n, q, r, u, v, x = 0; x < b.length; x += 3)
            (m = b[x]),
              (n = b[x + 1]),
              (q = b[x + 2]),
              (r = e[2 * m] * c),
              (m = e[2 * m + 1] * f),
              (u = e[2 * n] * c),
              (n = e[2 * n + 1] * f),
              (v = e[2 * q] * c),
              (q = e[2 * q + 1] * f),
              g.push(new k(r, m, u, n, v, q));
          return g;
        };
      },
      function (h, t, a) {
        var d = a(82);
        h.exports = function (k, e, b, c) {
          void 0 === c && (c = b);
          return new d(k, e, k, e - c, k + b, e);
        };
      },
      function (h, t, a) {
        var d = a(504),
          k = a(505);
        h.exports = function (e, b, c, f) {
          void 0 === f && (f = d);
          f = f(e);
          return k(e, b - f.x, c - f.y);
        };
      },
      function (h, t, a) {
        var d = a(3);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          var b = k.x3,
            c = k.y3,
            f = k.x1 - b,
            g = k.y1 - c,
            m = k.x2 - b;
          k = k.y2 - c;
          var n = 2 * (f * k - g * m);
          e.x = b - (g * (m * m + k * k) - (f * f + g * g) * k) / n;
          e.y = c + (f * (m * m + k * k) - (f * f + g * g) * m) / n;
          return e;
        };
      },
      function (h, t, a) {
        var d = a(65);
        h.exports = function (k, e) {
          void 0 === e && (e = new d());
          var b = k.x1,
            c = k.y1,
            f = k.x2,
            g = k.y2,
            m = k.x3;
          k = k.y3;
          var n = f - b,
            q = g - c,
            r = m - b,
            u = k - c,
            v = n * (b + f) + q * (c + g),
            x = r * (b + m) + u * (c + k),
            y = 2 * (n * (k - g) - q * (m - f));
          1e-6 > Math.abs(y)
            ? ((n = Math.min(b, f, m)),
              (q = Math.min(c, g, k)),
              (b = 0.5 * (Math.max(b, f, m) - n)),
              (c = 0.5 * (Math.max(c, g, k) - q)),
              (e.x = n + b),
              (e.y = q + c))
            : ((e.x = (u * v - q * x) / y),
              (e.y = (n * x - r * v) / y),
              (b = e.x - b),
              (c = e.y - c));
          e.radius = Math.sqrt(b * b + c * c);
          return e;
        };
      },
      function (h, t, a) {
        var d = a(82);
        h.exports = function (k) {
          return new d(k.x1, k.y1, k.x2, k.y2, k.x3, k.y3);
        };
      },
      function (h, t, a) {
        var d = a(115);
        h.exports = function (k, e) {
          return d(k, e.x, e.y);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return d.setTo(a.x1, a.y1, a.x2, a.y2, a.x3, a.y3);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return (
            a.x1 === d.x1 &&
            a.y1 === d.y1 &&
            a.x2 === d.x2 &&
            a.y2 === d.y2 &&
            a.x3 === d.x3 &&
            a.y3 === d.y3
          );
        };
      },
      function (h, t, a) {
        var d = a(67);
        h.exports = function (k) {
          var e = k.getLineA(),
            b = k.getLineB();
          k = k.getLineC();
          return d(e) + d(b) + d(k);
        };
      },
      function (h, t, a) {
        var d = a(238),
          k = a(506);
        h.exports = function (e, b) {
          var c = k(e);
          return d(e, c.x, c.y, b);
        };
      },
      function (h, t, a) {
        var d = a(238);
        h.exports = function (k, e, b) {
          return d(k, e.x, e.y, b);
        };
      },
      function (h, t, a) {
        t = a(203);
        var d = a(17);
        a = {
          CreatePixelPerfectHandler: a(507),
          CreateInteractiveObject: a(508),
          Events: a(51),
          Gamepad: a(1309),
          InputManager: a(409),
          InputPlugin: a(1321),
          InputPluginCache: a(153),
          Keyboard: a(1322),
          Mouse: a(1336),
          Pointer: a(412),
          Touch: a(1337),
        };
        a = d(!1, a, t);
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          Axis: a(509),
          Button: a(510),
          Events: a(239),
          Gamepad: a(511),
          GamepadPlugin: a(1316),
          Configs: a(1317),
        };
      },
      function (h, t) {
        h.exports = "down";
      },
      function (h, t) {
        h.exports = "up";
      },
      function (h, t) {
        h.exports = "connected";
      },
      function (h, t) {
        h.exports = "disconnected";
      },
      function (h, t) {
        h.exports = "down";
      },
      function (h, t) {
        h.exports = "up";
      },
      function (h, t, a) {
        var d = a(0),
          k = a(9),
          e = a(239),
          b = a(511),
          c = a(6);
        t = a(153);
        var f = a(51);
        a = new d({
          Extends: k,
          initialize: function (g) {
            k.call(this);
            this.scene = g.scene;
            this.settings = this.scene.sys.settings;
            this.sceneInputPlugin = g;
            this.enabled = !0;
            this.target;
            this.gamepads = [];
            this.queue = [];
            this.onGamepadHandler;
            this._pad1;
            this._pad2;
            this._pad3;
            this._pad4;
            g.pluginEvents.once(f.BOOT, this.boot, this);
            g.pluginEvents.on(f.START, this.start, this);
          },
          boot: function () {
            var g = this.scene.sys.game,
              m = this.settings.input,
              n = g.config;
            this.enabled =
              c(m, "gamepad", n.inputGamepad) && g.device.input.gamepads;
            this.target = c(m, "gamepad.target", n.inputGamepadEventTarget);
            this.sceneInputPlugin.pluginEvents.once(
              f.DESTROY,
              this.destroy,
              this
            );
          },
          start: function () {
            this.enabled && (this.startListeners(), this.refreshPads());
            this.sceneInputPlugin.pluginEvents.once(
              f.SHUTDOWN,
              this.shutdown,
              this
            );
          },
          isActive: function () {
            return this.enabled && this.scene.sys.isActive();
          },
          startListeners: function () {
            var g = this,
              m = this.target,
              n = function (q) {
                !q.defaultPrevented &&
                  g.isActive() &&
                  (g.refreshPads(), g.queue.push(q));
              };
            this.onGamepadHandler = n;
            m.addEventListener("gamepadconnected", n, !1);
            m.addEventListener("gamepaddisconnected", n, !1);
            this.sceneInputPlugin.pluginEvents.on(f.UPDATE, this.update, this);
          },
          stopListeners: function () {
            this.target.removeEventListener(
              "gamepadconnected",
              this.onGamepadHandler
            );
            this.target.removeEventListener(
              "gamepaddisconnected",
              this.onGamepadHandler
            );
            this.sceneInputPlugin.pluginEvents.off(f.UPDATE, this.update);
            for (var g = 0; g < this.gamepads.length; g++)
              this.gamepads[g].removeAllListeners();
          },
          disconnectAll: function () {
            for (var g = 0; g < this.gamepads.length; g++)
              this.gamepads[g].pad.connected = !1;
          },
          refreshPads: function () {
            var g = navigator.getGamepads();
            if (g)
              for (var m = this.gamepads, n = 0; n < g.length; n++) {
                var q = g[n];
                if (q) {
                  var r = q.id,
                    u = q.index,
                    v = m[u];
                  v
                    ? v.id !== r
                      ? (v.destroy(), (m[u] = new b(this, q)))
                      : v.update(q)
                    : ((q = new b(this, q)), (m[u] = q), this._pad1)
                    ? this._pad2
                      ? this._pad3
                        ? this._pad4 || (this._pad4 = q)
                        : (this._pad3 = q)
                      : (this._pad2 = q)
                    : (this._pad1 = q);
                }
              }
            else this.disconnectAll();
          },
          getAll: function () {
            for (var g = [], m = this.gamepads, n = 0; n < m.length; n++)
              m[n] && g.push(m[n]);
            return g;
          },
          getPad: function (g) {
            for (var m = this.gamepads, n = 0; n < m.length; n++)
              if (m[n] && m[n].index === g) return m[n];
          },
          update: function () {
            if (this.enabled) {
              this.refreshPads();
              var g = this.queue.length;
              if (0 !== g)
                for (var m = this.queue.splice(0, g), n = 0; n < g; n++) {
                  var q = m[n],
                    r = this.getPad(q.gamepad.index);
                  "gamepadconnected" === q.type
                    ? this.emit(e.CONNECTED, r, q)
                    : "gamepaddisconnected" === q.type &&
                      this.emit(e.DISCONNECTED, r, q);
                }
            }
          },
          shutdown: function () {
            this.stopListeners();
            this.removeAllListeners();
          },
          destroy: function () {
            this.shutdown();
            for (var g = 0; g < this.gamepads.length; g++)
              this.gamepads[g] && this.gamepads[g].destroy();
            this.gamepads = [];
            this.target =
              this.sceneInputPlugin =
              this.settings =
              this.scene =
                null;
          },
          total: {
            get: function () {
              return this.gamepads.length;
            },
          },
          pad1: {
            get: function () {
              return this._pad1;
            },
          },
          pad2: {
            get: function () {
              return this._pad2;
            },
          },
          pad3: {
            get: function () {
              return this._pad3;
            },
          },
          pad4: {
            get: function () {
              return this._pad4;
            },
          },
        });
        t.register("GamepadPlugin", a, "gamepad", "gamepad", "inputGamepad");
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          DUALSHOCK_4: a(1318),
          SNES_USB: a(1319),
          XBOX_360: a(1320),
        };
      },
      function (h, t) {
        h.exports = {
          UP: 12,
          DOWN: 13,
          LEFT: 14,
          RIGHT: 15,
          SHARE: 8,
          OPTIONS: 9,
          PS: 16,
          TOUCHBAR: 17,
          X: 0,
          CIRCLE: 1,
          SQUARE: 2,
          TRIANGLE: 3,
          L1: 4,
          R1: 5,
          L2: 6,
          R2: 7,
          L3: 10,
          R3: 11,
          LEFT_STICK_H: 0,
          LEFT_STICK_V: 1,
          RIGHT_STICK_H: 2,
          RIGHT_STICK_V: 3,
        };
      },
      function (h, t) {
        h.exports = {
          UP: 12,
          DOWN: 13,
          LEFT: 14,
          RIGHT: 15,
          SELECT: 8,
          START: 9,
          B: 0,
          A: 1,
          Y: 2,
          X: 3,
          LEFT_SHOULDER: 4,
          RIGHT_SHOULDER: 5,
        };
      },
      function (h, t) {
        h.exports = {
          UP: 12,
          DOWN: 13,
          LEFT: 14,
          RIGHT: 15,
          MENU: 16,
          A: 0,
          B: 1,
          X: 2,
          Y: 3,
          LB: 4,
          RB: 5,
          LT: 6,
          RT: 7,
          BACK: 8,
          START: 9,
          LS: 10,
          RS: 11,
          LEFT_STICK_H: 0,
          LEFT_STICK_V: 1,
          RIGHT_STICK_H: 2,
          RIGHT_STICK_V: 3,
        };
      },
      function (h, t, a) {
        var d = a(65),
          k = a(66),
          e = a(0),
          b = a(203),
          c = a(508),
          f = a(507),
          g = a(50),
          m = a(111),
          n = a(112),
          q = a(51),
          r = a(9),
          u = a(2),
          v = a(56),
          x = a(153),
          y = a(7);
        t = a(24);
        var z = a(10),
          A = a(57),
          B = a(20),
          D = a(82),
          E = a(115);
        a = new e({
          Extends: r,
          initialize: function (C) {
            r.call(this);
            this.scene = C;
            this.systems = C.sys;
            this.settings = C.sys.settings;
            this.manager = C.sys.game.input;
            this.pluginEvents = new r();
            this.enabled = !0;
            this.displayList;
            this.cameras;
            x.install(this);
            this.mouse = this.manager.mouse;
            this.topOnly = !0;
            this.pollRate = -1;
            this._pollTimer = 0;
            var F = {
              cancelled: !1,
            };
            this._eventContainer = {
              stopPropagation: function () {
                F.cancelled = !0;
              },
            };
            this._eventData = F;
            this.dragTimeThreshold = this.dragDistanceThreshold = 0;
            this._temp = [];
            this._tempZones = [];
            this._list = [];
            this._pendingInsertion = [];
            this._pendingRemoval = [];
            this._draggable = [];
            this._drag = {
              0: [],
              1: [],
              2: [],
              3: [],
              4: [],
              5: [],
              6: [],
              7: [],
              8: [],
              9: [],
              10: [],
            };
            this._dragState = [];
            this._over = {
              0: [],
              1: [],
              2: [],
              3: [],
              4: [],
              5: [],
              6: [],
              7: [],
              8: [],
              9: [],
              10: [],
            };
            this._validTypes =
              "onDown onUp onOver onOut onMove onDragStart onDrag onDragEnd onDragEnter onDragLeave onDragOver onDrop".split(
                " "
              );
            this._updatedThisFrame = !1;
            C.sys.events.once(B.BOOT, this.boot, this);
            C.sys.events.on(B.START, this.start, this);
          },
          boot: function () {
            this.cameras = this.systems.cameras;
            this.displayList = this.systems.displayList;
            this.systems.events.once(B.DESTROY, this.destroy, this);
            this.pluginEvents.emit(q.BOOT);
          },
          start: function () {
            var C = this.systems.events;
            C.on(B.TRANSITION_START, this.transitionIn, this);
            C.on(B.TRANSITION_OUT, this.transitionOut, this);
            C.on(B.TRANSITION_COMPLETE, this.transitionComplete, this);
            C.on(B.PRE_UPDATE, this.preUpdate, this);
            C.once(B.SHUTDOWN, this.shutdown, this);
            this.manager.events.on(q.GAME_OUT, this.onGameOut, this);
            this.manager.events.on(q.GAME_OVER, this.onGameOver, this);
            this.enabled = !0;
            this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            this.pluginEvents.emit(q.START);
          },
          onGameOver: function (C) {
            this.isActive() && this.emit(q.GAME_OVER, C.timeStamp, C);
          },
          onGameOut: function (C) {
            this.isActive() && this.emit(q.GAME_OUT, C.timeStamp, C);
          },
          preUpdate: function () {
            this.pluginEvents.emit(q.PRE_UPDATE);
            var C = this._pendingRemoval,
              F = this._pendingInsertion,
              G = C.length,
              H = F.length;
            if (0 !== G || 0 !== H) {
              H = this._list;
              for (var K = 0; K < G; K++) {
                var I = C[K],
                  M = H.indexOf(I);
                -1 < M && (H.splice(M, 1), this.clear(I, !0));
              }
              C.length = 0;
              this._pendingRemoval.length = 0;
              this._list = H.concat(F.splice(0));
            }
          },
          isActive: function () {
            return this.enabled && this.scene.sys.isActive();
          },
          updatePoll: function (C, F) {
            if (!this.isActive()) return !1;
            this.pluginEvents.emit(q.UPDATE, C, F);
            if (this._updatedThisFrame) return (this._updatedThisFrame = !1);
            var G,
              H = this.manager,
              K = H.pointers;
            H = H.pointersTotal;
            for (G = 0; G < H; G++) K[G].updateMotion();
            if (0 === this._list.length) return !1;
            G = this.pollRate;
            if (-1 === G) return !1;
            if (0 < G)
              if (((this._pollTimer -= F), 0 > this._pollTimer))
                this._pollTimer = this.pollRate;
              else return !1;
            F = !1;
            for (G = 0; G < H; G++) {
              var I = 0,
                M = K[G];
              this._tempZones = [];
              this._temp = this.hitTestPointer(M);
              this.sortGameObjects(this._temp, M);
              this.sortDropZones(this._tempZones);
              this.topOnly &&
                (this._temp.length && this._temp.splice(1),
                this._tempZones.length && this._tempZones.splice(1));
              I += this.processOverOutEvents(M);
              2 === this.getDragState(M) &&
                this.processDragThresholdEvent(M, C);
              0 < I && (F = !0);
            }
            return F;
          },
          update: function (C, F) {
            if (!this.isActive()) return !1;
            for (var G = F.length, H = !1, K = 0; K < G; K++) {
              var I = 0,
                M = F[K];
              this._tempZones = [];
              this._temp = this.hitTestPointer(M);
              this.sortGameObjects(this._temp, M);
              this.sortDropZones(this._tempZones);
              this.topOnly &&
                (this._temp.length && this._temp.splice(1),
                this._tempZones.length && this._tempZones.splice(1));
              switch (C) {
                case b.MOUSE_DOWN:
                  I += this.processDragDownEvent(M);
                  I += this.processDownEvents(M);
                  I += this.processOverOutEvents(M);
                  break;
                case b.MOUSE_UP:
                  I += this.processDragUpEvent(M);
                  I += this.processUpEvents(M);
                  I += this.processOverOutEvents(M);
                  break;
                case b.TOUCH_START:
                  I += this.processDragDownEvent(M);
                  I += this.processDownEvents(M);
                  I += this.processOverEvents(M);
                  break;
                case b.TOUCH_END:
                case b.TOUCH_CANCEL:
                  I += this.processDragUpEvent(M);
                  I += this.processUpEvents(M);
                  I += this.processOutEvents(M);
                  break;
                case b.MOUSE_MOVE:
                case b.TOUCH_MOVE:
                  I += this.processDragMoveEvent(M);
                  I += this.processMoveEvents(M);
                  I += this.processOverOutEvents(M);
                  break;
                case b.MOUSE_WHEEL:
                  I += this.processWheelEvent(M);
              }
              0 < I && (H = !0);
            }
            this._updatedThisFrame = !0;
            return H;
          },
          clear: function (C, F) {
            void 0 === F && (F = !1);
            var G = C.input;
            if (G)
              return (
                F || this.queueForRemoval(C),
                (G.gameObject = void 0),
                (G.target = void 0),
                (G.hitArea = void 0),
                (G.hitAreaCallback = void 0),
                (G.callbackContext = void 0),
                (C.input = null),
                (F = this._draggable.indexOf(C)),
                -1 < F && this._draggable.splice(F, 1),
                (F = this._drag[0].indexOf(C)),
                -1 < F && this._drag[0].splice(F, 1),
                (F = this._over[0].indexOf(C)),
                -1 < F &&
                  (this._over[0].splice(F, 1), this.manager.resetCursor(G)),
                C
              );
          },
          disable: function (C) {
            C.input.enabled = !1;
          },
          enable: function (C, F, G, H) {
            void 0 === H && (H = !1);
            C.input ? (C.input.enabled = !0) : this.setHitArea(C, F, G);
            C.input && H && !C.input.dropZone && (C.input.dropZone = H);
            return this;
          },
          hitTestPointer: function (C) {
            for (
              var F = this.cameras.getCamerasBelowPointer(C), G = 0;
              G < F.length;
              G++
            ) {
              for (
                var H = F[G], K = this.manager.hitTest(C, this._list, H), I = 0;
                I < K.length;
                I++
              ) {
                var M = K[I];
                M.input.dropZone && this._tempZones.push(M);
              }
              if (0 < K.length) return (C.camera = H), K;
            }
            C.camera = F[0];
            return [];
          },
          processDownEvents: function (C) {
            for (
              var F = 0,
                G = this._temp,
                H = this._eventData,
                K = this._eventContainer,
                I = (H.cancelled = !1),
                M = 0;
              M < G.length;
              M++
            ) {
              var N = G[M];
              if (N.input) {
                F++;
                N.emit(
                  q.GAMEOBJECT_POINTER_DOWN,
                  C,
                  N.input.localX,
                  N.input.localY,
                  K
                );
                if (H.cancelled || !N.input) {
                  I = !0;
                  break;
                }
                this.emit(q.GAMEOBJECT_DOWN, C, N, K);
                if (H.cancelled || !N.input) {
                  I = !0;
                  break;
                }
              }
            }
            !I &&
              this.manager &&
              (C.downElement === this.manager.game.canvas
                ? this.emit(q.POINTER_DOWN, C, G)
                : this.emit(q.POINTER_DOWN_OUTSIDE, C));
            return F;
          },
          getDragState: function (C) {
            return this._dragState[C.id];
          },
          setDragState: function (C, F) {
            this._dragState[C.id] = F;
          },
          processDragThresholdEvent: function (C, F) {
            var G = !1,
              H = this.dragTimeThreshold,
              K = this.dragDistanceThreshold;
            0 < K && g(C.x, C.y, C.downX, C.downY) >= K
              ? (G = !0)
              : 0 < H && F >= C.downTime + H && (G = !0);
            if (G) return this.setDragState(C, 3), this.processDragStartList(C);
          },
          processDragStartList: function (C) {
            if (3 !== this.getDragState(C)) return 0;
            for (var F = this._drag[C.id], G = 0; G < F.length; G++) {
              var H = F[G],
                K = H.input;
              K.dragState = 2;
              K.dragStartX = H.x;
              K.dragStartY = H.y;
              K.dragStartXGlobal = C.worldX;
              K.dragStartYGlobal = C.worldY;
              K.dragX = K.dragStartXGlobal - K.dragStartX;
              K.dragY = K.dragStartYGlobal - K.dragStartY;
              H.emit(q.GAMEOBJECT_DRAG_START, C, K.dragX, K.dragY);
              this.emit(q.DRAG_START, C, H);
            }
            this.setDragState(C, 4);
            return F.length;
          },
          processDragDownEvent: function (C) {
            var F = this._temp;
            if (
              0 === this._draggable.length ||
              0 === F.length ||
              !C.primaryDown ||
              0 !== this.getDragState(C)
            )
              return 0;
            this.setDragState(C, 1);
            for (var G = [], H = 0; H < F.length; H++) {
              var K = F[H];
              K.input.draggable && 0 === K.input.dragState && G.push(K);
            }
            if (0 === G.length) return this.setDragState(C, 0), 0;
            1 < G.length &&
              (this.sortGameObjects(G, C), this.topOnly && G.splice(1));
            this._drag[C.id] = G;
            if (
              0 === this.dragDistanceThreshold &&
              0 === this.dragTimeThreshold
            )
              return this.setDragState(C, 3), this.processDragStartList(C);
            this.setDragState(C, 2);
            return 0;
          },
          processDragMoveEvent: function (C) {
            2 === this.getDragState(C) &&
              this.processDragThresholdEvent(C, this.manager.game.loop.now);
            if (4 !== this.getDragState(C)) return 0;
            for (
              var F = this._tempZones, G = this._drag[C.id], H = 0;
              H < G.length;
              H++
            ) {
              var K = G[H],
                I = K.input,
                M = I.target;
              if (M) {
                var N = F.indexOf(M);
                0 === N
                  ? (K.emit(q.GAMEOBJECT_DRAG_OVER, C, M),
                    this.emit(q.DRAG_OVER, C, K, M))
                  : 0 < N
                  ? (K.emit(q.GAMEOBJECT_DRAG_LEAVE, C, M),
                    this.emit(q.DRAG_LEAVE, C, K, M),
                    (I.target = F[0]),
                    (M = I.target),
                    K.emit(q.GAMEOBJECT_DRAG_ENTER, C, M),
                    this.emit(q.DRAG_ENTER, C, K, M))
                  : (K.emit(q.GAMEOBJECT_DRAG_LEAVE, C, M),
                    this.emit(q.DRAG_LEAVE, C, K, M),
                    F[0]
                      ? ((I.target = F[0]),
                        (M = I.target),
                        K.emit(q.GAMEOBJECT_DRAG_ENTER, C, M),
                        this.emit(q.DRAG_ENTER, C, K, M))
                      : (I.target = null));
              } else
                !M &&
                  F[0] &&
                  ((I.target = F[0]),
                  (M = I.target),
                  K.emit(q.GAMEOBJECT_DRAG_ENTER, C, M),
                  this.emit(q.DRAG_ENTER, C, K, M));
              if (K.parentContainer) {
                N = C.worldX - I.dragStartXGlobal;
                var P = C.worldY - I.dragStartYGlobal,
                  J = K.getParentRotation();
                M = N * Math.cos(J) + P * Math.sin(J);
                N = P * Math.cos(J) - N * Math.sin(J);
                M *= 1 / K.parentContainer.scaleX;
                N *= 1 / K.parentContainer.scaleY;
                M += I.dragStartX;
                I = N + I.dragStartY;
              } else (M = C.worldX - I.dragX), (I = C.worldY - I.dragY);
              K.emit(q.GAMEOBJECT_DRAG, C, M, I);
              this.emit(q.DRAG, C, K, M, I);
            }
            return G.length;
          },
          processDragUpEvent: function (C) {
            for (var F = this._drag[C.id], G = 0; G < F.length; G++) {
              var H = F[G],
                K = H.input;
              if (K && 2 === K.dragState) {
                K.dragState = 0;
                K.dragX = K.localX - H.displayOriginX;
                K.dragY = K.localY - H.displayOriginY;
                var I = !1,
                  M = K.target;
                M &&
                  (H.emit(q.GAMEOBJECT_DROP, C, M),
                  this.emit(q.DROP, C, H, M),
                  (K.target = null),
                  (I = !0));
                H.input &&
                  (H.emit(q.GAMEOBJECT_DRAG_END, C, K.dragX, K.dragY, I),
                  this.emit(q.DRAG_END, C, H, I));
              }
            }
            this.setDragState(C, 0);
            F.splice(0);
            return 0;
          },
          processMoveEvents: function (C) {
            for (
              var F = 0,
                G = this._temp,
                H = this._eventData,
                K = this._eventContainer,
                I = (H.cancelled = !1),
                M = 0;
              M < G.length;
              M++
            ) {
              var N = G[M];
              if (N.input) {
                F++;
                N.emit(
                  q.GAMEOBJECT_POINTER_MOVE,
                  C,
                  N.input.localX,
                  N.input.localY,
                  K
                );
                if (H.cancelled || !N.input) {
                  I = !0;
                  break;
                }
                this.emit(q.GAMEOBJECT_MOVE, C, N, K);
                if (H.cancelled || !N.input) {
                  I = !0;
                  break;
                }
                if (this.topOnly) break;
              }
            }
            I || this.emit(q.POINTER_MOVE, C, G);
            return F;
          },
          processWheelEvent: function (C) {
            for (
              var F = 0,
                G = this._temp,
                H = this._eventData,
                K = this._eventContainer,
                I = (H.cancelled = !1),
                M = C.deltaX,
                N = C.deltaY,
                P = C.deltaZ,
                J = 0;
              J < G.length;
              J++
            ) {
              var L = G[J];
              if (L.input) {
                F++;
                L.emit(q.GAMEOBJECT_POINTER_WHEEL, C, M, N, P, K);
                if (H.cancelled || !L.input) {
                  I = !0;
                  break;
                }
                this.emit(q.GAMEOBJECT_WHEEL, C, L, M, N, P, K);
                if (H.cancelled || !L.input) {
                  I = !0;
                  break;
                }
              }
            }
            I || this.emit(q.POINTER_WHEEL, C, G, M, N, P);
            return F;
          },
          processOverEvents: function (C) {
            var F = this._temp,
              G = 0,
              H = F.length,
              K = [];
            if (0 < H) {
              for (
                var I = this.manager,
                  M = this._eventData,
                  N = this._eventContainer,
                  P = (M.cancelled = !1),
                  J = 0;
                J < H;
                J++
              ) {
                var L = F[J];
                if (L.input) {
                  K.push(L);
                  I.setCursor(L.input);
                  L.emit(
                    q.GAMEOBJECT_POINTER_OVER,
                    C,
                    L.input.localX,
                    L.input.localY,
                    N
                  );
                  G++;
                  if (M.cancelled || !L.input) {
                    P = !0;
                    break;
                  }
                  this.emit(q.GAMEOBJECT_OVER, C, L, N);
                  if (M.cancelled || !L.input) {
                    P = !0;
                    break;
                  }
                }
              }
              P || this.emit(q.POINTER_OVER, C, K);
            }
            this._over[C.id] = K;
            return G;
          },
          processOutEvents: function (C) {
            var F = this._over[C.id],
              G = 0,
              H = F.length;
            if (0 < H) {
              var K = this.manager,
                I = this._eventData,
                M = this._eventContainer;
              I.cancelled = !1;
              this.sortGameObjects(F, C);
              for (var N = 0; N < H; N++) {
                var P = F[N];
                if (P.input) {
                  K.resetCursor(P.input);
                  P.emit(q.GAMEOBJECT_POINTER_OUT, C, M);
                  G++;
                  if (I.cancelled || !P.input) break;
                  this.emit(q.GAMEOBJECT_OUT, C, P, M);
                  if (I.cancelled || !P.input) break;
                  this.emit(q.POINTER_OUT, C, F);
                }
              }
              this._over[C.id] = [];
            }
            return G;
          },
          processOverOutEvents: function (C) {
            var F = this._temp,
              G,
              H = [],
              K = [],
              I = [],
              M = this._over[C.id],
              N = this._drag[C.id],
              P = this.manager;
            for (G = 0; G < M.length; G++) {
              var J = M[G];
              -1 === F.indexOf(J) && -1 === N.indexOf(J)
                ? H.push(J)
                : I.push(J);
            }
            for (G = 0; G < F.length; G++)
              (J = F[G]), -1 === M.indexOf(J) && K.push(J);
            M = H.length;
            F = 0;
            N = this._eventData;
            var L = this._eventContainer,
              O = (N.cancelled = !1);
            if (0 < M) {
              this.sortGameObjects(H, C);
              for (G = 0; G < M; G++)
                if (((J = H[G]), J.input)) {
                  P.resetCursor(J.input);
                  J.emit(q.GAMEOBJECT_POINTER_OUT, C, L);
                  F++;
                  if (N.cancelled || !J.input) {
                    O = !0;
                    break;
                  }
                  this.emit(q.GAMEOBJECT_OUT, C, J, L);
                  if (N.cancelled || !J.input) {
                    O = !0;
                    break;
                  }
                }
              O || this.emit(q.POINTER_OUT, C, H);
            }
            M = K.length;
            O = N.cancelled = !1;
            if (0 < M) {
              this.sortGameObjects(K, C);
              for (G = 0; G < M; G++)
                if (((J = K[G]), J.input)) {
                  P.setCursor(J.input);
                  J.emit(
                    q.GAMEOBJECT_POINTER_OVER,
                    C,
                    J.input.localX,
                    J.input.localY,
                    L
                  );
                  F++;
                  if (N.cancelled || !J.input) {
                    O = !0;
                    break;
                  }
                  this.emit(q.GAMEOBJECT_OVER, C, J, L);
                  if (N.cancelled || !J.input) {
                    O = !0;
                    break;
                  }
                }
              O || this.emit(q.POINTER_OVER, C, K);
            }
            M = I.concat(K);
            this._over[C.id] = this.sortGameObjects(M, C);
            return F;
          },
          processUpEvents: function (C) {
            for (
              var F = this._temp,
                G = this._eventData,
                H = this._eventContainer,
                K = (G.cancelled = !1),
                I = 0;
              I < F.length;
              I++
            ) {
              var M = F[I];
              if (M.input) {
                M.emit(
                  q.GAMEOBJECT_POINTER_UP,
                  C,
                  M.input.localX,
                  M.input.localY,
                  H
                );
                if (G.cancelled || !M.input) {
                  K = !0;
                  break;
                }
                this.emit(q.GAMEOBJECT_UP, C, M, H);
                if (G.cancelled || !M.input) {
                  K = !0;
                  break;
                }
              }
            }
            !K &&
              this.manager &&
              (C.upElement === this.manager.game.canvas
                ? this.emit(q.POINTER_UP, C, F)
                : this.emit(q.POINTER_UP_OUTSIDE, C));
            return F.length;
          },
          queueForInsertion: function (C) {
            -1 === this._pendingInsertion.indexOf(C) &&
              -1 === this._list.indexOf(C) &&
              this._pendingInsertion.push(C);
            return this;
          },
          queueForRemoval: function (C) {
            this._pendingRemoval.push(C);
            return this;
          },
          setDraggable: function (C, F) {
            void 0 === F && (F = !0);
            Array.isArray(C) || (C = [C]);
            for (var G = 0; G < C.length; G++) {
              var H = C[G];
              H.input.draggable = F;
              var K = this._draggable.indexOf(H);
              F && -1 === K
                ? this._draggable.push(H)
                : !F && -1 < K && this._draggable.splice(K, 1);
            }
            return this;
          },
          makePixelPerfect: function (C) {
            void 0 === C && (C = 1);
            return f(this.systems.textures, C);
          },
          setHitArea: function (C, F, G) {
            if (void 0 === F) return this.setHitAreaFromTexture(C);
            Array.isArray(C) || (C = [C]);
            var H = !1,
              K = !1,
              I = !1,
              M = !1,
              N = !1,
              P = !0;
            if (y(F)) {
              var J = F;
              F = u(J, "hitArea", null);
              G = u(J, "hitAreaCallback", null);
              H = u(J, "draggable", !1);
              K = u(J, "dropZone", !1);
              I = u(J, "cursor", !1);
              M = u(J, "useHandCursor", !1);
              N = u(J, "pixelPerfect", !1);
              J = u(J, "alphaTolerance", 1);
              N && ((F = {}), (G = this.makePixelPerfect(J)));
              (F && G) || (this.setHitAreaFromTexture(C), (P = !1));
            } else "function" !== typeof F || G || ((G = F), (F = {}));
            for (J = 0; J < C.length; J++) {
              var L = C[J];
              if (N && "Container" === L.type)
                console.warn(
                  "Cannot pixelPerfect test a Container. Use a custom callback."
                );
              else {
                var O = L.input ? L.input : c(L, F, G);
                O.customHitArea = P;
                O.dropZone = K;
                O.cursor = M ? "pointer" : I;
                L.input = O;
                H && this.setDraggable(L);
                this.queueForInsertion(L);
              }
            }
            return this;
          },
          setHitAreaCircle: function (C, F, G, H, K) {
            void 0 === K && (K = k);
            F = new d(F, G, H);
            return this.setHitArea(C, F, K);
          },
          setHitAreaEllipse: function (C, F, G, H, K, I) {
            void 0 === I && (I = n);
            F = new m(F, G, H, K);
            return this.setHitArea(C, F, I);
          },
          setHitAreaFromTexture: function (C, F) {
            void 0 === F && (F = A);
            Array.isArray(C) || (C = [C]);
            for (var G = 0; G < C.length; G++) {
              var H = C[G],
                K = H.frame,
                I = 0,
                M = 0;
              H.width
                ? ((I = H.width), (M = H.height))
                : K && ((I = K.realWidth), (M = K.realHeight));
              "Container" !== H.type || (0 !== I && 0 !== M)
                ? 0 !== I &&
                  0 !== M &&
                  ((H.input = c(H, new z(0, 0, I, M), F)),
                  this.queueForInsertion(H))
                : console.warn(
                    "Container.setInteractive must specify a Shape or call setSize() first"
                  );
            }
            return this;
          },
          setHitAreaRectangle: function (C, F, G, H, K, I) {
            void 0 === I && (I = A);
            F = new z(F, G, H, K);
            return this.setHitArea(C, F, I);
          },
          setHitAreaTriangle: function (C, F, G, H, K, I, M, N) {
            void 0 === N && (N = E);
            F = new D(F, G, H, K, I, M);
            return this.setHitArea(C, F, N);
          },
          enableDebug: function (C, F) {
            void 0 === F && (F = 65280);
            var G = C.input;
            if (!G || !G.hitArea) return this;
            var H = G.hitArea,
              K = H.type,
              I = G.hitAreaDebug,
              M = this.systems.add,
              N = this.systems.updateList;
            I && (N.remove(I), I.destroy(), (I = null));
            var P = 0,
              J = 0;
            switch (K) {
              case v.CIRCLE:
                I = M.arc(0, 0, H.radius);
                P = H.x - H.radius;
                J = H.y - H.radius;
                break;
              case v.ELLIPSE:
                I = M.ellipse(0, 0, H.width, H.height);
                P = H.x - H.width / 2;
                J = H.y - H.height / 2;
                break;
              case v.LINE:
                I = M.line(0, 0, H.x1, H.y1, H.x2, H.y2);
                break;
              case v.POLYGON:
                I = M.polygon(0, 0, H.points);
                break;
              case v.RECTANGLE:
                I = M.rectangle(0, 0, H.width, H.height);
                P = H.x;
                J = H.y;
                break;
              case v.TRIANGLE:
                I = M.triangle(0, 0, H.x1, H.y1, H.x2, H.y2, H.x3, H.y3);
            }
            I &&
              ((I.isFilled = !1),
              (I.preUpdate = function () {
                I.setStrokeStyle(1 / C.scale, F);
                I.setDisplayOrigin(C.displayOriginX, C.displayOriginY);
                var L = C.x,
                  O = C.y,
                  Q = C.rotation,
                  S = C.scaleX,
                  R = C.scaleY;
                C.parentContainer &&
                  ((R = C.getWorldTransformMatrix()),
                  (L = R.tx),
                  (O = R.ty),
                  (Q = R.rotation),
                  (S = R.scaleX),
                  (R = R.scaleY));
                I.setRotation(Q);
                I.setScale(S, R);
                I.setPosition(L + P, O + J);
                I.setScrollFactor(C.scrollFactorX, C.scrollFactorY);
                I.setDepth(C.depth);
              }),
              N.add(I),
              (G.hitAreaDebug = I));
            return this;
          },
          removeDebug: function (C) {
            if ((C = C.input) && C.hitAreaDebug) {
              var F = C.hitAreaDebug;
              this.systems.updateList.remove(F);
              F.destroy();
              C.hitAreaDebug = null;
            }
            return this;
          },
          setPollAlways: function () {
            return this.setPollRate(0);
          },
          setPollOnMove: function () {
            return this.setPollRate(-1);
          },
          setPollRate: function (C) {
            this.pollRate = C;
            this._pollTimer = 0;
            return this;
          },
          setGlobalTopOnly: function (C) {
            this.manager.globalTopOnly = C;
            return this;
          },
          setTopOnly: function (C) {
            this.topOnly = C;
            return this;
          },
          sortGameObjects: function (C, F) {
            if (2 > C.length) return C;
            var G = F.camera.renderList;
            return C.sort(function (H, K) {
              return G.indexOf(K) - G.indexOf(H);
            });
          },
          sortDropZones: function (C) {
            if (2 > C.length) return C;
            this.scene.sys.depthSort();
            return C.sort(this.sortDropZoneHandler.bind(this));
          },
          sortDropZoneHandler: function (C, F) {
            if (C.parentContainer || F.parentContainer) {
              if (C.parentContainer === F.parentContainer)
                return (
                  F.parentContainer.getIndex(F) - C.parentContainer.getIndex(C)
                );
              if (C.parentContainer === F) return -1;
              if (F.parentContainer === C) return 1;
              C = C.getIndexList();
              F = F.getIndexList();
              for (var G = Math.min(C.length, F.length), H = 0; H < G; H++) {
                var K = C[H],
                  I = F[H];
                if (K !== I) return I - K;
              }
              return F.length - C.length;
            }
            return this.displayList.getIndex(F) - this.displayList.getIndex(C);
          },
          stopPropagation: function () {
            this.manager._tempSkip = !0;
            return this;
          },
          addPointer: function (C) {
            return this.manager.addPointer(C);
          },
          setDefaultCursor: function (C) {
            this.manager.setDefaultCursor(C);
            return this;
          },
          transitionIn: function () {
            this.enabled = this.settings.transitionAllowInput;
          },
          transitionComplete: function () {
            this.settings.transitionAllowInput || (this.enabled = !0);
          },
          transitionOut: function () {
            this.enabled = this.settings.transitionAllowInput;
          },
          shutdown: function () {
            this.pluginEvents.emit(q.SHUTDOWN);
            this._temp.length = 0;
            this._list.length = 0;
            this._draggable.length = 0;
            this._pendingRemoval.length = 0;
            this._pendingInsertion.length = 0;
            for (var C = (this._dragState.length = 0); 10 > C; C++)
              (this._drag[C] = []), (this._over[C] = []);
            this.removeAllListeners();
            C = this.manager;
            C.canvas.style.cursor = C.defaultCursor;
            var F = this.systems.events;
            F.off(B.TRANSITION_START, this.transitionIn, this);
            F.off(B.TRANSITION_OUT, this.transitionOut, this);
            F.off(B.TRANSITION_COMPLETE, this.transitionComplete, this);
            F.off(B.PRE_UPDATE, this.preUpdate, this);
            C.events.off(q.GAME_OUT, this.onGameOut, this);
            C.events.off(q.GAME_OVER, this.onGameOver, this);
            F.off(B.SHUTDOWN, this.shutdown, this);
          },
          destroy: function () {
            this.shutdown();
            this.pluginEvents.emit(q.DESTROY);
            this.pluginEvents.removeAllListeners();
            this.scene.sys.events.off(B.START, this.start, this);
            this.mouse =
              this.events =
              this.manager =
              this.cameras =
              this.scene =
                null;
          },
          x: {
            get: function () {
              return this.manager.activePointer.x;
            },
          },
          y: {
            get: function () {
              return this.manager.activePointer.y;
            },
          },
          isOver: {
            get: function () {
              return this.manager.isOver;
            },
          },
          mousePointer: {
            get: function () {
              return this.manager.mousePointer;
            },
          },
          activePointer: {
            get: function () {
              return this.manager.activePointer;
            },
          },
          pointer1: {
            get: function () {
              return this.manager.pointers[1];
            },
          },
          pointer2: {
            get: function () {
              return this.manager.pointers[2];
            },
          },
          pointer3: {
            get: function () {
              return this.manager.pointers[3];
            },
          },
          pointer4: {
            get: function () {
              return this.manager.pointers[4];
            },
          },
          pointer5: {
            get: function () {
              return this.manager.pointers[5];
            },
          },
          pointer6: {
            get: function () {
              return this.manager.pointers[6];
            },
          },
          pointer7: {
            get: function () {
              return this.manager.pointers[7];
            },
          },
          pointer8: {
            get: function () {
              return this.manager.pointers[8];
            },
          },
          pointer9: {
            get: function () {
              return this.manager.pointers[9];
            },
          },
          pointer10: {
            get: function () {
              return this.manager.pointers[10];
            },
          },
        });
        t.register("InputPlugin", a, "input");
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          Events: a(154),
          KeyboardManager: a(410),
          KeyboardPlugin: a(1330),
          Key: a(512),
          KeyCodes: a(143),
          KeyCombo: a(513),
          AdvanceKeyCombo: a(515),
          ProcessKeyCombo: a(514),
          ResetKeyCombo: a(516),
          JustDown: a(1332),
          JustUp: a(1333),
          DownDuration: a(1334),
          UpDuration: a(1335),
        };
      },
      function (h, t) {
        h.exports = "keydown";
      },
      function (h, t) {
        h.exports = "keyup";
      },
      function (h, t) {
        h.exports = "keycombomatch";
      },
      function (h, t) {
        h.exports = "down";
      },
      function (h, t) {
        h.exports = "keydown-";
      },
      function (h, t) {
        h.exports = "keyup-";
      },
      function (h, t) {
        h.exports = "up";
      },
      function (h, t, a) {
        var d = a(0),
          k = a(9),
          e = a(154),
          b = a(22),
          c = a(6),
          f = a(51);
        t = a(153);
        var g = a(512),
          m = a(143),
          n = a(513),
          q = a(1331),
          r = a(20),
          u = a(76);
        a = new d({
          Extends: k,
          initialize: function (v) {
            k.call(this);
            this.game = v.systems.game;
            this.scene = v.scene;
            this.settings = this.scene.sys.settings;
            this.sceneInputPlugin = v;
            this.manager = v.manager.keyboard;
            this.enabled = !0;
            this.keys = [];
            this.combos = [];
            this.prevCode = null;
            this.prevTime = 0;
            this.prevType = null;
            v.pluginEvents.once(f.BOOT, this.boot, this);
            v.pluginEvents.on(f.START, this.start, this);
          },
          boot: function () {
            var v = this.settings.input;
            this.enabled = c(v, "keyboard", !0);
            (v = c(v, "keyboard.capture", null)) && this.addCaptures(v);
            this.sceneInputPlugin.pluginEvents.once(
              f.DESTROY,
              this.destroy,
              this
            );
          },
          start: function () {
            this.sceneInputPlugin.manager.events.on(
              f.MANAGER_PROCESS,
              this.update,
              this
            );
            this.sceneInputPlugin.pluginEvents.once(
              f.SHUTDOWN,
              this.shutdown,
              this
            );
            this.game.events.on(b.BLUR, this.resetKeys, this);
            this.scene.sys.events.on(r.PAUSE, this.resetKeys, this);
            this.scene.sys.events.on(r.SLEEP, this.resetKeys, this);
          },
          isActive: function () {
            return this.enabled && this.scene.sys.isActive();
          },
          addCapture: function (v) {
            this.manager.addCapture(v);
            return this;
          },
          removeCapture: function (v) {
            this.manager.removeCapture(v);
            return this;
          },
          getCaptures: function () {
            return this.manager.captures;
          },
          enableGlobalCapture: function () {
            this.manager.preventDefault = !0;
            return this;
          },
          disableGlobalCapture: function () {
            this.manager.preventDefault = !1;
            return this;
          },
          clearCaptures: function () {
            this.manager.clearCaptures();
            return this;
          },
          createCursorKeys: function () {
            return this.addKeys({
              up: m.UP,
              down: m.DOWN,
              left: m.LEFT,
              right: m.RIGHT,
              space: m.SPACE,
              shift: m.SHIFT,
            });
          },
          addKeys: function (v, x, y) {
            void 0 === x && (x = !0);
            void 0 === y && (y = !1);
            var z = {};
            if ("string" === typeof v) {
              v = v.split(",");
              for (var A = 0; A < v.length; A++) {
                var B = v[A].trim();
                B && (z[B] = this.addKey(B, x, y));
              }
            } else for (A in v) z[A] = this.addKey(v[A], x, y);
            return z;
          },
          addKey: function (v, x, y) {
            void 0 === x && (x = !0);
            void 0 === y && (y = !1);
            var z = this.keys;
            if (v instanceof g) {
              var A = z.indexOf(v);
              -1 < A ? (z[A] = v) : (z[v.keyCode] = v);
              x && this.addCapture(v.keyCode);
              v.setEmitOnRepeat(y);
              return v;
            }
            "string" === typeof v && (v = m[v.toUpperCase()]);
            z[v] ||
              ((z[v] = new g(this, v)),
              x && this.addCapture(v),
              z[v].setEmitOnRepeat(y));
            return z[v];
          },
          removeKey: function (v, x) {
            void 0 === x && (x = !1);
            var y = this.keys;
            if (v instanceof g) {
              var z = y.indexOf(v);
              if (-1 < z) {
                var A = this.keys[z];
                this.keys[z] = void 0;
              }
            } else "string" === typeof v && (v = m[v.toUpperCase()]);
            y[v] && ((A = y[v]), (y[v] = void 0));
            A && ((A.plugin = null), x && A.destroy());
            return this;
          },
          removeAllKeys: function (v) {
            for (var x = this.keys, y = 0; y < x.length; y++) {
              var z = x[y];
              z && ((x[y] = void 0), v && z.destroy());
            }
            return this;
          },
          createCombo: function (v, x) {
            return new n(this, v, x);
          },
          checkDown: function (v, x) {
            void 0 === x && (x = 0);
            return this.enabled &&
              v.isDown &&
              ((x = u(this.time - v.timeDown, x)), x > v._tick)
              ? ((v._tick = x), !0)
              : !1;
          },
          update: function () {
            var v = this.manager.queue,
              x = v.length;
            if (this.isActive() && 0 !== x)
              for (var y = this.keys, z = 0; z < x; z++) {
                var A = v[z],
                  B = A.keyCode,
                  D = y[B],
                  E = !1;
                void 0 === A.cancelled &&
                  ((A.cancelled = 0),
                  (A.stopImmediatePropagation = function () {
                    A.cancelled = 1;
                  }),
                  (A.stopPropagation = function () {
                    A.cancelled = -1;
                  }));
                if (
                  -1 !== A.cancelled &&
                  (B !== this.prevCode ||
                    A.timeStamp !== this.prevTime ||
                    A.type !== this.prevType)
                ) {
                  this.prevCode = B;
                  this.prevTime = A.timeStamp;
                  this.prevType = A.type;
                  if ("keydown" === A.type)
                    D && ((E = D.isDown), D.onDown(A)),
                      A.cancelled ||
                        (D && E) ||
                        (q[B] && this.emit(e.KEY_DOWN + q[B], A),
                        A.cancelled || this.emit(e.ANY_KEY_DOWN, A));
                  else {
                    if (D) D.onUp(A);
                    A.cancelled ||
                      (q[B] && this.emit(e.KEY_UP + q[B], A),
                      A.cancelled || this.emit(e.ANY_KEY_UP, A));
                  }
                  1 === A.cancelled && (A.cancelled = 0);
                }
              }
          },
          resetKeys: function () {
            for (var v = this.keys, x = 0; x < v.length; x++)
              v[x] && v[x].reset();
            return this;
          },
          shutdown: function () {
            this.removeAllKeys(!0);
            this.removeAllListeners();
            this.sceneInputPlugin.manager.events.off(
              f.MANAGER_PROCESS,
              this.update,
              this
            );
            this.game.events.off(b.BLUR, this.resetKeys);
            this.scene.sys.events.off(r.PAUSE, this.resetKeys, this);
            this.scene.sys.events.off(r.SLEEP, this.resetKeys, this);
            this.queue = [];
          },
          destroy: function () {
            this.shutdown();
            for (var v = this.keys, x = 0; x < v.length; x++)
              v[x] && v[x].destroy();
            this.keys = [];
            this.combos = [];
            this.queue = [];
            this.manager =
              this.sceneInputPlugin =
              this.settings =
              this.scene =
                null;
          },
          time: {
            get: function () {
              return this.sceneInputPlugin.manager.time;
            },
          },
        });
        t.register(
          "KeyboardPlugin",
          a,
          "keyboard",
          "keyboard",
          "inputKeyboard"
        );
        h.exports = a;
      },
      function (h, t, a) {
        t = a(143);
        a = {};
        for (var d in t) a[t[d]] = d;
        h.exports = a;
      },
      function (h, t) {
        h.exports = function (a) {
          return a._justDown ? ((a._justDown = !1), !0) : !1;
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a._justUp ? ((a._justUp = !1), !0) : !1;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = 50);
          var k = a.plugin.game.loop.time - a.timeDown;
          return a.isDown && k < d;
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          void 0 === d && (d = 50);
          var k = a.plugin.game.loop.time - a.timeUp;
          return a.isUp && k < d;
        };
      },
      function (h, t, a) {
        h.exports = {
          MouseManager: a(411),
        };
      },
      function (h, t, a) {
        h.exports = {
          TouchManager: a(413),
        };
      },
      function (h, t, a) {
        t = a(21);
        var d = a(17);
        a = {
          Events: a(95),
          FileTypes: a(1339),
          File: a(23),
          FileTypesManager: a(8),
          GetURL: a(155),
          LoaderPlugin: a(1365),
          MergeXHRSettings: a(240),
          MultiFile: a(49),
          XHRLoader: a(517),
          XHRSettings: a(156),
        };
        a = d(!1, a, t);
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          AnimationJSONFile: a(1340),
          AsepriteFile: a(1341),
          AtlasJSONFile: a(1342),
          AtlasXMLFile: a(1343),
          AudioFile: a(518),
          AudioSpriteFile: a(1344),
          BinaryFile: a(1345),
          BitmapFontFile: a(1346),
          CSSFile: a(1347),
          GLSLFile: a(1348),
          HTML5AudioFile: a(519),
          HTMLFile: a(1349),
          HTMLTextureFile: a(1350),
          ImageFile: a(71),
          JSONFile: a(61),
          MultiAtlasFile: a(1351),
          MultiScriptFile: a(1352),
          OBJFile: a(1353),
          PackFile: a(1354),
          PluginFile: a(1355),
          SceneFile: a(1356),
          ScenePluginFile: a(1357),
          ScriptFile: a(520),
          SpriteSheetFile: a(1358),
          SVGFile: a(1359),
          TextFile: a(242),
          TilemapCSVFile: a(1360),
          TilemapImpactFile: a(1361),
          TilemapJSONFile: a(1362),
          UnityAtlasFile: a(1363),
          VideoFile: a(1364),
          XMLFile: a(241),
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(8),
          k = a(61),
          e = a(95),
          b = new t({
            Extends: k,
            initialize: function (c, f, g, m, n) {
              k.call(this, c, f, g, m, n);
              this.type = "animationJSON";
            },
            onProcess: function () {
              this.loader.once(e.POST_PROCESS, this.onLoadComplete, this);
              k.prototype.onProcess.call(this);
            },
            onLoadComplete: function () {
              this.loader.systems.anims.fromJSON(this.data);
            },
          });
        d.register("animation", function (c, f, g, m) {
          if (Array.isArray(c))
            for (f = 0; f < c.length; f++) this.addFile(new b(this, c[f]));
          else this.addFile(new b(this, c, f, m, g));
          return this;
        });
        h.exports = b;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(8),
          k = a(2),
          e = a(71),
          b = a(7),
          c = a(61),
          f = a(49),
          g = new t({
            Extends: f,
            initialize: function (m, n, q, r, u, v) {
              b(n)
                ? ((r = n),
                  (n = k(r, "key")),
                  (q = new e(m, {
                    key: n,
                    url: k(r, "textureURL"),
                    extension: k(r, "textureExtension", "png"),
                    normalMap: k(r, "normalMap"),
                    xhrSettings: k(r, "textureXhrSettings"),
                  })),
                  (r = new c(m, {
                    key: n,
                    url: k(r, "atlasURL"),
                    extension: k(r, "atlasExtension", "json"),
                    xhrSettings: k(r, "atlasXhrSettings"),
                  })))
                : ((q = new e(m, n, q, u)), (r = new c(m, n, r, v)));
              q.linkFile
                ? f.call(this, m, "atlasjson", n, [q, r, q.linkFile])
                : f.call(this, m, "atlasjson", n, [q, r]);
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var m = this.files[0],
                  n = this.files[1];
                this.loader.textureManager.addAtlas(
                  m.key,
                  m.data,
                  n.data,
                  this.files[2] ? this.files[2].data : null
                );
                n.addToCache();
                this.complete = !0;
              }
            },
          });
        d.register("aseprite", function (m, n, q, r, u) {
          if (Array.isArray(m))
            for (q = 0; q < m.length; q++)
              (n = new g(this, m[q])), this.addFile(n.files);
          else (n = new g(this, m, n, q, r, u)), this.addFile(n.files);
          return this;
        });
        h.exports = g;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(8),
          k = a(2),
          e = a(71),
          b = a(7),
          c = a(61),
          f = a(49),
          g = new t({
            Extends: f,
            initialize: function (m, n, q, r, u, v) {
              b(n)
                ? ((r = n),
                  (n = k(r, "key")),
                  (q = new e(m, {
                    key: n,
                    url: k(r, "textureURL"),
                    extension: k(r, "textureExtension", "png"),
                    normalMap: k(r, "normalMap"),
                    xhrSettings: k(r, "textureXhrSettings"),
                  })),
                  (r = new c(m, {
                    key: n,
                    url: k(r, "atlasURL"),
                    extension: k(r, "atlasExtension", "json"),
                    xhrSettings: k(r, "atlasXhrSettings"),
                  })))
                : ((q = new e(m, n, q, u)), (r = new c(m, n, r, v)));
              q.linkFile
                ? f.call(this, m, "atlasjson", n, [q, r, q.linkFile])
                : f.call(this, m, "atlasjson", n, [q, r]);
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var m = this.files[0],
                  n = this.files[1];
                this.loader.textureManager.addAtlas(
                  m.key,
                  m.data,
                  n.data,
                  this.files[2] ? this.files[2].data : null
                );
                n.pendingDestroy();
                this.complete = !0;
              }
            },
          });
        d.register("atlas", function (m, n, q, r, u) {
          if (Array.isArray(m))
            for (q = 0; q < m.length; q++)
              (n = new g(this, m[q])), this.addFile(n.files);
          else (n = new g(this, m, n, q, r, u)), this.addFile(n.files);
          return this;
        });
        h.exports = g;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(8),
          k = a(2),
          e = a(71),
          b = a(7),
          c = a(49),
          f = a(241),
          g = new t({
            Extends: c,
            initialize: function (m, n, q, r, u, v) {
              b(n)
                ? ((r = n),
                  (n = k(r, "key")),
                  (q = new e(m, {
                    key: n,
                    url: k(r, "textureURL"),
                    extension: k(r, "textureExtension", "png"),
                    normalMap: k(r, "normalMap"),
                    xhrSettings: k(r, "textureXhrSettings"),
                  })),
                  (r = new f(m, {
                    key: n,
                    url: k(r, "atlasURL"),
                    extension: k(r, "atlasExtension", "xml"),
                    xhrSettings: k(r, "atlasXhrSettings"),
                  })))
                : ((q = new e(m, n, q, u)), (r = new f(m, n, r, v)));
              q.linkFile
                ? c.call(this, m, "atlasxml", n, [q, r, q.linkFile])
                : c.call(this, m, "atlasxml", n, [q, r]);
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var m = this.files[0],
                  n = this.files[1];
                this.loader.textureManager.addAtlasXML(
                  m.key,
                  m.data,
                  n.data,
                  this.files[2] ? this.files[2].data : null
                );
                n.pendingDestroy();
                this.complete = !0;
              }
            },
          });
        d.register("atlasXML", function (m, n, q, r, u) {
          if (Array.isArray(m))
            for (q = 0; q < m.length; q++)
              (n = new g(this, m[q])), this.addFile(n.files);
          else (n = new g(this, m, n, q, r, u)), this.addFile(n.files);
          return this;
        });
        h.exports = g;
      },
      function (h, t, a) {
        var d = a(518);
        h = a(0);
        t = a(8);
        var k = a(2),
          e = a(7),
          b = a(61),
          c = a(49),
          f = new h({
            Extends: c,
            initialize: function (g, m, n, q, r, u, v) {
              e(m) &&
                ((v = m),
                (m = k(v, "key")),
                (n = k(v, "jsonURL")),
                (q = k(v, "audioURL")),
                (r = k(v, "audioConfig")),
                (u = k(v, "audioXhrSettings")),
                (v = k(v, "jsonXhrSettings")));
              if (q) {
                if ((r = d.create(g, m, q, r, u)))
                  (n = new b(g, m, n, v)),
                    c.call(this, g, "audiosprite", m, [r, n]),
                    (this.config.resourceLoad = !1);
              } else
                (n = new b(g, m, n, v)),
                  c.call(this, g, "audiosprite", m, [n]),
                  (this.config.resourceLoad = !0),
                  (this.config.audioConfig = r),
                  (this.config.audioXhrSettings = u);
            },
            onFileComplete: function (g) {
              if (
                -1 !== this.files.indexOf(g) &&
                (this.pending--,
                this.config.resourceLoad &&
                  "json" === g.type &&
                  g.data.hasOwnProperty("resources"))
              ) {
                var m = g.data.resources,
                  n = k(this.config, "audioConfig"),
                  q = k(this.config, "audioXhrSettings");
                if ((g = d.create(this.loader, g.key, m, n, q)))
                  this.addToMultiFile(g), this.loader.addFile(g);
              }
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var g = this.files[1];
                this.files[0].addToCache();
                g.addToCache();
                this.complete = !0;
              }
            },
          });
        t.register("audioSprite", function (g, m, n, q, r, u) {
          var v = this.systems.game,
            x = v.config.audio;
          v = v.device.audio;
          if ((x && x.noAudio) || (!v.webAudio && !v.audioData)) return this;
          if (Array.isArray(g))
            for (n = 0; n < g.length; n++)
              (m = new f(this, g[n])), m.files && this.addFile(m.files);
          else
            (m = new f(this, g, m, n, q, r, u)),
              m.files && this.addFile(m.files);
          return this;
        });
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(7),
          f = new t({
            Extends: k,
            initialize: function (g, m, n, q, r) {
              var u = "bin";
              if (c(m)) {
                var v = m;
                m = b(v, "key");
                n = b(v, "url");
                q = b(v, "xhrSettings");
                u = b(v, "extension", u);
                r = b(v, "dataType", r);
              }
              k.call(this, g, {
                type: "binary",
                cache: g.cacheManager.binary,
                extension: u,
                responseType: "arraybuffer",
                key: m,
                url: n,
                xhrSettings: q,
                config: {
                  dataType: r,
                },
              });
            },
            onProcess: function () {
              this.state = d.FILE_PROCESSING;
              var g = this.config.dataType;
              this.data = g
                ? new g(this.xhrLoader.response)
                : this.xhrLoader.response;
              this.onProcessComplete();
            },
          });
        e.register("binary", function (g, m, n, q) {
          if (Array.isArray(g))
            for (m = 0; m < g.length; m++) this.addFile(new f(this, g[m]));
          else this.addFile(new f(this, g, m, q, n));
          return this;
        });
        h.exports = f;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(8),
          k = a(2),
          e = a(71),
          b = a(7),
          c = a(49),
          f = a(212),
          g = a(241),
          m = new t({
            Extends: c,
            initialize: function (n, q, r, u, v, x) {
              b(q)
                ? ((u = q),
                  (q = k(u, "key")),
                  (r = new e(n, {
                    key: q,
                    url: k(u, "textureURL"),
                    extension: k(u, "textureExtension", "png"),
                    normalMap: k(u, "normalMap"),
                    xhrSettings: k(u, "textureXhrSettings"),
                  })),
                  (u = new g(n, {
                    key: q,
                    url: k(u, "fontDataURL"),
                    extension: k(u, "fontDataExtension", "xml"),
                    xhrSettings: k(u, "fontDataXhrSettings"),
                  })))
                : ((r = new e(n, q, r, v)), (u = new g(n, q, u, x)));
              r.linkFile
                ? c.call(this, n, "bitmapfont", q, [r, u, r.linkFile])
                : c.call(this, n, "bitmapfont", q, [r, u]);
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var n = this.files[0],
                  q = this.files[1];
                n.addToCache();
                q.pendingDestroy();
                var r = n.cache.get(n.key);
                q = f(q.data, n.cache.getFrame(n.key), 0, 0, r);
                this.loader.cacheManager.bitmapFont.add(n.key, {
                  data: q,
                  texture: n.key,
                  frame: null,
                });
                this.complete = !0;
              }
            },
          });
        d.register("bitmapFont", function (n, q, r, u, v) {
          if (Array.isArray(n))
            for (r = 0; r < n.length; r++)
              (q = new m(this, n[r])), this.addFile(q.files);
          else (q = new m(this, n, q, r, u, v)), this.addFile(q.files);
          return this;
        });
        h.exports = m;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(7),
          f = new t({
            Extends: k,
            initialize: function (g, m, n, q) {
              var r = "css";
              if (c(m)) {
                var u = m;
                m = b(u, "key");
                n = b(u, "url");
                q = b(u, "xhrSettings");
                r = b(u, "extension", r);
              }
              k.call(this, g, {
                type: "script",
                cache: !1,
                extension: r,
                responseType: "text",
                key: m,
                url: n,
                xhrSettings: q,
              });
            },
            onProcess: function () {
              this.state = d.FILE_PROCESSING;
              this.data = document.createElement("style");
              this.data.defer = !1;
              this.data.innerHTML = this.xhrLoader.responseText;
              document.head.appendChild(this.data);
              this.onProcessComplete();
            },
          });
        e.register("css", function (g, m, n) {
          if (Array.isArray(g))
            for (m = 0; m < g.length; m++) this.addFile(new f(this, g[m]));
          else this.addFile(new f(this, g, m, n));
          return this;
        });
        h.exports = f;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(7),
          f = a(396),
          g = new t({
            Extends: k,
            initialize: function (m, n, q, r, u) {
              var v = "glsl";
              if (c(n)) {
                var x = n;
                n = b(x, "key");
                q = b(x, "url");
                r = b(x, "shaderType", "fragment");
                u = b(x, "xhrSettings");
                v = b(x, "extension", v);
              } else void 0 === r && (r = "fragment");
              k.call(this, m, {
                type: "glsl",
                cache: m.cacheManager.shader,
                extension: v,
                responseType: "text",
                key: n,
                url: q,
                config: {
                  shaderType: r,
                },
                xhrSettings: u,
              });
            },
            onProcess: function () {
              this.state = d.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            },
            addToCache: function () {
              var m = this.data.split("\n"),
                n = this.extractBlock(m, 0);
              if (n)
                for (; n; ) {
                  var q = this.getShaderName(n.header),
                    r = this.getShaderType(n.header),
                    u = this.getShaderUniforms(n.header),
                    v = n.shader;
                  this.cache.has(q)
                    ? ((q = this.cache.get(q)),
                      "fragment" === r
                        ? (q.fragmentSrc = v)
                        : (q.vertexSrc = v),
                      q.uniforms || (q.uniforms = u))
                    : "fragment" === r
                    ? this.cache.add(q, new f(q, v, "", u))
                    : this.cache.add(q, new f(q, "", v, u));
                  n = this.extractBlock(m, n.offset);
                }
              else
                "fragment" === this.config.shaderType
                  ? this.cache.add(this.key, new f(this.key, this.data))
                  : this.cache.add(this.key, new f(this.key, "", this.data));
              this.pendingDestroy();
            },
            getShaderName: function (m) {
              for (var n = 0; n < m.length; n++) {
                var q = m[n].trim();
                if ("name:" === q.substring(0, 5)) return q.substring(5).trim();
              }
              return this.key;
            },
            getShaderType: function (m) {
              for (var n = 0; n < m.length; n++) {
                var q = m[n].trim();
                if ("type:" === q.substring(0, 5)) return q.substring(5).trim();
              }
              return this.config.shaderType;
            },
            getShaderUniforms: function (m) {
              for (var n = {}, q = 0; q < m.length; q++) {
                var r = m[q].trim();
                if ("uniform." === r.substring(0, 8)) {
                  var u = r.indexOf(":");
                  if (u) {
                    var v = r.substring(8, u);
                    try {
                      n[v] = JSON.parse(r.substring(u + 1));
                    } catch (x) {
                      console.warn("Invalid uniform JSON: " + v);
                    }
                  }
                }
              }
              return n;
            },
            extractBlock: function (m, n) {
              for (
                var q = -1, r = -1, u = -1, v = !1, x = !1, y = [], z = [];
                n < m.length;
                n++
              ) {
                var A = m[n].trim();
                if ("---" === A)
                  if (-1 === q) (q = n), (v = !0);
                  else if (v) (r = n), (v = !1), (x = !0);
                  else break;
                else v ? y.push(A) : x && (z.push(A), (u = n));
              }
              return v || -1 === r
                ? null
                : {
                    header: y,
                    shader: z.join("\n"),
                    offset: u,
                  };
            },
          });
        e.register("glsl", function (m, n, q, r) {
          if (Array.isArray(m))
            for (n = 0; n < m.length; n++) this.addFile(new g(this, m[n]));
          else this.addFile(new g(this, m, n, q, r));
          return this;
        });
        h.exports = g;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(7),
          f = new t({
            Extends: k,
            initialize: function (g, m, n, q) {
              var r = "html";
              if (c(m)) {
                var u = m;
                m = b(u, "key");
                n = b(u, "url");
                q = b(u, "xhrSettings");
                r = b(u, "extension", r);
              }
              k.call(this, g, {
                type: "text",
                cache: g.cacheManager.html,
                extension: r,
                responseType: "text",
                key: m,
                url: n,
                xhrSettings: q,
              });
            },
            onProcess: function () {
              this.state = d.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            },
          });
        e.register("html", function (g, m, n) {
          if (Array.isArray(g))
            for (m = 0; m < g.length; m++) this.addFile(new f(this, g[m]));
          else this.addFile(new f(this, g, m, n));
          return this;
        });
        h.exports = f;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(7),
          f = new t({
            Extends: k,
            initialize: function (g, m, n, q, r, u) {
              void 0 === q && (q = 512);
              void 0 === r && (r = 512);
              var v = "html";
              if (c(m)) {
                var x = m;
                m = b(x, "key");
                n = b(x, "url");
                u = b(x, "xhrSettings");
                v = b(x, "extension", v);
                q = b(x, "width", q);
                r = b(x, "height", r);
              }
              k.call(this, g, {
                type: "html",
                cache: g.textureManager,
                extension: v,
                responseType: "text",
                key: m,
                url: n,
                xhrSettings: u,
                config: {
                  width: q,
                  height: r,
                },
              });
            },
            onProcess: function () {
              this.state = d.FILE_PROCESSING;
              var g = this.config.width,
                m = this.config.height,
                n = [];
              n.push(
                '<svg width="' +
                  g +
                  'px" height="' +
                  m +
                  'px" viewBox="0 0 ' +
                  g +
                  " " +
                  m +
                  '" xmlns="http://www.w3.org/2000/svg">'
              );
              n.push('<foreignObject width="100%" height="100%">');
              n.push('<body xmlns="http://www.w3.org/1999/xhtml">');
              n.push(this.xhrLoader.responseText);
              n.push("</body>");
              n.push("</foreignObject>");
              n.push("</svg>");
              g = [n.join("\n")];
              var q = this;
              try {
                var r = new window.Blob(g, {
                  type: "image/svg+xml;charset=utf-8",
                });
              } catch (u) {
                q.state = d.FILE_ERRORED;
                q.onProcessComplete();
                return;
              }
              this.data = new Image();
              this.data.crossOrigin = this.crossOrigin;
              this.data.onload = function () {
                k.revokeObjectURL(q.data);
                q.onProcessComplete();
              };
              this.data.onerror = function () {
                k.revokeObjectURL(q.data);
                q.onProcessError();
              };
              k.createObjectURL(this.data, r, "image/svg+xml");
            },
            addToCache: function () {
              var g = this.cache.addImage(this.key, this.data);
              this.pendingDestroy(g);
            },
          });
        e.register("htmlTexture", function (g, m, n, q, r) {
          if (Array.isArray(g))
            for (m = 0; m < g.length; m++) this.addFile(new f(this, g[m]));
          else this.addFile(new f(this, g, m, n, q, r));
          return this;
        });
        h.exports = f;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(8),
          k = a(2),
          e = a(71),
          b = a(7),
          c = a(61),
          f = a(49),
          g = new t({
            Extends: f,
            initialize: function (m, n, q, r, u, v, x) {
              b(n) &&
                ((x = n),
                (n = k(x, "key")),
                (q = k(x, "url", !1) ? k(x, "url") : k(x, "atlasURL")),
                (v = k(x, "xhrSettings")),
                (r = k(x, "path")),
                (u = k(x, "baseURL")),
                (x = k(x, "textureXhrSettings")));
              q = new c(m, n, q, v);
              f.call(this, m, "multiatlas", n, [q]);
              this.config.path = r;
              this.config.baseURL = u;
              this.config.textureXhrSettings = x;
            },
            onFileComplete: function (m) {
              if (
                -1 !== this.files.indexOf(m) &&
                (this.pending--,
                "json" === m.type && m.data.hasOwnProperty("textures"))
              ) {
                m = m.data.textures;
                var n = this.config,
                  q = this.loader,
                  r = q.baseURL,
                  u = q.path,
                  v = q.prefix,
                  x = k(n, "baseURL", this.baseURL),
                  y = k(n, "path", this.path),
                  z = k(n, "prefix", this.prefix);
                n = k(n, "textureXhrSettings");
                q.setBaseURL(x);
                q.setPath(y);
                q.setPrefix(z);
                for (x = 0; x < m.length; x++)
                  (z = m[x].image),
                    (y = "MA" + this.multiKeyIndex + "_" + z),
                    (z = new e(q, y, z, n)),
                    this.addToMultiFile(z),
                    q.addFile(z),
                    m[x].normalMap &&
                      ((y = new e(q, y, m[x].normalMap, n)),
                      (y.type = "normalMap"),
                      z.setLink(y),
                      this.addToMultiFile(y),
                      q.addFile(y));
                q.setBaseURL(r);
                q.setPath(u);
                q.setPrefix(v);
              }
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                for (
                  var m = this.files[0], n = [], q = [], r = [], u = 1;
                  u < this.files.length;
                  u++
                ) {
                  var v = this.files[u];
                  if ("normalMap" !== v.type) {
                    var x = v.key.indexOf("_");
                    x = v.key.substr(x + 1);
                    for (
                      var y = v.data, z = 0;
                      z < m.data.textures.length;
                      z++
                    ) {
                      var A = m.data.textures[z];
                      if (A.image === x) {
                        q.push(y);
                        n.push(A);
                        v.linkFile && r.push(v.linkFile.data);
                        break;
                      }
                    }
                  }
                }
                0 === r.length && (r = void 0);
                this.loader.textureManager.addAtlasJSONArray(this.key, q, n, r);
                this.complete = !0;
                for (u = 0; u < this.files.length; u++)
                  this.files[u].pendingDestroy();
              }
            },
          });
        d.register("multiatlas", function (m, n, q, r, u) {
          if (Array.isArray(m))
            for (q = 0; q < m.length; q++)
              (n = new g(this, m[q])), this.addFile(n.files);
          else (n = new g(this, m, n, q, r, u)), this.addFile(n.files);
          return this;
        });
        h.exports = g;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(8),
          k = a(2),
          e = a(7),
          b = a(49),
          c = a(520),
          f = new t({
            Extends: b,
            initialize: function (g, m, n, q) {
              var r = "js",
                u = [];
              if (e(m)) {
                var v = m;
                m = k(v, "key");
                n = k(v, "url");
                q = k(v, "xhrSettings");
                r = k(v, "extension", r);
              }
              Array.isArray(n) || (n = [n]);
              for (v = 0; v < n.length; v++) {
                var x = new c(g, {
                  key: m + "_" + v.toString(),
                  url: n[v],
                  extension: r,
                  xhrSettings: q,
                });
                x.onProcess = function () {
                  this.onProcessComplete();
                };
                u.push(x);
              }
              b.call(this, g, "scripts", m, u);
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                for (var g = 0; g < this.files.length; g++) {
                  var m = this.files[g];
                  m.data = document.createElement("script");
                  m.data.language = "javascript";
                  m.data.type = "text/javascript";
                  m.data.defer = !1;
                  m.data.text = m.xhrLoader.responseText;
                  document.head.appendChild(m.data);
                }
                this.complete = !0;
              }
            },
          });
        d.register("scripts", function (g, m, n) {
          if (Array.isArray(g))
            for (n = 0; n < g.length; n++)
              (m = new f(this, g[n])), this.addFile(m.files);
          else (m = new f(this, g, m, n)), this.addFile(m.files);
          return this;
        });
        h.exports = f;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(8),
          k = a(2),
          e = a(7),
          b = a(49),
          c = a(498),
          f = a(499),
          g = a(242),
          m = new t({
            Extends: b,
            initialize: function (n, q, r, u, v, x) {
              var y,
                z = n.cacheManager.obj;
              e(q)
                ? ((x = q),
                  (q = k(x, "key")),
                  (v = new g(n, {
                    key: q,
                    type: "obj",
                    cache: z,
                    url: k(x, "url"),
                    extension: k(x, "extension", "obj"),
                    xhrSettings: k(x, "xhrSettings"),
                    config: {
                      flipUV: k(x, "flipUV", v),
                    },
                  })),
                  (u = k(x, "matURL")) &&
                    (y = new g(n, {
                      key: q,
                      type: "mat",
                      cache: z,
                      url: u,
                      extension: k(x, "matExtension", "mat"),
                      xhrSettings: k(x, "xhrSettings"),
                    })))
                : ((v = new g(n, {
                    key: q,
                    url: r,
                    type: "obj",
                    cache: z,
                    extension: "obj",
                    xhrSettings: x,
                    config: {
                      flipUV: v,
                    },
                  })),
                  u &&
                    (y = new g(n, {
                      key: q,
                      url: u,
                      type: "mat",
                      cache: z,
                      extension: "mat",
                      xhrSettings: x,
                    })));
              b.call(this, n, "obj", q, [v, y]);
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var n = this.files[0],
                  q = this.files[1],
                  r = c(n.data, n.config.flipUV);
                q && (r.materials = f(q.data));
                n.cache.add(n.key, r);
                this.complete = !0;
              }
            },
          });
        d.register("obj", function (n, q, r, u, v) {
          if (Array.isArray(n))
            for (r = 0; r < n.length; r++)
              (q = new m(this, n[r])), this.addFile(q.files);
          else (q = new m(this, n, q, r, u, v)), this.addFile(q.files);
          return this;
        });
        h.exports = m;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(8),
          e = a(61),
          b = new t({
            Extends: e,
            initialize: function (c, f, g, m, n) {
              e.call(this, c, f, g, m, n);
              this.type = "packfile";
            },
            onProcess: function () {
              this.state !== d.FILE_POPULATED &&
                ((this.state = d.FILE_PROCESSING),
                (this.data = JSON.parse(this.xhrLoader.responseText)));
              this.loader.addPack(this.data, this.config);
              this.onProcessComplete();
            },
          });
        k.register("pack", function (c, f, g, m) {
          if (Array.isArray(c))
            for (f = 0; f < c.length; f++) this.addFile(new b(this, c[f]));
          else this.addFile(new b(this, c, f, m, g));
          return this;
        });
        h.exports = b;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(7),
          f = new t({
            Extends: k,
            initialize: function (g, m, n, q, r, u) {
              var v = "js";
              c(m) &&
                ((r = m),
                (m = b(r, "key")),
                (n = b(r, "url")),
                (u = b(r, "xhrSettings")),
                (v = b(r, "extension", v)),
                (q = b(r, "start")),
                (r = b(r, "mapping")));
              k.call(this, g, {
                type: "plugin",
                cache: !1,
                extension: v,
                responseType: "text",
                key: m,
                url: n,
                xhrSettings: u,
                config: {
                  start: q,
                  mapping: r,
                },
              });
              "function" === typeof n &&
                ((this.data = n), (this.state = d.FILE_POPULATED));
            },
            onProcess: function () {
              var g = this.loader.systems.plugins,
                m = this.config,
                n = b(m, "start", !1);
              m = b(m, "mapping", null);
              if (this.state === d.FILE_POPULATED)
                g.install(this.key, this.data, n, m);
              else if (
                ((this.state = d.FILE_PROCESSING),
                (this.data = document.createElement("script")),
                (this.data.language = "javascript"),
                (this.data.type = "text/javascript"),
                (this.data.defer = !1),
                (this.data.text = this.xhrLoader.responseText),
                document.head.appendChild(this.data),
                (g = g.install(this.key, window[this.key], n, m)),
                n || m)
              )
                (this.loader.systems[m] = g), (this.loader.scene[m] = g);
              this.onProcessComplete();
            },
          });
        e.register("plugin", function (g, m, n, q, r) {
          if (Array.isArray(g))
            for (m = 0; m < g.length; m++) this.addFile(new f(this, g[m]));
          else this.addFile(new f(this, g, m, n, q, r));
          return this;
        });
        h.exports = f;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(7),
          f = new t({
            Extends: k,
            initialize: function (g, m, n, q) {
              var r = "js";
              if (c(m)) {
                var u = m;
                m = b(u, "key");
                n = b(u, "url");
                q = b(u, "xhrSettings");
                r = b(u, "extension", r);
              }
              k.call(this, g, {
                type: "text",
                extension: r,
                responseType: "text",
                key: m,
                url: n,
                xhrSettings: q,
              });
            },
            onProcess: function () {
              this.state = d.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            },
            addToCache: function () {
              var g = this.data.concat(
                "(function(){\nreturn new " + this.key + "();\n}).call(this);"
              );
              this.loader.sceneManager.add(this.key, (0, eval)(g));
              this.complete = !0;
            },
          });
        e.register("sceneFile", function (g, m, n) {
          if (Array.isArray(g))
            for (m = 0; m < g.length; m++) this.addFile(new f(this, g[m]));
          else this.addFile(new f(this, g, m, n));
          return this;
        });
        h.exports = f;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(7),
          f = new t({
            Extends: k,
            initialize: function (g, m, n, q, r, u) {
              var v = "js";
              c(m) &&
                ((r = m),
                (m = b(r, "key")),
                (n = b(r, "url")),
                (u = b(r, "xhrSettings")),
                (v = b(r, "extension", v)),
                (q = b(r, "systemKey")),
                (r = b(r, "sceneKey")));
              k.call(this, g, {
                type: "scenePlugin",
                cache: !1,
                extension: v,
                responseType: "text",
                key: m,
                url: n,
                xhrSettings: u,
                config: {
                  systemKey: q,
                  sceneKey: r,
                },
              });
              "function" === typeof n &&
                ((this.data = n), (this.state = d.FILE_POPULATED));
            },
            onProcess: function () {
              var g = this.loader.systems.plugins,
                m = this.config,
                n = this.key,
                q = b(m, "systemKey", n);
              m = b(m, "sceneKey", n);
              this.state === d.FILE_POPULATED
                ? g.installScenePlugin(q, this.data, m, this.loader.scene, !0)
                : ((this.state = d.FILE_PROCESSING),
                  (this.data = document.createElement("script")),
                  (this.data.language = "javascript"),
                  (this.data.type = "text/javascript"),
                  (this.data.defer = !1),
                  (this.data.text = this.xhrLoader.responseText),
                  document.head.appendChild(this.data),
                  g.installScenePlugin(
                    q,
                    window[this.key],
                    m,
                    this.loader.scene,
                    !0
                  ));
              this.onProcessComplete();
            },
          });
        e.register("scenePlugin", function (g, m, n, q, r) {
          if (Array.isArray(g))
            for (m = 0; m < g.length; m++) this.addFile(new f(this, g[m]));
          else this.addFile(new f(this, g, m, n, q, r));
          return this;
        });
        h.exports = f;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(8),
          k = a(71),
          e = new t({
            Extends: k,
            initialize: function (b, c, f, g, m) {
              k.call(this, b, c, f, m, g);
              this.type = "spritesheet";
            },
            addToCache: function () {
              var b = this.cache.addSpriteSheet(
                this.key,
                this.data,
                this.config
              );
              this.pendingDestroy(b);
            },
          });
        d.register("spritesheet", function (b, c, f, g) {
          if (Array.isArray(b))
            for (c = 0; c < b.length; c++) this.addFile(new e(this, b[c]));
          else this.addFile(new e(this, b, c, f, g));
          return this;
        });
        h.exports = e;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(7),
          f = new t({
            Extends: k,
            initialize: function (g, m, n, q, r) {
              var u = "svg";
              if (c(m)) {
                var v = m;
                m = b(v, "key");
                n = b(v, "url");
                q = b(v, "svgConfig", {});
                r = b(v, "xhrSettings");
                u = b(v, "extension", u);
              }
              m = {
                type: "svg",
                cache: g.textureManager,
                extension: u,
                responseType: "text",
                key: m,
                url: n,
                xhrSettings: r,
                config: {
                  width: b(q, "width"),
                  height: b(q, "height"),
                  scale: b(q, "scale"),
                },
              };
              k.call(this, g, m);
            },
            onProcess: function () {
              this.state = d.FILE_PROCESSING;
              var g = this.xhrLoader.responseText,
                m = [g],
                n = this.config.width,
                q = this.config.height,
                r = this.config.scale;
              a: if ((n && q) || r) {
                var u = null;
                u = new DOMParser().parseFromString(g, "text/xml");
                g = u.getElementsByTagName("svg")[0];
                var v = g.hasAttribute("viewBox");
                u = parseFloat(g.getAttribute("width"));
                var x = parseFloat(g.getAttribute("height"));
                !v && u && x
                  ? g.setAttribute("viewBox", "0  0 " + u + " " + x)
                  : !v ||
                    u ||
                    x ||
                    ((v = g.getAttribute("viewBox").split(/\s+|,/)),
                    (u = v[2]),
                    (x = v[3]));
                if (r)
                  if (u && x) (n = u * r), (q = x * r);
                  else break a;
                g.setAttribute("width", n.toString() + "px");
                g.setAttribute("height", q.toString() + "px");
                m = [new XMLSerializer().serializeToString(g)];
              }
              try {
                var y = new window.Blob(m, {
                  type: "image/svg+xml;charset=utf-8",
                });
              } catch (B) {
                this.onProcessError();
                return;
              }
              this.data = new Image();
              this.data.crossOrigin = this.crossOrigin;
              var z = this,
                A = !1;
              this.data.onload = function () {
                A || k.revokeObjectURL(z.data);
                z.onProcessComplete();
              };
              this.data.onerror = function () {
                if (A) z.onProcessError();
                else
                  (A = !0),
                    k.revokeObjectURL(z.data),
                    (z.data.src =
                      "data:image/svg+xml," + encodeURIComponent(m.join("")));
              };
              k.createObjectURL(this.data, y, "image/svg+xml");
            },
            addToCache: function () {
              var g = this.cache.addImage(this.key, this.data);
              this.pendingDestroy(g);
            },
          });
        e.register("svg", function (g, m, n, q) {
          if (Array.isArray(g))
            for (m = 0; m < g.length; m++) this.addFile(new f(this, g[m]));
          else this.addFile(new f(this, g, m, n, q));
          return this;
        });
        h.exports = f;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(2),
          c = a(7),
          f = a(40),
          g = new t({
            Extends: k,
            initialize: function (m, n, q, r) {
              var u = "csv";
              if (c(n)) {
                var v = n;
                n = b(v, "key");
                q = b(v, "url");
                r = b(v, "xhrSettings");
                u = b(v, "extension", u);
              }
              k.call(this, m, {
                type: "tilemapCSV",
                cache: m.cacheManager.tilemap,
                extension: u,
                responseType: "text",
                key: n,
                url: q,
                xhrSettings: r,
              });
              this.tilemapFormat = f.CSV;
            },
            onProcess: function () {
              this.state = d.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            },
            addToCache: function () {
              var m = {
                format: this.tilemapFormat,
                data: this.data,
              };
              this.cache.add(this.key, m);
              this.pendingDestroy(m);
            },
          });
        e.register("tilemapCSV", function (m, n, q) {
          if (Array.isArray(m))
            for (n = 0; n < m.length; n++) this.addFile(new g(this, m[n]));
          else this.addFile(new g(this, m, n, q));
          return this;
        });
        h.exports = g;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(8),
          k = a(61),
          e = a(40),
          b = new t({
            Extends: k,
            initialize: function (c, f, g, m) {
              k.call(this, c, f, g, m);
              this.type = "tilemapJSON";
              this.cache = c.cacheManager.tilemap;
            },
            addToCache: function () {
              var c = {
                format: e.WELTMEISTER,
                data: this.data,
              };
              this.cache.add(this.key, c);
              this.pendingDestroy(c);
            },
          });
        d.register("tilemapImpact", function (c, f, g) {
          if (Array.isArray(c))
            for (f = 0; f < c.length; f++) this.addFile(new b(this, c[f]));
          else this.addFile(new b(this, c, f, g));
          return this;
        });
        h.exports = b;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(8),
          k = a(61),
          e = a(40),
          b = new t({
            Extends: k,
            initialize: function (c, f, g, m) {
              k.call(this, c, f, g, m);
              this.type = "tilemapJSON";
              this.cache = c.cacheManager.tilemap;
            },
            addToCache: function () {
              var c = {
                format: e.TILED_JSON,
                data: this.data,
              };
              this.cache.add(this.key, c);
              this.pendingDestroy(c);
            },
          });
        d.register("tilemapTiledJSON", function (c, f, g) {
          if (Array.isArray(c))
            for (f = 0; f < c.length; f++) this.addFile(new b(this, c[f]));
          else this.addFile(new b(this, c, f, g));
          return this;
        });
        h.exports = b;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(8),
          k = a(2),
          e = a(71),
          b = a(7),
          c = a(49),
          f = a(242),
          g = new t({
            Extends: c,
            initialize: function (m, n, q, r, u, v) {
              b(n)
                ? ((r = n),
                  (n = k(r, "key")),
                  (q = new e(m, {
                    key: n,
                    url: k(r, "textureURL"),
                    extension: k(r, "textureExtension", "png"),
                    normalMap: k(r, "normalMap"),
                    xhrSettings: k(r, "textureXhrSettings"),
                  })),
                  (r = new f(m, {
                    key: n,
                    url: k(r, "atlasURL"),
                    extension: k(r, "atlasExtension", "txt"),
                    xhrSettings: k(r, "atlasXhrSettings"),
                  })))
                : ((q = new e(m, n, q, u)), (r = new f(m, n, r, v)));
              q.linkFile
                ? c.call(this, m, "unityatlas", n, [q, r, q.linkFile])
                : c.call(this, m, "unityatlas", n, [q, r]);
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var m = this.files[0],
                  n = this.files[1];
                this.loader.textureManager.addUnityAtlas(
                  m.key,
                  m.data,
                  n.data,
                  this.files[2] ? this.files[2].data : null
                );
                n.pendingDestroy();
                this.complete = !0;
              }
            },
          });
        d.register("unityAtlas", function (m, n, q, r, u) {
          if (Array.isArray(m))
            for (q = 0; q < m.length; q++)
              (n = new g(this, m[q])), this.addFile(n.files);
          else (n = new g(this, m, n, q, r, u)), this.addFile(n.files);
          return this;
        });
        h.exports = g;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(21),
          k = a(23),
          e = a(8),
          b = a(155),
          c = a(2),
          f = a(7),
          g = new t({
            Extends: k,
            initialize: function (m, n, q, r, u, v, x) {
              void 0 === r && (r = "loadeddata");
              void 0 === u && (u = !1);
              void 0 === v && (v = !1);
              "loadeddata" !== r &&
                "canplay" !== r &&
                "canplaythrough" !== r &&
                (r = "loadeddata");
              n = {
                type: "video",
                cache: m.cacheManager.video,
                extension: q.type,
                responseType: "blob",
                key: n,
                url: q.url,
                xhrSettings: x,
                config: {
                  loadEvent: r,
                  asBlob: u,
                  noAudio: v,
                },
              };
              this.onLoadCallback = this.onVideoLoadHandler.bind(this);
              this.onErrorCallback = this.onVideoErrorHandler.bind(this);
              k.call(this, m, n);
            },
            onProcess: function () {
              this.state = d.FILE_PROCESSING;
              if (this.config.asBlob) {
                var m = this.createVideoElement();
                this.data = m;
                var n = this;
                this.data.onloadeddata = function () {
                  n.onProcessComplete();
                };
                this.data.onerror = function () {
                  k.revokeObjectURL(n.data);
                  n.onProcessError();
                };
                k.createObjectURL(m, this.xhrLoader.response, "");
                m.load();
              } else this.onProcessComplete();
            },
            createVideoElement: function () {
              var m = document.createElement("video");
              m.controls = !1;
              m.crossOrigin = this.loader.crossOrigin;
              this.config.noAudio &&
                ((m.muted = !0),
                (m.defaultMuted = !0),
                m.setAttribute("autoplay", "autoplay"));
              m.setAttribute("playsinline", "playsinline");
              m.setAttribute("preload", "auto");
              return m;
            },
            onVideoLoadHandler: function (m) {
              m = m.target;
              m.removeEventListener(
                this.config.loadEvent,
                this.onLoadCallback,
                !0
              );
              m.removeEventListener("error", this.onErrorCallback, !0);
              this.data = m;
              this.resetXHR();
              this.loader.nextFile(this, !0);
            },
            onVideoErrorHandler: function (m) {
              if ((m = m.target))
                m.removeEventListener(
                  this.config.loadEvent,
                  this.onLoadCallback,
                  !0
                ),
                  m.removeEventListener("error", this.onErrorCallback, !0);
              this.resetXHR();
              this.loader.nextFile(this, !1);
            },
            load: function () {
              var m = this.config.loadEvent;
              if (this.config.asBlob) k.prototype.load.call(this);
              else {
                this.percentComplete = 0;
                var n = this.createVideoElement();
                n.addEventListener(m, this.onLoadCallback, !0);
                n.addEventListener("error", this.onErrorCallback, !0);
                n.src = b(this, this.loader.baseURL);
                n.load();
              }
            },
          });
        g.create = function (m, n, q, r, u, v, x) {
          var y = m.systems.game;
          f(n) &&
            ((q = c(n, "url", [])),
            (r = c(n, "loadEvent", "loadeddata")),
            (u = c(n, "asBlob", !1)),
            (v = c(n, "noAudio", !1)),
            (x = c(n, "xhrSettings")),
            (n = c(n, "key")));
          if ((q = g.getVideoURL(y, q))) return new g(m, n, q, r, u, v, x);
        };
        g.getVideoURL = function (m, n) {
          Array.isArray(n) || (n = [n]);
          for (var q = 0; q < n.length; q++) {
            var r = c(n[q], "url", n[q]);
            if (0 === r.indexOf("blob:"))
              return {
                url: r,
                type: "",
              };
            var u =
              0 === r.indexOf("data:")
                ? r.split(",")[0].match(/\/(.*?);/)
                : r.match(/\.([a-zA-Z0-9]+)($|\?)/);
            u = c(n[q], "type", u ? u[1] : "").toLowerCase();
            if (m.device.video[u])
              return {
                url: r,
                type: u,
              };
          }
          return null;
        };
        e.register("video", function (m, n, q, r, u, v) {
          if (Array.isArray(m))
            for (q = 0; q < m.length; q++)
              (n = g.create(this, m[q])) && this.addFile(n);
          else (n = g.create(this, m, n, q, r, u, v)) && this.addFile(n);
          return this;
        });
        h.exports = g;
      },
      function (h, t, a) {
        var d = a(0),
          k = a(21),
          e = a(149),
          b = a(9),
          c = a(95),
          f = a(8),
          g = a(2);
        t = a(24);
        var m = a(20),
          n = a(156);
        a = new d({
          Extends: b,
          initialize: function (q) {
            b.call(this);
            var r = q.sys.game.config,
              u = q.sys.settings.loader;
            this.scene = q;
            this.systems = q.sys;
            this.cacheManager = q.sys.cache;
            this.textureManager = q.sys.textures;
            this.sceneManager = q.sys.game.scene;
            f.install(this);
            this.baseURL = this.path = this.prefix = "";
            this.setBaseURL(g(u, "baseURL", r.loaderBaseURL));
            this.setPath(g(u, "path", r.loaderPath));
            this.setPrefix(g(u, "prefix", r.loaderPrefix));
            this.maxParallelDownloads = g(
              u,
              "maxParallelDownloads",
              r.loaderMaxParallelDownloads
            );
            this.xhr = n(
              g(u, "responseType", r.loaderResponseType),
              g(u, "async", r.loaderAsync),
              g(u, "user", r.loaderUser),
              g(u, "password", r.loaderPassword),
              g(u, "timeout", r.loaderTimeout),
              g(u, "withCredentials", r.loaderWithCredentials)
            );
            this.crossOrigin = g(u, "crossOrigin", r.loaderCrossOrigin);
            this.progress = this.totalToLoad = 0;
            this.list = new e();
            this.inflight = new e();
            this.queue = new e();
            this._deleteQueue = new e();
            this.totalComplete = this.totalFailed = 0;
            this.state = k.LOADER_IDLE;
            this.multiKeyIndex = 0;
            q.sys.events.once(m.BOOT, this.boot, this);
            q.sys.events.on(m.START, this.pluginStart, this);
          },
          boot: function () {
            this.systems.events.once(m.DESTROY, this.destroy, this);
          },
          pluginStart: function () {
            this.systems.events.once(m.SHUTDOWN, this.shutdown, this);
          },
          setBaseURL: function (q) {
            void 0 === q && (q = "");
            "" !== q && "/" !== q.substr(-1) && (q = q.concat("/"));
            this.baseURL = q;
            return this;
          },
          setPath: function (q) {
            void 0 === q && (q = "");
            "" !== q && "/" !== q.substr(-1) && (q = q.concat("/"));
            this.path = q;
            return this;
          },
          setPrefix: function (q) {
            void 0 === q && (q = "");
            this.prefix = q;
            return this;
          },
          setCORS: function (q) {
            this.crossOrigin = q;
            return this;
          },
          addFile: function (q) {
            Array.isArray(q) || (q = [q]);
            for (var r = 0; r < q.length; r++) {
              var u = q[r];
              this.keyExists(u) ||
                (this.list.set(u),
                this.emit(c.ADD, u.key, u.type, this, u),
                this.isLoading() &&
                  (this.totalToLoad++, this.updateProgress()));
            }
          },
          keyExists: function (q) {
            var r = q.hasCacheConflict();
            r ||
              this.list.iterate(function (u) {
                if (u.type === q.type && u.key === q.key) return (r = !0), !1;
              });
            !r &&
              this.isLoading() &&
              (this.inflight.iterate(function (u) {
                if (u.type === q.type && u.key === q.key) return (r = !0), !1;
              }),
              this.queue.iterate(function (u) {
                if (u.type === q.type && u.key === q.key) return (r = !0), !1;
              }));
            return r;
          },
          addPack: function (q, r) {
            r &&
              q.hasOwnProperty(r) &&
              (q = {
                packKey: q[r],
              });
            r = 0;
            var u = this.baseURL,
              v = this.path,
              x = this.prefix,
              y;
            for (y in q)
              if (Object.prototype.hasOwnProperty.call(q, y)) {
                var z = q[y],
                  A = g(z, "baseURL", u),
                  B = g(z, "path", v),
                  D = g(z, "prefix", x),
                  E = g(z, "files", null);
                z = g(z, "defaultType", "void");
                if (Array.isArray(E))
                  for (
                    this.setBaseURL(A),
                      this.setPath(B),
                      this.setPrefix(D),
                      A = 0;
                    A < E.length;
                    A++
                  )
                    (B = E[A]),
                      (D = B.hasOwnProperty("type") ? B.type : z),
                      this[D] && (this[D](B), r++);
              }
            this.setBaseURL(u);
            this.setPath(v);
            this.setPrefix(x);
            return 0 < r;
          },
          isLoading: function () {
            return (
              this.state === k.LOADER_LOADING ||
              this.state === k.LOADER_PROCESSING
            );
          },
          isReady: function () {
            return (
              this.state === k.LOADER_IDLE || this.state === k.LOADER_COMPLETE
            );
          },
          start: function () {
            this.isReady() &&
              ((this.totalComplete = this.totalFailed = this.progress = 0),
              (this.totalToLoad = this.list.size),
              this.emit(c.START, this),
              0 === this.list.size
                ? this.loadComplete()
                : ((this.state = k.LOADER_LOADING),
                  this.inflight.clear(),
                  this.queue.clear(),
                  this.updateProgress(),
                  this.checkLoadQueue(),
                  this.systems.events.on(m.UPDATE, this.update, this)));
          },
          updateProgress: function () {
            this.progress =
              1 - (this.list.size + this.inflight.size) / this.totalToLoad;
            this.emit(c.PROGRESS, this.progress);
          },
          update: function () {
            this.state === k.LOADER_LOADING &&
              0 < this.list.size &&
              this.inflight.size < this.maxParallelDownloads &&
              this.checkLoadQueue();
          },
          checkLoadQueue: function () {
            this.list.each(function (q) {
              if (
                q.state === k.FILE_POPULATED ||
                (q.state === k.FILE_PENDING &&
                  this.inflight.size < this.maxParallelDownloads)
              )
                this.inflight.set(q),
                  this.list.delete(q),
                  q.crossOrigin || (q.crossOrigin = this.crossOrigin),
                  q.load();
              if (this.inflight.size === this.maxParallelDownloads) return !1;
            }, this);
          },
          nextFile: function (q, r) {
            this.inflight &&
              (this.inflight.delete(q),
              this.updateProgress(),
              r
                ? (this.totalComplete++,
                  this.queue.set(q),
                  this.emit(c.FILE_LOAD, q),
                  q.onProcess())
                : (this.totalFailed++,
                  this._deleteQueue.set(q),
                  this.emit(c.FILE_LOAD_ERROR, q),
                  this.fileProcessComplete(q)));
          },
          fileProcessComplete: function (q) {
            if (
              this.scene &&
              this.systems &&
              this.systems.game &&
              !this.systems.game.pendingDestroy
            ) {
              if (q.state === k.FILE_ERRORED) {
                if (q.multiFile) q.multiFile.onFileFailed(q);
              } else
                q.state === k.FILE_COMPLETE &&
                  (q.multiFile
                    ? q.multiFile.isReadyToProcess() && q.multiFile.addToCache()
                    : q.addToCache());
              this.queue.delete(q);
              0 === this.list.size &&
                0 === this.inflight.size &&
                0 === this.queue.size &&
                this.loadComplete();
            }
          },
          loadComplete: function () {
            this.emit(c.POST_PROCESS, this);
            this.list.clear();
            this.inflight.clear();
            this.queue.clear();
            this.progress = 1;
            this.state = k.LOADER_COMPLETE;
            this.systems.events.off(m.UPDATE, this.update, this);
            this._deleteQueue.iterateLocal("destroy");
            this._deleteQueue.clear();
            this.emit(c.COMPLETE, this, this.totalComplete, this.totalFailed);
          },
          flagForRemoval: function (q) {
            this._deleteQueue.set(q);
          },
          saveJSON: function (q, r) {
            return this.save(JSON.stringify(q), r);
          },
          save: function (q, r, u) {
            void 0 === r && (r = "file.json");
            void 0 === u && (u = "application/json");
            q = new Blob([q], {
              type: u,
            });
            q = URL.createObjectURL(q);
            u = document.createElement("a");
            u.download = r;
            u.textContent = "Download " + r;
            u.href = q;
            u.click();
            return this;
          },
          reset: function () {
            this.list.clear();
            this.inflight.clear();
            this.queue.clear();
            var q = this.systems.game.config,
              r = this.systems.settings.loader;
            this.setBaseURL(g(r, "baseURL", q.loaderBaseURL));
            this.setPath(g(r, "path", q.loaderPath));
            this.setPrefix(g(r, "prefix", q.loaderPrefix));
            this.state = k.LOADER_IDLE;
          },
          shutdown: function () {
            this.reset();
            this.state = k.LOADER_SHUTDOWN;
            this.systems.events.off(m.UPDATE, this.update, this);
            this.systems.events.off(m.SHUTDOWN, this.shutdown, this);
          },
          destroy: function () {
            this.shutdown();
            this.state = k.LOADER_DESTROYED;
            this.systems.events.off(m.UPDATE, this.update, this);
            this.systems.events.off(m.START, this.pluginStart, this);
            this.sceneManager =
              this.cacheManager =
              this.textureManager =
              this.systems =
              this.scene =
              this.queue =
              this.inflight =
              this.list =
                null;
          },
        });
        t.register("Loader", a, "load");
        h.exports = a;
      },
      function (h, t, a) {
        t = a(62);
        var d = a(17);
        a = {
          ArcadePhysics: a(1367),
          Body: a(527),
          Collider: a(528),
          Components: a(243),
          Events: a(245),
          Factory: a(521),
          GetOverlapX: a(246),
          GetOverlapY: a(247),
          SeparateX: a(537),
          SeparateY: a(538),
          Group: a(524),
          Image: a(522),
          Sprite: a(157),
          StaticBody: a(539),
          StaticGroup: a(525),
          Tilemap: a(1391),
          World: a(526),
        };
        a = d(!1, a, t);
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(0),
          k = a(36),
          e = a(50),
          b = a(353),
          c = a(521),
          f = a(2),
          g = a(127),
          m = a(523),
          n = a(244);
        t = a(24);
        var q = a(20),
          r = a(3),
          u = a(526);
        a = new d({
          initialize: function (v) {
            this.scene = v;
            this.systems = v.sys;
            this.config = this.getConfig();
            this.world;
            this.add;
            v.sys.events.once(q.BOOT, this.boot, this);
            v.sys.events.on(q.START, this.start, this);
          },
          boot: function () {
            this.world = new u(this.scene, this.config);
            this.add = new c(this.world);
            this.systems.events.once(q.DESTROY, this.destroy, this);
          },
          start: function () {
            this.world ||
              ((this.world = new u(this.scene, this.config)),
              (this.add = new c(this.world)));
            var v = this.systems.events;
            if (!f(this.config, "customUpdate", !1))
              v.on(q.UPDATE, this.world.update, this.world);
            v.on(q.POST_UPDATE, this.world.postUpdate, this.world);
            v.once(q.SHUTDOWN, this.shutdown, this);
          },
          enableUpdate: function () {
            this.systems.events.on(q.UPDATE, this.world.update, this.world);
          },
          disableUpdate: function () {
            this.systems.events.off(q.UPDATE, this.world.update, this.world);
          },
          getConfig: function () {
            var v = this.systems.game.config.physics;
            return g(
              f(this.systems.settings.physics, "arcade", {}),
              f(v, "arcade", {})
            );
          },
          overlap: function (v, x, y, z, A) {
            void 0 === y && (y = null);
            void 0 === z && (z = null);
            void 0 === A && (A = y);
            return this.world.collideObjects(v, x, y, z, A, !0);
          },
          collide: function (v, x, y, z, A) {
            void 0 === y && (y = null);
            void 0 === z && (z = null);
            void 0 === A && (A = y);
            return this.world.collideObjects(v, x, y, z, A, !1);
          },
          collideTiles: function (v, x, y, z, A) {
            return this.world.collideTiles(v, x, y, z, A);
          },
          overlapTiles: function (v, x, y, z, A) {
            return this.world.overlapTiles(v, x, y, z, A);
          },
          pause: function () {
            return this.world.pause();
          },
          resume: function () {
            return this.world.resume();
          },
          accelerateTo: function (v, x, y, z, A, B) {
            void 0 === z && (z = 60);
            x = Math.atan2(y - v.y, x - v.x);
            v.body.acceleration.setToPolar(x, z);
            void 0 !== A && void 0 !== B && v.body.maxVelocity.set(A, B);
            return x;
          },
          accelerateToObject: function (v, x, y, z, A) {
            return this.accelerateTo(v, x.x, x.y, y, z, A);
          },
          closest: function (v, x) {
            x || (x = this.world.bodies.entries);
            for (
              var y = Number.MAX_VALUE,
                z = null,
                A = v.x,
                B = v.y,
                D = x.length,
                E = 0;
              E < D;
              E++
            ) {
              var C = x[E],
                F = C.body || C;
              v !== C &&
                v !== F &&
                v !== F.gameObject &&
                v !== F.center &&
                ((F = b(A, B, F.center.x, F.center.y)),
                F < y && ((z = C), (y = F)));
            }
            return z;
          },
          furthest: function (v, x) {
            x || (x = this.world.bodies.entries);
            for (
              var y = -1, z = null, A = v.x, B = v.y, D = x.length, E = 0;
              E < D;
              E++
            ) {
              var C = x[E],
                F = C.body || C;
              v !== C &&
                v !== F &&
                v !== F.gameObject &&
                v !== F.center &&
                ((F = b(A, B, F.center.x, F.center.y)),
                F > y && ((z = C), (y = F)));
            }
            return z;
          },
          moveTo: function (v, x, y, z, A) {
            void 0 === z && (z = 60);
            void 0 === A && (A = 0);
            var B = Math.atan2(y - v.y, x - v.x);
            0 < A && (z = e(v.x, v.y, x, y) / (A / 1e3));
            v.body.velocity.setToPolar(B, z);
            return B;
          },
          moveToObject: function (v, x, y, z) {
            return this.moveTo(v, x.x, x.y, y, z);
          },
          velocityFromAngle: function (v, x, y) {
            void 0 === x && (x = 60);
            void 0 === y && (y = new r());
            return y.setToPolar(k(v), x);
          },
          velocityFromRotation: function (v, x, y) {
            void 0 === x && (x = 60);
            void 0 === y && (y = new r());
            return y.setToPolar(v, x);
          },
          overlapRect: function (v, x, y, z, A, B) {
            return n(this.world, v, x, y, z, A, B);
          },
          overlapCirc: function (v, x, y, z, A) {
            return m(this.world, v, x, y, z, A);
          },
          shutdown: function () {
            if (this.world) {
              var v = this.systems.events;
              v.off(q.UPDATE, this.world.update, this.world);
              v.off(q.POST_UPDATE, this.world.postUpdate, this.world);
              v.off(q.SHUTDOWN, this.shutdown, this);
              this.add.destroy();
              this.world.destroy();
              this.world = this.add = null;
            }
          },
          destroy: function () {
            this.shutdown();
            this.scene.sys.events.off(q.START, this.start, this);
            this.systems = this.scene = null;
          },
        });
        t.register("ArcadePhysics", a, "arcadePhysics");
        h.exports = a;
      },
      function (h, t) {
        h.exports = {
          setAcceleration: function (a, d) {
            this.body.acceleration.set(a, d);
            return this;
          },
          setAccelerationX: function (a) {
            this.body.acceleration.x = a;
            return this;
          },
          setAccelerationY: function (a) {
            this.body.acceleration.y = a;
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          setAngularVelocity: function (a) {
            this.body.angularVelocity = a;
            return this;
          },
          setAngularAcceleration: function (a) {
            this.body.angularAcceleration = a;
            return this;
          },
          setAngularDrag: function (a) {
            this.body.angularDrag = a;
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          setBounce: function (a, d) {
            this.body.bounce.set(a, d);
            return this;
          },
          setBounceX: function (a) {
            this.body.bounce.x = a;
            return this;
          },
          setBounceY: function (a) {
            this.body.bounce.y = a;
            return this;
          },
          setCollideWorldBounds: function (a, d, k) {
            this.body.setCollideWorldBounds(a, d, k);
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          setDebug: function (a, d, k) {
            this.debugShowBody = a;
            this.debugShowVelocity = d;
            this.debugBodyColor = k;
            return this;
          },
          setDebugBodyColor: function (a) {
            this.body.debugBodyColor = a;
            return this;
          },
          debugShowBody: {
            get: function () {
              return this.body.debugShowBody;
            },
            set: function (a) {
              this.body.debugShowBody = a;
            },
          },
          debugShowVelocity: {
            get: function () {
              return this.body.debugShowVelocity;
            },
            set: function (a) {
              this.body.debugShowVelocity = a;
            },
          },
          debugBodyColor: {
            get: function () {
              return this.body.debugBodyColor;
            },
            set: function (a) {
              this.body.debugBodyColor = a;
            },
          },
        };
      },
      function (h, t) {
        h.exports = {
          setDrag: function (a, d) {
            this.body.drag.set(a, d);
            return this;
          },
          setDragX: function (a) {
            this.body.drag.x = a;
            return this;
          },
          setDragY: function (a) {
            this.body.drag.y = a;
            return this;
          },
          setDamping: function (a) {
            this.body.useDamping = a;
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          enableBody: function (a, d, k, e, b) {
            a && this.body.reset(d, k);
            e && (this.body.gameObject.active = !0);
            b && (this.body.gameObject.visible = !0);
            this.body.enable = !0;
            return this;
          },
          disableBody: function (a, d) {
            void 0 === a && (a = !1);
            void 0 === d && (d = !1);
            this.body.stop();
            this.body.enable = !1;
            a && (this.body.gameObject.active = !1);
            d && (this.body.gameObject.visible = !1);
            return this;
          },
          refreshBody: function () {
            this.body.updateFromGameObject();
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          setFriction: function (a, d) {
            this.body.friction.set(a, d);
            return this;
          },
          setFrictionX: function (a) {
            this.body.friction.x = a;
            return this;
          },
          setFrictionY: function (a) {
            this.body.friction.y = a;
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          setGravity: function (a, d) {
            this.body.gravity.set(a, d);
            return this;
          },
          setGravityX: function (a) {
            this.body.gravity.x = a;
            return this;
          },
          setGravityY: function (a) {
            this.body.gravity.y = a;
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          setImmovable: function (a) {
            void 0 === a && (a = !0);
            this.body.immovable = a;
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          setMass: function (a) {
            this.body.mass = a;
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          setPushable: function (a) {
            void 0 === a && (a = !0);
            this.body.pushable = a;
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          setOffset: function (a, d) {
            this.body.setOffset(a, d);
            return this;
          },
          setSize: function (a, d, k) {
            this.body.setSize(a, d, k);
            return this;
          },
          setBodySize: function (a, d, k) {
            this.body.setSize(a, d, k);
            return this;
          },
          setCircle: function (a, d, k) {
            this.body.setCircle(a, d, k);
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          setVelocity: function (a, d) {
            this.body.setVelocity(a, d);
            return this;
          },
          setVelocityX: function (a) {
            this.body.setVelocityX(a);
            return this;
          },
          setVelocityY: function (a) {
            this.body.setVelocityY(a);
            return this;
          },
          setMaxVelocity: function (a, d) {
            this.body.maxVelocity.set(a, d);
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = "collide";
      },
      function (h, t) {
        h.exports = "overlap";
      },
      function (h, t) {
        h.exports = "pause";
      },
      function (h, t) {
        h.exports = "resume";
      },
      function (h, t) {
        h.exports = "tilecollide";
      },
      function (h, t) {
        h.exports = "tileoverlap";
      },
      function (h, t) {
        h.exports = "worldbounds";
      },
      function (h, t) {
        h.exports = "worldstep";
      },
      function (h, t) {
        var a,
          d,
          k,
          e,
          b,
          c,
          f,
          g,
          m,
          n,
          q,
          r,
          u,
          v,
          x,
          y,
          z,
          A = function () {
            return n && x && d.blocked.right
              ? (a.processX(-z, f, !1, !0), 1)
              : m && y && d.blocked.left
              ? (a.processX(z, f, !0), 1)
              : u && y && a.blocked.right
              ? (d.processX(-z, g, !1, !0), 2)
              : r && x && a.blocked.left
              ? (d.processX(z, g, !0), 2)
              : 0;
          },
          B = function (D) {
            if (k && e)
              (z *= 0.5),
                0 === D || 3 === D
                  ? (a.processX(z, b), d.processX(-z, c))
                  : (a.processX(-z, b), d.processX(z, c));
            else if (k && !e)
              0 === D || 3 === D
                ? a.processX(z, f, !0)
                : a.processX(-z, f, !1, !0);
            else if (!k && e)
              0 === D || 3 === D
                ? d.processX(-z, g, !1, !0)
                : d.processX(z, g, !0);
            else {
              var E = 0.5 * z;
              0 === D
                ? v
                  ? (a.processX(z, 0, !0), d.processX(0, null, !1, !0))
                  : u
                  ? (a.processX(E, 0, !0), d.processX(-E, 0, !1, !0))
                  : (a.processX(E, d.velocity.x, !0),
                    d.processX(-E, null, !1, !0))
                : 1 === D
                ? q
                  ? (a.processX(0, null, !1, !0), d.processX(z, 0, !0))
                  : n
                  ? (a.processX(-E, 0, !1, !0), d.processX(E, 0, !0))
                  : (a.processX(-E, null, !1, !0),
                    d.processX(E, a.velocity.x, !0))
                : 2 === D
                ? v
                  ? (a.processX(-z, 0, !1, !0), d.processX(0, null, !0))
                  : r
                  ? (a.processX(-E, 0, !1, !0), d.processX(E, 0, !0))
                  : (a.processX(-E, d.velocity.x, !1, !0),
                    d.processX(E, null, !0))
                : 3 === D &&
                  (q
                    ? (a.processX(0, null, !0), d.processX(-z, 0, !1, !0))
                    : m
                    ? (a.processX(E, 0, !0), d.processX(-E, 0, !1, !0))
                    : (a.processX(E, d.velocity.y, !0),
                      d.processX(-E, null, !1, !0)));
            }
            return !0;
          };
        h.exports = {
          BlockCheck: A,
          Check: function () {
            var D = a.velocity.x,
              E = d.velocity.x;
            E = Math.sqrt((E * E * d.mass) / a.mass) * (0 < E ? 1 : -1);
            D = Math.sqrt((D * D * a.mass) / d.mass) * (0 < D ? 1 : -1);
            var C = 0.5 * (E + D);
            b = C + (E - C) * a.bounce.x;
            c = C + (D - C) * d.bounce.x;
            return m && y
              ? B(0)
              : r && x
              ? B(1)
              : n && x
              ? B(2)
              : u && y
              ? B(3)
              : !1;
          },
          Set: function (D, E, C) {
            a = D;
            d = E;
            D = a.velocity.x;
            E = d.velocity.x;
            k = a.pushable;
            m = 0 > a._dx;
            n = 0 < a._dx;
            q = 0 === a._dx;
            x = Math.abs(a.right - d.x) <= Math.abs(d.right - a.x);
            f = E - D * a.bounce.x;
            e = d.pushable;
            r = 0 > d._dx;
            u = 0 < d._dx;
            v = 0 === d._dx;
            y = !x;
            g = D - E * d.bounce.x;
            z = Math.abs(C);
            return A();
          },
          Run: B,
          RunImmovableBody1: function (D) {
            1 === D
              ? (d.velocity.x = 0)
              : x
              ? d.processX(z, g, !0)
              : d.processX(-z, g, !1, !0);
            a.moves &&
              ((d.y += (a.y - a.prev.y) * a.friction.y),
              (d._dy = d.y - d.prev.y));
          },
          RunImmovableBody2: function (D) {
            2 === D
              ? (a.velocity.x = 0)
              : y
              ? a.processX(z, f, !0)
              : a.processX(-z, f, !1, !0);
            d.moves &&
              ((a.y += (d.y - d.prev.y) * d.friction.y),
              (a._dy = a.y - a.prev.y));
          },
        };
      },
      function (h, t) {
        var a,
          d,
          k,
          e,
          b,
          c,
          f,
          g,
          m,
          n,
          q,
          r,
          u,
          v,
          x,
          y,
          z,
          A = function () {
            return n && x && d.blocked.down
              ? (a.processY(-z, f, !1, !0), 1)
              : m && y && d.blocked.up
              ? (a.processY(z, f, !0), 1)
              : u && y && a.blocked.down
              ? (d.processY(-z, g, !1, !0), 2)
              : r && x && a.blocked.up
              ? (d.processY(z, g, !0), 2)
              : 0;
          },
          B = function (D) {
            if (k && e)
              (z *= 0.5),
                0 === D || 3 === D
                  ? (a.processY(z, b), d.processY(-z, c))
                  : (a.processY(-z, b), d.processY(z, c));
            else if (k && !e)
              0 === D || 3 === D
                ? a.processY(z, f, !0)
                : a.processY(-z, f, !1, !0);
            else if (!k && e)
              0 === D || 3 === D
                ? d.processY(-z, g, !1, !0)
                : d.processY(z, g, !0);
            else {
              var E = 0.5 * z;
              0 === D
                ? v
                  ? (a.processY(z, 0, !0), d.processY(0, null, !1, !0))
                  : u
                  ? (a.processY(E, 0, !0), d.processY(-E, 0, !1, !0))
                  : (a.processY(E, d.velocity.y, !0),
                    d.processY(-E, null, !1, !0))
                : 1 === D
                ? q
                  ? (a.processY(0, null, !1, !0), d.processY(z, 0, !0))
                  : n
                  ? (a.processY(-E, 0, !1, !0), d.processY(E, 0, !0))
                  : (a.processY(-E, null, !1, !0),
                    d.processY(E, a.velocity.y, !0))
                : 2 === D
                ? v
                  ? (a.processY(-z, 0, !1, !0), d.processY(0, null, !0))
                  : r
                  ? (a.processY(-E, 0, !1, !0), d.processY(E, 0, !0))
                  : (a.processY(-E, d.velocity.y, !1, !0),
                    d.processY(E, null, !0))
                : 3 === D &&
                  (q
                    ? (a.processY(0, null, !0), d.processY(-z, 0, !1, !0))
                    : m
                    ? (a.processY(E, 0, !0), d.processY(-E, 0, !1, !0))
                    : (a.processY(E, d.velocity.y, !0),
                      d.processY(-E, null, !1, !0)));
            }
            return !0;
          };
        h.exports = {
          BlockCheck: A,
          Check: function () {
            var D = a.velocity.y,
              E = d.velocity.y;
            E = Math.sqrt((E * E * d.mass) / a.mass) * (0 < E ? 1 : -1);
            D = Math.sqrt((D * D * a.mass) / d.mass) * (0 < D ? 1 : -1);
            var C = 0.5 * (E + D);
            b = C + (E - C) * a.bounce.y;
            c = C + (D - C) * d.bounce.y;
            return m && y
              ? B(0)
              : r && x
              ? B(1)
              : n && x
              ? B(2)
              : u && y
              ? B(3)
              : !1;
          },
          Set: function (D, E, C) {
            a = D;
            d = E;
            D = a.velocity.y;
            E = d.velocity.y;
            k = a.pushable;
            m = 0 > a._dy;
            n = 0 < a._dy;
            q = 0 === a._dy;
            x = Math.abs(a.bottom - d.y) <= Math.abs(d.bottom - a.y);
            f = E - D * a.bounce.y;
            e = d.pushable;
            r = 0 > d._dy;
            u = 0 < d._dy;
            v = 0 === d._dy;
            y = !x;
            g = D - E * d.bounce.y;
            z = Math.abs(C);
            return A();
          },
          Run: B,
          RunImmovableBody1: function (D) {
            1 === D
              ? (d.velocity.y = 0)
              : x
              ? d.processY(z, g, !0)
              : d.processY(-z, g, !1, !0);
            a.moves &&
              ((d.x += (a.x - a.prev.x) * a.friction.x),
              (d._dx = d.x - d.prev.x));
          },
          RunImmovableBody2: function (D) {
            2 === D
              ? (a.velocity.y = 0)
              : y
              ? a.processY(z, f, !0)
              : a.processY(-z, f, !1, !0);
            d.moves &&
              ((a.x += (d.x - d.prev.x) * d.friction.x),
              (a._dx = a.x - a.prev.x));
          },
        };
      },
      function (h, t, a) {
        t = {
          ProcessTileCallbacks: a(530),
          ProcessTileSeparationX: a(534),
          ProcessTileSeparationY: a(536),
          SeparateTile: a(532),
          TileCheckX: a(533),
          TileCheckY: a(535),
          TileIntersectsBody: a(248),
        };
        h.exports = t;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(3);
        a = new t({
          initialize: function () {
            this.boundsCenter = new d();
            this.centerDiff = new d();
          },
          parseBody: function (k) {
            k = k.hasOwnProperty("body") ? k.body : k;
            if (
              !k.hasOwnProperty("bounds") ||
              !k.hasOwnProperty("centerOfMass")
            )
              return !1;
            var e = this.boundsCenter,
              b = this.centerDiff,
              c = k.bounds.max.x - k.bounds.min.x,
              f = k.bounds.max.y - k.bounds.min.y,
              g = c * k.centerOfMass.x;
            k = f * k.centerOfMass.y;
            e.set(c / 2, f / 2);
            b.set(g - e.x, k - e.y);
            return !0;
          },
          getTopLeft: function (k, e, b) {
            void 0 === e && (e = 0);
            void 0 === b && (b = 0);
            if (this.parseBody(k)) {
              k = this.boundsCenter;
              var c = this.centerDiff;
              return new d(e + k.x + c.x, b + k.y + c.y);
            }
            return !1;
          },
          getTopCenter: function (k, e, b) {
            void 0 === e && (e = 0);
            void 0 === b && (b = 0);
            return this.parseBody(k)
              ? ((k = this.centerDiff),
                new d(e + k.x, b + this.boundsCenter.y + k.y))
              : !1;
          },
          getTopRight: function (k, e, b) {
            void 0 === e && (e = 0);
            void 0 === b && (b = 0);
            if (this.parseBody(k)) {
              k = this.boundsCenter;
              var c = this.centerDiff;
              return new d(e - (k.x - c.x), b + k.y + c.y);
            }
            return !1;
          },
          getLeftCenter: function (k, e, b) {
            void 0 === e && (e = 0);
            void 0 === b && (b = 0);
            return this.parseBody(k)
              ? ((k = this.centerDiff),
                new d(e + this.boundsCenter.x + k.x, b + k.y))
              : !1;
          },
          getCenter: function (k, e, b) {
            void 0 === e && (e = 0);
            void 0 === b && (b = 0);
            return this.parseBody(k)
              ? ((k = this.centerDiff), new d(e + k.x, b + k.y))
              : !1;
          },
          getRightCenter: function (k, e, b) {
            void 0 === e && (e = 0);
            void 0 === b && (b = 0);
            return this.parseBody(k)
              ? ((k = this.centerDiff),
                new d(e - (this.boundsCenter.x - k.x), b + k.y))
              : !1;
          },
          getBottomLeft: function (k, e, b) {
            void 0 === e && (e = 0);
            void 0 === b && (b = 0);
            if (this.parseBody(k)) {
              k = this.boundsCenter;
              var c = this.centerDiff;
              return new d(e + k.x + c.x, b - (k.y - c.y));
            }
            return !1;
          },
          getBottomCenter: function (k, e, b) {
            void 0 === e && (e = 0);
            void 0 === b && (b = 0);
            return this.parseBody(k)
              ? ((k = this.centerDiff),
                new d(e + k.x, b - (this.boundsCenter.y - k.y)))
              : !1;
          },
          getBottomRight: function (k, e, b) {
            void 0 === e && (e = 0);
            void 0 === b && (b = 0);
            if (this.parseBody(k)) {
              k = this.boundsCenter;
              var c = this.centerDiff;
              return new d(e - (k.x - c.x), b - (k.y - c.y));
            }
            return !1;
          },
        });
        h.exports = a;
      },
      function (h, t) {
        function a(B, D, E, C) {
          var F = D[0] - B[0];
          D = D[1] - B[1];
          var G = C[0] - E[0],
            H = C[1] - E[1];
          if (0 === G * D - H * F) return !1;
          C = (F * (E[1] - B[1]) + D * (B[0] - E[0])) / (G * D - H * F);
          B = (G * (B[1] - E[1]) + H * (E[0] - B[0])) / (H * F - G * D);
          return 0 <= C && 1 >= C && 0 <= B && 1 >= B;
        }

        function d(B, D, E) {
          return (D[0] - B[0]) * (E[1] - B[1]) - (E[0] - B[0]) * (D[1] - B[1]);
        }

        function k(B, D, E) {
          return 0 < d(B, D, E);
        }

        function e(B, D, E) {
          return 0 <= d(B, D, E);
        }

        function b(B, D, E) {
          return 0 >= d(B, D, E);
        }

        function c(B, D) {
          var E = D[0] - B[0];
          B = D[1] - B[1];
          return E * E + B * B;
        }

        function f(B, D) {
          var E = B.length;
          return B[0 > D ? (D % E) + E : D % E];
        }

        function g(B, D, E, C) {
          for (; E < C; E++) B.push(D[E]);
        }

        function m(B, D) {
          var E = f(B, D - 1),
            C = f(B, D);
          B = f(B, D + 1);
          return 0 > d(E, C, B);
        }

        function n(B, D, E, C) {
          C = C || [];
          C.length = 0;
          if (D < E) for (var F = D; F <= E; F++) C.push(B[F]);
          else {
            for (F = 0; F <= E; F++) C.push(B[F]);
            for (F = D; F < B.length; F++) C.push(B[F]);
          }
          return C;
        }

        function q(B) {
          for (
            var D = [], E, C, F = [], G = Number.MAX_VALUE, H = 0;
            H < B.length;
            ++H
          )
            if (m(B, H))
              for (var K = 0; K < B.length; ++K) {
                a: {
                  C = B;
                  var I = H,
                    M = K,
                    N = z,
                    P = A;
                  if (
                    e(f(C, I + 1), f(C, I), f(C, M)) &&
                    b(f(C, I - 1), f(C, I), f(C, M))
                  )
                    E = !1;
                  else {
                    E = c(f(C, I), f(C, M));
                    for (var J = 0; J !== C.length; ++J)
                      if (
                        (J + 1) % C.length !== I &&
                        J !== I &&
                        e(f(C, I), f(C, M), f(C, J + 1)) &&
                        b(f(C, I), f(C, M), f(C, J))
                      ) {
                        N[0] = f(C, I);
                        N[1] = f(C, M);
                        P[0] = f(C, J);
                        P[1] = f(C, J + 1);
                        var L = [0, 0];
                        var O = N[1][1] - N[0][1];
                        var Q = N[0][0] - N[1][0];
                        var S = O * N[0][0] + Q * N[0][1];
                        var R = P[1][1] - P[0][1];
                        var T = P[0][0] - P[1][0];
                        var U = R * P[0][0] + T * P[0][1];
                        var V = O * T - R * Q;
                        0 >= Math.abs(V - 0) ||
                          ((L[0] = (T * S - Q * U) / V),
                          (L[1] = (O * U - R * S) / V));
                        V = L;
                        if (c(f(C, I), V) < E) {
                          E = !1;
                          break a;
                        }
                      }
                    E = !0;
                  }
                }
                if (E) {
                  E = q(n(B, H, K, F));
                  C = q(n(B, K, H, F));
                  for (I = 0; I < C.length; I++) E.push(C[I]);
                  E.length < G &&
                    ((D = E), (G = E.length), D.push([f(B, H), f(B, K)]));
                }
              }
          return D;
        }

        function r(B, D) {
          if (0 === D.length) return [B];
          if (
            D instanceof Array &&
            D.length &&
            D[0] instanceof Array &&
            2 === D[0].length &&
            D[0][0] instanceof Array
          ) {
            B = [B];
            for (var E = 0; E < D.length; E++)
              for (var C = D[E], F = 0; F < B.length; F++) {
                var G = r(B[F], C);
                if (G) {
                  B.splice(F, 1);
                  B.push(G[0], G[1]);
                  break;
                }
              }
            return B;
          }
          C = D;
          E = B.indexOf(C[0]);
          F = B.indexOf(C[1]);
          return -1 !== E && -1 !== F ? [n(B, E, F), n(B, F, E)] : !1;
        }

        function u(B, D, E, C, F) {
          var G = D[1] - B[1];
          D = B[0] - D[0];
          B = G * B[0] + D * B[1];
          var H = C[1] - E[1];
          C = E[0] - C[0];
          E = H * E[0] + C * E[1];
          var K = G * C - H * D;
          return Math.abs(K - 0) <= (F || 0)
            ? [0, 0]
            : [(C * B - D * E) / K, (G * E - H * B) / K];
        }

        function v(B, D, E, C, F, G, H) {
          G = G || 100;
          H = H || 0;
          F = F || 25;
          D = "undefined" !== typeof D ? D : [];
          E = E || [];
          C = C || [];
          var K = [0, 0],
            I = [0, 0],
            M = [0, 0],
            N,
            P = 0,
            J = 0,
            L = 0,
            O = [],
            Q = [];
          if (3 > B.length) return D;
          H++;
          if (H > G)
            return (
              console.warn("quickDecomp: max level (" + G + ") reached."), D
            );
          for (var S = 0; S < B.length; ++S)
            if (m(B, S)) {
              E.push(B[S]);
              var R = (N = Number.MAX_VALUE);
              for (var T = 0; T < B.length; ++T) {
                if (
                  k(f(B, S - 1), f(B, S), f(B, T)) &&
                  b(f(B, S - 1), f(B, S), f(B, T - 1))
                ) {
                  M = u(f(B, S - 1), f(B, S), f(B, T), f(B, T - 1));
                  var U = f(B, S + 1);
                  var V = f(B, S);
                  0 > d(U, V, M) &&
                    ((U = c(B[S], M)), U < N && ((N = U), (I = M), (J = T)));
                }
                k(f(B, S + 1), f(B, S), f(B, T + 1)) &&
                  b(f(B, S + 1), f(B, S), f(B, T)) &&
                  ((M = u(f(B, S + 1), f(B, S), f(B, T), f(B, T + 1))),
                  k(f(B, S - 1), f(B, S), M) &&
                    ((U = c(B[S], M)), U < R && ((R = U), (K = M), (P = T))));
              }
              if (J === (P + 1) % B.length)
                (M[0] = (I[0] + K[0]) / 2),
                  (M[1] = (I[1] + K[1]) / 2),
                  C.push(M),
                  S < P
                    ? (g(O, B, S, P + 1),
                      O.push(M),
                      Q.push(M),
                      0 !== J && g(Q, B, J, B.length),
                      g(Q, B, 0, S + 1))
                    : (0 !== S && g(O, B, S, B.length),
                      g(O, B, 0, P + 1),
                      O.push(M),
                      Q.push(M),
                      g(Q, B, J, S + 1));
              else {
                J > P && (P += B.length);
                K = Number.MAX_VALUE;
                if (P < J) return D;
                for (T = J; T <= P; ++T)
                  if (
                    e(f(B, S - 1), f(B, S), f(B, T)) &&
                    b(f(B, S + 1), f(B, S), f(B, T))
                  ) {
                    U = c(f(B, S), f(B, T));
                    if ((J = U < K))
                      a: {
                        J = B;
                        I = S;
                        M = T;
                        for (R = 0; R !== J.length; ++R)
                          if (
                            R !== I &&
                            R !== M &&
                            (R + 1) % J.length !== I &&
                            (R + 1) % J.length !== M &&
                            a(f(J, I), f(J, M), f(J, R), f(J, R + 1))
                          ) {
                            J = !1;
                            break a;
                          }
                        J = !0;
                      }
                    J && ((K = U), (L = T % B.length));
                  }
                S < L
                  ? (g(O, B, S, L + 1),
                    0 !== L && g(Q, B, L, B.length),
                    g(Q, B, 0, S + 1))
                  : (0 !== S && g(O, B, S, B.length),
                    g(O, B, 0, L + 1),
                    g(Q, B, L, S + 1));
              }
              O.length < Q.length
                ? (v(O, D, E, C, F, G, H), v(Q, D, E, C, F, G, H))
                : (v(Q, D, E, C, F, G, H), v(O, D, E, C, F, G, H));
              return D;
            }
          D.push(B);
          return D;
        }
        h.exports = {
          decomp: function (B) {
            var D = q(B);
            return 0 < D.length ? r(B, D) : [B];
          },
          quickDecomp: v,
          isSimple: function (B) {
            var D;
            for (D = 0; D < B.length - 1; D++)
              for (var E = 0; E < D - 1; E++)
                if (a(B[D], B[D + 1], B[E], B[E + 1])) return !1;
            for (D = 1; D < B.length - 2; D++)
              if (a(B[0], B[B.length - 1], B[D], B[D + 1])) return !1;
            return !0;
          },
          removeCollinearPoints: function (B, D) {
            for (var E = 0, C = B.length - 1; 3 < B.length && 0 <= C; --C) {
              var F = f(B, C - 1);
              var G = f(B, C),
                H = f(B, C + 1),
                K = D;
              if (K) {
                var I = x,
                  M = y;
                I[0] = G[0] - F[0];
                I[1] = G[1] - F[1];
                M[0] = H[0] - G[0];
                M[1] = H[1] - G[1];
                F =
                  Math.acos(
                    (I[0] * M[0] + I[1] * M[1]) /
                      (Math.sqrt(I[0] * I[0] + I[1] * I[1]) *
                        Math.sqrt(M[0] * M[0] + M[1] * M[1]))
                  ) < K;
              } else F = 0 === d(F, G, H);
              F && (B.splice(C % B.length, 1), E++);
            }
            return E;
          },
          removeDuplicatePoints: function (B, D) {
            for (var E = B.length - 1; 1 <= E; --E)
              for (var C = B[E], F = E - 1; 0 <= F; --F) {
                var G = C,
                  H = B[F],
                  K = D;
                Math.abs(G[0] - H[0]) <= (K || 0) &&
                  Math.abs(G[1] - H[1]) <= (K || 0) &&
                  B.splice(E, 1);
              }
          },
          makeCCW: function (B) {
            for (var D = 0, E = 1; E < B.length; ++E)
              if (
                B[E][1] < B[D][1] ||
                (B[E][1] === B[D][1] && B[E][0] > B[D][0])
              )
                D = E;
            if (k(f(B, D - 1), f(B, D), f(B, D + 1))) return !1;
            D = [];
            E = B.length;
            for (var C = 0; C !== E; C++) D.push(B.pop());
            for (C = 0; C !== E; C++) B[C] = D[C];
            return !0;
          },
        };
        var x = [],
          y = [],
          z = [],
          A = [];
      },
      function (h, t, a) {
        var d = a(86);
        t = a(0);
        var k = a(591),
          e = a(128),
          b = a(592),
          c = a(1395),
          f = a(1396),
          g = a(1397),
          m = a(593),
          n = a(589),
          q = a(590),
          r = a(1398),
          u = a(64);
        a = new t({
          initialize: function (v) {
            this.world = v;
            this.scene = v.scene;
            this.sys = v.scene.sys;
          },
          rectangle: function (v, x, y, z, A) {
            v = d.rectangle(v, x, y, z, A);
            this.world.add(v);
            return v;
          },
          trapezoid: function (v, x, y, z, A, B) {
            v = d.trapezoid(v, x, y, z, A, B);
            this.world.add(v);
            return v;
          },
          circle: function (v, x, y, z, A) {
            v = d.circle(v, x, y, z, A);
            this.world.add(v);
            return v;
          },
          polygon: function (v, x, y, z, A) {
            v = d.polygon(v, x, y, z, A);
            this.world.add(v);
            return v;
          },
          fromVertices: function (v, x, y, z, A, B, D) {
            "string" === typeof y && (y = u.fromPath(y));
            v = d.fromVertices(v, x, y, z, A, B, D);
            this.world.add(v);
            return v;
          },
          fromPhysicsEditor: function (v, x, y, z, A) {
            void 0 === A && (A = !0);
            v = n.parseBody(v, x, y, z);
            A && !this.world.has(v) && this.world.add(v);
            return v;
          },
          fromSVG: function (v, x, y, z, A, B) {
            void 0 === z && (z = 1);
            void 0 === A && (A = {});
            void 0 === B && (B = !0);
            y = y.getElementsByTagName("path");
            for (var D = [], E = 0; E < y.length; E++) {
              var C = b.pathToVertices(y[E], 30);
              1 !== z && u.scale(C, z, z);
              D.push(C);
            }
            v = d.fromVertices(v, x, D, A);
            B && this.world.add(v);
            return v;
          },
          fromJSON: function (v, x, y, z, A) {
            void 0 === z && (z = {});
            void 0 === A && (A = !0);
            (v = q.parseBody(v, x, y, z)) && A && this.world.add(v);
            return v;
          },
          imageStack: function (v, x, y, z, A, B, D, E, C) {
            void 0 === D && (D = 0);
            void 0 === E && (E = 0);
            void 0 === C && (C = {});
            var F = this.world,
              G = this.sys.displayList;
            C.addToWorld = !1;
            y = k.stack(y, z, A, B, D, E, function (H, K) {
              H = new f(F, H, K, v, x, C);
              G.add(H);
              return H.body;
            });
            F.add(y);
            return y;
          },
          stack: function (v, x, y, z, A, B, D) {
            v = k.stack(v, x, y, z, A, B, D);
            this.world.add(v);
            return v;
          },
          pyramid: function (v, x, y, z, A, B, D) {
            v = k.pyramid(v, x, y, z, A, B, D);
            this.world.add(v);
            return v;
          },
          chain: function (v, x, y, z, A, B) {
            return k.chain(v, x, y, z, A, B);
          },
          mesh: function (v, x, y, z, A) {
            return k.mesh(v, x, y, z, A);
          },
          newtonsCradle: function (v, x, y, z, A) {
            v = k.newtonsCradle(v, x, y, z, A);
            this.world.add(v);
            return v;
          },
          car: function (v, x, y, z, A) {
            v = k.car(v, x, y, z, A);
            this.world.add(v);
            return v;
          },
          softBody: function (v, x, y, z, A, B, D, E, C, F) {
            v = k.softBody(v, x, y, z, A, B, D, E, C, F);
            this.world.add(v);
            return v;
          },
          joint: function (v, x, y, z, A) {
            return this.constraint(v, x, y, z, A);
          },
          spring: function (v, x, y, z, A) {
            return this.constraint(v, x, y, z, A);
          },
          constraint: function (v, x, y, z, A) {
            void 0 === z && (z = 1);
            void 0 === A && (A = {});
            A.bodyA = "body" === v.type ? v : v.body;
            A.bodyB = "body" === x.type ? x : x.body;
            isNaN(y) || (A.length = y);
            A.stiffness = z;
            v = e.create(A);
            this.world.add(v);
            return v;
          },
          worldConstraint: function (v, x, y, z) {
            void 0 === y && (y = 1);
            void 0 === z && (z = {});
            z.bodyB = "body" === v.type ? v : v.body;
            isNaN(x) || (z.length = x);
            z.stiffness = y;
            v = e.create(z);
            this.world.add(v);
            return v;
          },
          mouseSpring: function (v) {
            return this.pointerConstraint(v);
          },
          pointerConstraint: function (v) {
            void 0 === v && (v = {});
            v.hasOwnProperty("render") ||
              (v.render = {
                visible: !1,
              });
            v = new r(this.scene, this.world, v);
            this.world.add(v.constraint);
            return v;
          },
          image: function (v, x, y, z, A) {
            v = new f(this.world, v, x, y, z, A);
            this.sys.displayList.add(v);
            return v;
          },
          tileBody: function (v, x) {
            return new m(this.world, v, x);
          },
          sprite: function (v, x, y, z, A) {
            v = new g(this.world, v, x, y, z, A);
            this.sys.displayList.add(v);
            this.sys.updateList.add(v);
            return v;
          },
          gameObject: function (v, x, y) {
            return c(this.world, v, x, y);
          },
          destroy: function () {
            this.sys = this.scene = this.world = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(249),
          k = a(2),
          e = a(3);
        h.exports = function (b, c, f, g) {
          void 0 === f && (f = {});
          void 0 === g && (g = !0);
          var m = c.x,
            n = c.y;
          c.body = {
            temp: !0,
            position: {
              x: m,
              y: n,
            },
          };
          [
            d.Bounce,
            d.Collision,
            d.Force,
            d.Friction,
            d.Gravity,
            d.Mass,
            d.Sensor,
            d.SetBody,
            d.Sleep,
            d.Static,
            d.Transform,
            d.Velocity,
          ].forEach(function (q) {
            for (var r in q) {
              var u = q[r];
              (u.get && "function" === typeof u.get) ||
              (u.set && "function" === typeof u.set)
                ? Object.defineProperty(c, r, {
                    get: q[r].get,
                    set: q[r].set,
                  })
                : Object.defineProperty(c, r, {
                    value: q[r],
                  });
            }
          });
          c.world = b;
          c._tempVec2 = new e(m, n);
          f.hasOwnProperty("type") && "body" === f.type
            ? c.setExistingBody(f, g)
            : ((b = k(f, "shape", null)) || (b = "rectangle"),
              (f.addToWorld = g),
              c.setBody(b, f));
          return c;
        };
      },
      function (h, t, a) {
        t = a(0);
        var d = a(249),
          k = a(15),
          e = a(2),
          b = a(125),
          c = a(167),
          f = a(3);
        a = new t({
          Extends: b,
          Mixins: [
            d.Bounce,
            d.Collision,
            d.Force,
            d.Friction,
            d.Gravity,
            d.Mass,
            d.Sensor,
            d.SetBody,
            d.Sleep,
            d.Static,
            d.Transform,
            d.Velocity,
            c,
          ],
          initialize: function (g, m, n, q, r, u) {
            k.call(this, g.scene, "Image");
            this._crop = this.resetCropObject();
            this.setTexture(q, r);
            this.setSizeToFrame();
            this.setOrigin();
            this.world = g;
            this._tempVec2 = new f(m, n);
            (g = e(u, "shape", null))
              ? this.setBody(g, u)
              : this.setRectangle(this.width, this.height, u);
            this.setPosition(m, n);
            this.initPipeline();
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(164);
        t = a(0);
        var k = a(249),
          e = a(15),
          b = a(2),
          c = a(167),
          f = a(73),
          g = a(3);
        a = new t({
          Extends: f,
          Mixins: [
            k.Bounce,
            k.Collision,
            k.Force,
            k.Friction,
            k.Gravity,
            k.Mass,
            k.Sensor,
            k.SetBody,
            k.Sleep,
            k.Static,
            k.Transform,
            k.Velocity,
            c,
          ],
          initialize: function (m, n, q, r, u, v) {
            e.call(this, m.scene, "Sprite");
            this._crop = this.resetCropObject();
            this.anims = new d(this);
            this.setTexture(r, u);
            this.setSizeToFrame();
            this.setOrigin();
            this.world = m;
            this._tempVec2 = new g(n, q);
            (m = b(v, "shape", null))
              ? this.setBody(m, v)
              : this.setRectangle(this.width, this.height, v);
            this.setPosition(n, q);
            this.initPipeline();
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(84);
        t = a(0);
        var k = a(118),
          e = a(128),
          b = a(273),
          c = a(272),
          f = a(51),
          g = a(127),
          m = a(165),
          n = a(3),
          q = a(64);
        a = new t({
          initialize: function (r, u, v) {
            void 0 === v && (v = {});
            this.scene = r;
            this.world = u;
            this.pointer = this.camera = null;
            this.active = !0;
            this.position = new n();
            this.part = this.body = null;
            this.constraint = e.create(
              g(v, {
                label: "Pointer Constraint",
                pointA: {
                  x: 0,
                  y: 0,
                },
                pointB: {
                  x: 0,
                  y: 0,
                },
                length: 0.01,
                stiffness: 0.1,
                angularStiffness: 1,
                collisionFilter: {
                  category: 1,
                  mask: 4294967295,
                  group: 0,
                },
              })
            );
            this.world.on(c.BEFORE_UPDATE, this.update, this);
            r.sys.input.on(f.POINTER_DOWN, this.onDown, this);
            r.sys.input.on(f.POINTER_UP, this.onUp, this);
          },
          onDown: function (r) {
            this.pointer || ((this.pointer = r), (this.camera = r.camera));
          },
          onUp: function (r) {
            r === this.pointer && (this.pointer = null);
          },
          getBody: function (r) {
            var u = this.position,
              v = this.constraint;
            this.camera.getWorldPoint(r.x, r.y, u);
            r = k.allBodies(this.world.localWorld);
            for (var x = 0; x < r.length; x++) {
              var y = r[x];
              if (
                !y.ignorePointer &&
                d.contains(y.bounds, u) &&
                b.canCollide(y.collisionFilter, v.collisionFilter) &&
                this.hitTestBody(y, u)
              )
                return this.world.emit(c.DRAG_START, y, this.part, this), !0;
            }
            return !1;
          },
          hitTestBody: function (r, u) {
            for (
              var v = this.constraint, x = r.parts.length, y = 1 < x ? 1 : 0;
              y < x;
              y++
            ) {
              var z = r.parts[y];
              if (q.contains(z.vertices, u))
                return (
                  (v.pointA = u),
                  (v.pointB = {
                    x: u.x - r.position.x,
                    y: u.y - r.position.y,
                  }),
                  (v.bodyB = r),
                  (v.angleB = r.angle),
                  m.set(r, !1),
                  (this.part = z),
                  (this.body = r),
                  !0
                );
            }
            return !1;
          },
          update: function () {
            var r = this.pointer,
              u = this.body;
            if (!this.active || !r) u && this.stopDrag();
            else if (!r.isDown && u) this.stopDrag();
            else if (r.isDown && (u || this.getBody(r))) {
              u = this.body;
              var v = this.position,
                x = this.constraint;
              this.camera.getWorldPoint(r.x, r.y, v);
              x.pointA.x = v.x;
              x.pointA.y = v.y;
              m.set(u, !1);
              this.world.emit(c.DRAG, u, this);
            }
          },
          stopDrag: function () {
            var r = this.body,
              u = this.constraint;
            u.bodyB = null;
            this.part = this.body = this.pointer = u.pointB = null;
            r && this.world.emit(c.DRAG_END, r, this);
          },
          destroy: function () {
            this.world.removeConstraint(this.constraint);
            this.part = this.body = this.constraint = this.pointer = null;
            this.world.off(c.BEFORE_UPDATE, this.update);
            this.scene.sys.input.off(f.POINTER_DOWN, this.onDown, this);
            this.scene.sys.input.off(f.POINTER_UP, this.onUp, this);
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(595),
          e = a(32);
        (function () {
          d.name = "matter-js";
          d.version = "0.14.2";
          d.uses = [];
          d.used = [];
          d.use = function () {
            k.use(d, Array.prototype.slice.call(arguments));
          };
          d.before = function (b, c) {
            b = b.replace(/^Matter./, "");
            return e.chainPathBefore(d, b, c);
          };
          d.after = function (b, c) {
            b = b.replace(/^Matter./, "");
            return e.chainPathAfter(d, b, c);
          };
        })();
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(83),
          e = a(274),
          b = a(84),
          c = a(86),
          f = a(64);
        (function () {
          d.collides = function (g, m) {
            for (var n = [], q = 0; q < m.length; q++) {
              var r = m[q];
              if (g !== r && b.overlaps(r.bounds, g.bounds))
                for (
                  var u = 1 === r.parts.length ? 0 : 1;
                  u < r.parts.length;
                  u++
                ) {
                  var v = r.parts[u];
                  if (
                    b.overlaps(v.bounds, g.bounds) &&
                    ((v = e.collides(v, g)), v.collided)
                  ) {
                    n.push(v);
                    break;
                  }
                }
            }
            return n;
          };
          d.ray = function (g, m, n, q) {
            q = q || 1e-100;
            var r = k.angle(m, n),
              u = k.magnitude(k.sub(m, n));
            m = c.rectangle(0.5 * (n.x + m.x), 0.5 * (n.y + m.y), u, q, {
              angle: r,
            });
            g = d.collides(m, g);
            for (m = 0; m < g.length; m += 1)
              (n = g[m]), (n.body = n.bodyB = n.bodyA);
            return g;
          };
          d.region = function (g, m, n) {
            for (var q = [], r = 0; r < g.length; r++) {
              var u = g[r],
                v = b.overlaps(u.bounds, m);
              ((v && !n) || (!v && n)) && q.push(u);
            }
            return q;
          };
          d.point = function (g, m) {
            for (var n = [], q = 0; q < g.length; q++) {
              var r = g[q];
              if (b.contains(r.bounds, m))
                for (
                  var u = 1 === r.parts.length ? 0 : 1;
                  u < r.parts.length;
                  u++
                ) {
                  var v = r.parts[u];
                  if (b.contains(v.bounds, m) && f.contains(v.vertices, m)) {
                    n.push(r);
                    break;
                  }
                }
            }
            return n;
          };
        })();
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(596),
          e = a(165),
          b = a(599),
          c = a(598),
          f = a(1523),
          g = a(597),
          m = a(166),
          n = a(118),
          q = a(128),
          r = a(32),
          u = a(41);
        (function () {
          d.create = function (v, x) {
            x = r.isElement(v) ? x : v;
            v = r.isElement(v) ? v : null;
            x = x || {};
            (v || x.render) &&
              r.warn("Engine.create: engine.render is deprecated (see docs)");
            v = r.extend(
              {
                positionIterations: 6,
                velocityIterations: 4,
                constraintIterations: 2,
                enableSleeping: !1,
                events: [],
                plugin: {},
                timing: {
                  timestamp: 0,
                  timeScale: 1,
                },
                broadphase: {
                  controller: g,
                },
              },
              x
            );
            v.world = x.world || k.create(v.world);
            v.pairs = c.create();
            v.broadphase = v.broadphase.controller.create(v.broadphase);
            v.metrics = v.metrics || {
              extended: !1,
            };
            v.metrics = f.create(v.metrics);
            return v;
          };
          d.update = function (v, x, y) {
            x = x || 1e3 / 60;
            y = y || 1;
            var z = v.world,
              A = v.timing,
              B = v.broadphase;
            A.timestamp += x * A.timeScale;
            var D = {
              timestamp: A.timestamp,
            };
            m.trigger(v, "beforeUpdate", D);
            var E = n.allBodies(z),
              C = n.allConstraints(z);
            f.reset(v.metrics);
            v.enableSleeping && e.update(E, A.timeScale);
            d._bodiesApplyGravity(E, z.gravity);
            d._bodiesUpdate(E, x, A.timeScale, y, z.bounds);
            q.preSolveAll(E);
            for (x = 0; x < v.constraintIterations; x++)
              q.solveAll(C, A.timeScale);
            q.postSolveAll(E);
            B.controller
              ? (z.isModified && B.controller.clear(B),
                B.controller.update(B, E, v, z.isModified),
                (x = B.pairsList))
              : (x = E);
            z.isModified && n.setModified(z, !1, !1, !0);
            B = B.detector(x, v);
            z = v.pairs;
            x = A.timestamp;
            c.update(z, B, x);
            c.removeOld(z, x);
            v.enableSleeping && e.afterCollisions(z.list, A.timeScale);
            0 < z.collisionStart.length &&
              m.trigger(v, "collisionStart", {
                pairs: z.collisionStart,
              });
            b.preSolvePosition(z.list);
            for (x = 0; x < v.positionIterations; x++)
              b.solvePosition(z.list, E, A.timeScale);
            b.postSolvePosition(E);
            q.preSolveAll(E);
            for (x = 0; x < v.constraintIterations; x++)
              q.solveAll(C, A.timeScale);
            q.postSolveAll(E);
            b.preSolveVelocity(z.list);
            for (x = 0; x < v.velocityIterations; x++)
              b.solveVelocity(z.list, A.timeScale);
            0 < z.collisionActive.length &&
              m.trigger(v, "collisionActive", {
                pairs: z.collisionActive,
              });
            0 < z.collisionEnd.length &&
              m.trigger(v, "collisionEnd", {
                pairs: z.collisionEnd,
              });
            f.update(v.metrics, v);
            d._bodiesClearForces(E);
            m.trigger(v, "afterUpdate", D);
            return v;
          };
          d.merge = function (v, x) {
            r.extend(v, x);
            if (x.world)
              for (
                v.world = x.world, d.clear(v), v = n.allBodies(v.world), x = 0;
                x < v.length;
                x++
              ) {
                var y = v[x];
                e.set(y, !1);
                y.id = r.nextId();
              }
          };
          d.clear = function (v) {
            var x = v.world;
            c.clear(v.pairs);
            var y = v.broadphase;
            y.controller &&
              ((x = n.allBodies(x)),
              y.controller.clear(y),
              y.controller.update(y, x, v, !0));
          };
          d._bodiesClearForces = function (v) {
            for (var x = 0; x < v.length; x++) {
              var y = v[x];
              y.force.x = 0;
              y.force.y = 0;
              y.torque = 0;
            }
          };
          d._bodiesApplyGravity = function (v, x) {
            var y = "undefined" !== typeof x.scale ? x.scale : 0.001;
            if ((0 !== x.x || 0 !== x.y) && 0 !== y)
              for (var z = 0; z < v.length; z++) {
                var A = v[z];
                A.ignoreGravity ||
                  A.isStatic ||
                  A.isSleeping ||
                  ((A.force.x += A.mass * x.x * y * A.gravityScale.x),
                  (A.force.y += A.mass * x.y * y * A.gravityScale.y));
              }
          };
          d._bodiesUpdate = function (v, x, y, z, A) {
            for (A = 0; A < v.length; A++) {
              var B = v[A];
              B.isStatic || B.isSleeping || u.update(B, x, y, z);
            }
          };
        })();
      },
      function (h, t, a) {
        var d = a(86),
          k = a(41);
        t = a(0);
        var e = a(32),
          b = a(118),
          c = a(1401),
          f = a(9),
          g = a(272),
          m = a(2),
          n = a(6),
          q = a(41),
          r = a(166),
          u = a(593),
          v = a(596),
          x = a(83);
        a = new t({
          Extends: f,
          initialize: function (y, z) {
            f.call(this);
            this.scene = y;
            this.engine = c.create(z);
            this.localWorld = this.engine.world;
            var A = n(z, "gravity", null);
            A
              ? this.setGravity(A.x, A.y, A.scale)
              : !1 === A && this.setGravity(0, 0, 0);
            this.walls = {
              left: null,
              right: null,
              top: null,
              bottom: null,
            };
            this.enabled = n(z, "enabled", !0);
            this.correction = n(z, "correction", 1);
            this.getDelta = n(z, "getDelta", this.update60Hz);
            A = m(z, "runner", {});
            var B = m(A, "fps", !1),
              D = m(A, "fps", 60),
              E = m(A, "delta", 1e3 / D),
              C = m(A, "deltaMin", 1e3 / D),
              F = m(A, "deltaMax", 1e3 / (0.5 * D));
            B || (D = 1e3 / E);
            this.runner = {
              fps: D,
              correction: m(A, "correction", 1),
              deltaSampleSize: m(A, "deltaSampleSize", 60),
              counterTimestamp: 0,
              frameCounter: 0,
              deltaHistory: [],
              timePrev: null,
              timeScalePrev: 1,
              frameRequestId: null,
              isFixed: m(A, "isFixed", !1),
              delta: E,
              deltaMin: C,
              deltaMax: F,
            };
            this.autoUpdate = n(z, "autoUpdate", !0);
            A = n(z, "debug", !1);
            this.drawDebug = "object" === typeof A ? !0 : A;
            this.debugGraphic;
            this.debugConfig = {
              showAxes: m(A, "showAxes", !1),
              showAngleIndicator: m(A, "showAngleIndicator", !1),
              angleColor: m(A, "angleColor", 15208787),
              showBroadphase: m(A, "showBroadphase", !1),
              broadphaseColor: m(A, "broadphaseColor", 16757760),
              showBounds: m(A, "showBounds", !1),
              boundsColor: m(A, "boundsColor", 16777215),
              showVelocity: m(A, "showVelocity", !1),
              velocityColor: m(A, "velocityColor", 44783),
              showCollisions: m(A, "showCollisions", !1),
              collisionColor: m(A, "collisionColor", 16094476),
              showSeparations: m(A, "showSeparations", !1),
              separationColor: m(A, "separationColor", 16753920),
              showBody: m(A, "showBody", !0),
              showStaticBody: m(A, "showStaticBody", !0),
              showInternalEdges: m(A, "showInternalEdges", !1),
              renderFill: m(A, "renderFill", !1),
              renderLine: m(A, "renderLine", !0),
              fillColor: m(A, "fillColor", 1075465),
              fillOpacity: m(A, "fillOpacity", 1),
              lineColor: m(A, "lineColor", 2678297),
              lineOpacity: m(A, "lineOpacity", 1),
              lineThickness: m(A, "lineThickness", 1),
              staticFillColor: m(A, "staticFillColor", 857979),
              staticLineColor: m(A, "staticLineColor", 1255396),
              showSleeping: m(A, "showSleeping", !1),
              staticBodySleepOpacity: m(A, "staticBodySleepOpacity", 0.7),
              sleepFillColor: m(A, "sleepFillColor", 4605510),
              sleepLineColor: m(A, "sleepLineColor", 10066585),
              showSensors: m(A, "showSensors", !0),
              sensorFillColor: m(A, "sensorFillColor", 857979),
              sensorLineColor: m(A, "sensorLineColor", 1255396),
              showPositions: m(A, "showPositions", !0),
              positionSize: m(A, "positionSize", 4),
              positionColor: m(A, "positionColor", 14697178),
              showJoint: m(A, "showJoint", !0),
              jointColor: m(A, "jointColor", 14737474),
              jointLineOpacity: m(A, "jointLineOpacity", 1),
              jointLineThickness: m(A, "jointLineThickness", 2),
              pinSize: m(A, "pinSize", 4),
              pinColor: m(A, "pinColor", 4382944),
              springColor: m(A, "springColor", 14697184),
              anchorColor: m(A, "anchorColor", 15724527),
              anchorSize: m(A, "anchorSize", 4),
              showConvexHulls: m(A, "showConvexHulls", !1),
              hullColor: m(A, "hullColor", 14091216),
            };
            this.drawDebug && this.createDebugGraphic();
            this.setEventsProxy();
            if (m(z, "setBounds", !1))
              if (((D = z.setBounds), "boolean" === typeof D)) this.setBounds();
              else {
                z = m(D, "x", 0);
                A = m(D, "y", 0);
                B = m(D, "width", y.sys.scale.width);
                y = m(D, "height", y.sys.scale.height);
                E = m(D, "thickness", 64);
                C = m(D, "left", !0);
                F = m(D, "right", !0);
                var G = m(D, "top", !0);
                D = m(D, "bottom", !0);
                this.setBounds(z, A, B, y, E, C, F, G, D);
              }
          },
          setCompositeRenderStyle: function (y) {
            var z = y.bodies,
              A = y.constraints;
            y = y.composites;
            var B;
            for (B = 0; B < z.length; B++) {
              var D = z[B];
              var E = D.render;
              this.setBodyRenderStyle(
                D,
                E.lineColor,
                E.lineOpacity,
                E.lineThickness,
                E.fillColor,
                E.fillOpacity
              );
            }
            for (B = 0; B < A.length; B++)
              (D = A[B]),
                (E = D.render),
                this.setConstraintRenderStyle(
                  D,
                  E.lineColor,
                  E.lineOpacity,
                  E.lineThickness,
                  E.pinSize,
                  E.anchorColor,
                  E.anchorSize
                );
            for (B = 0; B < y.length; B++)
              (D = y[B]), this.setCompositeRenderStyle(D);
            return this;
          },
          setBodyRenderStyle: function (y, z, A, B, D, E) {
            var C = y.render,
              F = this.debugConfig;
            if (!C) return this;
            if (void 0 === z || null === z)
              z = y.isStatic ? F.staticLineColor : F.lineColor;
            if (void 0 === A || null === A) A = F.lineOpacity;
            if (void 0 === B || null === B) B = F.lineThickness;
            if (void 0 === D || null === D)
              D = y.isStatic ? F.staticFillColor : F.fillColor;
            if (void 0 === E || null === E) E = F.fillOpacity;
            !1 !== z && (C.lineColor = z);
            !1 !== A && (C.lineOpacity = A);
            !1 !== B && (C.lineThickness = B);
            !1 !== D && (C.fillColor = D);
            !1 !== E && (C.fillOpacity = E);
            return this;
          },
          setConstraintRenderStyle: function (y, z, A, B, D, E, C) {
            y = y.render;
            var F = this.debugConfig;
            if (!y) return this;
            if (void 0 === z || null === z) {
              var G = y.type;
              "line" === G
                ? (z = F.jointColor)
                : "pin" === G
                ? (z = F.pinColor)
                : "spring" === G && (z = F.springColor);
            }
            if (void 0 === A || null === A) A = F.jointLineOpacity;
            if (void 0 === B || null === B) B = F.jointLineThickness;
            if (void 0 === D || null === D) D = F.pinSize;
            if (void 0 === E || null === E) E = F.anchorColor;
            if (void 0 === C || null === C) C = F.anchorSize;
            !1 !== z && (y.lineColor = z);
            !1 !== A && (y.lineOpacity = A);
            !1 !== B && (y.lineThickness = B);
            !1 !== D && (y.pinSize = D);
            !1 !== E && (y.anchorColor = E);
            !1 !== C && (y.anchorSize = C);
            return this;
          },
          setEventsProxy: function () {
            var y = this,
              z = this.engine,
              A = this.localWorld;
            this.drawDebug &&
              (r.on(A, "compositeModified", function (B) {
                y.setCompositeRenderStyle(B);
              }),
              r.on(A, "beforeAdd", function (B) {
                B = [].concat(B.object);
                for (var D = 0; D < B.length; D++) {
                  var E = B[D],
                    C = E.render;
                  "body" === E.type
                    ? y.setBodyRenderStyle(
                        E,
                        C.lineColor,
                        C.lineOpacity,
                        C.lineThickness,
                        C.fillColor,
                        C.fillOpacity
                      )
                    : "composite" === E.type
                    ? y.setCompositeRenderStyle(E)
                    : "constraint" === E.type &&
                      y.setConstraintRenderStyle(
                        E,
                        C.lineColor,
                        C.lineOpacity,
                        C.lineThickness,
                        C.pinSize,
                        C.anchorColor,
                        C.anchorSize
                      );
                }
              }));
            r.on(A, "beforeAdd", function (B) {
              y.emit(g.BEFORE_ADD, B);
            });
            r.on(A, "afterAdd", function (B) {
              y.emit(g.AFTER_ADD, B);
            });
            r.on(A, "beforeRemove", function (B) {
              y.emit(g.BEFORE_REMOVE, B);
            });
            r.on(A, "afterRemove", function (B) {
              y.emit(g.AFTER_REMOVE, B);
            });
            r.on(z, "beforeUpdate", function (B) {
              y.emit(g.BEFORE_UPDATE, B);
            });
            r.on(z, "afterUpdate", function (B) {
              y.emit(g.AFTER_UPDATE, B);
            });
            r.on(z, "collisionStart", function (B) {
              var D = B.pairs;
              if (0 < D.length) {
                var E = D[0].bodyA;
                var C = D[0].bodyB;
              }
              y.emit(g.COLLISION_START, B, E, C);
            });
            r.on(z, "collisionActive", function (B) {
              var D = B.pairs;
              if (0 < D.length) {
                var E = D[0].bodyA;
                var C = D[0].bodyB;
              }
              y.emit(g.COLLISION_ACTIVE, B, E, C);
            });
            r.on(z, "collisionEnd", function (B) {
              var D = B.pairs;
              if (0 < D.length) {
                var E = D[0].bodyA;
                var C = D[0].bodyB;
              }
              y.emit(g.COLLISION_END, B, E, C);
            });
          },
          setBounds: function (y, z, A, B, D, E, C, F, G) {
            void 0 === y && (y = 0);
            void 0 === z && (z = 0);
            void 0 === A && (A = this.scene.sys.scale.width);
            void 0 === B && (B = this.scene.sys.scale.height);
            void 0 === D && (D = 64);
            void 0 === E && (E = !0);
            void 0 === C && (C = !0);
            void 0 === F && (F = !0);
            void 0 === G && (G = !0);
            this.updateWall(E, "left", y - D, z - D, D, B + 2 * D);
            this.updateWall(C, "right", y + A, z - D, D, B + 2 * D);
            this.updateWall(F, "top", y, z - D, A, D);
            this.updateWall(G, "bottom", y, z + B, A, D);
            return this;
          },
          updateWall: function (y, z, A, B, D, E) {
            var C = this.walls[z];
            y
              ? (C && v.remove(this.localWorld, C),
                (this.walls[z] = this.create(A + D / 2, B + E / 2, D, E, {
                  isStatic: !0,
                  friction: 0,
                  frictionStatic: 0,
                })))
              : (C && v.remove(this.localWorld, C), (this.walls[z] = null));
          },
          createDebugGraphic: function () {
            var y = this.scene.sys.add.graphics({
              x: 0,
              y: 0,
            });
            y.setDepth(Number.MAX_VALUE);
            this.debugGraphic = y;
            this.drawDebug = !0;
            return y;
          },
          disableGravity: function () {
            this.localWorld.gravity.x = 0;
            this.localWorld.gravity.y = 0;
            this.localWorld.gravity.scale = 0;
            return this;
          },
          setGravity: function (y, z, A) {
            void 0 === y && (y = 0);
            void 0 === z && (z = 1);
            this.localWorld.gravity.x = y;
            this.localWorld.gravity.y = z;
            void 0 !== A && (this.localWorld.gravity.scale = A);
            return this;
          },
          create: function (y, z, A, B, D) {
            y = d.rectangle(y, z, A, B, D);
            v.add(this.localWorld, y);
            return y;
          },
          add: function (y) {
            v.add(this.localWorld, y);
            return this;
          },
          remove: function (y, z) {
            Array.isArray(y) || (y = [y]);
            for (var A = 0; A < y.length; A++) {
              var B = y[A];
              b.remove(this.localWorld, B.body ? B.body : B, z);
            }
            return this;
          },
          removeConstraint: function (y, z) {
            b.remove(this.localWorld, y, z);
            return this;
          },
          convertTilemapLayer: function (y, z) {
            var A = y.layer;
            y = y.getTilesWithin(0, 0, A.width, A.height, {
              isColliding: !0,
            });
            this.convertTiles(y, z);
            return this;
          },
          convertTiles: function (y, z) {
            if (0 === y.length) return this;
            for (var A = 0; A < y.length; A++) new u(this, y[A], z);
            return this;
          },
          nextGroup: function (y) {
            return q.nextGroup(y);
          },
          nextCategory: function () {
            return q.nextCategory();
          },
          pause: function () {
            this.enabled = !1;
            this.emit(g.PAUSE);
            return this;
          },
          resume: function () {
            this.enabled = !0;
            this.emit(g.RESUME);
            return this;
          },
          update: function (y, z) {
            if (this.enabled && this.autoUpdate) {
              var A = this.engine,
                B = this.runner,
                D = A.timing,
                E = this.correction;
              B.isFixed
                ? (z = this.getDelta(y, z))
                : ((z = y - B.timePrev || B.delta),
                  (B.timePrev = y),
                  B.deltaHistory.push(z),
                  (B.deltaHistory = B.deltaHistory.slice(-B.deltaSampleSize)),
                  (z = Math.min.apply(null, B.deltaHistory)),
                  (z = z < B.deltaMin ? B.deltaMin : z),
                  (z = z > B.deltaMax ? B.deltaMax : z),
                  (E = z / B.delta),
                  (B.delta = z));
              0 !== B.timeScalePrev && (E *= D.timeScale / B.timeScalePrev);
              0 === D.timeScale && (E = 0);
              B.timeScalePrev = D.timeScale;
              B.correction = E;
              B.frameCounter += 1;
              1e3 <= y - B.counterTimestamp &&
                ((B.fps = ((y - B.counterTimestamp) / 1e3) * B.frameCounter),
                (B.counterTimestamp = y),
                (B.frameCounter = 0));
              c.update(A, z, E);
            }
          },
          step: function (y, z) {
            c.update(this.engine, y, z);
          },
          update60Hz: function () {
            return 1e3 / 60;
          },
          update30Hz: function () {
            return 1e3 / 30;
          },
          has: function (y) {
            y = y.hasOwnProperty("body") ? y.body : y;
            return null !== b.get(this.localWorld, y.id, y.type);
          },
          getAllBodies: function () {
            return b.allBodies(this.localWorld);
          },
          getAllConstraints: function () {
            return b.allConstraints(this.localWorld);
          },
          getAllComposites: function () {
            return b.allComposites(this.localWorld);
          },
          postUpdate: function () {
            if (this.drawDebug) {
              var y = this.debugConfig,
                z = this.engine,
                A = this.debugGraphic,
                B = b.allBodies(this.localWorld);
              this.debugGraphic.clear();
              y.showBroadphase &&
                z.broadphase.controller &&
                this.renderGrid(z.broadphase, A, y.broadphaseColor, 0.5);
              y.showBounds && this.renderBodyBounds(B, A, y.boundsColor, 0.5);
              (y.showBody || y.showStaticBody) && this.renderBodies(B);
              y.showJoint && this.renderJoints();
              (y.showAxes || y.showAngleIndicator) &&
                this.renderBodyAxes(B, A, y.showAxes, y.angleColor, 0.5);
              y.showVelocity &&
                this.renderBodyVelocity(B, A, y.velocityColor, 1, 2);
              y.showSeparations &&
                this.renderSeparations(z.pairs.list, A, y.separationColor);
              y.showCollisions &&
                this.renderCollisions(z.pairs.list, A, y.collisionColor);
            }
          },
          renderGrid: function (y, z, A, B) {
            z.lineStyle(1, A, B);
            A = e.keys(y.buckets);
            for (B = 0; B < A.length; B++) {
              var D = A[B];
              2 > y.buckets[D].length ||
                ((D = D.split(/C|R/)),
                z.strokeRect(
                  parseInt(D[1], 10) * y.bucketWidth,
                  parseInt(D[2], 10) * y.bucketHeight,
                  y.bucketWidth,
                  y.bucketHeight
                ));
            }
            return this;
          },
          renderSeparations: function (y, z, A) {
            z.lineStyle(1, A, 1);
            for (A = 0; A < y.length; A++) {
              var B = y[A];
              if (B.isActive) {
                var D = B.collision;
                B = D.bodyA;
                var E = D.bodyB,
                  C = B.position,
                  F = E.position;
                D = D.penetration;
                var G = B.isStatic || E.isStatic ? 1 : 4;
                E.isStatic && (G = 0);
                z.lineBetween(F.x, F.y, F.x - D.x * G, F.y - D.y * G);
                G = B.isStatic || E.isStatic ? 1 : 4;
                B.isStatic && (G = 0);
                z.lineBetween(C.x, C.y, C.x - D.x * G, C.y - D.y * G);
              }
            }
            return this;
          },
          renderCollisions: function (y, z, A) {
            z.lineStyle(1, A, 0.5);
            z.fillStyle(A, 1);
            for (A = 0; A < y.length; A++) {
              var B = y[A];
              if (B.isActive)
                for (var D = 0; D < B.activeContacts.length; D++) {
                  var E = B.activeContacts[D].vertex;
                  z.fillRect(E.x - 2, E.y - 2, 5, 5);
                }
            }
            for (A = 0; A < y.length; A++)
              if (
                ((B = y[A]),
                B.isActive &&
                  ((D = B.collision), (B = B.activeContacts), 0 < B.length))
              ) {
                E = B[0].vertex.x;
                var C = B[0].vertex.y;
                2 === B.length &&
                  ((E = (B[0].vertex.x + B[1].vertex.x) / 2),
                  (C = (B[0].vertex.y + B[1].vertex.y) / 2));
                D.bodyB === D.supports[0].body || D.bodyA.isStatic
                  ? z.lineBetween(E - 8 * D.normal.x, C - 8 * D.normal.y, E, C)
                  : z.lineBetween(E + 8 * D.normal.x, C + 8 * D.normal.y, E, C);
              }
            return this;
          },
          renderBodyBounds: function (y, z, A, B) {
            z.lineStyle(1, A, B);
            for (A = 0; A < y.length; A++)
              if (((B = y[A]), B.render.visible)) {
                var D = B.bounds;
                if (D)
                  z.strokeRect(
                    D.min.x,
                    D.min.y,
                    D.max.x - D.min.x,
                    D.max.y - D.min.y
                  );
                else
                  for (
                    B = B.parts, D = 1 < B.length ? 1 : 0;
                    D < B.length;
                    D++
                  ) {
                    var E = B[D];
                    z.strokeRect(
                      E.bounds.min.x,
                      E.bounds.min.y,
                      E.bounds.max.x - E.bounds.min.x,
                      E.bounds.max.y - E.bounds.min.y
                    );
                  }
              }
            return this;
          },
          renderBodyAxes: function (y, z, A, B, D) {
            z.lineStyle(1, B, D);
            for (B = 0; B < y.length; B++) {
              var E = y[B];
              D = E.parts;
              if (E.render.visible) {
                var C, F;
                if (A)
                  for (C = 1 < D.length ? 1 : 0; C < D.length; C++)
                    for (E = D[C], F = 0; F < E.axes.length; F++) {
                      var G = E.axes[F];
                      z.lineBetween(
                        E.position.x,
                        E.position.y,
                        E.position.x + 20 * G.x,
                        E.position.y + 20 * G.y
                      );
                    }
                else
                  for (C = 1 < D.length ? 1 : 0; C < D.length; C++)
                    for (E = D[C], F = 0; F < E.axes.length; F++)
                      z.lineBetween(
                        E.position.x,
                        E.position.y,
                        (E.vertices[0].x +
                          E.vertices[E.vertices.length - 1].x) /
                          2,
                        (E.vertices[0].y +
                          E.vertices[E.vertices.length - 1].y) /
                          2
                      );
              }
            }
            return this;
          },
          renderBodyVelocity: function (y, z, A, B, D) {
            z.lineStyle(D, A, B);
            for (A = 0; A < y.length; A++)
              (B = y[A]),
                B.render.visible &&
                  z.lineBetween(
                    B.position.x,
                    B.position.y,
                    B.position.x + 2 * (B.position.x - B.positionPrev.x),
                    B.position.y + 2 * (B.position.y - B.positionPrev.y)
                  );
            return this;
          },
          renderBodies: function (y) {
            var z = this.debugGraphic,
              A = this.debugConfig,
              B = A.showBody,
              D = A.showStaticBody,
              E = A.showSleeping,
              C = A.showInternalEdges,
              F = A.showConvexHulls,
              G = A.renderFill,
              H = A.renderLine,
              K = A.staticBodySleepOpacity,
              I = A.sleepFillColor,
              M = A.sleepLineColor;
            A = A.hullColor;
            for (var N = 0; N < y.length; N++) {
              var P = y[N];
              if (P.render.visible && (D || !P.isStatic) && (B || P.isStatic)) {
                var J = P.render.lineColor,
                  L = P.render.lineOpacity,
                  O = P.render.lineThickness,
                  Q = P.render.fillColor,
                  S = P.render.fillOpacity;
                E &&
                  P.isSleeping &&
                  (P.isStatic ? ((L *= K), (S *= K)) : ((J = M), (Q = I)));
                G || (Q = null);
                H || (J = null);
                this.renderBody(P, z, C, J, L, O, Q, S);
                J = P.parts.length;
                F && 1 < J && this.renderConvexHull(P, z, A, O);
              }
            }
          },
          renderBody: function (y, z, A, B, D, E, C, F) {
            void 0 === B && (B = null);
            void 0 === D && (D = null);
            void 0 === E && (E = 1);
            void 0 === C && (C = null);
            void 0 === F && (F = null);
            for (
              var G = this.debugConfig,
                H = G.sensorFillColor,
                K = G.sensorLineColor,
                I = y.parts,
                M = I.length,
                N = 1 < M ? 1 : 0;
              N < M;
              N++
            ) {
              var P = I[N],
                J = P.render,
                L = J.opacity;
              if (J.visible && 0 !== L && (!P.isSensor || G.showSensors)) {
                J = P.circleRadius;
                z.beginPath();
                P.isSensor
                  ? (null !== C && z.fillStyle(H, F * L),
                    null !== B && z.lineStyle(E, K, D * L))
                  : (null !== C && z.fillStyle(C, F * L),
                    null !== B && z.lineStyle(E, B, D * L));
                if (J) z.arc(P.position.x, P.position.y, J, 0, 2 * Math.PI);
                else {
                  P = P.vertices;
                  L = P.length;
                  z.moveTo(P[0].x, P[0].y);
                  for (J = 1; J < L; J++) {
                    var O = P[J];
                    !P[J - 1].isInternal || A
                      ? z.lineTo(O.x, O.y)
                      : z.moveTo(O.x, O.y);
                    J < L &&
                      O.isInternal &&
                      !A &&
                      ((O = (J + 1) % L), z.moveTo(P[O].x, P[O].y));
                  }
                  z.closePath();
                }
                null !== C && z.fillPath();
                null !== B && z.strokePath();
              }
            }
            G.showPositions &&
              !y.isStatic &&
              ((A = y.position.x),
              (y = y.position.y),
              (B = Math.ceil(G.positionSize / 2)),
              z.fillStyle(G.positionColor, 1),
              z.fillRect(A - B, y - B, G.positionSize, G.positionSize));
            return this;
          },
          renderConvexHull: function (y, z, A, B) {
            void 0 === B && (B = 1);
            if (1 < y.parts.length) {
              y = y.vertices;
              z.lineStyle(B, A);
              z.beginPath();
              z.moveTo(y[0].x, y[0].y);
              for (A = 1; A < y.length; A++) z.lineTo(y[A].x, y[A].y);
              z.lineTo(y[0].x, y[0].y);
              z.strokePath();
            }
            return this;
          },
          renderJoints: function () {
            for (
              var y = this.debugGraphic,
                z = b.allConstraints(this.localWorld),
                A = 0;
              A < z.length;
              A++
            ) {
              var B = z[A].render;
              this.renderConstraint(
                z[A],
                y,
                B.lineColor,
                B.lineOpacity,
                B.lineThickness,
                B.pinSize,
                B.anchorColor,
                B.anchorSize
              );
            }
          },
          renderConstraint: function (y, z, A, B, D, E, C, F) {
            var G = y.render;
            if (!G.visible || !y.pointA || !y.pointB) return this;
            z.lineStyle(D, A, B);
            A = y.bodyA;
            B = y.bodyB;
            A = A ? x.add(A.position, y.pointA) : y.pointA;
            if ("pin" === G.type) z.strokeCircle(A.x, A.y, E);
            else {
              var H = B ? x.add(B.position, y.pointB) : y.pointB;
              z.beginPath();
              z.moveTo(A.x, A.y);
              if ("spring" === G.type) {
                E = x.sub(H, A);
                B = x.perp(x.normalise(E));
                y = Math.ceil(e.clamp(y.length / 5, 12, 20));
                for (var K = 1; K < y; K += 1)
                  (D = 0 === K % 2 ? 1 : -1),
                    z.lineTo(
                      A.x + (K / y) * E.x + B.x * D * 4,
                      A.y + (K / y) * E.y + B.y * D * 4
                    );
              }
              z.lineTo(H.x, H.y);
            }
            z.strokePath();
            G.anchors &&
              0 < F &&
              (z.fillStyle(C),
              z.fillCircle(A.x, A.y, F),
              z.fillCircle(H.x, H.y, F));
            return this;
          },
          resetCollisionIDs: function () {
            k._nextCollidingGroupId = 1;
            k._nextNonCollidingGroupId = -1;
            k._nextCategory = 1;
            return this;
          },
          shutdown: function () {
            r.off(this.engine);
            this.removeAllListeners();
            v.clear(this.localWorld, !1);
            c.clear(this.engine);
            this.drawDebug && this.debugGraphic.destroy();
          },
          destroy: function () {
            this.shutdown();
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          BasePlugin: a(540),
          DefaultPlugins: a(197),
          PluginCache: a(24),
          PluginManager: a(414),
          ScenePlugin: a(1404),
        };
      },
      function (h, t, a) {
        var d = a(540);
        t = a(0);
        var k = a(20);
        a = new t({
          Extends: d,
          initialize: function (e, b, c) {
            d.call(this, b);
            this.scene = e;
            this.systems = e.sys;
            this.pluginKey = c;
            e.sys.events.once(k.BOOT, this.boot, this);
          },
          boot: function () {},
          destroy: function () {
            this.systems = this.scene = this.game = this.pluginManager = null;
          },
        });
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          Canvas: a(1406),
          Events: a(91),
          Snapshot: a(1407),
          WebGL: a(1408),
        };
      },
      function (h, t, a) {
        h.exports = {
          CanvasRenderer: a(368),
          GetBlendModes: a(370),
          SetTransform: a(30),
        };
      },
      function (h, t, a) {
        h.exports = {
          Canvas: a(369),
          WebGL: a(383),
        };
      },
      function (h, t, a) {
        t = a(107);
        var d = a(17);
        a = {
          PipelineManager: a(372),
          Pipelines: a(1409),
          RenderTarget: a(141),
          Utils: a(12),
          WebGLPipeline: a(58),
          WebGLRenderer: a(371),
          WebGLShader: a(375),
        };
        a = d(!1, a, t);
        h.exports = a;
      },
      function (h, t, a) {
        t = a(92);
        var d = a(17);
        a = {
          BitmapMaskPipeline: a(373),
          Events: a(374),
          GraphicsPipeline: a(376),
          LightPipeline: a(377),
          MultiPipeline: a(108),
          PointLightPipeline: a(378),
          PostFXPipeline: a(1410),
          RopePipeline: a(379),
          SinglePipeline: a(380),
          UtilityPipeline: a(381),
        };
        a = d(!1, a, t);
        h.exports = a;
      },
      function (h, t, a) {
        t = a(0);
        var d = a(198),
          k = a(2),
          e = a(1411),
          b = a(382),
          c = a(58);
        a = new t({
          Extends: c,
          initialize: function (f) {
            f.renderTarget = k(f, "renderTarget", 1);
            f.fragShader = k(f, "fragShader", e);
            f.vertShader = k(f, "vertShader", b);
            f.attributes = k(f, "attributes", [
              {
                name: "inPosition",
                size: 2,
              },
              {
                name: "inTexCoord",
                size: 2,
              },
            ]);
            f.batchSize = 1;
            f.vertices = [
              -1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1,
              1, -1, 1, 0,
            ];
            c.call(this, f);
            this.isPostFX = !0;
            this.gameObject;
            this.colorMatrix = new d();
            this.fullFrame1;
            this.fullFrame2;
            this.halfFrame1;
            this.halfFrame2;
            this.renderer.isBooted &&
              ((this.manager = this.renderer.pipelines), this.boot());
          },
          boot: function () {
            c.prototype.boot.call(this);
            var f = this.manager.UTILITY_PIPELINE;
            this.fullFrame1 = f.fullFrame1;
            this.fullFrame2 = f.fullFrame2;
            this.halfFrame1 = f.halfFrame1;
            this.halfFrame2 = f.halfFrame2;
            this.set1i("uMainSampler", 0);
          },
          onDraw: function (f) {
            this.bindAndDraw(f);
          },
          copyFrame: function (f, g, m, n, q) {
            this.manager.copyFrame(f, g, m, n, q);
          },
          copyToGame: function (f) {
            this.manager.copyToGame(f);
          },
          drawFrame: function (f, g, m) {
            this.manager.drawFrame(f, g, m, this.colorMatrix);
          },
          blendFrames: function (f, g, m, n, q) {
            this.manager.blendFrames(f, g, m, n, q);
          },
          blendFramesAdditive: function (f, g, m, n, q) {
            this.manager.blendFramesAdditive(f, g, m, n, q);
          },
          clearFrame: function (f, g) {
            this.manager.clearFrame(f, g);
          },
          blitFrame: function (f, g, m, n, q, r) {
            this.manager.blitFrame(f, g, m, n, q, r);
          },
          copyFrameRect: function (f, g, m, n, q, r, u, v) {
            this.manager.copyFrameRect(f, g, m, n, q, r, u, v);
          },
          bindAndDraw: function (f, g, m, n, q) {
            void 0 === m && (m = !0);
            void 0 === n && (n = !0);
            var r = this.gl,
              u = this.renderer;
            this.bind(q);
            this.set1i("uMainSampler", 0);
            g
              ? (r.viewport(0, 0, g.width, g.height),
                r.bindFramebuffer(r.FRAMEBUFFER, g.framebuffer),
                r.framebufferTexture2D(
                  r.FRAMEBUFFER,
                  r.COLOR_ATTACHMENT0,
                  r.TEXTURE_2D,
                  g.texture,
                  0
                ),
                m &&
                  (n ? r.clearColor(0, 0, 0, 0) : r.clearColor(0, 0, 0, 1),
                  r.clear(r.COLOR_BUFFER_BIT)))
              : (u.popFramebuffer(!1, !1, !1),
                u.currentFramebuffer || r.viewport(0, 0, u.width, u.height));
            r.activeTexture(r.TEXTURE0);
            r.bindTexture(r.TEXTURE_2D, f.texture);
            r.bufferData(r.ARRAY_BUFFER, this.vertexData, r.STATIC_DRAW);
            r.drawArrays(r.TRIANGLES, 0, 6);
            g
              ? (r.bindTexture(r.TEXTURE_2D, null),
                r.bindFramebuffer(r.FRAMEBUFFER, null))
              : u.resetTextures();
          },
        });
        h.exports = a;
      },
      function (h, t) {
        h.exports =
          "#define SHADER_NAME PHASER_POSTFX_FS\n\nprecision mediump float;\n\nuniform sampler2D uMainSampler;\n\nvarying vec2 outTexCoord;\n\nvoid main ()\n{\n    gl_FragColor = texture2D(uMainSampler, outTexCoord);\n}\n";
      },
      function (h, t, a) {
        t = a(17);
        var d = a(201);
        a = {
          Center: a(403),
          Events: a(104),
          Orientation: a(404),
          ScaleManager: a(415),
          ScaleModes: a(405),
          Zoom: a(406),
        };
        a = t(!1, a, d.CENTER);
        a = t(!1, a, d.ORIENTATION);
        a = t(!1, a, d.SCALE_MODE);
        a = t(!1, a, d.ZOOM);
        h.exports = a;
      },
      function (h, t, a) {
        t = a(144);
        var d = a(17);
        a = {
          Events: a(20),
          GetPhysicsPlugins: a(419),
          GetScenePlugins: a(420),
          SceneManager: a(417),
          ScenePlugin: a(1414),
          Settings: a(421),
          Systems: a(204),
        };
        a = d(!1, a, t);
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(18);
        t = a(0);
        var k = a(20),
          e = a(2);
        a = a(24);
        t = new t({
          initialize: function (b) {
            this.scene = b;
            this.systems = b.sys;
            this.settings = b.sys.settings;
            this.key = b.sys.settings.key;
            this.manager = b.sys.game.scene;
            this._elapsed = this.transitionProgress = 0;
            this._target = null;
            this._duration = 0;
            this._onUpdate;
            this._onUpdateScope;
            this._willRemove = this._willSleep = !1;
            b.sys.events.once(k.BOOT, this.boot, this);
            b.sys.events.on(k.START, this.pluginStart, this);
          },
          boot: function () {
            this.systems.events.once(k.DESTROY, this.destroy, this);
          },
          pluginStart: function () {
            this._target = null;
            this.systems.events.once(k.SHUTDOWN, this.shutdown, this);
          },
          start: function (b, c) {
            void 0 === b && (b = this.key);
            this.manager.queueOp("stop", this.key);
            this.manager.queueOp("start", b, c);
            return this;
          },
          restart: function (b) {
            var c = this.key;
            this.manager.queueOp("stop", c);
            this.manager.queueOp("start", c, b);
            return this;
          },
          transition: function (b) {
            void 0 === b && (b = {});
            var c = e(b, "target", !1),
              f = this.manager.getScene(c);
            if (!c || !this.checkValidTransition(f)) return !1;
            var g = e(b, "duration", 1e3);
            this._elapsed = 0;
            this._target = f;
            this._duration = g;
            this._willSleep = e(b, "sleep", !1);
            this._willRemove = e(b, "remove", !1);
            var m = e(b, "onUpdate", null);
            m &&
              ((this._onUpdate = m),
              (this._onUpdateScope = e(b, "onUpdateScope", this.scene)));
            m = e(b, "allowInput", !1);
            this.settings.transitionAllowInput = m;
            var n = f.sys.settings;
            n.isTransition = !0;
            n.transitionFrom = this.scene;
            n.transitionDuration = g;
            n.transitionAllowInput = m;
            e(b, "moveAbove", !1)
              ? this.manager.moveAbove(this.key, c)
              : e(b, "moveBelow", !1) && this.manager.moveBelow(this.key, c);
            f.sys.isSleeping()
              ? f.sys.wake(e(b, "data"))
              : this.manager.start(c, e(b, "data"));
            this.systems.events.emit(k.TRANSITION_OUT, f, g);
            this.systems.events.on(k.UPDATE, this.step, this);
            return !0;
          },
          checkValidTransition: function (b) {
            return !b ||
              b.sys.isActive() ||
              b.sys.isTransitioning() ||
              b === this.scene ||
              this.systems.isTransitioning()
              ? !1
              : !0;
          },
          step: function (b, c) {
            this._elapsed += c;
            this.transitionProgress = d(this._elapsed / this._duration, 0, 1);
            this._onUpdate &&
              this._onUpdate.call(this._onUpdateScope, this.transitionProgress);
            this._elapsed >= this._duration && this.transitionComplete();
          },
          transitionComplete: function () {
            var b = this._target.sys,
              c = this._target.sys.settings;
            this.systems.events.off(k.UPDATE, this.step, this);
            b.events.emit(k.TRANSITION_COMPLETE, this.scene);
            c.isTransition = !1;
            c.transitionFrom = null;
            this._duration = 0;
            this._onUpdateScope = this._onUpdate = this._target = null;
            this._willRemove
              ? this.manager.remove(this.key)
              : this._willSleep
              ? this.systems.sleep()
              : this.manager.stop(this.key);
          },
          add: function (b, c, f, g) {
            return this.manager.add(b, c, f, g);
          },
          launch: function (b, c) {
            b && b !== this.key && this.manager.queueOp("start", b, c);
            return this;
          },
          run: function (b, c) {
            b && b !== this.key && this.manager.queueOp("run", b, c);
            return this;
          },
          pause: function (b, c) {
            void 0 === b && (b = this.key);
            this.manager.queueOp("pause", b, c);
            return this;
          },
          resume: function (b, c) {
            void 0 === b && (b = this.key);
            this.manager.queueOp("resume", b, c);
            return this;
          },
          sleep: function (b, c) {
            void 0 === b && (b = this.key);
            this.manager.queueOp("sleep", b, c);
            return this;
          },
          wake: function (b, c) {
            void 0 === b && (b = this.key);
            this.manager.queueOp("wake", b, c);
            return this;
          },
          switch: function (b) {
            b !== this.key && this.manager.queueOp("switch", this.key, b);
            return this;
          },
          stop: function (b, c) {
            void 0 === b && (b = this.key);
            this.manager.queueOp("stop", b, c);
            return this;
          },
          setActive: function (b, c, f) {
            void 0 === c && (c = this.key);
            (c = this.manager.getScene(c)) && c.sys.setActive(b, f);
            return this;
          },
          setVisible: function (b, c) {
            void 0 === c && (c = this.key);
            (c = this.manager.getScene(c)) && c.sys.setVisible(b);
            return this;
          },
          isSleeping: function (b) {
            void 0 === b && (b = this.key);
            return this.manager.isSleeping(b);
          },
          isActive: function (b) {
            void 0 === b && (b = this.key);
            return this.manager.isActive(b);
          },
          isPaused: function (b) {
            void 0 === b && (b = this.key);
            return this.manager.isPaused(b);
          },
          isVisible: function (b) {
            void 0 === b && (b = this.key);
            return this.manager.isVisible(b);
          },
          swapPosition: function (b, c) {
            void 0 === c && (c = this.key);
            b !== c && this.manager.swapPosition(b, c);
            return this;
          },
          moveAbove: function (b, c) {
            void 0 === c && (c = this.key);
            b !== c && this.manager.moveAbove(b, c);
            return this;
          },
          moveBelow: function (b, c) {
            void 0 === c && (c = this.key);
            b !== c && this.manager.moveBelow(b, c);
            return this;
          },
          remove: function (b) {
            void 0 === b && (b = this.key);
            this.manager.remove(b);
            return this;
          },
          moveUp: function (b) {
            void 0 === b && (b = this.key);
            this.manager.moveUp(b);
            return this;
          },
          moveDown: function (b) {
            void 0 === b && (b = this.key);
            this.manager.moveDown(b);
            return this;
          },
          bringToTop: function (b) {
            void 0 === b && (b = this.key);
            this.manager.bringToTop(b);
            return this;
          },
          sendToBack: function (b) {
            void 0 === b && (b = this.key);
            this.manager.sendToBack(b);
            return this;
          },
          get: function (b) {
            return this.manager.getScene(b);
          },
          getIndex: function (b) {
            void 0 === b && (b = this.key);
            return this.manager.getIndex(b);
          },
          shutdown: function () {
            var b = this.systems.events;
            b.off(k.SHUTDOWN, this.shutdown, this);
            b.off(k.POST_UPDATE, this.step, this);
            b.off(k.TRANSITION_OUT);
          },
          destroy: function () {
            this.shutdown();
            this.scene.sys.events.off(k.START, this.start, this);
            this.manager = this.settings = this.systems = this.scene = null;
          },
        });
        a.register("ScenePlugin", t, "scenePlugin");
        h.exports = t;
      },
      function (h, t, a) {
        h.exports = {
          Events: a(438),
          List: a(110),
          Map: a(102),
          ProcessQueue: a(211),
          RTree: a(531),
          Set: a(149),
          Size: a(416),
        };
      },
      function (h, t, a) {
        t = a(17);
        var d = a(1417);
        a = {
          CanvasTexture: a(423),
          Events: a(106),
          FilterMode: d,
          Frame: a(109),
          Parsers: a(425),
          Texture: a(206),
          TextureManager: a(422),
          TextureSource: a(424),
        };
        a = t(!1, a, d);
        h.exports = a;
      },
      function (h, t) {
        h.exports = {
          LINEAR: 0,
          NEAREST: 1,
        };
      },
      function (h, t, a) {
        t = a(17);
        var d = a(1419);
        a = {
          Components: a(251),
          Parsers: a(1452),
          Formats: a(40),
          ImageCollection: a(576),
          ParseToTilemap: a(262),
          Tile: a(85),
          Tilemap: a(580),
          TilemapCreator: a(1459),
          TilemapFactory: a(1460),
          Tileset: a(122),
          TilemapLayer: a(581),
          Orientation: a(29),
          LayerData: a(120),
          MapData: a(121),
          ObjectLayer: a(572),
        };
        a = t(!1, a, d.ORIENTATION);
        h.exports = a;
      },
      function (h, t, a) {
        t = {
          ORIENTATION: a(29),
        };
        h.exports = t;
      },
      function (h, t, a) {
        var d = a(26),
          k = a(63);
        h.exports = function (e, b, c, f, g, m, n, q) {
          void 0 === n && (n = !0);
          0 > e && (e = 0);
          0 > b && (b = 0);
          var r = d(e, b, c, f, null, q);
          e = g - e;
          b = m - b;
          for (var u = 0; u < r.length; u++) {
            var v = r[u].x + e,
              x = r[u].y + b;
            0 <= v &&
              v < q.width &&
              0 <= x &&
              x < q.height &&
              q.data[x][v] &&
              q.data[x][v].copy(r[u]);
          }
          n && k(g - 1, m - 1, c + 2, f + 2, q);
        };
      },
      function (h, t, a) {
        var d = a(26),
          k = a(542);
        h.exports = function (e, b, c, f, g, m) {
          c || (c = {});
          Array.isArray(e) || (e = [e]);
          var n = m.tilemapLayer;
          f || (f = n.scene);
          g || (g = f.cameras.main);
          var q = d(0, 0, m.width, m.height, null, m),
            r = [],
            u;
          for (u = 0; u < q.length; u++) {
            var v = q[u];
            -1 !== e.indexOf(v.index) &&
              ((v = n.tileToWorldXY(v.x, v.y, void 0, g, m)),
              (c.x = v.x),
              (c.y = v.y),
              r.push(f.make.sprite(c)));
          }
          if ("number" === typeof b)
            for (u = 0; u < e.length; u++)
              k(e[u], b, 0, 0, m.width, m.height, m);
          else if (Array.isArray(b))
            for (u = 0; u < e.length; u++)
              k(e[u], b[u], 0, 0, m.width, m.height, m);
          return r;
        };
      },
      function (h, t, a) {
        var d = a(26),
          k = a(63),
          e = a(72);
        h.exports = function (b, c, f, g, m, n, q) {
          for (
            var r = -1 !== q.collideIndexes.indexOf(b),
              u = d(c, f, g, m, null, q),
              v = 0;
            v < u.length;
            v++
          )
            (u[v].index = b), e(u[v], r);
          n && k(c - 1, f - 1, g + 2, m + 2, q);
        };
      },
      function (h, t, a) {
        var d = a(26);
        h.exports = function (k, e, b, c, f, g, m, n) {
          return d(b, c, f, g, m, n).filter(k, e);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          void 0 === d && (d = 0);
          void 0 === k && (k = !1);
          var b = 0,
            c,
            f;
          if (k)
            for (c = e.height - 1; 0 <= c; c--)
              for (k = e.width - 1; 0 <= k; k--) {
                if ((f = e.data[c][k]) && f.index === a) {
                  if (b === d) return f;
                  b += 1;
                }
              }
          else
            for (c = 0; c < e.height; c++)
              for (k = 0; k < e.width; k++)
                if ((f = e.data[c][k]) && f.index === a) {
                  if (b === d) return f;
                  b += 1;
                }
          return null;
        };
      },
      function (h, t, a) {
        var d = a(26);
        h.exports = function (k, e, b, c, f, g, m, n) {
          return d(b, c, f, g, m, n).find(k, e) || null;
        };
      },
      function (h, t, a) {
        var d = a(26);
        h.exports = function (k, e, b, c, f, g, m, n) {
          d(b, c, f, g, m, n).forEach(k, e);
        };
      },
      function (h, t, a) {
        var d = a(29),
          k = a(544),
          e = a(545),
          b = a(547),
          c = a(1),
          f = a(548);
        h.exports = function (g) {
          return g === d.ORTHOGONAL
            ? k
            : g === d.HEXAGONAL
            ? e
            : g === d.STAGGERED
            ? f
            : g === d.ISOMETRIC
            ? b
            : c;
        };
      },
      function (h, t, a) {
        var d = a(158),
          k = new (a(3))();
        h.exports = function (e, b, c, f, g) {
          g.tilemapLayer.worldToTileXY(e, b, !0, k, f);
          return d(k.x, k.y, c, g);
        };
      },
      function (h, t, a) {
        var d = a(483),
          k = a(26),
          e = a(484),
          b = a(1);
        t = a(3);
        var c = function (n, q) {
            return e.RectangleToTriangle(q, n);
          },
          f = new t(),
          g = new t(),
          m = new t();
        h.exports = function (n, q, r, u) {
          if (void 0 === n) return [];
          var v = b;
          n instanceof d.Circle
            ? (v = e.CircleToRectangle)
            : n instanceof d.Rectangle
            ? (v = e.RectangleToRectangle)
            : n instanceof d.Triangle
            ? (v = c)
            : n instanceof d.Line && (v = e.LineToRectangle);
          u.tilemapLayer.worldToTileXY(n.left, n.top, !0, g, r);
          var x = g.x,
            y = g.y;
          u.tilemapLayer.worldToTileXY(n.right, n.bottom, !0, m, r);
          q = k(
            x,
            y,
            Math.max(Math.ceil(m.x) - x, 1),
            Math.max(Math.ceil(m.y) - y, 1),
            q,
            u
          );
          y = u.tileWidth;
          var z = u.tileHeight;
          u.tilemapLayer &&
            ((y *= u.tilemapLayer.scaleX), (z *= u.tilemapLayer.scaleY));
          x = [];
          y = new d.Rectangle(0, 0, y, z);
          for (z = 0; z < q.length; z++) {
            var A = q[z];
            u.tilemapLayer.tileToWorldXY(A.x, A.y, f, r);
            y.x = f.x;
            y.y = f.y;
            v(n, y) && x.push(A);
          }
          return x;
        };
      },
      function (h, t, a) {
        var d = a(29),
          k = a(1),
          e = a(253);
        h.exports = function (b) {
          return b === d.ORTHOGONAL ? e : k;
        };
      },
      function (h, t, a) {
        var d = a(29),
          k = a(550),
          e = a(551),
          b = a(1),
          c = a(552),
          f = a(553);
        h.exports = function (g) {
          return g === d.ORTHOGONAL
            ? f
            : g === d.ISOMETRIC
            ? e
            : g === d.HEXAGONAL
            ? k
            : g === d.STAGGERED
            ? c
            : b;
        };
      },
      function (h, t, a) {
        var d = a(29),
          k = a(554),
          e = a(1),
          b = a(555),
          c = a(254);
        h.exports = function (f) {
          return f === d.ORTHOGONAL
            ? c
            : f === d.HEXAGONAL
            ? k
            : f === d.STAGGERED
            ? b
            : e;
        };
      },
      function (h, t, a) {
        var d = a(29),
          k = a(1),
          e = a(255);
        h.exports = function (b) {
          return b === d.ORTHOGONAL ? e : k;
        };
      },
      function (h, t, a) {
        var d = a(29),
          k = a(556),
          e = a(557),
          b = a(1),
          c = a(558),
          f = a(559);
        h.exports = function (g) {
          return g === d.ORTHOGONAL
            ? f
            : g === d.ISOMETRIC
            ? e
            : g === d.HEXAGONAL
            ? k
            : g === d.STAGGERED
            ? c
            : b;
        };
      },
      function (h, t, a) {
        var d = a(29),
          k = a(560),
          e = a(1),
          b = a(561),
          c = a(256);
        h.exports = function (f) {
          return f === d.ORTHOGONAL
            ? c
            : f === d.HEXAGONAL
            ? k
            : f === d.STAGGERED
            ? b
            : e;
        };
      },
      function (h, t, a) {
        var d = a(562),
          k = new (a(3))();
        h.exports = function (e, b, c, f) {
          f.tilemapLayer.worldToTileXY(e, b, !0, k, c);
          return d(k.x, k.y, f);
        };
      },
      function (h, t, a) {
        var d = a(257),
          k = new (a(3))();
        h.exports = function (e, b, c, f, g, m) {
          m.tilemapLayer.worldToTileXY(b, c, !0, k, g, m);
          return d(e, k.x, k.y, f, m);
        };
      },
      function (h, t, a) {
        var d = a(63),
          k = a(257);
        h.exports = function (e, b, c, f, g) {
          void 0 === f && (f = !0);
          if (!Array.isArray(e)) return null;
          Array.isArray(e[0]) || (e = [e]);
          for (var m = e.length, n = e[0].length, q = 0; q < m; q++)
            for (var r = 0; r < n; r++) k(e[q][r], b + r, c + q, !1, g);
          f && d(b - 1, c - 1, n + 2, m + 2, g);
        };
      },
      function (h, t, a) {
        var d = a(26),
          k = a(210);
        h.exports = function (e, b, c, f, g, m) {
          b = d(e, b, c, f, {}, m);
          if (!g)
            for (g = [], e = 0; e < b.length; e++)
              -1 === g.indexOf(b[e].index) && g.push(b[e].index);
          for (e = 0; e < b.length; e++) b[e].index = k(g);
        };
      },
      function (h, t, a) {
        var d = a(563),
          k = new (a(3))();
        h.exports = function (e, b, c, f, g, m) {
          m.tilemapLayer.worldToTileXY(e, b, !0, k, g, m);
          return d(k.x, k.y, c, f, m);
        };
      },
      function (h, t, a) {
        var d = a(26);
        t = a(397);
        var k = new t(105, 210, 231, 150),
          e = new t(243, 134, 48, 200),
          b = new t(40, 39, 37, 150);
        h.exports = function (c, f, g) {
          void 0 === f && (f = {});
          var m = void 0 !== f.tileColor ? f.tileColor : k,
            n = void 0 !== f.collidingTileColor ? f.collidingTileColor : e;
          f = void 0 !== f.faceColor ? f.faceColor : b;
          var q = d(0, 0, g.width, g.height, null, g);
          c.translateCanvas(g.tilemapLayer.x, g.tilemapLayer.y);
          c.scaleCanvas(g.tilemapLayer.scaleX, g.tilemapLayer.scaleY);
          for (g = 0; g < q.length; g++) {
            var r = q[g],
              u = r.width,
              v = r.height,
              x = r.pixelX,
              y = r.pixelY,
              z = r.collides ? n : m;
            null !== z &&
              (c.fillStyle(z.color, z.alpha / 255), c.fillRect(x, y, u, v));
            x += 1;
            y += 1;
            u -= 2;
            v -= 2;
            null !== f &&
              (c.lineStyle(1, f.color, f.alpha / 255),
              r.faceTop && c.lineBetween(x, y, x + u, y),
              r.faceRight && c.lineBetween(x + u, y, x + u, y + v),
              r.faceBottom && c.lineBetween(x, y + v, x + u, y + v),
              r.faceLeft && c.lineBetween(x, y, x, y + v));
          }
        };
      },
      function (h, t, a) {
        var d = a(72),
          k = a(63),
          e = a(160);
        h.exports = function (b, c, f, g, m) {
          void 0 === c && (c = !0);
          void 0 === f && (f = !0);
          void 0 === m && (m = !0);
          Array.isArray(b) || (b = [b]);
          for (var n = 0; n < b.length; n++) e(b[n], c, g);
          if (m)
            for (m = 0; m < g.height; m++)
              for (n = 0; n < g.width; n++) {
                var q = g.data[m][n];
                q && -1 !== b.indexOf(q.index) && d(q, c);
              }
          f && k(0, 0, g.width, g.height, g);
        };
      },
      function (h, t, a) {
        var d = a(72),
          k = a(63),
          e = a(160);
        h.exports = function (b, c, f, g, m, n) {
          void 0 === f && (f = !0);
          void 0 === g && (g = !0);
          void 0 === n && (n = !0);
          if (!(b > c)) {
            for (var q = b; q <= c; q++) e(q, f, m);
            if (n)
              for (n = 0; n < m.height; n++)
                for (q = 0; q < m.width; q++) {
                  var r = m.data[n][q];
                  r && r.index >= b && r.index <= c && d(r, f);
                }
            g && k(0, 0, m.width, m.height, m);
          }
        };
      },
      function (h, t, a) {
        var d = a(72),
          k = a(63),
          e = a(160);
        h.exports = function (b, c, f, g) {
          void 0 === c && (c = !0);
          void 0 === f && (f = !0);
          Array.isArray(b) || (b = [b]);
          for (var m = 0; m < g.height; m++)
            for (var n = 0; n < g.width; n++) {
              var q = g.data[m][n];
              q && -1 === b.indexOf(q.index) && (d(q, c), e(q.index, c, g));
            }
          f && k(0, 0, g.width, g.height, g);
        };
      },
      function (h, t, a) {
        var d = a(72),
          k = a(63),
          e = a(126);
        h.exports = function (b, c, f, g) {
          void 0 === c && (c = !0);
          void 0 === f && (f = !0);
          for (var m = 0; m < g.height; m++)
            for (var n = 0; n < g.width; n++) {
              var q = g.data[m][n];
              if (q)
                for (var r in b)
                  if (e(q.properties, r)) {
                    var u = b[r];
                    Array.isArray(u) || (u = [u]);
                    for (var v = 0; v < u.length; v++)
                      q.properties[r] === u[v] && d(q, c);
                  }
            }
          f && k(0, 0, g.width, g.height, g);
        };
      },
      function (h, t, a) {
        var d = a(72),
          k = a(63);
        h.exports = function (e, b, c) {
          void 0 === e && (e = !0);
          void 0 === b && (b = !0);
          for (var f = 0; f < c.height; f++)
            for (var g = 0; g < c.width; g++) {
              var m = c.data[f][g];
              if (m) {
                var n = m.getCollisionGroup();
                n && n.objects && 0 < n.objects.length && d(m, e);
              }
            }
          b && k(0, 0, c.width, c.height, c);
        };
      },
      function (h, t) {
        h.exports = function (a, d, k, e) {
          if ("number" === typeof a)
            e.callbacks[a] =
              null !== d
                ? {
                    callback: d,
                    callbackContext: k,
                  }
                : void 0;
          else
            for (var b = 0, c = a.length; b < c; b++)
              e.callbacks[a[b]] =
                null !== d
                  ? {
                      callback: d,
                      callbackContext: k,
                    }
                  : void 0;
        };
      },
      function (h, t, a) {
        var d = a(26);
        h.exports = function (k, e, b, c, f, g, m) {
          k = d(k, e, b, c, null, m);
          for (e = 0; e < k.length; e++) k[e].setCollisionCallback(f, g);
        };
      },
      function (h, t, a) {
        var d = a(26),
          k = a(131);
        h.exports = function (e, b, c, f, g) {
          e = d(e, b, c, f, null, g);
          b = e.map(function (m) {
            return m.index;
          });
          k(b);
          for (c = 0; c < e.length; c++) e[c].index = b[c];
        };
      },
      function (h, t, a) {
        var d = a(26);
        h.exports = function (k, e, b, c, f, g, m) {
          b = d(b, c, f, g, null, m);
          for (c = 0; c < b.length; c++)
            b[c] &&
              (b[c].index === k
                ? (b[c].index = e)
                : b[c].index === e && (b[c].index = k));
        };
      },
      function (h, t, a) {
        var d = a(26);
        h.exports = function (k, e, b, c, f, g) {
          if (f) {
            e = d(k, e, b, c, null, g);
            for (k = b = 0; k < f.length; k++) b += f[k].weight;
            if (!(0 >= b))
              for (k = 0; k < e.length; k++) {
                c = Math.random() * b;
                g = 0;
                for (var m = -1, n = 0; n < f.length; n++)
                  if (((g += f[n].weight), c <= g)) {
                    c = f[n].index;
                    m = Array.isArray(c)
                      ? c[Math.floor(Math.random() * c.length)]
                      : c;
                    break;
                  }
                e[k].index = m;
              }
          }
        };
      },
      function (h, t, a) {
        h.exports = {
          FromOrientationString: a(258),
          Parse: a(564),
          Parse2DArray: a(259),
          ParseCSV: a(565),
          Impact: a(1454),
          Tiled: a(1455),
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          for (var k = 0; k < a.length; k++) {
            var e = a[k],
              b = k;
            e.name && "" !== e.name && (b = e.name);
            if (Array.isArray(e.wangtiles) && 0 < e.wangtiles.length) {
              var c = {},
                f = {},
                g;
              if (Array.isArray(e.edgecolors))
                for (g = 0; g < e.edgecolors.length; g++) {
                  var m = 1 + g;
                  var n = e.edgecolors[g];
                  "" !== n.name && (c[m] = n.name);
                }
              if (Array.isArray(e.cornercolors))
                for (g = 0; g < e.cornercolors.length; g++)
                  (m = 1 + g),
                    (n = e.cornercolors[g]),
                    "" !== n.name && (f[m] = n.name);
              if (Array.isArray(e.colors))
                for (g = 0; g < e.colors.length; g++)
                  (n = e.colors[g]),
                    (m = 1 + g),
                    "" !== n.name && (c[m] = f[m] = n.name);
              c = [c, f, c, f, c, f, c, f];
              for (f = 0; f < e.wangtiles.length; f++) {
                g = e.wangtiles[f];
                m = d[g.tileid] || (d[g.tileid] = {});
                m = m.wangid || (m.wangid = {});
                for (
                  var q = [], r = 0;
                  r < Math.min(c.length, g.wangid.length);
                  r++
                )
                  if (((n = g.wangid[r]), 0 === n)) q.push(void 0);
                  else {
                    var u = c[r][n];
                    void 0 !== u ? q.push(u) : q.push(n);
                  }
                m[b] = q;
              }
            }
          }
        };
      },
      function (h, t, a) {
        h.exports = {
          ParseTileLayers: a(578),
          ParseTilesets: a(579),
          ParseWeltmeister: a(577),
        };
      },
      function (h, t, a) {
        h.exports = {
          AssignTileProperties: a(567),
          Base64Decode: a(574),
          BuildTilesetIndex: a(568),
          CreateGroupLayer: a(161),
          ParseGID: a(261),
          ParseImageLayers: a(569),
          ParseJSONTiled: a(566),
          ParseObject: a(260),
          ParseObjectLayers: a(570),
          ParseTileLayers: a(573),
          ParseTilesets: a(575),
        };
      },
      function (h, t, a) {
        a(1);
        a(1);
        t = a(1457);
        a = a(1458);
        h.exports = {
          renderWebGL: t,
          renderCanvas: a,
        };
      },
      function (h, t, a) {
        var d = a(12);
        h.exports = function (k, e, b) {
          var c = e.cull(b),
            f = c.length,
            g = b.alpha * e.alpha;
          if (!(0 === f || 0 >= g)) {
            var m = e.gidMap,
              n = k.pipelines.set(e.pipeline, e),
              q = d.getTintAppendFloatAlpha,
              r = e.scrollFactorX,
              u = e.scrollFactorY,
              v = e.x,
              x = e.y,
              y = e.scaleX,
              z = e.scaleY;
            k.pipelines.preBatch(e);
            for (var A = 0; A < f; A++) {
              var B = c[A],
                D = m[B.index];
              if (D) {
                var E = D.getTileTextureCoordinates(B.index);
                if (null !== E) {
                  var C = D.glTexture,
                    F = n.setTexture2D(C, e),
                    G = D.tileWidth,
                    H = D.tileHeight,
                    K = E.x;
                  E = E.y;
                  var I = 0.5 * D.tileWidth;
                  D = 0.5 * D.tileHeight;
                  var M = q(B.tint, g * B.alpha);
                  n.batchTexture(
                    e,
                    C,
                    C.width,
                    C.height,
                    v + (I + B.pixelX) * y,
                    x + (D + B.pixelY) * z,
                    B.width,
                    B.height,
                    y,
                    z,
                    B.rotation,
                    B.flipX,
                    B.flipY,
                    r,
                    u,
                    I,
                    D,
                    K,
                    E,
                    G,
                    H,
                    M,
                    M,
                    M,
                    M,
                    !1,
                    0,
                    0,
                    b,
                    null,
                    !0,
                    F
                  );
                }
              }
            }
            k.pipelines.postBatch(e);
          }
        };
      },
      function (h, t, a) {
        t = a(25);
        var d = new t(),
          k = new t(),
          e = new t();
        h.exports = function (b, c, f, g) {
          var m = c.cull(f),
            n = m.length,
            q = f.alpha * c.alpha;
          if (!(0 === n || 0 >= q)) {
            k.applyITRS(c.x, c.y, c.rotation, c.scaleX, c.scaleY);
            d.copyFrom(f.matrix);
            var r = b.currentContext,
              u = c.gidMap;
            r.save();
            g
              ? (d.multiplyWithOffset(
                  g,
                  -f.scrollX * c.scrollFactorX,
                  -f.scrollY * c.scrollFactorY
                ),
                (k.e = c.x),
                (k.f = c.y),
                d.multiply(k, e),
                e.copyToContext(r))
              : ((k.e -= f.scrollX * c.scrollFactorX),
                (k.f -= f.scrollY * c.scrollFactorY),
                k.copyToContext(r));
            if (!b.antialias || 1 < c.scaleX || 1 < c.scaleY)
              r.imageSmoothingEnabled = !1;
            for (b = 0; b < n; b++) {
              c = m[b];
              var v = u[c.index];
              if (
                v &&
                ((f = v.image.getSourceImage()),
                (g = v.getTileTextureCoordinates(c.index)),
                null !== g)
              ) {
                var x = v.tileWidth;
                v = v.tileHeight;
                var y = 0.5 * x,
                  z = 0.5 * v;
                r.save();
                r.translate(c.pixelX + y, c.pixelY + z);
                0 !== c.rotation && r.rotate(c.rotation);
                (c.flipX || c.flipY) &&
                  r.scale(c.flipX ? -1 : 1, c.flipY ? -1 : 1);
                r.globalAlpha = q * c.alpha;
                r.drawImage(f, g.x, g.y, x, v, -y, -z, x, v);
                r.restore();
              }
            }
            r.restore();
          }
        };
      },
      function (h, t, a) {
        h = a(16);
        var d = a(262);
        h.register("tilemap", function (k) {
          k = void 0 !== k ? k : {};
          return d(
            this.scene,
            k.key,
            k.tileWidth,
            k.tileHeight,
            k.width,
            k.height,
            k.data,
            k.insertNull
          );
        });
      },
      function (h, t, a) {
        h = a(5);
        var d = a(262);
        h.register("tilemap", function (k, e, b, c, f, g, m) {
          null === k && (k = void 0);
          null === e && (e = void 0);
          null === b && (b = void 0);
          null === c && (c = void 0);
          null === f && (f = void 0);
          return d(this.scene, k, e, b, c, f, g, m);
        });
      },
      function (h, t, a) {
        h.exports = {
          Clock: a(1462),
          TimerEvent: a(582),
        };
      },
      function (h, t, a) {
        var d = a(0);
        t = a(24);
        var k = a(20),
          e = a(582),
          b = a(93);
        a = new d({
          initialize: function (c) {
            this.scene = c;
            this.systems = c.sys;
            this.now = 0;
            this.timeScale = 1;
            this.paused = !1;
            this._active = [];
            this._pendingInsertion = [];
            this._pendingRemoval = [];
            c.sys.events.once(k.BOOT, this.boot, this);
            c.sys.events.on(k.START, this.start, this);
          },
          boot: function () {
            this.now = this.systems.game.loop.time;
            this.systems.events.once(k.DESTROY, this.destroy, this);
          },
          start: function () {
            var c = this.systems.events;
            c.on(k.PRE_UPDATE, this.preUpdate, this);
            c.on(k.UPDATE, this.update, this);
            c.once(k.SHUTDOWN, this.shutdown, this);
          },
          addEvent: function (c) {
            c instanceof e
              ? (this.removeEvent(c),
                (c.elapsed = c.startAt),
                (c.hasDispatched = !1),
                (c.repeatCount =
                  -1 === c.repeat || c.loop ? 999999999999 : c.repeat))
              : (c = new e(c));
            this._pendingInsertion.push(c);
            return c;
          },
          delayedCall: function (c, f, g, m) {
            return this.addEvent({
              delay: c,
              callback: f,
              args: g,
              callbackScope: m,
            });
          },
          clearPendingEvents: function () {
            this._pendingInsertion = [];
            return this;
          },
          removeEvent: function (c) {
            Array.isArray(c) || (c = [c]);
            for (var f = 0; f < c.length; f++) {
              var g = c[f];
              b(this._pendingRemoval, g);
              b(this._pendingInsertion, g);
              b(this._active, g);
            }
            return this;
          },
          removeAllEvents: function () {
            this._pendingRemoval = this._pendingRemoval.concat(this._active);
            return this;
          },
          preUpdate: function () {
            var c = this._pendingRemoval.length,
              f = this._pendingInsertion.length;
            if (0 !== c || 0 !== f) {
              var g;
              for (g = 0; g < c; g++) {
                var m = this._pendingRemoval[g];
                var n = this._active.indexOf(m);
                -1 < n && this._active.splice(n, 1);
                m.destroy();
              }
              for (g = 0; g < f; g++)
                (m = this._pendingInsertion[g]), this._active.push(m);
              this._pendingRemoval.length = 0;
              this._pendingInsertion.length = 0;
            }
          },
          update: function (c, f) {
            this.now = c;
            if (!this.paused)
              for (f *= this.timeScale, c = 0; c < this._active.length; c++) {
                var g = this._active[c];
                if (
                  !g.paused &&
                  ((g.elapsed += f * g.timeScale), g.elapsed >= g.delay)
                ) {
                  var m = g.elapsed - g.delay;
                  g.elapsed = g.delay;
                  !g.hasDispatched &&
                    g.callback &&
                    ((g.hasDispatched = !0),
                    g.callback.apply(g.callbackScope, g.args));
                  0 < g.repeatCount
                    ? (g.repeatCount--, (g.elapsed = m), (g.hasDispatched = !1))
                    : this._pendingRemoval.push(g);
                }
              }
          },
          shutdown: function () {
            var c;
            for (c = 0; c < this._pendingInsertion.length; c++)
              this._pendingInsertion[c].destroy();
            for (c = 0; c < this._active.length; c++) this._active[c].destroy();
            for (c = 0; c < this._pendingRemoval.length; c++)
              this._pendingRemoval[c].destroy();
            this._active.length = 0;
            this._pendingRemoval.length = 0;
            this._pendingInsertion.length = 0;
            c = this.systems.events;
            c.off(k.PRE_UPDATE, this.preUpdate, this);
            c.off(k.UPDATE, this.update, this);
            c.off(k.SHUTDOWN, this.shutdown, this);
          },
          destroy: function () {
            this.shutdown();
            this.scene.sys.events.off(k.START, this.start, this);
            this.systems = this.scene = null;
          },
        });
        t.register("Clock", a, "time");
        h.exports = a;
      },
      function (h, t, a) {
        t = a(100);
        var d = a(17);
        a = {
          Builders: a(1464),
          Events: a(267),
          TweenManager: a(1480),
          Tween: a(266),
          TweenData: a(268),
          Timeline: a(588),
        };
        a = d(!1, a, t);
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          GetBoolean: a(99),
          GetEaseFunction: a(80),
          GetNewValue: a(162),
          GetProps: a(583),
          GetTargets: a(263),
          GetTweens: a(584),
          GetValueOp: a(264),
          NumberTweenBuilder: a(585),
          StaggerBuilder: a(586),
          TimelineBuilder: a(587),
          TweenBuilder: a(163),
        };
      },
      function (h, t) {
        h.exports =
          "callbackScope completeDelay delay duration ease easeParams flipX flipY hold loop loopDelay offset onActive onActiveParams onActiveScope onComplete onCompleteParams onCompleteScope onLoop onLoopParams onLoopScope onRepeat onRepeatParams onRepeatScope onStart onStartParams onStartScope onStop onStopParams onStopScope onUpdate onUpdateParams onUpdateScope onYoyo onYoyoParams onYoyoScope paused props repeat repeatDelay targets useFrames yoyo".split(
            " "
          );
      },
      function (h, t) {
        h.exports = "complete";
      },
      function (h, t) {
        h.exports = "loop";
      },
      function (h, t) {
        h.exports = "pause";
      },
      function (h, t) {
        h.exports = "resume";
      },
      function (h, t) {
        h.exports = "start";
      },
      function (h, t) {
        h.exports = "update";
      },
      function (h, t) {
        h.exports = "active";
      },
      function (h, t) {
        h.exports = "complete";
      },
      function (h, t) {
        h.exports = "loop";
      },
      function (h, t) {
        h.exports = "repeat";
      },
      function (h, t) {
        h.exports = "start";
      },
      function (h, t) {
        h.exports = "stop";
      },
      function (h, t) {
        h.exports = "update";
      },
      function (h, t) {
        h.exports = "yoyo";
      },
      function (h, t, a) {
        var d = a(93),
          k = a(0),
          e = a(585);
        t = a(24);
        var b = a(20),
          c = a(586),
          f = a(587),
          g = a(100),
          m = a(163);
        a = new k({
          initialize: function (n) {
            this.scene = n;
            this.systems = n.sys;
            this.timeScale = 1;
            this._add = [];
            this._pending = [];
            this._active = [];
            this._destroy = [];
            this._toProcess = 0;
            n.sys.events.once(b.BOOT, this.boot, this);
            n.sys.events.on(b.START, this.start, this);
          },
          boot: function () {
            this.systems.events.once(b.DESTROY, this.destroy, this);
          },
          start: function () {
            var n = this.systems.events;
            n.on(b.PRE_UPDATE, this.preUpdate, this);
            n.on(b.UPDATE, this.update, this);
            n.once(b.SHUTDOWN, this.shutdown, this);
            this.timeScale = 1;
          },
          createTimeline: function (n) {
            return f(this, n);
          },
          timeline: function (n) {
            n = f(this, n);
            n.paused || (this._add.push(n), this._toProcess++);
            return n;
          },
          create: function (n) {
            return m(this, n);
          },
          add: function (n) {
            n = m(this, n);
            this._add.push(n);
            this._toProcess++;
            return n;
          },
          existing: function (n) {
            this._add.push(n);
            this._toProcess++;
            return this;
          },
          addCounter: function (n) {
            n = e(this, n);
            this._add.push(n);
            this._toProcess++;
            return n;
          },
          stagger: function (n, q) {
            return c(n, q);
          },
          preUpdate: function () {
            if (0 !== this._toProcess) {
              var n = this._destroy,
                q = this._active,
                r = this._pending,
                u;
              for (u = 0; u < n.length; u++) {
                var v = n[u];
                var x = q.indexOf(v);
                -1 === x
                  ? ((x = r.indexOf(v)),
                    -1 < x && ((v.state = g.REMOVED), r.splice(x, 1)))
                  : ((v.state = g.REMOVED), q.splice(x, 1));
              }
              n.length = 0;
              n = this._add;
              for (u = 0; u < n.length; u++)
                (v = n[u]),
                  v.state === g.PENDING_ADD &&
                    (v.init()
                      ? (v.play(), this._active.push(v))
                      : this._pending.push(v));
              this._toProcess = n.length = 0;
            }
          },
          update: function (n, q) {
            var r = this._active;
            q *= this.timeScale;
            for (var u = 0; u < r.length; u++) {
              var v = r[u];
              v.update(n, q) && (this._destroy.push(v), this._toProcess++);
            }
          },
          remove: function (n) {
            d(this._add, n);
            d(this._pending, n);
            d(this._active, n);
            d(this._destroy, n);
            n.state = g.REMOVED;
            return this;
          },
          makeActive: function (n) {
            if (-1 !== this._add.indexOf(n) || -1 !== this._active.indexOf(n))
              return this;
            var q = this._pending.indexOf(n);
            -1 !== q && this._pending.splice(q, 1);
            this._add.push(n);
            n.state = g.PENDING_ADD;
            this._toProcess++;
            return this;
          },
          each: function (n, q) {
            for (var r = [null], u = 1; u < arguments.length; u++)
              r.push(arguments[u]);
            for (var v in this.list) (r[0] = this.list[v]), n.apply(q, r);
          },
          getAllTweens: function () {
            for (var n = this._active, q = [], r = 0; r < n.length; r++)
              q.push(n[r]);
            return q;
          },
          getGlobalTimeScale: function () {
            return this.timeScale;
          },
          getTweensOf: function (n, q) {
            void 0 === q && (q = !1);
            var r = this._active,
              u = [],
              v,
              x;
            Array.isArray(n) || (n = [n]);
            for (v = 0; v < r.length; v++) {
              var y = r[v];
              for (x = 0; x < n.length; x++) y.hasTarget(n[x]) && u.push(y);
            }
            if (q)
              for (r = this._pending, v = 0; v < r.length; v++)
                for (y = r[v], x = 0; x < n.length; x++)
                  y.hasTarget(n[x]) && u.push(y);
            return u;
          },
          isTweening: function (n) {
            for (var q = this._active, r, u = 0; u < q.length; u++)
              if (((r = q[u]), r.hasTarget(n) && r.isPlaying())) return !0;
            return !1;
          },
          killAll: function () {
            for (var n = this.getAllTweens(), q = 0; q < n.length; q++)
              n[q].stop();
            return this;
          },
          killTweensOf: function (n) {
            n = this.getTweensOf(n);
            for (var q = 0; q < n.length; q++) n[q].stop();
            return this;
          },
          pauseAll: function () {
            for (var n = this._active, q = 0; q < n.length; q++) n[q].pause();
            return this;
          },
          resumeAll: function () {
            for (var n = this._active, q = 0; q < n.length; q++) n[q].resume();
            return this;
          },
          setGlobalTimeScale: function (n) {
            this.timeScale = n;
            return this;
          },
          shutdown: function () {
            this.killAll();
            this._add = [];
            this._pending = [];
            this._active = [];
            this._destroy = [];
            this._toProcess = 0;
            var n = this.systems.events;
            n.off(b.PRE_UPDATE, this.preUpdate, this);
            n.off(b.UPDATE, this.update, this);
            n.off(b.SHUTDOWN, this.shutdown, this);
          },
          destroy: function () {
            this.shutdown();
            this.scene.sys.events.off(b.START, this.start, this);
            this.systems = this.scene = null;
          },
        });
        t.register("TweenManager", a, "tweens");
        h.exports = a;
      },
      function (h, t, a) {
        h.exports = {
          Array: a(208),
          Base64: a(1482),
          Objects: a(1484),
          String: a(1488),
          NOOP: a(1),
        };
      },
      function (h, t, a) {
        h.exports = {
          ArrayBufferToBase64: a(1483),
          Base64ToArrayBuffer: a(433),
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          a = new Uint8Array(a);
          var k = a.length;
          d = d ? "data:" + d + ";base64," : "";
          for (var e = 0; e < k; e += 3)
            (d +=
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[
                a[e] >> 2
              ]),
              (d +=
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[
                  ((a[e] & 3) << 4) | (a[e + 1] >> 4)
                ]),
              (d +=
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[
                  ((a[e + 1] & 15) << 2) | (a[e + 2] >> 6)
                ]),
              (d +=
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[
                  a[e + 2] & 63
                ]);
          2 === k % 3
            ? (d = d.substring(0, d.length - 1) + "=")
            : 1 === k % 3 && (d = d.substring(0, d.length - 2) + "==");
          return d;
        };
      },
      function (h, t, a) {
        h.exports = {
          Clone: a(77),
          DeepCopy: a(175),
          Extend: a(17),
          GetAdvancedValue: a(13),
          GetFastValue: a(2),
          GetMinMaxValue: a(1485),
          GetValue: a(6),
          HasAll: a(1486),
          HasAny: a(455),
          HasValue: a(126),
          IsPlainObject: a(7),
          Merge: a(127),
          MergeRight: a(1487),
          Pick: a(571),
          SetValue: a(478),
        };
      },
      function (h, t, a) {
        var d = a(6),
          k = a(18);
        h.exports = function (e, b, c, f, g) {
          void 0 === g && (g = c);
          e = d(e, b, g);
          return k(e, c, f);
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          for (var k = 0; k < d.length; k++)
            if (!a.hasOwnProperty(d[k])) return !1;
          return !0;
        };
      },
      function (h, t, a) {
        var d = a(77);
        h.exports = function (k, e) {
          k = d(k);
          for (var b in e) k.hasOwnProperty(b) && (k[b] = e[b]);
          return k;
        };
      },
      function (h, t, a) {
        h.exports = {
          Format: a(1489),
          Pad: a(186),
          RemoveAt: a(1490),
          Reverse: a(1491),
          UppercaseFirst: a(205),
          UUID: a(222),
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return a.replace(/%([0-9]+)/g, function (k, e) {
            return d[Number(e) - 1];
          });
        };
      },
      function (h, t) {
        h.exports = function (a, d) {
          return 0 === d ? a.slice(1) : a.slice(0, d - 1) + a.slice(d);
        };
      },
      function (h, t) {
        h.exports = function (a) {
          return a.split("").reverse().join("");
        };
      },
      function (h, t, a) {
        h.exports = {
          SoundManagerCreator: a(426),
          Events: a(70),
          BaseSound: a(146),
          BaseSoundManager: a(145),
          WebAudioSound: a(434),
          WebAudioSoundManager: a(432),
          HTML5AudioSound: a(429),
          HTML5AudioSoundManager: a(427),
          NoAudioSound: a(431),
          NoAudioSoundManager: a(430),
        };
      },
      function (h, t, a) {
        h.exports = {
          Arcade: a(1366),
          Matter: a(1494),
        };
      },
      function (h, t, a) {
        h.exports = {
          BodyBounds: a(1392),
          Components: a(249),
          Events: a(272),
          Factory: a(1394),
          MatterGameObject: a(1395),
          Image: a(1396),
          Matter: a(594),
          MatterPhysics: a(1524),
          PolyDecomp: a(1393),
          Sprite: a(1397),
          TileBody: a(593),
          PhysicsEditorParser: a(589),
          PhysicsJSONParser: a(590),
          PointerConstraint: a(1398),
          World: a(1402),
        };
      },
      function (h, t) {
        h.exports = {
          setBounce: function (a) {
            this.body.restitution = a;
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          setCollisionCategory: function (a) {
            this.body.collisionFilter.category = a;
            return this;
          },
          setCollisionGroup: function (a) {
            this.body.collisionFilter.group = a;
            return this;
          },
          setCollidesWith: function (a) {
            var d = 0;
            if (Array.isArray(a)) for (var k = 0; k < a.length; k++) d |= a[k];
            else d = a;
            this.body.collisionFilter.mask = d;
            return this;
          },
          setOnCollide: function (a) {
            this.body.onCollideCallback = a;
            return this;
          },
          setOnCollideEnd: function (a) {
            this.body.onCollideEndCallback = a;
            return this;
          },
          setOnCollideActive: function (a) {
            this.body.onCollideActiveCallback = a;
            return this;
          },
          setOnCollideWith: function (a, d) {
            Array.isArray(a) || (a = [a]);
            for (var k = 0; k < a.length; k++) {
              var e = a[k].hasOwnProperty("body") ? a[k].body : a[k];
              this.body.setOnCollideWith(e, d);
            }
            return this;
          },
        };
      },
      function (h, t, a) {
        var d = a(41);
        h.exports = {
          applyForce: function (k) {
            this._tempVec2.set(this.body.position.x, this.body.position.y);
            d.applyForce(this.body, this._tempVec2, k);
            return this;
          },
          applyForceFrom: function (k, e) {
            d.applyForce(this.body, k, e);
            return this;
          },
          thrust: function (k) {
            var e = this.body.angle;
            this._tempVec2.set(k * Math.cos(e), k * Math.sin(e));
            d.applyForce(
              this.body,
              {
                x: this.body.position.x,
                y: this.body.position.y,
              },
              this._tempVec2
            );
            return this;
          },
          thrustLeft: function (k) {
            var e = this.body.angle - Math.PI / 2;
            this._tempVec2.set(k * Math.cos(e), k * Math.sin(e));
            d.applyForce(
              this.body,
              {
                x: this.body.position.x,
                y: this.body.position.y,
              },
              this._tempVec2
            );
            return this;
          },
          thrustRight: function (k) {
            var e = this.body.angle + Math.PI / 2;
            this._tempVec2.set(k * Math.cos(e), k * Math.sin(e));
            d.applyForce(
              this.body,
              {
                x: this.body.position.x,
                y: this.body.position.y,
              },
              this._tempVec2
            );
            return this;
          },
          thrustBack: function (k) {
            var e = this.body.angle - Math.PI;
            this._tempVec2.set(k * Math.cos(e), k * Math.sin(e));
            d.applyForce(
              this.body,
              {
                x: this.body.position.x,
                y: this.body.position.y,
              },
              this._tempVec2
            );
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          setFriction: function (a, d, k) {
            this.body.friction = a;
            void 0 !== d && (this.body.frictionAir = d);
            void 0 !== k && (this.body.frictionStatic = k);
            return this;
          },
          setFrictionAir: function (a) {
            this.body.frictionAir = a;
            return this;
          },
          setFrictionStatic: function (a) {
            this.body.frictionStatic = a;
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = {
          setIgnoreGravity: function (a) {
            this.body.ignoreGravity = a;
            return this;
          },
        };
      },
      function (h, t, a) {
        var d = a(41),
          k = a(3);
        h.exports = {
          setMass: function (e) {
            d.setMass(this.body, e);
            return this;
          },
          setDensity: function (e) {
            d.setDensity(this.body, e);
            return this;
          },
          centerOfMass: {
            get: function () {
              return new k(this.body.centerOfMass.x, this.body.centerOfMass.y);
            },
          },
        };
      },
      function (h, t) {
        h.exports = {
          setSensor: function (a) {
            this.body.isSensor = a;
            return this;
          },
          isSensor: function () {
            return this.body.isSensor;
          },
        };
      },
      function (h, t, a) {
        var d = a(86),
          k = a(41),
          e = a(124),
          b = a(2),
          c = a(589),
          f = a(590),
          g = a(64);
        h.exports = {
          setRectangle: function (m, n, q) {
            return this.setBody(
              {
                type: "rectangle",
                width: m,
                height: n,
              },
              q
            );
          },
          setCircle: function (m, n) {
            return this.setBody(
              {
                type: "circle",
                radius: m,
              },
              n
            );
          },
          setPolygon: function (m, n, q) {
            return this.setBody(
              {
                type: "polygon",
                sides: n,
                radius: m,
              },
              q
            );
          },
          setTrapezoid: function (m, n, q, r) {
            return this.setBody(
              {
                type: "trapezoid",
                width: m,
                height: n,
                slope: q,
              },
              r
            );
          },
          setExistingBody: function (m, n) {
            void 0 === n && (n = !0);
            this.body && this.world.remove(this.body, !0);
            this.body = m;
            for (var q = 0; q < m.parts.length; q++)
              m.parts[q].gameObject = this;
            var r = this;
            m.destroy = function () {
              r.world.remove(r.body, !0);
              r.body.gameObject = null;
            };
            n &&
              (this.world.has(m) && this.world.remove(m, !0),
              this.world.add(m));
            if (this._originComponent) {
              n = m.render.sprite.xOffset;
              q = m.render.sprite.yOffset;
              var u = m.centerOfMass.y;
              e(m.centerOfMass.x, 0.5) && e(u, 0.5)
                ? this.setOrigin(n + 0.5, q + 0.5)
                : this.setOrigin(
                    n + m.centerOffset.x / this.displayWidth,
                    q + m.centerOffset.y / this.displayHeight
                  );
            }
            return this;
          },
          setBody: function (m, n) {
            if (!m) return this;
            "string" === typeof m &&
              (m = {
                type: m,
              });
            var q = b(m, "type", "rectangle"),
              r = b(m, "x", this._tempVec2.x),
              u = b(m, "y", this._tempVec2.y),
              v = b(m, "width", this.width),
              x = b(m, "height", this.height);
            switch (q) {
              case "rectangle":
                var y = d.rectangle(r, u, v, x, n);
                break;
              case "circle":
                v = b(m, "radius", Math.max(v, x) / 2);
                x = b(m, "maxSides", 25);
                y = d.circle(r, u, v, n, x);
                break;
              case "trapezoid":
                y = b(m, "slope", 0.5);
                y = d.trapezoid(r, u, v, x, y, n);
                break;
              case "polygon":
                y = b(m, "sides", 5);
                v = b(m, "radius", Math.max(v, x) / 2);
                y = d.polygon(r, u, y, v, n);
                break;
              case "fromVertices":
              case "fromVerts":
                if ((v = b(m, "verts", null)))
                  "string" === typeof v && (v = g.fromPath(v)),
                    this.body && !this.body.hasOwnProperty("temp")
                      ? (k.setVertices(this.body, v), (y = this.body))
                      : ((x = b(m, "flagInternal", !1)),
                        (y = b(m, "removeCollinear", 0.01)),
                        (q = b(m, "minimumArea", 10)),
                        (y = d.fromVertices(r, u, v, n, x, y, q)));
                break;
              case "fromPhysicsEditor":
                y = c.parseBody(r, u, m, n);
                break;
              case "fromPhysicsTracer":
                y = f.parseBody(r, u, m, n);
            }
            y && this.setExistingBody(y, m.addToWorld);
            return this;
          },
        };
      },
      function (h, t, a) {
        var d = a(272),
          k = a(165),
          e = a(166);
        h.exports = {
          setToSleep: function () {
            k.set(this.body, !0);
            return this;
          },
          setAwake: function () {
            k.set(this.body, !1);
            return this;
          },
          setSleepThreshold: function (b) {
            void 0 === b && (b = 60);
            this.body.sleepThreshold = b;
            return this;
          },
          setSleepEvents: function (b, c) {
            this.setSleepStartEvent(b);
            this.setSleepEndEvent(c);
            return this;
          },
          setSleepStartEvent: function (b) {
            if (b) {
              var c = this.world;
              e.on(this.body, "sleepStart", function (f) {
                c.emit(d.SLEEP_START, f, this);
              });
            } else e.off(this.body, "sleepStart");
            return this;
          },
          setSleepEndEvent: function (b) {
            if (b) {
              var c = this.world;
              e.on(this.body, "sleepEnd", function (f) {
                c.emit(d.SLEEP_END, f, this);
              });
            } else e.off(this.body, "sleepEnd");
            return this;
          },
        };
      },
      function (h, t) {
        h.exports = "afteradd";
      },
      function (h, t) {
        h.exports = "afterremove";
      },
      function (h, t) {
        h.exports = "afterupdate";
      },
      function (h, t) {
        h.exports = "beforeadd";
      },
      function (h, t) {
        h.exports = "beforeremove";
      },
      function (h, t) {
        h.exports = "beforeupdate";
      },
      function (h, t) {
        h.exports = "collisionactive";
      },
      function (h, t) {
        h.exports = "collisionend";
      },
      function (h, t) {
        h.exports = "collisionstart";
      },
      function (h, t) {
        h.exports = "dragend";
      },
      function (h, t) {
        h.exports = "drag";
      },
      function (h, t) {
        h.exports = "dragstart";
      },
      function (h, t) {
        h.exports = "pause";
      },
      function (h, t) {
        h.exports = "resume";
      },
      function (h, t) {
        h.exports = "sleepend";
      },
      function (h, t) {
        h.exports = "sleepstart";
      },
      function (h, t, a) {
        var d = a(41);
        h.exports = {
          setStatic: function (k) {
            d.setStatic(this.body, k);
            return this;
          },
          isStatic: function () {
            return this.body.isStatic;
          },
        };
      },
      function (h, t, a) {
        var d = a(41),
          k = a(14),
          e = a(269),
          b = a(270);
        h.exports = {
          x: {
            get: function () {
              return this.body.position.x;
            },
            set: function (c) {
              this._tempVec2.set(c, this.y);
              d.setPosition(this.body, this._tempVec2);
            },
          },
          y: {
            get: function () {
              return this.body.position.y;
            },
            set: function (c) {
              this._tempVec2.set(this.x, c);
              d.setPosition(this.body, this._tempVec2);
            },
          },
          scaleX: {
            get: function () {
              return this._scaleX;
            },
            set: function (c) {
              var f = 1 / this._scaleX,
                g = 1 / this._scaleY;
              this._scaleX = c;
              this.renderFlags =
                0 === this._scaleX
                  ? this.renderFlags & -5
                  : this.renderFlags | 4;
              d.scale(this.body, f, g);
              d.scale(this.body, c, this._scaleY);
            },
          },
          scaleY: {
            get: function () {
              return this._scaleY;
            },
            set: function (c) {
              var f = 1 / this._scaleX,
                g = 1 / this._scaleY;
              this._scaleY = c;
              this.renderFlags =
                0 === this._scaleY
                  ? this.renderFlags & -5
                  : this.renderFlags | 4;
              d.scale(this.body, f, g);
              d.scale(this.body, this._scaleX, c);
            },
          },
          angle: {
            get: function () {
              return b(this.body.angle * k.RAD_TO_DEG);
            },
            set: function (c) {
              this.rotation = b(c) * k.DEG_TO_RAD;
            },
          },
          rotation: {
            get: function () {
              return this.body.angle;
            },
            set: function (c) {
              this._rotation = e(c);
              d.setAngle(this.body, this._rotation);
            },
          },
          setPosition: function (c, f) {
            void 0 === c && (c = 0);
            void 0 === f && (f = c);
            this._tempVec2.set(c, f);
            d.setPosition(this.body, this._tempVec2);
            return this;
          },
          setRotation: function (c) {
            void 0 === c && (c = 0);
            this._rotation = e(c);
            d.setAngle(this.body, c);
            return this;
          },
          setFixedRotation: function () {
            d.setInertia(this.body, Infinity);
            return this;
          },
          setAngle: function (c) {
            void 0 === c && (c = 0);
            this.angle = c;
            d.setAngle(this.body, this.rotation);
            return this;
          },
          setScale: function (c, f, g) {
            void 0 === c && (c = 1);
            void 0 === f && (f = c);
            var m = 1 / this._scaleX,
              n = 1 / this._scaleY;
            this._scaleX = c;
            this._scaleY = f;
            d.scale(this.body, m, n, g);
            d.scale(this.body, c, f, g);
            return this;
          },
        };
      },
      function (h, t, a) {
        var d = a(41);
        h.exports = {
          setAngularVelocity: function (k) {
            d.setAngularVelocity(this.body, k);
            return this;
          },
          setVelocityX: function (k) {
            this._tempVec2.set(k, this.body.velocity.y);
            d.setVelocity(this.body, this._tempVec2);
            return this;
          },
          setVelocityY: function (k) {
            this._tempVec2.set(this.body.velocity.x, k);
            d.setVelocity(this.body, this._tempVec2);
            return this;
          },
          setVelocity: function (k, e) {
            this._tempVec2.set(k, e);
            d.setVelocity(this.body, this._tempVec2);
            return this;
          },
        };
      },
      function (h, t, a) {
        var d = {};
        h.exports = d;
        var k = a(118),
          e = a(32);
        (function () {
          d.create = function (b) {
            return e.extend(
              {
                extended: !1,
                narrowDetections: 0,
                narrowphaseTests: 0,
                narrowReuse: 0,
                narrowReuseCount: 0,
                midphaseTests: 0,
                broadphaseTests: 0,
                narrowEff: 1e-4,
                midEff: 1e-4,
                broadEff: 1e-4,
                collisions: 0,
                buckets: 0,
                bodies: 0,
                pairs: 0,
              },
              !1,
              b
            );
          };
          d.reset = function (b) {
            b.extended &&
              ((b.narrowDetections = 0),
              (b.narrowphaseTests = 0),
              (b.narrowReuse = 0),
              (b.narrowReuseCount = 0),
              (b.midphaseTests = 0),
              (b.broadphaseTests = 0),
              (b.narrowEff = 0),
              (b.midEff = 0),
              (b.broadEff = 0),
              (b.collisions = 0),
              (b.buckets = 0),
              (b.pairs = 0),
              (b.bodies = 0));
          };
          d.update = function (b, c) {
            if (b.extended) {
              var f = k.allBodies(c.world);
              b.collisions = b.narrowDetections;
              b.pairs = c.pairs.list.length;
              b.bodies = f.length;
              b.midEff = (b.narrowDetections / (b.midphaseTests || 1)).toFixed(
                2
              );
              b.narrowEff = (
                b.narrowDetections / (b.narrowphaseTests || 1)
              ).toFixed(2);
              b.broadEff = (1 - b.broadphaseTests / (f.length || 1)).toFixed(2);
              b.narrowReuse = (
                b.narrowReuseCount / (b.narrowphaseTests || 1)
              ).toFixed(2);
            }
          };
        })();
      },
      function (h, t, a) {
        var d = a(123),
          k = a(271),
          e = a(86),
          b = a(41),
          c = a(1392),
          f = a(84),
          g = a(0),
          m = a(118),
          n = a(591),
          q = a(128),
          r = a(273),
          u = a(50),
          v = a(1394),
          x = a(2),
          y = a(6),
          z = a(597),
          A = a(1525),
          B = a(1526),
          D = a(1399),
          E = a(1527),
          C = a(127),
          F = a(250),
          G = a(598),
          H = a(595);
        t = a(24);
        var K = a(1400),
          I = a(599),
          M = a(274),
          N = a(20),
          P = a(592),
          J = a(83),
          L = a(64),
          O = a(1402);
        a = new g({
          initialize: function (Q) {
            this.scene = Q;
            this.systems = Q.sys;
            this.config = this.getConfig();
            this.world;
            this.add;
            this.bodyBounds;
            this.body = b;
            this.composite = m;
            this.detector = r;
            this.grid = z;
            this.pair = F;
            this.pairs = G;
            this.query = K;
            this.resolver = I;
            this.sat = M;
            this.constraint = q;
            this.bodies = e;
            this.composites = n;
            this.axes = k;
            this.bounds = f;
            this.svg = P;
            this.vector = J;
            this.verts = this.vertices = L;
            this._tempVec2 = J.create();
            y(this.config, "plugins.collisionevents", !0) &&
              this.enableCollisionEventsPlugin();
            y(this.config, "plugins.attractors", !1) &&
              this.enableAttractorPlugin();
            y(this.config, "plugins.wrap", !1) && this.enableWrapPlugin();
            I._restingThresh = y(this.config, "restingThresh", 4);
            I._restingThreshTangent = y(this.config, "restingThreshTangent", 6);
            I._positionDampen = y(this.config, "positionDampen", 0.9);
            I._positionWarming = y(this.config, "positionWarming", 0.8);
            I._frictionNormalMultiplier = y(
              this.config,
              "frictionNormalMultiplier",
              5
            );
            Q.sys.events.once(N.BOOT, this.boot, this);
            Q.sys.events.on(N.START, this.start, this);
          },
          boot: function () {
            this.world = new O(this.scene, this.config);
            this.add = new v(this.world);
            this.bodyBounds = new c();
            this.systems.events.once(N.DESTROY, this.destroy, this);
          },
          start: function () {
            this.world ||
              ((this.world = new O(this.scene, this.config)),
              (this.add = new v(this.world)));
            var Q = this.systems.events;
            Q.on(N.UPDATE, this.world.update, this.world);
            Q.on(N.POST_UPDATE, this.world.postUpdate, this.world);
            Q.once(N.SHUTDOWN, this.shutdown, this);
          },
          getConfig: function () {
            var Q = this.systems.game.config.physics;
            return C(
              x(this.systems.settings.physics, "matter", {}),
              x(Q, "matter", {})
            );
          },
          enableAttractorPlugin: function () {
            H.register(A);
            H.use(D, A);
            return this;
          },
          enableWrapPlugin: function () {
            H.register(E);
            H.use(D, E);
            return this;
          },
          enableCollisionEventsPlugin: function () {
            H.register(B);
            H.use(D, B);
            return this;
          },
          pause: function () {
            return this.world.pause();
          },
          resume: function () {
            return this.world.resume();
          },
          set60Hz: function () {
            this.world.getDelta = this.world.update60Hz;
            this.world.autoUpdate = !0;
            return this;
          },
          set30Hz: function () {
            this.world.getDelta = this.world.update30Hz;
            this.world.autoUpdate = !0;
            return this;
          },
          step: function (Q, S) {
            this.world.step(Q, S);
          },
          containsPoint: function (Q, S, R) {
            Q = this.getMatterBodies(Q);
            S = J.create(S, R);
            return 0 < K.point(Q, S).length ? !0 : !1;
          },
          intersectPoint: function (Q, S, R) {
            R = this.getMatterBodies(R);
            Q = J.create(Q, S);
            var T = [];
            K.point(R, Q).forEach(function (U) {
              -1 === T.indexOf(U) && T.push(U);
            });
            return T;
          },
          intersectRect: function (Q, S, R, T, U, V) {
            void 0 === U && (U = !1);
            V = this.getMatterBodies(V);
            var X = [];
            K.region(
              V,
              {
                min: {
                  x: Q,
                  y: S,
                },
                max: {
                  x: Q + R,
                  y: S + T,
                },
              },
              U
            ).forEach(function (W) {
              -1 === X.indexOf(W) && X.push(W);
            });
            return X;
          },
          intersectRay: function (Q, S, R, T, U, V) {
            void 0 === U && (U = 1);
            V = this.getMatterBodies(V);
            var X = [];
            Q = K.ray(V, J.create(Q, S), J.create(R, T), U);
            for (S = 0; S < Q.length; S++) X.push(Q[S].body);
            return X;
          },
          intersectBody: function (Q, S) {
            S = this.getMatterBodies(S);
            var R = [];
            S = K.collides(Q, S);
            for (var T = 0; T < S.length; T++) {
              var U = S[T];
              U.bodyA === Q ? R.push(U.bodyB) : R.push(U.bodyA);
            }
            return R;
          },
          overlap: function (Q, S, R, T, U) {
            void 0 === R && (R = null);
            void 0 === T && (T = null);
            void 0 === U && (U = R);
            Array.isArray(Q) || (Q = [Q]);
            Q = this.getMatterBodies(Q);
            S = this.getMatterBodies(S);
            for (var V = !1, X = 0; X < Q.length; X++)
              for (
                var W = Q[X], Z = K.collides(W, S), aa = 0;
                aa < Z.length;
                aa++
              ) {
                var Y = Z[aa],
                  ba = Y.bodyA.id === W.id ? Y.bodyB : Y.bodyA;
                if (!T || T.call(U, W, ba, Y))
                  if (((V = !0), R)) R.call(U, W, ba, Y);
                  else if (!T) return !0;
              }
            return V;
          },
          setCollisionCategory: function (Q, S) {
            Q = this.getMatterBodies(Q);
            Q.forEach(function (R) {
              R.collisionFilter.category = S;
            });
            return this;
          },
          setCollisionGroup: function (Q, S) {
            Q = this.getMatterBodies(Q);
            Q.forEach(function (R) {
              R.collisionFilter.group = S;
            });
            return this;
          },
          setCollidesWith: function (Q, S) {
            Q = this.getMatterBodies(Q);
            var R = 0;
            if (Array.isArray(S)) for (var T = 0; T < S.length; T++) R |= S[T];
            else R = S;
            Q.forEach(function (U) {
              U.collisionFilter.mask = R;
            });
            return this;
          },
          getMatterBodies: function (Q) {
            if (!Q) return this.world.getAllBodies();
            Array.isArray(Q) || (Q = [Q]);
            for (var S = [], R = 0; R < Q.length; R++) {
              var T = Q[R].hasOwnProperty("body") ? Q[R].body : Q[R];
              S.push(T);
            }
            return S;
          },
          setVelocity: function (Q, S, R) {
            Q = this.getMatterBodies(Q);
            var T = this._tempVec2;
            T.x = S;
            T.y = R;
            Q.forEach(function (U) {
              b.setVelocity(U, T);
            });
            return this;
          },
          setVelocityX: function (Q, S) {
            Q = this.getMatterBodies(Q);
            var R = this._tempVec2;
            R.x = S;
            Q.forEach(function (T) {
              R.y = T.velocity.y;
              b.setVelocity(T, R);
            });
            return this;
          },
          setVelocityY: function (Q, S) {
            Q = this.getMatterBodies(Q);
            var R = this._tempVec2;
            R.y = S;
            Q.forEach(function (T) {
              R.x = T.velocity.x;
              b.setVelocity(T, R);
            });
            return this;
          },
          setAngularVelocity: function (Q, S) {
            Q = this.getMatterBodies(Q);
            Q.forEach(function (R) {
              b.setAngularVelocity(R, S);
            });
            return this;
          },
          applyForce: function (Q, S) {
            Q = this.getMatterBodies(Q);
            var R = this._tempVec2;
            Q.forEach(function (T) {
              R.x = T.position.x;
              R.y = T.position.y;
              b.applyForce(T, R, S);
            });
            return this;
          },
          applyForceFromPosition: function (Q, S, R, T) {
            Q = this.getMatterBodies(Q);
            var U = this._tempVec2;
            Q.forEach(function (V) {
              void 0 === T && (T = V.angle);
              U.x = R * Math.cos(T);
              U.y = R * Math.sin(T);
              b.applyForce(V, S, U);
            });
            return this;
          },
          applyForceFromAngle: function (Q, S, R) {
            Q = this.getMatterBodies(Q);
            var T = this._tempVec2;
            Q.forEach(function (U) {
              void 0 === R && (R = U.angle);
              T.x = S * Math.cos(R);
              T.y = S * Math.sin(R);
              b.applyForce(
                U,
                {
                  x: U.position.x,
                  y: U.position.y,
                },
                T
              );
            });
            return this;
          },
          getConstraintLength: function (Q) {
            var S = Q.pointA.x,
              R = Q.pointA.y,
              T = Q.pointB.x,
              U = Q.pointB.y;
            Q.bodyA && ((S += Q.bodyA.position.x), (R += Q.bodyA.position.y));
            Q.bodyB && ((T += Q.bodyB.position.x), (U += Q.bodyB.position.y));
            return u(S, R, T, U);
          },
          alignBody: function (Q, S, R, T) {
            Q = Q.hasOwnProperty("body") ? Q.body : Q;
            switch (T) {
              case d.TOP_LEFT:
              case d.LEFT_TOP:
                var U = this.bodyBounds.getTopLeft(Q, S, R);
                break;
              case d.TOP_CENTER:
                U = this.bodyBounds.getTopCenter(Q, S, R);
                break;
              case d.TOP_RIGHT:
              case d.RIGHT_TOP:
                U = this.bodyBounds.getTopRight(Q, S, R);
                break;
              case d.LEFT_CENTER:
                U = this.bodyBounds.getLeftCenter(Q, S, R);
                break;
              case d.CENTER:
                U = this.bodyBounds.getCenter(Q, S, R);
                break;
              case d.RIGHT_CENTER:
                U = this.bodyBounds.getRightCenter(Q, S, R);
                break;
              case d.LEFT_BOTTOM:
              case d.BOTTOM_LEFT:
                U = this.bodyBounds.getBottomLeft(Q, S, R);
                break;
              case d.BOTTOM_CENTER:
                U = this.bodyBounds.getBottomCenter(Q, S, R);
                break;
              case d.BOTTOM_RIGHT:
              case d.RIGHT_BOTTOM:
                U = this.bodyBounds.getBottomRight(Q, S, R);
            }
            U && b.setPosition(Q, U);
            return this;
          },
          shutdown: function () {
            var Q = this.systems.events;
            this.world &&
              (Q.off(N.UPDATE, this.world.update, this.world),
              Q.off(N.POST_UPDATE, this.world.postUpdate, this.world));
            Q.off(N.SHUTDOWN, this.shutdown, this);
            this.add && this.add.destroy();
            this.world && this.world.destroy();
            this.world = this.add = null;
          },
          destroy: function () {
            this.shutdown();
            this.scene.sys.events.off(N.START, this.start, this);
            this.systems = this.scene = null;
          },
        });
        t.register("MatterPhysics", a, "matterPhysics");
        h.exports = a;
      },
      function (h, t, a) {
        var d = a(594),
          k = {
            name: "matter-attractors",
            version: "0.1.7",
            for: "matter-js@^0.14.2",
            silent: !0,
            install: function (e) {
              e.after("Body.create", function () {
                k.Body.init(this);
              });
              e.before("Engine.update", function (b) {
                k.Engine.update(b);
              });
            },
            Body: {
              init: function (e) {
                e.plugin.attractors = e.plugin.attractors || [];
              },
            },
            Engine: {
              update: function (e) {
                e = d.Composite.allBodies(e.world);
                for (var b = 0; b < e.length; b++) {
                  var c = e[b],
                    f = c.plugin.attractors;
                  if (f && 0 < f.length)
                    for (var g = 0; g < e.length; g++) {
                      var m = e[g];
                      if (b !== g)
                        for (var n = 0; n < f.length; n++) {
                          var q = f[n],
                            r = q;
                          d.Common.isFunction(q) && (r = q(c, m));
                          r && d.Body.applyForce(m, m.position, r);
                        }
                    }
                }
              },
            },
            Attractors: {
              gravityConstant: 0.001,
              gravity: function (e, b) {
                var c = d.Vector.sub(b.position, e.position),
                  f = d.Vector.magnitudeSquared(c) || 1e-4;
                c = d.Vector.normalise(c);
                f = d.Vector.mult(
                  c,
                  ((e.mass * b.mass) / f) * -k.Attractors.gravityConstant
                );
                d.Body.applyForce(e, e.position, d.Vector.neg(f));
                d.Body.applyForce(b, b.position, f);
              },
            },
          };
        h.exports = k;
      },
      function (h, t) {
        h.exports = {
          name: "matter-collision-events",
          version: "0.1.6",
          for: "matter-js@^0.14.2",
          silent: !0,
          install: function (a) {
            a.after("Engine.create", function () {
              a.Events.on(this, "collisionStart", function (d) {
                d.pairs.map(function (k) {
                  var e = k.bodyA,
                    b = k.bodyB;
                  e.gameObject && e.gameObject.emit("collide", e, b, k);
                  b.gameObject && b.gameObject.emit("collide", b, e, k);
                  a.Events.trigger(e, "onCollide", {
                    pair: k,
                  });
                  a.Events.trigger(b, "onCollide", {
                    pair: k,
                  });
                  if (e.onCollideCallback) e.onCollideCallback(k);
                  if (b.onCollideCallback) b.onCollideCallback(k);
                  if (e.onCollideWith[b.id]) e.onCollideWith[b.id](b, k);
                  if (b.onCollideWith[e.id]) b.onCollideWith[e.id](e, k);
                });
              });
              a.Events.on(this, "collisionActive", function (d) {
                d.pairs.map(function (k) {
                  var e = k.bodyA,
                    b = k.bodyB;
                  e.gameObject && e.gameObject.emit("collideActive", e, b, k);
                  b.gameObject && b.gameObject.emit("collideActive", b, e, k);
                  a.Events.trigger(e, "onCollideActive", {
                    pair: k,
                  });
                  a.Events.trigger(b, "onCollideActive", {
                    pair: k,
                  });
                  if (e.onCollideActiveCallback) e.onCollideActiveCallback(k);
                  if (b.onCollideActiveCallback) b.onCollideActiveCallback(k);
                });
              });
              a.Events.on(this, "collisionEnd", function (d) {
                d.pairs.map(function (k) {
                  var e = k.bodyA,
                    b = k.bodyB;
                  e.gameObject && e.gameObject.emit("collideEnd", e, b, k);
                  b.gameObject && b.gameObject.emit("collideEnd", b, e, k);
                  a.Events.trigger(e, "onCollideEnd", {
                    pair: k,
                  });
                  a.Events.trigger(b, "onCollideEnd", {
                    pair: k,
                  });
                  if (e.onCollideEndCallback) e.onCollideEndCallback(k);
                  if (b.onCollideEndCallback) b.onCollideEndCallback(k);
                });
              });
            });
          },
        };
      },
      function (h, t, a) {
        var d = a(594),
          k = {
            name: "matter-wrap",
            version: "0.1.4",
            for: "matter-js@^0.14.2",
            silent: !0,
            install: function (e) {
              e.after("Engine.update", function () {
                k.Engine.update(this);
              });
            },
            Engine: {
              update: function (e) {
                var b = e.world;
                e = d.Composite.allBodies(b);
                b = d.Composite.allComposites(b);
                for (var c = 0; c < e.length; c += 1) {
                  var f = e[c];
                  f.plugin.wrap && k.Body.wrap(f, f.plugin.wrap);
                }
                for (c = 0; c < b.length; c += 1)
                  (e = b[c]),
                    e.plugin.wrap && k.Composite.wrap(e, e.plugin.wrap);
              },
            },
            Bounds: {
              wrap: function (e, b) {
                var c = null,
                  f = null;
                "undefined" !== typeof b.min.x &&
                  "undefined" !== typeof b.max.x &&
                  (e.min.x > b.max.x
                    ? (c = b.min.x - e.max.x)
                    : e.max.x < b.min.x && (c = b.max.x - e.min.x));
                "undefined" !== typeof b.min.y &&
                  "undefined" !== typeof b.max.y &&
                  (e.min.y > b.max.y
                    ? (f = b.min.y - e.max.y)
                    : e.max.y < b.min.y && (f = b.max.y - e.min.y));
                if (null !== c || null !== f)
                  return {
                    x: c || 0,
                    y: f || 0,
                  };
              },
            },
            Body: {
              wrap: function (e, b) {
                (b = k.Bounds.wrap(e.bounds, b)) && d.Body.translate(e, b);
                return b;
              },
            },
            Composite: {
              bounds: function (e) {
                e = d.Composite.allBodies(e);
                for (var b = [], c = 0; c < e.length; c += 1) {
                  var f = e[c];
                  b.push(f.bounds.min, f.bounds.max);
                }
                return d.Bounds.create(b);
              },
              wrap: function (e, b) {
                (b = k.Bounds.wrap(k.Composite.bounds(e), b)) &&
                  d.Composite.translate(e, b);
                return b;
              },
            },
          };
        h.exports = k;
      },
      function (h, t, a) {
        t = a(600);
        var d = a(33),
          k = a(17),
          e = {
            Actions: a(275),
            Animations: a(723),
            BlendModes: a(35),
            Cache: a(735),
            Cameras: a(738),
            Core: a(806),
            Class: a(0),
            Create: a(888),
            Curves: a(894),
            Data: a(896),
            Display: a(898),
            DOM: a(917),
            Events: a(918),
            Game: a(920),
            GameObjects: a(1011),
            Geom: a(483),
            Input: a(1308),
            Loader: a(1338),
            Math: a(193),
            Physics: a(1493),
            Plugins: a(1403),
            Renderer: a(1405),
            Scale: a(1412),
            ScaleModes: a(168),
            Scene: a(418),
            Scenes: a(1413),
            Structs: a(1415),
            Textures: a(1416),
            Tilemaps: a(1418),
            Time: a(1461),
            Tweens: a(1463),
            Utils: a(1481),
          };
        e.Sound = a(1492);
        e = k(!1, e, d);
        h.exports = e;
        t.Phaser = e;
      },
    ]);
  });
})(phaser);
var Phaser$1 = getDefaultExportFromCjs(phaser.exports);
class RoutinesData {
  constructor() {
    this.routines = [];
    this.routinesByNames = {};
  }
}
const RoutinesDataInstance = new RoutinesData();
class RoutinesManager {
  static RegisterRoutine(l, w) {
    w = void 0 === w ? null : w;
    RoutinesDataInstance.routines.push(l);
    l.GetName();
    RoutinesDataInstance.routinesByNames[w] = l;
    console.assert(l.OnRegister, l);
    l.OnRegister();
  }
  static InitRoutines() {
    for (const l in RoutinesDataInstance.routines) {
      const w = RoutinesDataInstance.routines[l];
      console.assert(w.Init, w);
      w.Init();
    }
  }
  static UpdateRoutines(l, w) {
    for (const h in RoutinesDataInstance.routines)
      RoutinesDataInstance.routines[h].Update(w);
  }
}
let rng;
var crypto =
  "undefined" !== typeof global && (global.crypto || global.msCrypto);
if (crypto && crypto.getRandomValues) {
  var rnds8 = new Uint8Array(16);
  rng = function () {
    crypto.getRandomValues(rnds8);
    return rnds8;
  };
}
if (!rng) {
  var rnds = Array(16);
  rng = function () {
    for (var l = 0, w; 16 > l; l++)
      0 === (l & 3) && (w = 4294967296 * Math.random()),
        (rnds[l] = (w >>> ((l & 3) << 3)) & 255);
    return rnds;
  };
}
for (var byteToHex = [], i = 0; 256 > i; ++i)
  byteToHex[i] = (i + 256).toString(16).substr(1);

function bytesToUuid(l, w) {
  w = w || 0;
  var h = byteToHex;
  return (
    h[l[w++]] +
    h[l[w++]] +
    h[l[w++]] +
    h[l[w++]] +
    "-" +
    h[l[w++]] +
    h[l[w++]] +
    "-" +
    h[l[w++]] +
    h[l[w++]] +
    "-" +
    h[l[w++]] +
    h[l[w++]] +
    "-" +
    h[l[w++]] +
    h[l[w++]] +
    h[l[w++]] +
    h[l[w++]] +
    h[l[w++]] +
    h[l[w++]]
  );
}

function v4(l, w, h) {
  h = (w && h) || 0;
  "string" == typeof l && ((w = "binary" == l ? Array(16) : null), (l = null));
  l = l || {};
  l = l.random || (l.rng || rng)();
  l[6] = (l[6] & 15) | 64;
  l[8] = (l[8] & 63) | 128;
  if (w) for (var t = 0; 16 > t; ++t) w[h + t] = l[t];
  return w || bytesToUuid(l);
}

function GetGUID() {
  return v4();
}

function clone(l) {
  return Array.isArray(l)
    ? l.slice()
    : l instanceof Object
    ? Object.assign({}, l)
    : l;
}

function forEach(l, w) {
  Array.isArray(l) ? forEachOfArray(l, w) : forOwnOfNonArray(l, w);
  return l;
}

function forEachOfArray(l, w) {
  for (let h = 0, t = l.length; h < t && !1 !== w(l[h], h); ++h);
}

function keysOfNonArray(l) {
  return l ? Object.getOwnPropertyNames(l) : [];
}

function forOwnOfNonArray(l, w) {
  forEachOfArray(keysOfNonArray(l), (h) => w(l[h], h));
  return l;
}

function merge(l, ...w) {
  for (const h of w)
    forEach(h, (t, a) => {
      const d = l[a];
      d instanceof Object && (t = merge(clone(d), t));
      l[a] = t;
    });
  return l;
}

function upperFirst(l) {
  return l ? l.charAt(0).toUpperCase() + l.slice(1) : "";
}

function capitalize$1(l) {
  return upperFirst(l.toLowerCase());
}

function words$1(l) {
  var w;
  return null !==
    (w = l
      .replace(/([a-z])([A-Z])/g, "$1 $2")
      .replace(/(\d)([A-Za-z])/g, "$1 $2")
      .replace(/([A-Za-z])(\d)/g, "$1 $2")
      .replace(/\b([A-Z]+)([A-Z])([a-z])/, "$1 $2$3")
      .match(/[A-Za-z0-9]+/g)) && void 0 !== w
    ? w
    : [];
}

function camelCase$1(l) {
  return words$1(l)
    .map((w, h) => (h ? capitalize$1(w) : w.toLowerCase()))
    .join("");
}
const MyMerge = merge;
class Component {
  get world() {
    return this.entity.world;
  }
  get allowMultiple() {
    return this.constructor.allowMultiple;
  }
  get keyProperty() {
    return this.constructor.keyProperty;
  }
  constructor(l) {
    null == this._cbit && console.warn("COMPONENT NOT REGISTERED");
  }
  destroy() {
    this.entity.remove(this);
  }
  _onDestroyed() {
    this.onDestroyed();
    delete this.entity;
  }
  _onEvent(l) {
    this.onEvent(l);
    if ("function" === typeof this[l.handlerName]) this[l.handlerName](l);
  }
  _onAttached(l) {
    this.entity = l;
    this.onAttached(l);
  }
  serialize() {
    const l = {};
    for (const w in this.constructor.properties) l[w] = this[w];
    return JSON.parse(JSON.stringify(l));
  }
  onAttached(l) {}
  onDestroyed() {}
  onEvent(l) {}
}
__publicField(Component, "allowMultiple", !1);
__publicField(Component, "keyProperty", null);
__publicField(Component, "properties", {});
const camelCache = {},
  camelString = (l) => {
    const w = camelCache[l];
    return w ? w : ((camelCache[l] = camelCase$1(l)), camelCache[l]);
  };
class EntityEvent {
  constructor(l, w) {
    w = void 0 === w ? {} : w;
    __publicField(this, "data", {});
    __publicField(this, "prevented", !1);
    __publicField(this, "handled", !1);
    this.name = l;
    this.data = w;
    this.handlerName = camelString(`on ${this.name}`);
  }
  is(l) {
    return this.name === l;
  }
  handle() {
    this.prevented = this.handled = !0;
  }
  prevent() {
    this.prevented = !0;
  }
}
const GetBitZero = () => BIT_ZERO,
  BIT_ZERO = 0,
  BIT_ONE = 1,
  BIT_TWO = 2,
  subtractBit = (l, w) => l & ~(BIT_ONE << w),
  addBit = (l, w) => l | (BIT_ONE << w),
  hasBit = (l, w) => (l >> w) % BIT_TWO !== BIT_ZERO,
  bitIntersection = (l, w) => l & w,
  getNextBit = (l) => l,
  attachComponent = (l, w) => {
    const h = w._ckey;
    l[h] = w;
    l.components[h] = w;
  },
  attachComponentKeyed = (l, w) => {
    const h = w._ckey;
    l.components[h] || ((l[h] = {}), (l.components[h] = {}));
    l[h][w[w.keyProperty]] = w;
    l.components[h][w[w.keyProperty]] = w;
  },
  attachComponentArray = (l, w) => {
    const h = w._ckey;
    l.components[h] || ((l[h] = []), (l.components[h] = []));
    l[h].push(w);
    l.components[h].push(w);
  },
  removeComponent = (l, w) => {
    const h = w._ckey;
    l._cbits = subtractBit(l._cbits, w._cbit);
    l._candidacy();
    delete l.components[h];
    delete l[h];
  },
  removeComponentKeyed = (l, w) => {
    const h = w._ckey,
      t = w[w.keyProperty];
    delete l[h][t];
    delete l.components[h][t];
    0 >= Object.keys(l[h]).length &&
      ((l._cbits = subtractBit(l._cbits, w._cbit)),
      l._candidacy(),
      delete l.components[h],
      delete l[h]);
  },
  removeComponentArray = (l, w) => {
    const h = w._ckey,
      t = l[h].indexOf(w);
    l[h].splice(t, 1);
    l.components[h].splice(t, 1);
    0 >= l[h].length &&
      ((l._cbits = subtractBit(l._cbits, w._cbit)),
      l._candidacy(),
      delete l.components[h],
      delete l[h]);
  },
  serializeComponent = (l) => l.serialize(),
  serializeComponentArray = (l) => l.map(serializeComponent),
  serializeComponentKeyed = (l) => {
    const w = {};
    for (const h in l) w[h] = serializeComponent(l[h]);
    return w;
  };
class Entity {
  constructor(l, w) {
    __publicField(this, "_cbits", GetBitZero());
    __publicField(this, "_qeligible", !0);
    this.world = l;
    this.id = w;
    this.components = {};
    this.isDestroyed = !1;
  }
  _candidacy() {
    this._qeligible && this.world._candidate(this);
  }
  add(l, w) {
    l = new l(w);
    l.keyProperty
      ? attachComponentKeyed(this, l)
      : l.allowMultiple
      ? attachComponentArray(this, l)
      : attachComponent(this, l);
    this._cbits = addBit(this._cbits, l._cbit);
    l._onAttached(this);
    this._candidacy();
  }
  has(l) {
    return hasBit(this._cbits, l.prototype._cbit);
  }
  remove(l) {
    l.keyProperty
      ? removeComponentKeyed(this, l)
      : l.allowMultiple
      ? removeComponentArray(this, l)
      : removeComponent(this, l);
    l._onDestroyed();
  }
  destroy() {
    for (var l in this.components) {
      const w = this.components[l];
      if (w instanceof Component)
        this._cbits = subtractBit(this._cbits, w._cbit);
      else if (w instanceof Array)
        for (const h of w) this._cbits = subtractBit(this._cbits, h._cbit);
      else
        for (const h of Object.values(w))
          this._cbits = subtractBit(this._cbits, h._cbit);
    }
    this._candidacy();
    for (const w in this.components) {
      l = this.components[w];
      if (l instanceof Component) l._onDestroyed();
      else if (l instanceof Array) for (const h of l) h._onDestroyed();
      else for (const h of Object.values(l)) h._onDestroyed();
      delete this[w];
      delete this.components[w];
    }
    this.world._destroyed(this.id);
    this.components = {};
    this.isDestroyed = !0;
  }
  serialize() {
    const l = {};
    for (const w in this.components) {
      const h = this.components[w];
      l[w] =
        h instanceof Component
          ? serializeComponent(h)
          : h instanceof Array
          ? serializeComponentArray(h)
          : serializeComponentKeyed(h);
    }
    return Object.assign(
      {},
      {
        id: this.id,
      },
      l
    );
  }
  clone() {
    return this.world.cloneEntity(this);
  }
  fireEvent(l, w) {
    l = new EntityEvent(l, w);
    for (const h in this.components)
      if (((w = this.components[h]), w instanceof Component)) {
        if ((w._onEvent(l), l.prevented)) break;
      } else if (w instanceof Array)
        for (let t = 0; t < w.length; t++) {
          if ((w[t]._onEvent(l), l.prevented)) return l;
        }
      else
        for (const t of Object.values(w))
          if ((t._onEvent(l), l.prevented)) return l;
    return l;
  }
}
class DataComponent extends Component {
  constructor(l) {
    super(null);
    this.gameStateName = null;
    const w = JSON.parse(JSON.stringify(this.constructor.properties));
    Object.assign(this, w, l);
  }
  static At(l) {
    return l.data;
  }
  static get properties() {
    return {};
  }
  static AddToEntityWithProperties(l, w, h) {
    l.has(DataComponent) || l.add(DataComponent, {});
    merge(DataComponent.At(l), w);
    return DataComponent.At(l);
  }
}
class InternalData$b {
  constructor() {
    this.bags = {};
    this.entitiesByAlias = {};
  }
}
const InternalDataInstance = new InternalData$b();
class EntityKeeper {
  static Init() {}
  static PutActorIntoHisBags(l) {
    const w = BagsComponent.At(l);
    for (const h in w.keys)
      InternalDataInstance.bags[h] || (InternalDataInstance.bags[h] = []),
        -1 >= InternalDataInstance.bags[h].indexOf(l) &&
          InternalDataInstance.bags[h].push(l);
    w.alias && (InternalDataInstance.entitiesByAlias[w.alias] = l);
  }
  static RemoveActorFromAllHisBags(l) {
    const w = BagsComponent.At(l);
    for (const h in w.keys) {
      InternalDataInstance.bags[h] || (InternalDataInstance.bags[h] = []);
      let t = InternalDataInstance.bags[h].indexOf(l);
      0 <= t && InternalDataInstance.bags[h].splice(t, 1);
    }
    w.alias &&
      InternalDataInstance.entitiesByAlias[w.alias] &&
      InternalDataInstance.entitiesByAlias[w.alias] == l &&
      delete InternalDataInstance.entitiesByAlias[w.alias];
  }
  static QueueDisposeActorsInBag(l) {
    l = InternalDataInstance.bags[l];
    for (let w = l.length - 1; 0 <= w; w--)
      EndOfLoopRoutine.QueueActorToDisposeBuffer(l[w]);
  }
  static GetBagActorsReferenceList(l) {
    InternalDataInstance.bags[l] || (InternalDataInstance.bags[l] = []);
    return InternalDataInstance.bags[l];
  }
  static GetEntityByAlias(l) {
    return InternalDataInstance.entitiesByAlias[l];
  }
  static GetEntityByID(l) {
    return GeoticManager.GetWorld().getEntity(l);
  }
  static DumpLogBags() {}
  static DumpLogLengthALL() {}
}
class BagsComponent extends Component {
  constructor(l) {
    super(null);
    this.keys = {};
    this.alias = null;
    const w = JSON.parse(JSON.stringify(this.constructor.properties));
    Object.assign(this, w, l);
  }
  static At(l) {
    return l.bags;
  }
  static AddBagList(l, w) {
    console.assert(IsArray(w), "not an array! ", w);
    const h = {};
    for (const t in w) h[w[t]] = !0;
    l.has(BagsComponent) || l.add(BagsComponent, {});
    w = BagsComponent.At(l);
    merge(w.keys, h);
    EntityKeeper.PutActorIntoHisBags(l);
    return this;
  }
  setAlias(l) {
    this.alias && console.warn("FIX ME! ", this.alias, l);
    this.alias = l;
    EntityKeeper.PutActorIntoHisBags(this.entity);
  }
  onAttached(l) {
    EntityKeeper.PutActorIntoHisBags(l);
  }
  onDestroyed() {
    EntityKeeper.RemoveActorFromAllHisBags(this.entity);
  }
  static get properties() {
    return {};
  }
}
class ComponentRegistry {
  constructor() {
    __publicField(this, "_cbit", 0);
    __publicField(this, "_map", {});
  }
  register(l, w) {
    w = void 0 === w ? null : w;
    let h;
    h = camelString(l.name);
    null != w && (h = w);
    l.prototype._ckey = h;
    l.prototype._cbit = getNextBit(++this._cbit);
    this._map[h] = l;
  }
  get(l) {
    return this._map[l];
  }
}
class PrefabComponent {
  constructor(l, w, h) {
    w = void 0 === w ? {} : w;
    this.clazz = l;
    this.properties = w;
    this.overwrite = void 0 === h ? !0 : h;
  }
  applyToEntity(l, w) {
    w = void 0 === w ? {} : w;
    if (!this.clazz.allowMultiple && l.has(this.clazz)) {
      if (!this.overwrite) return;
      l.remove(l[this.clazz.prototype._ckey]);
    }
    w = merge(this.properties, w);
    l.add(this.clazz, w);
  }
}
class Prefab {
  constructor(l) {
    __publicField(this, "name", "");
    __publicField(this, "inherit", []);
    __publicField(this, "components", []);
    this.name = l;
  }
  addComponent(l) {
    this.components.push(l);
  }
  applyToEntity(l, w) {
    w = void 0 === w ? {} : w;
    this.inherit.forEach((t) => {
      t.applyToEntity(l, w);
    });
    const h = {};
    this.components.forEach((t) => {
      var a = t.clazz;
      const d = a.prototype._ckey;
      let k = {};
      a.allowMultiple
        ? a.keyProperty
          ? ((a = t.properties[a.keyProperty]),
            w[d] && w[d][a] && (k = w[d][a]))
          : (h[d] || (h[d] = 0), w[d] && w[d][h[d]] && (k = w[d][h[d]]), h[d]++)
        : (k = w[d]);
      t.applyToEntity(l, k);
    });
    return l;
  }
}
class PrefabRegistry {
  constructor(l) {
    __publicField(this, "_prefabs", {});
    __publicField(this, "_engine", null);
    this._engine = l;
  }
  deserialize(l) {
    var w = this.get(l.name);
    if (w) return w;
    const h = new Prefab(l.name);
    w = Array.isArray(l.inherit)
      ? l.inherit
      : "string" === typeof l.inherit
      ? [l.inherit]
      : [];
    h.inherit = w.map((t) => {
      const a = this.get(t);
      return a
        ? a
        : (console.warn(
            `Prefab "${l.name}" cannot inherit from Prefab "${t}" because is not registered yet! Prefabs must be registered in the right order.`
          ),
          t);
    });
    (l.components || []).forEach((t) => {
      let a = "unknown";
      if ("string" === typeof t) {
        a = t;
        var d = camelString(t);
        if ((d = this._engine._components.get(d))) {
          h.addComponent(new PrefabComponent(d));
          return;
        }
      }
      if (
        "object" === typeof t &&
        ((a = t.type || "unknown"),
        (d = camelString(t.type)),
        (d = this._engine._components.get(d)))
      ) {
        h.addComponent(new PrefabComponent(d, t.properties, t.overwrite));
        return;
      }
      console.warn(
        `Unrecognized component reference "${a}" in prefab "${l.name}". Ensure the component is registered before the prefab.`,
        t
      );
    });
    return h;
  }
  register(l) {
    l = this.deserialize(l);
    this._prefabs[l.name] = l;
  }
  get(l) {
    return this._prefabs[l];
  }
  create(l, w, h) {
    h = void 0 === h ? {} : h;
    const t = this.get(w);
    if (t)
      return (
        (l = l.createEntity()),
        (l._qeligible = !1),
        t.applyToEntity(l, h),
        (l._qeligible = !0),
        l._candidacy(),
        l
      );
    console.warn(
      `Could not instantiate prefab "${w}" since it is not registered`
    );
  }
}
class Query {
  constructor(l, w) {
    __publicField(this, "_cache", []);
    __publicField(this, "_onAddListeners", []);
    __publicField(this, "_onRemoveListeners", []);
    __publicField(this, "_immutableResult", !0);
    this._world = l;
    l = w.all || [];
    const h = w.none || [];
    this._any = (w.any || []).reduce(
      (t, a) => addBit(t, a.prototype._cbit),
      BIT_ZERO
    );
    this._all = l.reduce((t, a) => addBit(t, a.prototype._cbit), BIT_ZERO);
    this._none = h.reduce((t, a) => addBit(t, a.prototype._cbit), BIT_ZERO);
    this._immutableResult =
      void 0 == w.immutableResult ? !0 : w.immutableResult;
    this.refresh();
  }
  onEntityAdded(l) {
    this._onAddListeners.push(l);
  }
  onEntityRemoved(l) {
    this._onRemoveListeners.push(l);
  }
  has(l) {
    return 0 <= this.idx(l);
  }
  idx(l) {
    return this._cache.indexOf(l);
  }
  matches(l) {
    var w = l._cbits;
    l = this._any === BIT_ZERO || 0 < bitIntersection(w, this._any);
    const h = bitIntersection(w, this._all) === this._all;
    w = bitIntersection(w, this._none) === BIT_ZERO;
    return l && h && w;
  }
  candidate(l) {
    const w = this.idx(l),
      h = 0 <= w;
    if (!l.isDestroyed && this.matches(l))
      return (
        h || (this._cache.push(l), this._onAddListeners.forEach((t) => t(l))),
        !0
      );
    h &&
      (this._cache.splice(w, 1), this._onRemoveListeners.forEach((t) => t(l)));
    return !1;
  }
  refresh() {
    this._cache = [];
    this._world._entities.forEach((l) => {
      this.candidate(l);
    });
  }
  get() {
    return this._immutableResult ? [...this._cache] : this._cache;
  }
}
class World {
  constructor(l) {
    __publicField(this, "_id", 0);
    __publicField(this, "_queries", []);
    __publicField(this, "_entities", new Map());
    this.engine = l;
  }
  createId() {
    return ++this._id + Math.random().toString(36).substr(2, 9);
  }
  getEntity(l) {
    return this._entities.get(l);
  }
  getEntities() {
    return this._entities.values();
  }
  createEntity(l) {
    l = void 0 === l ? this.createId() : l;
    const w = new Entity(this, l);
    this._entities.set(l, w);
    return w;
  }
  destroyEntity(l) {
    (l = this.getEntity(l)) && l.destroy();
  }
  destroyEntities() {
    this._entities.forEach((l) => {
      l.destroy();
    });
  }
  destroy() {
    this.destroyEntities();
    this._id = 0;
    this._queries = [];
    this._entities = new Map();
  }
  createQuery(l) {
    l = new Query(this, l);
    this._queries.push(l);
    return l;
  }
  createPrefab(l, w) {
    w = void 0 === w ? {} : w;
    return this.engine._prefabs.create(this, l, w);
  }
  serialize(l) {
    const w = [];
    (l || this._entities).forEach((h) => {
      w.push(h.serialize());
    });
    return {
      entities: w,
    };
  }
  cloneEntity(l) {
    l = l.serialize();
    l.id = this.createId();
    return this._deserializeEntity(l);
  }
  deserialize(l) {
    for (const w of l.entities) this._createOrGetEntityById(w.id);
    for (const w of l.entities) this._deserializeEntity(w);
  }
  _createOrGetEntityById(l) {
    return this.getEntity(l) || this.createEntity(l);
  }
  _deserializeEntity(l) {
    var w = Object.assign({}, l);
    l = l.id;
    w = (delete w.id, w);
    const h = this._createOrGetEntityById(l);
    h._qeligible = !1;
    Object.entries(w).forEach((t) => {
      var [a, d] = t;
      t = camelString(a);
      const k = this.engine._components.get(t);
      k.allowMultiple
        ? Object.values(d).forEach((e) => {
            h.add(k, e);
          })
        : h.add(k, d);
    });
    h._qeligible = !0;
    h._candidacy();
    return h;
  }
  _candidate(l) {
    this._queries.forEach((w) => w.candidate(l));
  }
  _destroyed(l) {
    return this._entities.delete(l);
  }
}
class Engine {
  constructor() {
    __publicField(this, "_components", new ComponentRegistry());
    __publicField(this, "_prefabs", new PrefabRegistry(this));
  }
  registerComponent(l, w) {
    this._components.register(l, void 0 === w ? null : w);
  }
  registerPrefab(l) {
    this._prefabs.register(l);
  }
  createWorld() {
    return new World(this);
  }
  destroyWorld(l) {
    l.destroy();
  }
}
class InternalDataClass$8 {
  constructor() {
    this.world = this.engine = null;
  }
}
const InternalData$a = new InternalDataClass$8();
class GeoticManager {
  static SetEngine(l) {
    InternalData$a.engine = l;
  }
  static GetEngine() {
    return InternalData$a.engine;
  }
  static SetWorld(l) {
    InternalData$a.world = l;
  }
  static GetWorld() {
    return InternalData$a.world;
  }
  static CreateEntity(l) {
    console.assert(l, "GameState: ", l);
    l.name && (l = l.name);
    const w = InternalData$a.world.createEntity();
    DataComponent.AddToEntityWithProperties(w, {
      gameStateName: l,
    });
    BagsComponent.AddBagList(w, ["ALL"]);
    BagsComponent.AddBagList(w, [l]);
    return w;
  }
  static InstantActorDestroy(l) {
    l.isDestroyed || l.destroy();
  }
}
class DataHolder {
  constructor() {
    this.data = {};
    this.keyList = [];
  }
  register(l, w, h) {
    this.data[l] &&
      0 == (void 0 === h ? !1 : h) &&
      console.warn(l, " ALREADY EXIST IN DATA HOLDER");
    this.data[l] = w;
    -1 >= this.keyList.indexOf(l) && this.keyList.push(l);
    return w;
  }
  hasKey(l) {
    return this.data[l] ? !0 : !1;
  }
  getData(l) {
    console.assert(this.data[l], l, " not in: ", this.data);
    return this.data[l];
  }
  getKeyList() {
    return this.keyList;
  }
}
class GameCommand {
  constructor(l) {
    this._func = l;
  }
  run(l) {
    this._func(void 0 === l ? null : l);
  }
}
class ExtendedDataHolder$1 extends DataHolder {
  register(l, w, h) {
    super.register(l, w, void 0 === h ? !1 : h);
    return w;
  }
  getData(l) {
    return super.getData(l);
  }
  runCommand(l, w) {
    w = void 0 === w ? {} : w;
    this.getData(l).run(w);
  }
  runCommandObj(l) {
    this.runCommand(l.key, l);
  }
}
const GameCommandsRegistry = new ExtendedDataHolder$1();
class CommandsComponent extends Component {
  constructor(l) {
    super(null);
    this.byTriggers = {};
    const w = JSON.parse(JSON.stringify(this.constructor.properties));
    Object.assign(this, w, l);
  }
  runCommandAtTriggerKey(l, w) {
    w = void 0 === w ? null : w;
    if (null != this.byTriggers[l])
      if (((l = this.byTriggers[l]), GameCommandsRegistry.hasKey(l.key))) {
        var h = {
          entity: this.entity,
        };
        l && merge(h, l);
        l.pOptPayload && merge(h, w);
        GameCommandsRegistry.runCommand(l.key, h);
      } else console.warn("GameCommandsRegistry no defined command: ", l.key);
  }
  static At(l) {
    l.commands || CommandsComponent.AddWithData(l, {});
    return l.commands;
  }
  static AddWithData(l, w) {
    l.has(CommandsComponent) || l.add(CommandsComponent, {});
    l = CommandsComponent.At(l);
    merge(l, {
      byTriggers: w,
    });
    return l;
  }
  static get properties() {
    return {};
  }
}
const QUIT = "quit",
  EXIT = "exit",
  ENTER_FRESH = "enterFresh";
class GameState {
  constructor(l) {
    this.name = l;
    this.state = "null";
    this.curQuitDelay = 0;
    this.onEnter = () => {};
    this.onExit = () => {};
    this.onQuit = () => {};
    GlobalGameStateManager.register(this.name, this);
  }
  enterFresh() {
    this.state != QUIT &&
      "null" != this.state &&
      (this.state != EXIT && this.exit(), this.quit());
    this.state = ENTER_FRESH;
    this.onEnter();
    GameBranding.GetSingleton().gameEvent("stateChange", {
      stateName: this.name,
      stateChangeType: "enter",
    });
  }
  exit(l) {
    this.delayedFunctionDict = {};
    if (this.state != EXIT && this.state != QUIT && "null" != this.state) {
      this.curQuitDelay = void 0 === l ? 500 : l;
      this.state = EXIT;
      this.onExit();
      GameBranding.GetSingleton().gameEvent("stateChange", {
        stateName: this.name,
        stateChangeType: "exit",
      });
      l = EntityKeeper.GetBagActorsReferenceList(this.name);
      for (const w in l)
        CommandsComponent.At(l[w]).runCommandAtTriggerKey("exit");
    }
  }
  quit() {
    this.delayedFunctionDict = {};
    this.state != QUIT &&
      "null" != this.state &&
      ((this.state = QUIT),
      EntityKeeper.QueueDisposeActorsInBag(this.name),
      this.onQuit());
  }
  continue() {
    this.state == EXIT && this.quit();
    this.state != ENTER_FRESH && this.enterFresh();
  }
  isRunning() {
    return this.state == ENTER_FRESH ? !0 : !1;
  }
  updateDelayedQuit(l) {
    this.state == EXIT &&
      ((this.curQuitDelay -= l), 0 > this.curQuitDelay && this.quit());
  }
}
class ExtendedDataHolder extends DataHolder {
  register(l, w) {
    super.register(l, w);
    return w;
  }
  getData(l) {
    return super.getData(l);
  }
}
const GlobalGameStateManager = new ExtendedDataHolder(),
  _data = {
    entityDisposeBuffer: [],
    delayedFunctionDict: {},
    delayedFunctionDeleteKeysList: [],
    active: !0,
  };

function _FlushDisposeBuffer() {
  const l = _data.entityDisposeBuffer;
  _data.entityDisposeBuffer = [];
  for (let w = l.length - 1; 0 <= w; w--)
    GeoticManager.InstantActorDestroy(l[w]);
}
class EndOfLoopRoutine {
  static OnRegister() {}
  static Init() {}
  static Register() {
    RoutinesManager.RegisterRoutine(EndOfLoopRoutine);
  }
  static GetName() {
    return "EndOfLoopRoutine";
  }
  static QueueActorToDisposeBuffer(l) {
    l &&
      (l.isDestroyed ||
        -1 < _data.entityDisposeBuffer.indexOf(l) ||
        _data.entityDisposeBuffer.push(l));
  }
  static QueueDelayedFunction(l, w, h) {
    null == l && (l = GetGUID());
    _data.delayedFunctionDict[l] = {
      tag: l,
      delay: w,
      func: h,
    };
    return l;
  }
  static Update(l) {
    var w = GlobalGameStateManager.getKeyList();
    for (const h in w)
      GlobalGameStateManager.getData(w[h]).updateDelayedQuit(l);
    for (const h in _data.delayedFunctionDict)
      (w = _data.delayedFunctionDict[h]),
        (w.delay -= l),
        0 >= w.delay && (_data.delayedFunctionDeleteKeysList.push(h), w.func());
    for (l = _data.delayedFunctionDeleteKeysList.length - 1; 0 <= l; l--)
      delete _data.delayedFunctionDict[_data.delayedFunctionDeleteKeysList[l]],
        _data.delayedFunctionDeleteKeysList.splice(l, 1);
    0 < _data.entityDisposeBuffer.length && _FlushDisposeBuffer();
  }
}
var OS = {
    android: !1,
    chromeOS: !1,
    cordova: !1,
    crosswalk: !1,
    desktop: !1,
    ejecta: !1,
    electron: !1,
    iOS: !1,
    iOSVersion: 0,
    iPad: !1,
    iPhone: !1,
    kindle: !1,
    linux: !1,
    macOS: !1,
    node: !1,
    nodeWebkit: !1,
    pixelRatio: 1,
    webApp: !1,
    windows: !1,
    windowsPhone: !1,
  },
  _initialized$1 = !1;

function GetOs() {
  if (_initialized$1) return OS;
  _initialized$1 = !0;
  var l = navigator.userAgent;
  /Windows/.test(l)
    ? (OS.windows = !0)
    : /Mac OS/.test(l) && !/like Mac OS/.test(l)
    ? navigator.maxTouchPoints && 2 < navigator.maxTouchPoints
      ? ((OS.iOS = !0),
        (OS.iPad = !0),
        navigator.appVersion.match(/Version\/(\d+)/),
        (OS.iOSVersion = parseInt(RegExp.$1, 10)))
      : (OS.macOS = !0)
    : /Android/.test(l)
    ? (OS.android = !0)
    : /Linux/.test(l)
    ? (OS.linux = !0)
    : /iP[ao]d|iPhone/i.test(l)
    ? ((OS.iOS = !0),
      navigator.appVersion.match(/OS (\d+)/),
      (OS.iOSVersion = parseInt(RegExp.$1, 10)),
      (OS.iPhone = -1 !== l.toLowerCase().indexOf("iphone")),
      (OS.iPad = -1 !== l.toLowerCase().indexOf("ipad")))
    : /Kindle/.test(l) ||
      /\bKF[A-Z][A-Z]+/.test(l) ||
      /Silk.*Mobile Safari/.test(l)
    ? (OS.kindle = !0)
    : /CrOS/.test(l) && (OS.chromeOS = !0);
  if (/Windows Phone/i.test(l) || /IEMobile/i.test(l))
    (OS.android = !1),
      (OS.iOS = !1),
      (OS.macOS = !1),
      (OS.windows = !0),
      (OS.windowsPhone = !0);
  var w = /Silk/.test(l);
  if (OS.windows || OS.macOS || (OS.linux && !w) || OS.chromeOS)
    OS.desktop = !0;
  if (OS.windowsPhone || (/Windows NT/i.test(l) && /Touch/i.test(l)))
    OS.desktop = !1;
  navigator.standalone && (OS.webApp = !0);
  void 0 !== window.cordova && (OS.cordova = !0);
  "undefined" !== typeof process &&
    process.versions &&
    process.versions.node &&
    (OS.node = !0);
  OS.node &&
    "object" === typeof process.versions &&
    ((OS.nodeWebkit = !!process.versions["node-webkit"]),
    (OS.electron = !!process.versions.electron));
  void 0 !== window.ejecta && (OS.ejecta = !0);
  /Crosswalk/.test(l) && (OS.crosswalk = !0);
  OS.pixelRatio = window.devicePixelRatio || 1;
  return OS;
}
var BrowserData = {
    chrome: !1,
    chromeVersion: 0,
    edge: !1,
    firefox: !1,
    firefoxVersion: 0,
    ie: !1,
    ieVersion: 0,
    mobileSafari: !1,
    opera: !1,
    safari: !1,
    safariVersion: 0,
    silk: !1,
    trident: !1,
    tridentVersion: 0,
  },
  _initialized = !1;

function GetBrowser() {
  if (_initialized) return BrowserData;
  _initialized = !0;
  var l = navigator.userAgent;
  /Edge\/\d+/.test(l)
    ? (BrowserData.edge = !0)
    : /Chrome\/(\d+)/.test(l) && !GetOs().windowsPhone
    ? ((BrowserData.chrome = !0),
      (BrowserData.chromeVersion = parseInt(RegExp.$1, 10)))
    : /Firefox\D+(\d+)/.test(l)
    ? ((BrowserData.firefox = !0),
      (BrowserData.firefoxVersion = parseInt(RegExp.$1, 10)))
    : /AppleWebKit/.test(l) && GetOs().iOS
    ? (BrowserData.mobileSafari = !0)
    : /MSIE (\d+\.\d+);/.test(l)
    ? ((BrowserData.ie = !0), (BrowserData.ieVersion = parseInt(RegExp.$1, 10)))
    : /Opera/.test(l)
    ? (BrowserData.opera = !0)
    : /Safari/.test(l) && !GetOs().windowsPhone
    ? (BrowserData.safari = !0)
    : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(l) &&
      ((BrowserData.ie = !0),
      (BrowserData.trident = !0),
      (BrowserData.tridentVersion = parseInt(RegExp.$1, 10)),
      (BrowserData.ieVersion = parseInt(RegExp.$3, 10)));
  /Silk/.test(l) && (BrowserData.silk = !0);
  return BrowserData;
}
class ObjectFactory$1 {
  constructor(l) {
    this.scene = l;
    this.displayList = l.sys.displayList;
    this.updateList = l.sys.updateList;
    l.sys.events.once("destroy", this.destroy, this);
  }
  destroy() {
    this.updateList = this.displayList = this.scene = null;
  }
  static register(l, w) {
    ObjectFactory$1.prototype[l] = w;
  }
}
var eventemitter3 = {
  exports: {},
};
(function (l) {
  function w() {}

  function h(b, c, f) {
    this.fn = b;
    this.context = c;
    this.once = f || !1;
  }

  function t(b, c, f, g, m) {
    if ("function" !== typeof f)
      throw new TypeError("The listener must be a function");
    f = new h(f, g || b, m);
    c = e ? e + c : c;
    b._events[c]
      ? b._events[c].fn
        ? (b._events[c] = [b._events[c], f])
        : b._events[c].push(f)
      : ((b._events[c] = f), b._eventsCount++);
    return b;
  }

  function a(b, c) {
    0 === --b._eventsCount ? (b._events = new w()) : delete b._events[c];
  }

  function d() {
    this._events = new w();
    this._eventsCount = 0;
  }
  var k = Object.prototype.hasOwnProperty,
    e = "~";
  Object.create &&
    ((w.prototype = Object.create(null)), new w().__proto__ || (e = !1));
  d.prototype.eventNames = function () {
    var b = [],
      c,
      f;
    if (0 === this._eventsCount) return b;
    for (f in (c = this._events)) k.call(c, f) && b.push(e ? f.slice(1) : f);
    return Object.getOwnPropertySymbols
      ? b.concat(Object.getOwnPropertySymbols(c))
      : b;
  };
  d.prototype.listeners = function (b) {
    b = this._events[e ? e + b : b];
    if (!b) return [];
    if (b.fn) return [b.fn];
    for (var c = 0, f = b.length, g = Array(f); c < f; c++) g[c] = b[c].fn;
    return g;
  };
  d.prototype.listenerCount = function (b) {
    return (b = this._events[e ? e + b : b]) ? (b.fn ? 1 : b.length) : 0;
  };
  d.prototype.emit = function (b, c, f, g, m, n) {
    var q = e ? e + b : b;
    if (!this._events[q]) return !1;
    q = this._events[q];
    var r = arguments.length,
      u;
    if (q.fn) {
      q.once && this.removeListener(b, q.fn, void 0, !0);
      switch (r) {
        case 1:
          return q.fn.call(q.context), !0;
        case 2:
          return q.fn.call(q.context, c), !0;
        case 3:
          return q.fn.call(q.context, c, f), !0;
        case 4:
          return q.fn.call(q.context, c, f, g), !0;
        case 5:
          return q.fn.call(q.context, c, f, g, m), !0;
        case 6:
          return q.fn.call(q.context, c, f, g, m, n), !0;
      }
      var v = 1;
      for (u = Array(r - 1); v < r; v++) u[v - 1] = arguments[v];
      q.fn.apply(q.context, u);
    } else {
      var x = q.length;
      for (v = 0; v < x; v++)
        switch ((q[v].once && this.removeListener(b, q[v].fn, void 0, !0), r)) {
          case 1:
            q[v].fn.call(q[v].context);
            break;
          case 2:
            q[v].fn.call(q[v].context, c);
            break;
          case 3:
            q[v].fn.call(q[v].context, c, f);
            break;
          case 4:
            q[v].fn.call(q[v].context, c, f, g);
            break;
          default:
            if (!u) {
              var y = 1;
              for (u = Array(r - 1); y < r; y++) u[y - 1] = arguments[y];
            }
            q[v].fn.apply(q[v].context, u);
        }
    }
    return !0;
  };
  d.prototype.on = function (b, c, f) {
    return t(this, b, c, f, !1);
  };
  d.prototype.once = function (b, c, f) {
    return t(this, b, c, f, !0);
  };
  d.prototype.removeListener = function (b, c, f, g) {
    b = e ? e + b : b;
    if (!this._events[b]) return this;
    if (!c) return a(this, b), this;
    var m = this._events[b];
    if (m.fn)
      m.fn !== c || (g && !m.once) || (f && m.context !== f) || a(this, b);
    else {
      for (var n = 0, q = [], r = m.length; n < r; n++)
        (m[n].fn !== c || (g && !m[n].once) || (f && m[n].context !== f)) &&
          q.push(m[n]);
      q.length ? (this._events[b] = 1 === q.length ? q[0] : q) : a(this, b);
    }
    return this;
  };
  d.prototype.removeAllListeners = function (b) {
    b
      ? ((b = e ? e + b : b), this._events[b] && a(this, b))
      : ((this._events = new w()), (this._eventsCount = 0));
    return this;
  };
  d.prototype.off = d.prototype.removeListener;
  d.prototype.addListener = d.prototype.on;
  d.prefixed = e;
  d.EventEmitter = d;
  l.exports = d;
})(eventemitter3);
var EE = eventemitter3.exports;
class EventEmitter extends EE {
  shutdown() {
    this.removeAllListeners();
  }
  destroy() {
    this.removeAllListeners();
  }
}
var GetValue$l = function (l, w, h) {
  if (l && "number" !== typeof l) {
    if (l.hasOwnProperty(w)) return l[w];
    if (-1 !== w.indexOf(".")) {
      w = w.split(".");
      for (var t = h, a = 0; a < w.length; a++)
        if (l.hasOwnProperty(w[a])) (t = l[w[a]]), (l = l[w[a]]);
        else {
          t = h;
          break;
        }
      return t;
    }
  }
  return h;
};
class Bank {
  constructor(l) {
    this.nextId = GetValue$l(l, "start", 1);
    this.uidKey = GetValue$l(l, "uidKey", "$uid");
    this.autoRemove = GetValue$l(l, "remove", !0);
    this.refs = {};
    this.count = 0;
  }
  add(l, w) {
    var h = this.refs,
      t = this.uidKey;
    if (t && ((w = l[t]), null != w)) return this;
    if (null == w) {
      do (w = this.nextId), this.nextId++;
      while (h.hasOwnProperty(w));
    }
    if (h.hasOwnProperty(w)) w = null;
    else if (
      ((h[w] = l), this.count++, t && (l[t] = w), this.autoRemove && l.on)
    )
      l.once(
        "destroy",
        function () {
          this.remove(w);
        },
        this
      );
    return t ? this : w;
  }
  addMultiple(l) {
    for (var w = 0, h = l.length; w < h; w++) this.add(l[w]);
    return this;
  }
  get(l) {
    return this.refs[l];
  }
  has(l) {
    return this.refs.hasOwnProperty(l);
  }
  remove(l) {
    var w = this.refs;
    w.hasOwnProperty(l) &&
      (this.uidKey && (w[l][this.uidKey] = void 0), delete w[l], this.count--);
    return this;
  }
  forEach(l, w) {
    var h = this.refs,
      t;
    for (t in h) {
      var a = h[t];
      w ? l.call(w, a, t) : l(a, t);
    }
  }
  clear() {
    this.forEach(function (l) {
      this.remove(l);
    }, this);
  }
}
var ChessBank = new Bank({
    uidKey: "$uid",
    remove: !1,
  }),
  EventEmitterMethods = {
    setEventEmitter(l, w) {
      void 0 === w && (w = Phaser.Events.EventEmitter);
      this._eventEmitter = (this._privateEE = !0 === l || void 0 === l)
        ? new w()
        : l;
      return this;
    },
    destroyEventEmitter() {
      this._eventEmitter && this._privateEE && this._eventEmitter.shutdown();
      return this;
    },
    getEventEmitter() {
      return this._eventEmitter;
    },
    on: function () {
      this._eventEmitter &&
        this._eventEmitter.on.apply(this._eventEmitter, arguments);
      return this;
    },
    once: function () {
      this._eventEmitter &&
        this._eventEmitter.once.apply(this._eventEmitter, arguments);
      return this;
    },
    off: function () {
      this._eventEmitter &&
        this._eventEmitter.off.apply(this._eventEmitter, arguments);
      return this;
    },
    emit: function (l) {
      this._eventEmitter &&
        l &&
        this._eventEmitter.emit.apply(this._eventEmitter, arguments);
      return this;
    },
    addListener: function () {
      this._eventEmitter &&
        this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
      return this;
    },
    removeListener: function () {
      this._eventEmitter &&
        this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
      return this;
    },
    removeAllListeners: function () {
      this._eventEmitter &&
        this._eventEmitter.removeAllListeners.apply(
          this._eventEmitter,
          arguments
        );
      return this;
    },
    listenerCount: function () {
      return this._eventEmitter
        ? this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments)
        : 0;
    },
    listeners: function () {
      return this._eventEmitter
        ? this._eventEmitter.listeners.apply(this._eventEmitter, arguments)
        : [];
    },
    eventNames: function () {
      return this._eventEmitter
        ? this._eventEmitter.eventNames.apply(this._eventEmitter, arguments)
        : [];
    },
  };
const SceneClass = Phaser.Scene;
var IsSceneObject = function (l) {
    return l instanceof SceneClass;
  },
  GetSceneObject = function (l) {
    if (null == l || "object" !== typeof l) return null;
    if (IsSceneObject(l)) return l;
    if (l.scene && IsSceneObject(l.scene)) return l.scene;
    if (l.parent && l.parent.scene && IsSceneObject(l.parent.scene))
      return l.parent.scene;
  };
const GetValue$k = Phaser.Utils.Objects.GetValue;
class ComponentBase {
  constructor(l, w) {
    this.parent = l;
    this.scene = GetSceneObject(l);
    this.isShutdown = !1;
    this.setEventEmitter(GetValue$k(w, "eventEmitter", !0));
    if (this.parent && this.parent === this.scene)
      this.scene.sys.events.once("shutdown", this.onSceneDestroy, this);
    else if (this.parent && this.parent.once)
      this.parent.once("destroy", this.onParentDestroy, this);
  }
  shutdown(l) {
    this.isShutdown ||
      (this.parent && this.parent === this.scene
        ? this.scene.sys.events.off("shutdown", this.onSceneDestroy, this)
        : this.parent &&
          this.parent.once &&
          this.parent.off("destroy", this.onParentDestroy, this),
      this.destroyEventEmitter(),
      (this.scene = this.parent = void 0),
      (this.isShutdown = !0));
  }
  destroy(l) {
    this.shutdown(l);
  }
  onSceneDestroy() {
    this.destroy(!0);
  }
  onParentDestroy(l, w) {
    this.destroy(w);
  }
}
Object.assign(ComponentBase.prototype, EventEmitterMethods);
var GetTileDirection = function (l, w) {
    var h = this.board;
    if (null === h) return null;
    globTileXY$h.x = l;
    globTileXY$h.y = w;
    return h.getNeighborTileDirection(this.tileXYZ, globTileXY$h);
  },
  globTileXY$h = {
    x: 0,
    y: 0,
  },
  IsPlainObject = function (l) {
    if ("object" !== typeof l || l.nodeType || l === l.window) return !1;
    try {
      if (
        l.constructor &&
        !{}.hasOwnProperty.call(l.constructor.prototype, "isPrototypeOf")
      )
        return !1;
    } catch (w) {
      return !1;
    }
    return !0;
  };
const uidKey$1 = ChessBank.uidKey;
class Chess extends ComponentBase {
  constructor(l, w) {
    super(l, {
      eventEmitter: !1,
    });
    ChessBank.add(this, w);
    this.board = null;
    this.blocker = !1;
  }
  shutdown(l) {
    this.isShutdown ||
      (this.board && this.board.removeChess(this[uidKey$1]),
      ChessBank.remove(this[uidKey$1]),
      (this.board = null),
      super.shutdown(l));
  }
  setBoard(l) {
    this.board = l;
    return this;
  }
  get tileXYZ() {
    return null == this.board
      ? null
      : this.board.chessToTileXYZ(this[uidKey$1]);
  }
  setTileZ(l) {
    if (null == this.board) return this;
    this.board.setChessTileZ(this.parent, l);
    return this;
  }
  setBlocker(l) {
    void 0 === l && (l = !0);
    this.blocker = l;
    return this;
  }
  setBlockEdge(l, w) {
    !1 === this.blocker && (this.blocker = {});
    var h = this.blocker;
    if (IsPlainObject(l)) for (l in ((w = l), w)) h[l] = w[l];
    else void 0 === w && (w = !0), (h[l] = w);
    return this;
  }
  getBlockEdge(l) {
    var w = this.blocker;
    return !1 !== w && w.hasOwnProperty(l) ? w[l] : !1;
  }
}
var methods$9 = {
  getTileDirection: GetTileDirection,
};
Object.assign(Chess.prototype, methods$9);
var IsUID = function (l) {
    l = typeof l;
    return "number" === l || "string" === l;
  },
  GetChessData = function (l) {
    if (IsUID(l)) return ChessBank.get(l);
    l.hasOwnProperty("rexChess") || (l.rexChess = new Chess(l));
    return l.rexChess;
  };
const uidKey = ChessBank.uidKey;
var GetChessUID = function (l) {
    return IsUID(l) ? l : GetChessData(l)[uidKey];
  },
  SetBoardWidth = function (l) {
    if (this.infinityMode) return this;
    if (void 0 === this.width || this.width <= l) return (this.width = l), this;
    var w, h, t;
    for (w = l; w < this.width; w++)
      for (h = 0; h < this.height; h++) {
        var a = this.boardData.getUID(w, h);
        for (t in a) this.RemoveChess(!1, w, h, t);
      }
    this.width = l;
    return this;
  },
  SetBoardHeight = function (l) {
    if (this.infinityMode) return this;
    if (void 0 === this.height || this.height <= l)
      return (this.height = l), this;
    var w, h, t;
    for (h = l; h < this.height; h++)
      for (w = 0; w < this.width; w++) {
        var a = this.boardData.getUID(w, h);
        for (t in a) this.RemoveChess(!1, w, h, t);
      }
    this.height = l;
    return this;
  },
  TileXYZToKey = function (l, w, h, t) {
    void 0 === t && (t = ",");
    return `${l}${t}${w}${t}${h}`;
  },
  TileXYToKey = function (l, w, h) {
    void 0 === h && (h = ",");
    return `${l}${h}${w}`;
  },
  KeyToTileXYZ = function (l, w, h) {
    void 0 === w ? (w = {}) : !0 === w && (w = globTileXYZ$1);
    void 0 === h && (h = ",");
    l = l.split(h);
    w.x = l[0];
    w.y = l[1];
    w.z = l[2];
    return w;
  },
  globTileXYZ$1 = {},
  TileXYToWorldX = function (l, w) {
    return this.tileXYToWorldXY(l, w, !0).x;
  },
  TileXYToWorldY = function (l, w) {
    return this.tileXYToWorldXY(l, w, !0).y;
  },
  TileXYToWorldXY = function (l, w, h) {
    return this.grid.getWorldXY(l, w, h);
  },
  TileXYArrayToWorldXYArray = function (l, w) {
    void 0 === w && (w = []);
    for (var h, t = 0, a = l.length; t < a; t++)
      (h = l[t]), w.push(this.tileXYToWorldXY(h.x, h.y));
    return w;
  },
  WorldXYToTileX = function (l, w) {
    return this.worldXYToTileXY(l, w, !0).x;
  },
  WorldXYToTileY = function (l, w) {
    return this.worldXYToTileXY(l, w, !0).y;
  },
  WorldXYToTileXY = function (l, w, h) {
    return this.grid.getTileXY(l, w, h);
  },
  WorldXYToChessArray = function (l, w, h) {
    l = this.worldXYToTileXY(l, w, !0);
    return this.tileXYToChessArray(l.x, l.y, h);
  },
  WorldXYToChess = function (l, w, h) {
    l = this.worldXYToTileXY(l, w, !0);
    if (void 0 !== h) return this.tileXYZToChess(l.x, l.y, h);
    l = this.boardData.getUID(l.x, l.y);
    if (null == l) return null;
    for (h in l) return this.uidToChess(l[h]);
  },
  WorldXYSnapToGrid = function (l, w, h) {
    void 0 === h ? (h = {}) : !0 === h && (h = globWorldXY$4);
    this.worldXYToTileXY(l, w, h);
    this.tileXYToWorldXY(h.x, h.y, h);
    return h;
  },
  globWorldXY$4 = {},
  Between$1 = function (l, w, h, t) {
    return Math.atan2(t - w, h - l);
  },
  AngleBetween$4 = function (l, w) {
    l = this.chessToTileXYZ(l);
    w = this.chessToTileXYZ(w);
    l = this.tileXYToWorldXY(l.x, l.y, !0);
    var h = l.x,
      t = l.y;
    l = this.tileXYToWorldXY(w.x, w.y, !0);
    return Between$1(h, t, l.x, l.y);
  },
  Normalize = function (l) {
    l %= 2 * Math.PI;
    return 0 <= l ? l : l + 2 * Math.PI;
  },
  Equal = function (l, w, h) {
    void 0 === h && (h = 1e-4);
    return Math.abs(l - w) < h;
  },
  IsAngleInCone = function (l, w, h, t) {
    l = this.chessToTileXYZ(l);
    w = this.chessToTileXYZ(w);
    w = this.angleBetween(l, w);
    w = Normalize(w);
    h = Math.abs(w - h);
    h = Math.min(h, PI2 - h);
    t /= 2;
    return Equal(h, t) || h < t;
  };
const PI2 = 2 * Math.PI;
var AngleToward = function (l, w) {
    void 0 === l && (l = zeroTileXY);
    var h = this.wrapMode,
      t = this.infinityMode;
    this.wrapMode = !1;
    this.infinityMode = !0;
    w = this.getNeighborTileXY(l, w, !0);
    this.wrapMode = h;
    this.infinityMode = t;
    return this.angleBetween(l, w);
  },
  zeroTileXY = {
    x: 0,
    y: 0,
  },
  RAD_TO_DEG = 180 / Math.PI,
  RadToDeg$3 = function (l) {
    return l * RAD_TO_DEG;
  },
  ShortestBetween$1 = function (l, w) {
    l = w - l;
    return 0 === l ? 0 : l - 360 * Math.floor((l - -180) / 360);
  },
  AngleSnapToDirection = function (l, w) {
    w = RadToDeg$3(w);
    for (
      var h = this.grid.allDirections,
        t,
        a = Infinity,
        d = void 0,
        k = 0,
        e = h.length;
      k < e;
      k++
    )
      (t = RadToDeg$3(this.angleToward(l, h[k]))),
        (t = Math.abs(ShortestBetween$1(w, t))),
        t < a && ((a = t), (d = k));
    return d;
  },
  IsOverlappingPoint = function (l, w, h) {
    if (this.infinityMode && void 0 === h) return !0;
    l = this.worldXYToTileXY(l, w, !0);
    return this.contains(l.x, l.y, h);
  },
  GridAlign = function (l, w, h) {
    if (void 0 === l)
      for (l = this.getAllChess(), w = 0, h = l.length; w < h; w++)
        this.gridAlign(l[w]);
    else
      IsUID(l) && (l = this.uidToChess(l)),
        void 0 === w && ((h = this.chessToTileXYZ(l)), (w = h.x), (h = h.y)),
        this.tileXYToWorldXY(w, h, l);
    return this;
  },
  GetGridPoints$2 = function (l, w, h) {
    l &&
      "number" !== typeof l &&
      ((h = w), (w = this.chessToTileXYZ(l)), (l = w.x), (w = w.y));
    return this.grid.getGridPoints(l, w, h);
  },
  DistanceBetween$4 = function (l, w, h, t) {
    l -= h;
    w -= t;
    return Math.sqrt(l * l + w * w);
  },
  Linear$1 = function (l, w, h) {
    return (w - l) * h + l;
  },
  AreTileXYEqual = function (l, w) {
    return l && w && l.x === w.x && l.y === w.y;
  },
  LineToTileXYArray = function (l, w, h, t, a) {
    "number" !== typeof l &&
      ((t = l), (a = w), (l = t.x1), (w = t.y1), (h = t.x2), (t = t.y2));
    void 0 === a && (a = []);
    var d = DistanceBetween$4(l, w, h, t);
    d = Math.ceil(
      d / (Math.min(this.grid.cellWidth, this.grid.cellHeight) / 4)
    );
    for (var k, e, b, c = 0; c <= d; c++)
      (k = c / d),
        (e = Linear$1(l, h, k)),
        (k = Linear$1(w, t, k)),
        (e = this.worldXYToTileXY(e, k)),
        !this.contains(e.x, e.y) ||
          (b && AreTileXYEqual(b, e)) ||
          (a.push(e), (b = e));
    return a;
  },
  Contains$5 = function (l, w, h) {
    return 0 < l.radius &&
      w >= l.left &&
      w <= l.right &&
      h >= l.top &&
      h <= l.bottom
      ? (l.x - w) * (l.x - w) + (l.y - h) * (l.y - h) <= l.radius * l.radius
      : !1;
  },
  CircleToTileXYArray = function (l, w) {
    return this.shapeToTileXYArray(l, Contains$5, w);
  },
  Contains$4 = function (l, w, h) {
    if (0 >= l.width || 0 >= l.height) return !1;
    w = (w - l.x) / l.width;
    l = (h - l.y) / l.height;
    return 0.25 > w * w + l * l;
  },
  EllipseToTileXYArray = function (l, w) {
    return this.shapeToTileXYArray(l, Contains$4, w);
  },
  Contains$3 = function (l, w, h) {
    for (
      var t = !1, a = -1, d = l.points.length - 1;
      ++a < l.points.length;
      d = a
    ) {
      var k = l.points[a].x,
        e = l.points[a].y,
        b = l.points[d].x;
      d = l.points[d].y;
      ((e <= h && h < d) || (d <= h && h < e)) &&
        w < ((b - k) * (h - e)) / (d - e) + k &&
        (t = !t);
    }
    return t;
  };

function hasGetterOrSetter(l) {
  return (
    (!!l.get && "function" === typeof l.get) ||
    (!!l.set && "function" === typeof l.set)
  );
}

function getProperty(l, w, h) {
  l = h ? l[w] : Object.getOwnPropertyDescriptor(l, w);
  !h && l.value && "object" === typeof l.value && (l = l.value);
  return l && hasGetterOrSetter(l)
    ? ("undefined" === typeof l.enumerable && (l.enumerable = !0),
      "undefined" === typeof l.configurable && (l.configurable = !0),
      l)
    : !1;
}

function hasNonConfigurable(l, w) {
  l = Object.getOwnPropertyDescriptor(l, w);
  if (!l) return !1;
  l.value && "object" === typeof l.value && (l = l.value);
  return !1 === l.configurable ? !0 : !1;
}

function extend(l, w, h, t) {
  for (var a in w)
    if (w.hasOwnProperty(a)) {
      var d = getProperty(w, a, h);
      if (!1 !== d) {
        if (hasNonConfigurable((t || l).prototype, a)) {
          if (Class.ignoreFinals) continue;
          throw Error(
            "cannot override final property '" +
              a +
              "', set Class.ignoreFinals = true to skip"
          );
        }
        Object.defineProperty(l.prototype, a, d);
      } else l.prototype[a] = w[a];
    }
}

function mixin(l, w) {
  if (w) {
    Array.isArray(w) || (w = [w]);
    for (var h = 0; h < w.length; h++) extend(l, w[h].prototype || w[h]);
  }
}

function Class(l) {
  l || (l = {});
  if (l.initialize) {
    if ("function" !== typeof l.initialize)
      throw Error("initialize must be a function");
    var w = l.initialize;
    delete l.initialize;
  } else if (l.Extends) {
    var h = l.Extends;
    w = function () {
      h.apply(this, arguments);
    };
  } else w = function () {};
  if (l.Extends) {
    w.prototype = Object.create(l.Extends.prototype);
    w.prototype.constructor = w;
    var t = l.Extends;
    delete l.Extends;
  } else w.prototype.constructor = w;
  var a = null;
  l.Mixins && ((a = l.Mixins), delete l.Mixins);
  mixin(w, a);
  extend(w, l, !0, t);
  return w;
}
Class.extend = extend;
Class.mixin = mixin;
Class.ignoreFinals = !1;
var Contains$2 = function (l, w, h) {
    return 0 >= l.width || 0 >= l.height
      ? !1
      : l.x <= w && l.x + l.width >= w && l.y <= h && l.y + l.height >= h;
  },
  Perimeter = function (l) {
    return 2 * (l.width + l.height);
  },
  Point = new Class({
    initialize: function (l, w) {
      void 0 === l && (l = 0);
      void 0 === w && (w = l);
      this.x = l;
      this.y = w;
    },
    setTo: function (l, w) {
      void 0 === l && (l = 0);
      void 0 === w && (w = l);
      this.x = l;
      this.y = w;
      return this;
    },
  }),
  GetPoint$1 = function (l, w, h) {
    void 0 === h && (h = new Point());
    if (0 >= w || 1 <= w) return (h.x = l.x), (h.y = l.y), h;
    var t = Perimeter(l) * w;
    0.5 < w
      ? ((t -= l.width + l.height),
        t <= l.width
          ? ((h.x = l.right - t), (h.y = l.bottom))
          : ((h.x = l.x), (h.y = l.bottom - (t - l.width))))
      : t <= l.width
      ? ((h.x = l.x + t), (h.y = l.y))
      : ((h.x = l.right), (h.y = l.y + (t - l.width)));
    return h;
  },
  GetPoints$1 = function (l, w, h, t) {
    void 0 === t && (t = []);
    w || (w = Perimeter(l) / h);
    for (h = 0; h < w; h++) t.push(GetPoint$1(l, h / w));
    return t;
  },
  GetPoint = function (l, w, h) {
    void 0 === h && (h = new Point());
    h.x = l.x1 + (l.x2 - l.x1) * w;
    h.y = l.y1 + (l.y2 - l.y1) * w;
    return h;
  },
  Length = function (l) {
    return Math.sqrt(
      (l.x2 - l.x1) * (l.x2 - l.x1) + (l.y2 - l.y1) * (l.y2 - l.y1)
    );
  },
  GetPoints = function (l, w, h, t) {
    void 0 === t && (t = []);
    w || (w = Length(l) / h);
    h = l.x1;
    var a = l.y1,
      d = l.x2;
    l = l.y2;
    for (var k = 0; k < w; k++) {
      var e = k / w;
      t.push(new Point(h + (d - h) * e, a + (l - a) * e));
    }
    return t;
  },
  Random$1 = function (l, w) {
    void 0 === w && (w = new Point());
    var h = Math.random();
    w.x = l.x1 + h * (l.x2 - l.x1);
    w.y = l.y1 + h * (l.y2 - l.y1);
    return w;
  },
  Vector2 = new Class({
    initialize: function (l, w) {
      this.y = this.x = 0;
      "object" === typeof l
        ? ((this.x = l.x || 0), (this.y = l.y || 0))
        : (void 0 === w && (w = l), (this.x = l || 0), (this.y = w || 0));
    },
    clone: function () {
      return new Vector2(this.x, this.y);
    },
    copy: function (l) {
      this.x = l.x || 0;
      this.y = l.y || 0;
      return this;
    },
    setFromObject: function (l) {
      this.x = l.x || 0;
      this.y = l.y || 0;
      return this;
    },
    set: function (l, w) {
      void 0 === w && (w = l);
      this.x = l;
      this.y = w;
      return this;
    },
    setTo: function (l, w) {
      return this.set(l, w);
    },
    setToPolar: function (l, w) {
      null == w && (w = 1);
      this.x = Math.cos(l) * w;
      this.y = Math.sin(l) * w;
      return this;
    },
    equals: function (l) {
      return this.x === l.x && this.y === l.y;
    },
    angle: function () {
      var l = Math.atan2(this.y, this.x);
      0 > l && (l += 2 * Math.PI);
      return l;
    },
    add: function (l) {
      this.x += l.x;
      this.y += l.y;
      return this;
    },
    subtract: function (l) {
      this.x -= l.x;
      this.y -= l.y;
      return this;
    },
    multiply: function (l) {
      this.x *= l.x;
      this.y *= l.y;
      return this;
    },
    scale: function (l) {
      isFinite(l) ? ((this.x *= l), (this.y *= l)) : (this.y = this.x = 0);
      return this;
    },
    divide: function (l) {
      this.x /= l.x;
      this.y /= l.y;
      return this;
    },
    negate: function () {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    },
    distance: function (l) {
      var w = l.x - this.x;
      l = l.y - this.y;
      return Math.sqrt(w * w + l * l);
    },
    distanceSq: function (l) {
      var w = l.x - this.x;
      l = l.y - this.y;
      return w * w + l * l;
    },
    length: function () {
      var l = this.x,
        w = this.y;
      return Math.sqrt(l * l + w * w);
    },
    lengthSq: function () {
      var l = this.x,
        w = this.y;
      return l * l + w * w;
    },
    normalize: function () {
      var l = this.x,
        w = this.y,
        h = l * l + w * w;
      0 < h && ((h = 1 / Math.sqrt(h)), (this.x = l * h), (this.y = w * h));
      return this;
    },
    normalizeRightHand: function () {
      var l = this.x;
      this.x = -1 * this.y;
      this.y = l;
      return this;
    },
    dot: function (l) {
      return this.x * l.x + this.y * l.y;
    },
    cross: function (l) {
      return this.x * l.y - this.y * l.x;
    },
    lerp: function (l, w) {
      void 0 === w && (w = 0);
      var h = this.x,
        t = this.y;
      this.x = h + w * (l.x - h);
      this.y = t + w * (l.y - t);
      return this;
    },
    transformMat3: function (l) {
      var w = this.x,
        h = this.y;
      l = l.val;
      this.x = l[0] * w + l[3] * h + l[6];
      this.y = l[1] * w + l[4] * h + l[7];
      return this;
    },
    transformMat4: function (l) {
      var w = this.x,
        h = this.y;
      l = l.val;
      this.x = l[0] * w + l[4] * h + l[12];
      this.y = l[1] * w + l[5] * h + l[13];
      return this;
    },
    reset: function () {
      this.y = this.x = 0;
      return this;
    },
  });
Vector2.ZERO = new Vector2();
Vector2.RIGHT = new Vector2(1, 0);
Vector2.LEFT = new Vector2(-1, 0);
Vector2.UP = new Vector2(0, -1);
Vector2.DOWN = new Vector2(0, 1);
Vector2.ONE = new Vector2(1, 1);
var Line = new Class({
    initialize: function (l, w, h, t) {
      void 0 === l && (l = 0);
      void 0 === w && (w = 0);
      void 0 === h && (h = 0);
      void 0 === t && (t = 0);
      this.x1 = l;
      this.y1 = w;
      this.x2 = h;
      this.y2 = t;
    },
    getPoint: function (l, w) {
      return GetPoint(this, l, w);
    },
    getPoints: function (l, w, h) {
      return GetPoints(this, l, w, h);
    },
    getRandomPoint: function (l) {
      return Random$1(this, l);
    },
    setTo: function (l, w, h, t) {
      void 0 === l && (l = 0);
      void 0 === w && (w = 0);
      void 0 === h && (h = 0);
      void 0 === t && (t = 0);
      this.x1 = l;
      this.y1 = w;
      this.x2 = h;
      this.y2 = t;
      return this;
    },
    getPointA: function (l) {
      void 0 === l && (l = new Vector2());
      l.set(this.x1, this.y1);
      return l;
    },
    getPointB: function (l) {
      void 0 === l && (l = new Vector2());
      l.set(this.x2, this.y2);
      return l;
    },
    left: {
      get: function () {
        return Math.min(this.x1, this.x2);
      },
      set: function (l) {
        this.x1 <= this.x2 ? (this.x1 = l) : (this.x2 = l);
      },
    },
    right: {
      get: function () {
        return Math.max(this.x1, this.x2);
      },
      set: function (l) {
        this.x1 > this.x2 ? (this.x1 = l) : (this.x2 = l);
      },
    },
    top: {
      get: function () {
        return Math.min(this.y1, this.y2);
      },
      set: function (l) {
        this.y1 <= this.y2 ? (this.y1 = l) : (this.y2 = l);
      },
    },
    bottom: {
      get: function () {
        return Math.max(this.y1, this.y2);
      },
      set: function (l) {
        this.y1 > this.y2 ? (this.y1 = l) : (this.y2 = l);
      },
    },
  }),
  Random = function (l, w) {
    void 0 === w && (w = new Point());
    w.x = l.x + Math.random() * l.width;
    w.y = l.y + Math.random() * l.height;
    return w;
  },
  Rectangle = new Class({
    initialize: function (l, w, h, t) {
      void 0 === l && (l = 0);
      void 0 === w && (w = 0);
      void 0 === h && (h = 0);
      void 0 === t && (t = 0);
      this.x = l;
      this.y = w;
      this.width = h;
      this.height = t;
    },
    contains: function (l, w) {
      return Contains$2(this, l, w);
    },
    getPoint: function (l, w) {
      return GetPoint$1(this, l, w);
    },
    getPoints: function (l, w, h) {
      return GetPoints$1(this, l, w, h);
    },
    getRandomPoint: function (l) {
      return Random(this, l);
    },
    setTo: function (l, w, h, t) {
      this.x = l;
      this.y = w;
      this.width = h;
      this.height = t;
      return this;
    },
    setEmpty: function () {
      return this.setTo(0, 0, 0, 0);
    },
    setPosition: function (l, w) {
      void 0 === w && (w = l);
      this.x = l;
      this.y = w;
      return this;
    },
    setSize: function (l, w) {
      void 0 === w && (w = l);
      this.width = l;
      this.height = w;
      return this;
    },
    isEmpty: function () {
      return 0 >= this.width || 0 >= this.height;
    },
    getLineA: function (l) {
      void 0 === l && (l = new Line());
      l.setTo(this.x, this.y, this.right, this.y);
      return l;
    },
    getLineB: function (l) {
      void 0 === l && (l = new Line());
      l.setTo(this.right, this.y, this.right, this.bottom);
      return l;
    },
    getLineC: function (l) {
      void 0 === l && (l = new Line());
      l.setTo(this.right, this.bottom, this.x, this.bottom);
      return l;
    },
    getLineD: function (l) {
      void 0 === l && (l = new Line());
      l.setTo(this.x, this.bottom, this.x, this.y);
      return l;
    },
    left: {
      get: function () {
        return this.x;
      },
      set: function (l) {
        this.width = l >= this.right ? 0 : this.right - l;
        this.x = l;
      },
    },
    right: {
      get: function () {
        return this.x + this.width;
      },
      set: function (l) {
        this.width = l <= this.x ? 0 : l - this.x;
      },
    },
    top: {
      get: function () {
        return this.y;
      },
      set: function (l) {
        this.height = l >= this.bottom ? 0 : this.bottom - l;
        this.y = l;
      },
    },
    bottom: {
      get: function () {
        return this.y + this.height;
      },
      set: function (l) {
        this.height = l <= this.y ? 0 : l - this.y;
      },
    },
    centerX: {
      get: function () {
        return this.x + this.width / 2;
      },
      set: function (l) {
        this.x = l - this.width / 2;
      },
    },
    centerY: {
      get: function () {
        return this.y + this.height / 2;
      },
      set: function (l) {
        this.y = l - this.height / 2;
      },
    },
  }),
  GetAABB = function (l, w) {
    void 0 === w && (w = new Rectangle());
    for (
      var h = Infinity, t = Infinity, a = -h, d = -t, k, e = 0;
      e < l.points.length;
      e++
    )
      (k = l.points[e]),
        (h = Math.min(h, k.x)),
        (t = Math.min(t, k.y)),
        (a = Math.max(a, k.x)),
        (d = Math.max(d, k.y));
    w.x = h;
    w.y = t;
    w.width = a - h;
    w.height = d - t;
    return w;
  },
  PolygonToTileXYArray = function (l, w) {
    globSearchRectangle = GetAABB(l, globSearchRectangle);
    return this.shapeToTileXYArray(l, Contains$3, globSearchRectangle, w);
  },
  globSearchRectangle,
  RectangleToTileXYArray = function (l, w) {
    return this.shapeToTileXYArray(l, Contains$2, w);
  },
  Contains$1 = function (l, w, h) {
    var t = l.x3 - l.x1,
      a = l.y3 - l.y1,
      d = l.x2 - l.x1,
      k = l.y2 - l.y1;
    w -= l.x1;
    var e = h - l.y1;
    l = t * t + a * a;
    h = t * d + a * k;
    t = t * w + a * e;
    a = d * d + k * k;
    d = d * w + k * e;
    k = l * a - h * h;
    k = 0 === k ? 0 : 1 / k;
    w = (a * t - h * d) * k;
    l = (l * d - h * t) * k;
    return 0 <= w && 0 <= l && 1 > w + l;
  },
  TriangleToTileXYArray = function (l, w) {
    return this.shapeToTileXYArray(l, Contains$1, w);
  },
  Clamp$1 = function (l, w, h) {
    return Math.max(w, Math.min(h, l));
  },
  ShapeToTileXYArray = function (l, w, h) {
    void 0 === h && (h = []);
    globLeftToptileXY = this.worldXYToTileXY(l.left, l.top, globLeftToptileXY);
    globRightBottomTileXY = this.worldXYToTileXY(
      l.right,
      l.bottom,
      globRightBottomTileXY
    );
    var t = globLeftToptileXY.x - 1,
      a = globLeftToptileXY.y - 1,
      d = globRightBottomTileXY.x + 1,
      k = globRightBottomTileXY.y + 1;
    this.infinityMode ||
      ((t = Clamp$1(t, 0, this.width - 1)),
      (a = Clamp$1(a, 0, this.height - 1)),
      (d = Clamp$1(d, 0, this.width - 1)),
      (k = Clamp$1(k, 0, this.height - 1)));
    for (var e = t; e <= d; e++)
      for (var b = a; b <= k; b++)
        (t = this.tileXYToWorldXY(e, b, !0)),
          w(l, t.x, t.y) &&
            h.push({
              x: e,
              y: b,
            });
    return h;
  },
  globLeftToptileXY,
  globRightBottomTileXY,
  UidToChess = function (l) {
    return null == l
      ? null
      : this.boardData.exists(l)
      ? ChessBank.get(l).parent
      : null;
  },
  AddChess$1 = function (l, w, h, t, a) {
    if (!this.contains(w, h)) return this;
    void 0 === a && (a = !0);
    var d = this.chessToTileXYZ(l);
    void 0 === t && (t = d ? d.z : 0);
    if (d && d.x === w && d.y === h && d.z === t) return this;
    var k = this.tileXYZToChess(w, h, t);
    k && this.emit("kickout", l, k, d);
    this.removeChess(l);
    k && this.removeChess(k, w, h, t);
    this.boardData.addUID(this.getChessUID(l), w, h, t);
    this.isBoard && this.getChessData(l).setBoard(this);
    a && this.gridAlign(l, w, h);
    return this;
  },
  SetChessTileZ = function (l, w, h) {
    void 0 === h && (h = !1);
    var t = this.chessToTileXYZ(l);
    t && this.moveChess(l, t.x, t.y, w, h);
    return this;
  },
  RemoveChess$1 = function (l, w, h, t, a, d) {
    void 0 === a && (a = !1);
    void 0 === d && (d = !1);
    if (l)
      if ((t = this.chessToTileXYZ(l))) (w = t.x), (h = t.y), (t = t.z);
      else return this;
    else if (((l = this.tileXYZToChess(w, h, t)), !l)) return this;
    d || this.boardData.removeUID(w, h, t);
    this.isBoard && this.getChessData(l).setBoard(null);
    a && l.destroy && l.destroy();
    return this;
  },
  RemoveAllChess$1 = function (l, w) {
    for (var h = this.getAllChess(), t = 0, a = h.length; t < a; t++)
      this.removeChess(h[t], void 0, void 0, void 0, l, w);
    return this;
  },
  SwapChess = function (l, w, h) {
    void 0 === h && (h = !0);
    var t = this.chessToTileXYZ(l),
      a = this.chessToTileXYZ(w);
    if (null == t || null == a) return this;
    this.removeChess(l);
    this.removeChess(w);
    this.addChess(l, a.x, a.y, a.z, h);
    this.addChess(w, t.x, t.y, t.z, h);
    return this;
  },
  GetAllChess = function (l) {
    void 0 === l && (l = []);
    var w = this.boardData.UIDToXYZ,
      h;
    for (h in w) l.push(this.uidToChess(h));
    return l;
  },
  Contains = function (l, w, h) {
    var t;
    (t = this.infinityMode
      ? !0
      : 0 <= l && l < this.width && 0 <= w && w < this.height) &&
      void 0 !== h &&
      (t = this.boardData.contains(l, w, h));
    return t;
  },
  ForEachTileXY = function (l, w, h) {
    void 0 === h && (h = 0);
    switch (h) {
      case 0:
        for (var t = 0; t < this.height; t++)
          for (
            var a = 0;
            a < this.width &&
            !((globTileXY$g.x = a),
            (globTileXY$g.y = t),
            (h = w ? l.call(w, globTileXY$g, this) : l(globTileXY$g, this)));
            a++
          );
        break;
      case 1:
        for (t = 0; t < this.height; t++)
          for (
            a = this.width - 1;
            0 <= a &&
            !((globTileXY$g.x = a),
            (globTileXY$g.y = t),
            (h = w ? l.call(w, globTileXY$g, this) : l(globTileXY$g, this)));
            a--
          );
        break;
      case 2:
        for (a = 0; a < this.width; a++)
          for (
            t = 0;
            t < this.height &&
            !((globTileXY$g.x = a),
            (globTileXY$g.y = t),
            (h = w ? l.call(w, globTileXY$g, this) : l(globTileXY$g, this)));
            t++
          );
        break;
      case 3:
        for (a = 0; a < this.width; a++)
          for (
            t = this.height - 1;
            0 <= t &&
            !((globTileXY$g.x = a),
            (globTileXY$g.y = t),
            (h = w ? l.call(w, globTileXY$g, this) : l(globTileXY$g, this)));
            t--
          );
    }
    return this;
  },
  globTileXY$g = {
    x: 0,
    y: 0,
  },
  Wrap = function (l, w, h) {
    h -= w;
    return w + ((((l - w) % h) + h) % h);
  },
  GetWrapTileXY = function (l, w, h) {
    void 0 === h ? (h = {}) : !0 === h && (h = globTileXY$f);
    this.wrapMode
      ? (l = Wrap(l, 0, this.width))
      : !this.infinityMode && (0 > l || l >= this.width) && (l = null);
    this.wrapMode
      ? (w = Wrap(w, 0, this.height))
      : !this.infinityMode && (0 > w || w >= this.height) && (w = null);
    h.x = l;
    h.y = w;
    return h;
  },
  globTileXY$f = {},
  TileXYZToChess = function (l, w, h) {
    l = this.boardData.getUID(l, w, h);
    return this.uidToChess(l);
  },
  TileXYToChessArray = function (l, w, h) {
    void 0 === h && (h = []);
    l = this.boardData.getUID(l, w);
    if (null == l) return h;
    for (var t in l) h.push(this.uidToChess(l[t]));
    return h;
  },
  TileZToChessArray = function (l, w) {
    void 0 === w && (w = []);
    var h = this.boardData.UIDToXYZ,
      t;
    for (t in h) {
      var a = h[t];
      a.z === l && w.push(this.uidToChess(t));
    }
    return w;
  },
  TileXYArrayToChessArray = function (l, w, h) {
    Array.isArray(w) && ((h = w), (w = void 0));
    void 0 === h && (h = []);
    for (var t = null != w, a, d = 0, k = l.length; d < k; d++)
      (a = l[d]),
        t
          ? h.push(this.tileXYZToChess(a.x, a.y, w))
          : this.tileXYToChessArray(a.x, a.y, h);
    return h;
  },
  IsChess = function (l) {
    return IsUID(l) ? !1 : l && !!l.rexChess;
  },
  IsTileXYZ = function (l) {
    return l && (IsPlainObject(l) || l.isTileXYZ);
  },
  ChessToTileXYZ = function (l) {
    return l
      ? IsUID(l) || IsChess(l)
        ? ((l = GetChessUID(l)), this.boardData.getXYZ(l))
        : IsTileXYZ(l)
        ? l
        : null
      : null;
  },
  GetOppositeDirection$2 = function (l, w, h) {
    l &&
      "number" !== typeof l &&
      ((h = w), (w = this.chessToTileXYZ(l)), (l = w.x), (w = w.y));
    return this.grid.getOppositeDirection(l, w, h);
  },
  GetDistance$2 = function (l, w, h) {
    l = this.chessToTileXYZ(l);
    w = this.chessToTileXYZ(w);
    return this.grid.getDistance(l, w, h);
  },
  DirectionBetween$2 = function (l, w, h) {
    void 0 === h && (h = !0);
    l = this.chessToTileXYZ(l);
    w = this.chessToTileXYZ(w);
    return this.grid.directionBetween(l, w, h);
  },
  IsDirectionInCone = function (l, w, h, t) {
    l = this.chessToTileXYZ(l);
    var a = this.chessToTileXYZ(w);
    w = this.grid.directions;
    this.grid.setDirectionMode(this.sides);
    l = this.grid.directionBetween(l, a, !1);
    this.grid.setDirectionMode(w);
    h = Math.abs(l - h);
    h = Math.min(h, this.grid.directions - h);
    return h <= t / 2;
  },
  Offset$3 = function (l, w, h, t) {
    void 0 === t ? (t = {}) : !0 === t && (t = globTileXY$e);
    0 === w && 0 === h
      ? ((t.x = l.x), (t.y = l.y))
      : this.grid.offset(l, w, h, t);
    return t;
  },
  globTileXY$e = {},
  Mirror$4 = function (l, w, h, t) {
    void 0 === t ? (t = {}) : !0 === t && (t = globTileXY$d);
    void 0 !== h ? this.offset(l, -h.x, -h.y, t) : ((t.x = l.x), (t.y = l.y));
    this.grid.mirror(t, w, t);
    void 0 !== h && this.offset(t, h.x, h.y, t);
    return t;
  },
  globTileXY$d = {},
  Rotate$5 = function (l, w, h, t) {
    void 0 === t ? (t = {}) : !0 === t && (t = globTileXY$c);
    void 0 !== h ? this.offset(l, -h.x, -h.y, t) : ((t.x = l.x), (t.y = l.y));
    this.grid.rotate(t, w, t);
    void 0 !== h && this.offset(t, h.x, h.y, t);
    return t;
  },
  globTileXY$c = {},
  Fit = function (l) {
    var w = Infinity,
      h = Infinity,
      t;
    for (t in l) {
      var a = l[t];
      w = Math.min(w, a.x);
      h = Math.min(h, a.y);
    }
    if (0 !== w || 0 !== h) for (t in l) (a = l[t]), this.offset(a, -w, -h, a);
    h = w = -Infinity;
    for (t in l) (a = l[t]), (w = Math.max(w, a.x)), (h = Math.max(h, a.y));
    this.setBoardWidth(w + 1);
    this.setBoardHeight(h + 1);
    return l;
  },
  GetEmptyTileXYArray = function (l, w) {
    void 0 === w && (w = []);
    void 0 === l && (l = 0);
    for (var h = 0; h < this.height; h++)
      for (var t = 0; t < this.width; t++)
        null === this.tileXYZToChess(t, h, l) &&
          w.push({
            x: t,
            y: h,
          });
    return w;
  },
  Between = function (l, w) {
    return Math.floor(Math.random() * (w - l + 1) + l);
  },
  GetRandom = function (l, w, h) {
    void 0 === w && (w = 0);
    void 0 === h && (h = l.length);
    w += Math.floor(Math.random() * h);
    return void 0 === l[w] ? null : l[w];
  },
  GetRandomEmptyTileXY = function (l, w) {
    void 0 === l && (l = 0);
    void 0 === w ? (w = {}) : !0 === w && (w = globTileXY$b);
    for (var h, t, a = !0, d = 20; a && 0 < d; )
      (h = Between(0, this.width - 1)),
        (t = Between(0, this.height - 1)),
        (a = null !== this.tileXYZToChess(h, t, l)),
        d--;
    if (a) {
      globTileXYArray$1 = this.getEmptyTileXYArray(l, globTileXYArray$1);
      if (0 === globTileXYArray$1.length) return null;
      l = GetRandom(globTileXYArray$1);
      w.x = l.x;
      w.y = l.y;
      globTileXYArray$1.length = 0;
      return w;
    }
    w.x = h;
    w.y = t;
    return w;
  },
  globTileXYArray$1 = [],
  globTileXY$b = {},
  GetTileXYAtDirection = function (l, w, h, t) {
    l = this.chessToTileXYZ(l);
    if (!l) return null;
    "string" === typeof w &&
      (w = -1 === w.indexOf(",") ? parseInt(w) : w.split(","));
    var a = "number" === typeof w,
      d = "number" === typeof h;
    if (a && d) {
      if (
        ((t = this.grid.getTileXYAtDirection(l.x, l.y, w, h, t)),
        this.getWrapTileXY(t.x, t.y, t),
        null == t.x || null == t.y)
      )
        t = null;
    } else if (
      (void 0 === t && (t = []), null == w && (w = this.grid.allDirections), a)
    )
      if (IsPlainObject(h))
        if (
          ((d = GetValue$l(h, "end", 1)),
          (a = GetValue$l(h, "start", 0 < d ? 1 : -1)),
          (h = GetValue$l(h, "step", d >= a ? 1 : -1)),
          a === d)
        )
          (a = this.getTileXYAtDirection(l, w, d)), null !== a && t.push(a);
        else if (a < d)
          for (var k = a; k <= d; k += h)
            (a = this.getTileXYAtDirection(l, w, k)), null !== a && t.push(a);
        else
          for (k = a; k >= d; k += h)
            (a = this.getTileXYAtDirection(l, w, k)), null !== a && t.push(a);
      else {
        k = 0;
        for (var e = h.length; k < e; k++)
          (a = this.getTileXYAtDirection(l, w, h[k])), null !== a && t.push(a);
      }
    else
      for (k = 0, e = w.length; k < e; k++)
        d
          ? ((a = this.getTileXYAtDirection(l, w[k], h)),
            null !== a && t.push(a))
          : this.getTileXYAtDirection(l, w[k], h, t);
    return t;
  },
  GetNeighborTileXY$2 = function (l, w, h) {
    return this.getTileXYAtDirection(l, w, 1, h);
  },
  GetNeighborTileXYAtAngle = function (l, w, h) {
    w = this.angleSnapToDirection(l, w);
    return this.getTileXYAtDirection(l, w, 1, h);
  },
  GetNeighborChess = function (l, w, h, t) {
    l = this.chessToTileXYZ(l);
    if (null === l) return null;
    null == h && (h = l.z);
    var a = typeof w;
    if ("number" === a || ("string" === a && -1 === w.indexOf(",")))
      return (
        (t = this.getNeighborTileXY(l, w, !0)),
        null === t ? null : this.tileXYZToChess(t.x, t.y, h)
      );
    void 0 === t && (t = []);
    this.getNeighborTileXY(l, w, globTileXYArray);
    w = 0;
    for (a = globTileXYArray.length; w < a; w++)
      (l = this.tileXYZToChess(globTileXYArray[w].x, globTileXYArray[w].y, h)),
        null != l && t.push(l);
    globTileXYArray.length = 0;
    return t;
  },
  globTileXYArray = [],
  GetNeighborTileDirection$2 = function (l, w) {
    if (null === l || null === w) return null;
    l = this.chessToTileXYZ(l);
    w = this.chessToTileXYZ(w);
    if (AreTileXYEqual(l, w)) return null;
    var h = this.grid.getNeighborTileDirection(l, w);
    if (this.wrapMode && null === h) {
      globNeighborTileXYArray = this.getNeighborTileXY(
        l,
        null,
        globNeighborTileXYArray
      );
      l = 0;
      for (var t = globNeighborTileXYArray.length; l < t; l++)
        if (AreTileXYEqual(w, globNeighborTileXYArray[l])) {
          h = l;
          break;
        }
      globNeighborTileXYArray.length = 0;
    }
    return h;
  },
  globNeighborTileXYArray = [],
  GetNeighborChessDirection = function (l, w) {
    l = this.chessToTileXYZ(l);
    w = this.chessToTileXYZ(w);
    return this.getNeighborTileDirection(l, w);
  },
  AreNeighbors = function (l, w) {
    return null !== this.getNeighborChessDirection(l, w);
  },
  RingToTileXYArray$2 = function (l, w, h) {
    void 0 === h && (h = []);
    l = this.chessToTileXYZ(l);
    this.grid.ringToTileXYArray(l, w, globTileArray);
    w = 0;
    for (var t = globTileArray.length; w < t; w++)
      (l = globTileArray[w]), this.contains(l.x, l.y) && h.push(l);
    globTileArray.length = 0;
    return h;
  },
  globTileArray = [],
  FilledRingToTileXYArray = function (l, w, h, t) {
    IsArray(h) && ((t = h), (h = void 0));
    void 0 === h && (h = !0);
    void 0 === t && (t = []);
    l = this.chessToTileXYZ(l);
    for (var a, d = 0; d <= w; d++)
      (a = h ? d : w - d), this.ringToTileXYArray(l, a, t);
    return t;
  },
  HasBlocker = function (l, w, h) {
    l &&
      "number" !== typeof l &&
      ((h = this.chessToTileXYZ(l)), (l = h.x), (w = h.y), (h = h.z));
    if (void 0 === h) {
      l = this.tileXYToChessArray(l, w, globChessArray$5);
      h = 0;
      for (var t = l.length; h < t; h++)
        if (((w = this.getChessData(l[h]).blocker), !0 === w))
          return (globChessArray$5.length = 0), !0;
      globChessArray$5.length = 0;
      return !1;
    }
    l = this.tileXYZToChess(l, w, h);
    if (null === l) return !1;
    w = this.getChessData(l).blocker;
    return !0 === w;
  },
  globChessArray$5 = [],
  HasEdgeBlocker = function (l, w, h, t) {
    if (void 0 === h) {
      l = this.tileXYToChessArray(l, w, globChessArray$4);
      w = 0;
      for (h = l.length; w < h; w++)
        if (isEdgeBlocker(this.getChessData(l[w]).blocker))
          return (globChessArray$4.length = 0), !0;
      globChessArray$4.length = 0;
      return !1;
    }
    l = this.tileXYZToChess(l, w, h);
    return null === l ? !1 : isEdgeBlocker(this.getChessData(l).blocker);
  },
  isEdgeBlocker = function (l, w) {
    return !1 === l || !0 === l ? l : !0 === l[w];
  },
  globChessArray$4 = [],
  GetBoard = function (l) {
    if (l) {
      if (l.rexChess) return l.rexChess.board;
      if (l.mainBoard) return l.mainBoard;
    }
  },
  LogicMethods = {
    getChessData: GetChessData,
    getChessUID: GetChessUID,
    setBoardWidth: SetBoardWidth,
    setBoardHeight: SetBoardHeight,
    tileXYZToKey: TileXYZToKey,
    tileXYToKey: TileXYToKey,
    keyToTileXYZ: KeyToTileXYZ,
    tileXYToWorldX: TileXYToWorldX,
    tileXYToWorldY: TileXYToWorldY,
    tileXYToWorldXY: TileXYToWorldXY,
    tileXYArrayToWorldXYArray: TileXYArrayToWorldXYArray,
    worldXYToTileX: WorldXYToTileX,
    worldXYToTileY: WorldXYToTileY,
    worldXYToTileXY: WorldXYToTileXY,
    worldXYToChessArray: WorldXYToChessArray,
    worldXYToChess: WorldXYToChess,
    worldXYSnapToGrid: WorldXYSnapToGrid,
    angleBetween: AngleBetween$4,
    isAngleInCone: IsAngleInCone,
    angleToward: AngleToward,
    angleSnapToDirection: AngleSnapToDirection,
    isOverlappingPoint: IsOverlappingPoint,
    gridAlign: GridAlign,
    getGridPoints: GetGridPoints$2,
    lineToTileXYArray: LineToTileXYArray,
    circleToTileXYArray: CircleToTileXYArray,
    ellipseToTileXYArray: EllipseToTileXYArray,
    polygonToTileXYArray: PolygonToTileXYArray,
    rectangleToTileXYArray: RectangleToTileXYArray,
    triangleToTileXYArray: TriangleToTileXYArray,
    shapeToTileXYArray: ShapeToTileXYArray,
    uidToChess: UidToChess,
    addChess: AddChess$1,
    removeChess: RemoveChess$1,
    removeAllChess: RemoveAllChess$1,
    swapChess: SwapChess,
    moveChess: AddChess$1,
    setChessTileZ: SetChessTileZ,
    getAllChess: GetAllChess,
    contains: Contains,
    forEachTileXY: ForEachTileXY,
    getWrapTileXY: GetWrapTileXY,
    tileXYZToChess: TileXYZToChess,
    tileXYToChessArray: TileXYToChessArray,
    tileZToChessArray: TileZToChessArray,
    tileXYArrayToChessArray: TileXYArrayToChessArray,
    chessToTileXYZ: ChessToTileXYZ,
    offset: Offset$3,
    mirror: Mirror$4,
    rotate: Rotate$5,
    getOppositeDirection: GetOppositeDirection$2,
    getDistance: GetDistance$2,
    directionBetween: DirectionBetween$2,
    isDirectionInCone: IsDirectionInCone,
    fit: Fit,
    getEmptyTileXYArray: GetEmptyTileXYArray,
    getRandomEmptyTileXY: GetRandomEmptyTileXY,
    getTileXYAtDirection: GetTileXYAtDirection,
    getNeighborTileXY: GetNeighborTileXY$2,
    getNeighborTileXYAtAngle: GetNeighborTileXYAtAngle,
    getNeighborChess: GetNeighborChess,
    getNeighborTileDirection: GetNeighborTileDirection$2,
    getNeighborChessDirection: GetNeighborChessDirection,
    areNeighbors: AreNeighbors,
    ringToTileXYArray: RingToTileXYArray$2,
    filledRingToTileXYArray: FilledRingToTileXYArray,
    hasBlocker: HasBlocker,
    hasEdgeBlocker: HasEdgeBlocker,
    getGridPoints: GetGridPoints$2,
    chessToBoard: GetBoard,
  },
  Clear = function (l) {
    if ("object" !== typeof l || null === l) return l;
    if (Array.isArray(l)) l.length = 0;
    else for (var w in l) delete l[w];
    return l;
  },
  IsEmpty = function (l) {
    for (var w in l) return !1;
    return !0;
  };
class BoardData {
  constructor() {
    this.XYZToUID = {};
    this.UIDToXYZ = {};
    this.clear();
  }
  shutdown(l) {
    this.UIDToXYZ = this.XYZToUID = void 0;
    return this;
  }
  destroy(l) {
    this.shutdown(l);
    return this;
  }
  clear() {
    Clear(this.UIDToXYZ);
    Clear(this.XYZToUID);
    this.chessCount = 0;
    this.clearBounds();
    return this;
  }
  clearBounds() {
    this._yMin = this._yMax = this._xMin = this._xMax = void 0;
    return this;
  }
  addUID(l, w, h, t) {
    this.XYZToUID.hasOwnProperty(w) || (this.XYZToUID[w] = {});
    var a = this.XYZToUID[w];
    a.hasOwnProperty(h) || (a[h] = {});
    a[h][t] = l;
    this.UIDToXYZ[l] = {
      x: w,
      y: h,
      z: t,
    };
    this.chessCount++;
    this.clearBounds();
    return this;
  }
  getUID(l, w, h) {
    (l = this.XYZToUID[l]) && (l = l[w]) && void 0 !== h && (l = l[h]);
    return l;
  }
  removeUID(l, w, h) {
    if (!this.XYZToUID.hasOwnProperty(l)) return this;
    var t = this.XYZToUID[l];
    if (!t.hasOwnProperty(w)) return this;
    var a = t[w];
    if (!a.hasOwnProperty(h)) return this;
    var d = a[h];
    delete a[h];
    delete this.UIDToXYZ[d];
    IsEmpty(a) && delete t[w];
    IsEmpty(t) && delete this.XYZToUID[l];
    this.chessCount--;
    this.clearBounds();
    return this;
  }
  exists(l) {
    return this.UIDToXYZ.hasOwnProperty(l);
  }
  contains(l, w, h) {
    return null != this.getUID(l, w, h);
  }
  getXYZ(l) {
    return this.exists(l) ? this.UIDToXYZ[l] : null;
  }
  get xMax() {
    if (void 0 === this._xMax) {
      this._xMax = -Infinity;
      var l = this.UIDToXYZ,
        w;
      for (w in l) {
        var h = l[w].x;
        this._xMax < h && (this._xMax = h);
      }
    }
    return this._xMax;
  }
  get xMin() {
    if (void 0 === this._xMin) {
      this._xMin = Infinity;
      var l = this.UIDToXYZ,
        w;
      for (w in l) {
        var h = l[w].x;
        this._xMin > h && (this._xMin = h);
      }
    }
    return this._xMin;
  }
  get yMax() {
    if (void 0 === this._yMax) {
      this._yMax = -Infinity;
      var l = this.UIDToXYZ,
        w;
      for (w in l) {
        var h = l[w].y;
        this._yMax < h && (this._yMax = h);
      }
    }
    return this._yMax;
  }
  get yMin() {
    if (void 0 === this._yMin) {
      this._yMin = Infinity;
      var l = this.UIDToXYZ,
        w;
      for (w in l) {
        var h = l[w].y;
        this._yMin > h && (this._yMin = h);
      }
    }
    return this._yMin;
  }
}
var GetWorldX$2 = function (l, w, h) {
    void 0 === h ? (h = {}) : !0 === h && (h = globWorldXY$3);
    switch (this.mode) {
      case 0:
        var t = l * this.width;
        var a = w * this.height;
        break;
      case 1:
        (t = (l - w) * this._halfWidth), (a = (l + w) * this._halfHeight);
    }
    t += this.x;
    a += this.y;
    h.x = t;
    h.y = a;
    return h;
  },
  globWorldXY$3 = {},
  GetWorldX$1 = function (l, w) {
    return this.getWorldXY(l, w, !0).x;
  },
  GetWorldY$1 = function (l, w) {
    return this.getWorldXY(l, w, !0).y;
  },
  GetTileXY$1 = function (l, w, h) {
    void 0 === h ? (h = {}) : !0 === h && (h = globTileXY$a);
    l -= this.x;
    w -= this.y;
    l /= this.width;
    w /= this.height;
    switch (this.mode) {
      case 0:
        h.x = Math.round(l);
        h.y = Math.round(w);
        break;
      case 1:
        (h.x = Math.round(+l + w)), (h.y = Math.round(-l + w));
    }
    return h;
  },
  globTileXY$a = {},
  GetTileX$1 = function (l, w) {
    return this.getTileXY(l, w, !0).x;
  },
  GetTileY$1 = function (l, w) {
    return this.getTileXY(l, w, !0).y;
  };
class Quad {
  constructor(l) {
    this.resetFromJSON(l);
  }
  resetFromJSON(l) {
    this.setType(GetValue$l(l, "type", 0));
    this.setDirectionMode(GetValue$l(l, "dir", 4));
    this.setOriginPosition(GetValue$l(l, "x", 0), GetValue$l(l, "y", 0));
    this.setCellSize(
      GetValue$l(l, "cellWidth", 0),
      GetValue$l(l, "cellHeight", 0)
    );
  }
  setType(l) {
    "string" === typeof l && (l = ORIENTATIONTYPE[l]);
    this.mode = l;
    return this;
  }
  setDirectionMode(l) {
    "string" === typeof l && (l = DIRMODE$2[l]);
    this.directions = l;
    return this;
  }
  setOriginPosition(l, w) {
    this.x = l;
    this.y = w;
    return this;
  }
  get width() {
    return this._width;
  }
  set width(l) {
    this._width = l;
    this._halfWidth = l / 2;
  }
  get height() {
    return this._height;
  }
  set height(l) {
    this._height = l;
    this._halfHeight = l / 2;
  }
  setCellSize(l, w) {
    this.width = l;
    this.height = w;
    return this;
  }
  get cellWidth() {
    return this.width;
  }
  set cellWidth(l) {
    this.width = l;
  }
  get cellHeight() {
    return this.height;
  }
  set cellHeight(l) {
    this.height = l;
  }
}
var methods$8 = {
  getWorldXY: GetWorldX$2,
  getWorldX: GetWorldX$1,
  getWorldY: GetWorldY$1,
  getTileXY: GetTileXY$1,
  getTileX: GetTileX$1,
  getTileY: GetTileY$1,
};
Object.assign(Quad.prototype, methods$8);
const ORIENTATIONTYPE = {
    orthogonal: 0,
    isometric: 1,
    staggered: 2,
  },
  DIRMODE$2 = {
    "4dir": 4,
    "8dir": 8,
  };
var SaveOrigin = function () {
    this._savedOriginX = this.x;
    this._savedOriginY = this.y;
    return this;
  },
  RestoreOrigin = function () {
    this.x = this._savedOriginX;
    this.y = this._savedOriginY;
    return this;
  };
const OrthogonalMap = [
    [1, 0],
    [0, 1],
    [-1, 0],
    [0, -1],
    [1, 1],
    [-1, 1],
    [-1, -1],
    [1, -1],
  ],
  IsometricMap = OrthogonalMap;
var GetTileXAtDirection$1 = function (l, w, h, t, a) {
    void 0 === a ? (a = {}) : !0 === a && (a = globTileXY$9);
    switch (this.mode) {
      case 0:
        var d = OrthogonalMap[h][0];
        var k = OrthogonalMap[h][1];
        break;
      case 1:
        (d = OrthogonalMap[h][0]), (k = OrthogonalMap[h][1]);
    }
    1 === t
      ? ((a.x = l + d), (a.y = w + k))
      : ((a.x = l + t * d), (a.y = w + t * k));
    return a;
  },
  globTileXY$9 = {},
  GetNeighborTileXY$1 = function (l, w, h, t) {
    return GetTileXAtDirection$1.call(this, l, w, h, 1, t);
  },
  ReverseDirMap$1 = function (l) {
    var w = {},
      h;
    for (h in l) {
      var t = l[h];
      var a = t[0];
      t = t[1];
      w.hasOwnProperty(a) || (w[a] = {});
      w[a][t] = parseInt(h);
    }
    return w;
  };
const OrthogonalMapOut = ReverseDirMap$1(OrthogonalMap),
  IsometricMapOut = OrthogonalMapOut;
var GetNeighborTileDirection$1 = function (l, w) {
    switch (this.mode) {
      case 0:
        var h = OrthogonalMapOut;
        break;
      case 1:
        h = OrthogonalMapOut;
    }
    var t = w.x - l.x;
    l = w.y - l.y;
    return h.hasOwnProperty(t) && ((h = h[t]), h.hasOwnProperty(l))
      ? h[l]
      : null;
  },
  GetOppositeDirection$1 = function (l, w, h) {
    return oppositeDirectionMap[h];
  };
const oppositeDirectionMap = {
  0: 2,
  1: 3,
  2: 0,
  3: 1,
  4: 6,
  5: 7,
  6: 4,
  7: 5,
};
var Offset$2 = function (l, w, h, t) {
    void 0 === t ? (t = {}) : !0 === t && (t = globTileXY$8);
    h = l.y + h;
    t.x = l.x + w;
    t.y = h;
    return t;
  },
  globTileXY$8 = {},
  Mirror$3 = function (l, w, h) {
    void 0 === h ? (h = {}) : !0 === h && (h = globTileXY$7);
    h.x = w & 1 ? -l.x : l.x;
    h.y = w & 2 ? -l.y : l.y;
    return h;
  },
  globTileXY$7 = {},
  Rotate$4 = function (l, w, h) {
    void 0 === h ? (h = {}) : !0 === h && (h = globTileXY$6);
    w = Wrap(w, 0, 3);
    switch (w) {
      case 1:
        w = -l.y;
        l = l.x;
        break;
      case 2:
        w = -l.x;
        l = -l.y;
        break;
      case 3:
        w = l.y;
        l = -l.x;
        break;
      default:
        (w = l.x), (l = l.y);
    }
    h.x = w;
    h.y = l;
    return h;
  },
  globTileXY$6 = {},
  GetDistance$1 = function (l, w, h) {
    var t = w.x - l.x;
    l = w.y - l.y;
    return h ? Math.abs(t) + Math.abs(l) : Math.sqrt(t * t + l * l);
  },
  DirectionBetween$1 = function (l, w, h) {
    void 0 === h && (h = !0);
    switch (this.mode) {
      case 0:
      case 1:
        if (l.y === w.y) var t = w.x >= l.x ? 0 : 2;
        else
          l.x === w.x
            ? (t = w.y >= l.y ? 1 : 3)
            : 4 === this.directions
            ? ((l = RadToDeg$3(Between$1(l.x, l.y, w.x, w.y))),
              0 > l && (l += 360),
              (t = l / 90),
              h && (t = Math.round(t)))
            : ((t = w.x - l.x),
              (l = w.y - l.y),
              t === l
                ? (t = 0 < t ? 4 : 6)
                : t === -l
                ? (t = 0 < t ? 7 : 5)
                : ((l = RadToDeg$3(Math.atan2(l, t))),
                  0 > l && (l += 360),
                  (l /= 45),
                  h && (l = Math.round(l)),
                  (t =
                    0 <= l && 1 > l
                      ? l
                      : 1 <= l && 2 > l
                      ? l + 3
                      : 2 <= l && 3 > l
                      ? l - 1
                      : 3 <= l && 4 > l
                      ? l + 2
                      : 4 <= l && 5 > l
                      ? l - 2
                      : 5 <= l && 6 > l
                      ? l + 1
                      : 6 <= l && 7 > l
                      ? l - 3
                      : l)));
    }
    t === this.directions && (t = 0);
    return t;
  },
  DirectionNormalize = function (l) {
    return Wrap(l, 0, this.directions);
  },
  InitPoints = function (l) {
    for (var w = [], h = 0; h < l; h++)
      w.push({
        x: 0,
        y: 0,
      });
    return w;
  },
  SetPoints$1 = function (l, w, h, t, a, d) {
    void 0 === d && (d = InitPoints(4));
    h /= 2;
    t /= 2;
    0 === a
      ? ((d[0].x = l + h),
        (d[0].y = w - t),
        (d[1].x = l + h),
        (d[1].y = w + t),
        (d[2].x = l - h),
        (d[2].y = w + t),
        (d[3].x = l - h))
      : ((d[0].x = l + h),
        (d[0].y = w),
        (d[1].x = l),
        (d[1].y = w + t),
        (d[2].x = l - h),
        (d[2].y = w),
        (d[3].x = l));
    d[3].y = w - t;
    return d;
  },
  GetGridPoints$1 = function (l, w, h) {
    void 0 === h ? (h = InitPoints(4)) : !0 === h && (h = globPoints$1);
    void 0 === l
      ? ((globWorldXY$2.x = 0), (globWorldXY$2.y = 0))
      : this.getWorldXY(l, w, globWorldXY$2);
    SetPoints$1(
      globWorldXY$2.x,
      globWorldXY$2.y,
      this.width,
      this.height,
      0 === this.mode ? 0 : 1,
      h
    );
    return h;
  },
  globWorldXY$2 = {},
  globPoints$1 = InitPoints(4),
  RingToTileXYArray$1 = function (l, w, h) {
    void 0 === h && (h = []);
    var t;
    var a = w;
    for (t = -w; t <= w; t++) h.push(Offset$2(l, a, t));
    t = w;
    for (a = w - 1; a >= -w; a--) h.push(Offset$2(l, a, t));
    a = -w;
    for (t = w - 1; t >= -w; t--) h.push(Offset$2(l, a, t));
    t = -w;
    for (a = -w + 1; a <= w - 1; a++) h.push(Offset$2(l, a, t));
    return h;
  };
class QuadGrid extends Quad {
  constructor(l) {
    super(l);
    this.sides = 4;
  }
  get allDirections() {
    return 4 === this.directions ? ALLDIR4 : ALLDIR8;
  }
  get halfDirections() {
    return 4 === this.directions ? HALFDIR4 : HALFDIR8;
  }
}
const ALLDIR4 = [0, 1, 2, 3],
  ALLDIR8 = [0, 1, 2, 3, 4, 5, 6, 7],
  HALFDIR4 = [0, 1],
  HALFDIR8 = [0, 1, 4, 5];
var methods$7 = {
  saveOrigin: SaveOrigin,
  restoreOrigin: RestoreOrigin,
  getTileXYAtDirection: GetTileXAtDirection$1,
  getNeighborTileXY: GetNeighborTileXY$1,
  getNeighborTileDirection: GetNeighborTileDirection$1,
  getOppositeDirection: GetOppositeDirection$1,
  offset: Offset$2,
  mirror: Mirror$3,
  rotate: Rotate$4,
  getDistance: GetDistance$1,
  directionBetween: DirectionBetween$1,
  directionNormalize: DirectionNormalize,
  getGridPoints: GetGridPoints$1,
  ringToTileXYArray: RingToTileXYArray$1,
};
Object.assign(QuadGrid.prototype, methods$7);
const SQRT3$1 = Math.sqrt(3);
var Width = function (l) {
  return 0 === l.type ? 2 * l.size : SQRT3$1 * l.size;
};
const SQRT3 = Math.sqrt(3);
var Height = function (l) {
    return 0 === l.type ? SQRT3 * l.size : 2 * l.size;
  },
  CONST$3 = {
    ODD_R: 0,
    EVEN_R: 1,
    ODD_Q: 2,
    EVEN_Q: 3,
  };
const ODD_R$7 = CONST$3.ODD_R,
  EVEN_R$7 = CONST$3.EVEN_R,
  ODD_Q$6 = CONST$3.ODD_Q,
  EVEN_Q$6 = CONST$3.EVEN_Q;
var GetWorldXY = function (l, w, h) {
    void 0 === h ? (h = {}) : !0 === h && (h = globWorldXY$1);
    var t = l * this.width,
      a = w * this.height;
    switch (this.mode) {
      case CONST$3.ODD_R:
        w & 1 && (t += this._halfWidth);
        a *= 0.75;
        break;
      case CONST$3.EVEN_R:
        w & 1 && (t -= this._halfWidth);
        a *= 0.75;
        break;
      case CONST$3.ODD_Q:
        t *= 0.75;
        l & 1 && (a += this._halfHeight);
        break;
      case CONST$3.EVEN_Q:
        (t *= 0.75), l & 1 && (a -= this._halfHeight);
    }
    t += this.x;
    a += this.y;
    h.x = t;
    h.y = a;
    return h;
  },
  globWorldXY$1 = {},
  GetWorldX = function (l, w) {
    return this.getWorldXY(l, w, !0).x;
  },
  GetWorldY = function (l, w) {
    return this.getWorldXY(l, w, !0).y;
  };
const ODD_R$6 = CONST$3.ODD_R,
  EVEN_R$6 = CONST$3.EVEN_R,
  ODD_Q$5 = CONST$3.ODD_Q,
  EVEN_Q$5 = CONST$3.EVEN_Q;
var cr2cube = function (l, w, h, t) {
    void 0 === t ? (t = {}) : !0 === t && (t = globCube$1);
    switch (l) {
      case CONST$3.ODD_R:
        t.x = w - (h - (h & 1)) / 2;
        t.z = h;
        break;
      case CONST$3.EVEN_R:
        t.x = w - (h + (h & 1)) / 2;
        t.z = h;
        break;
      case CONST$3.ODD_Q:
        t.x = w;
        t.z = h - (w - (w & 1)) / 2;
        break;
      case CONST$3.EVEN_Q:
        (t.x = w), (t.z = h - (w + (w & 1)) / 2);
    }
    t.y = -t.x - t.z;
    return t;
  },
  roundcube = function (l, w, h, t) {
    "number" !== typeof l && ((t = l), (l = t.x), (w = t.y), (h = t.z));
    void 0 === t ? (t = {}) : !0 === t && (t = globCube$1);
    var a = Math.round(l),
      d = Math.round(w),
      k = Math.round(h);
    l = Math.abs(a - l);
    w = Math.abs(d - w);
    h = Math.abs(k - h);
    l > w && l > h ? (a = -d - k) : w > h ? (d = -a - k) : (k = -a - d);
    t.x = a;
    t.y = d;
    t.z = k;
    return t;
  },
  cube2cr = function (l, w, h, t, a) {
    void 0 === a ? (a = {}) : !0 === a && (a = globCR);
    switch (l) {
      case CONST$3.ODD_R:
        a.x = w + (t - (t & 1)) / 2;
        a.y = t;
        break;
      case CONST$3.EVEN_R:
        a.x = w + (t + (t & 1)) / 2;
        a.y = t;
        break;
      case CONST$3.ODD_Q:
        a.x = w;
        a.y = t + (w - (w & 1)) / 2;
        break;
      case CONST$3.EVEN_Q:
        (a.x = w), (a.y = t + (w + (w & 1)) / 2);
    }
    return a;
  },
  qr2cube = function (l, w, h) {
    void 0 === h ? (h = {}) : !0 === h && (h = globCube$1);
    h.x = l;
    h.y = -l - w;
    h.z = w;
    return h;
  },
  globCube$1 = {},
  globCR = {};
const ODD_R$5 = CONST$3.ODD_R,
  EVEN_R$5 = CONST$3.EVEN_R,
  ODD_Q$4 = CONST$3.ODD_Q,
  EVEN_Q$4 = CONST$3.EVEN_Q,
  C4DIV3 = 4 / 3,
  C2DIV3 = 2 / 3;
var GetTileXY = function (l, w, h) {
    void 0 === h ? (h = {}) : !0 === h && (h = globTileXY$5);
    l -= this.x;
    w -= this.y;
    switch (this.mode) {
      case CONST$3.ODD_R:
      case CONST$3.EVEN_R:
        var t = (w * C4DIV3) / this.height;
        var a = l / this.width - (w / this.height) * C2DIV3;
        break;
      case CONST$3.ODD_Q:
      case CONST$3.EVEN_Q:
        (t = w / this.height - (l / this.width) * C2DIV3),
          (a = (l * C4DIV3) / this.width);
    }
    l = qr2cube(a, t, globCube);
    roundcube(l);
    cube2cr(this.mode, l.x, l.y, l.z, h);
    return h;
  },
  globCube = {},
  globTileXY$5 = {},
  GetTileX = function (l, w) {
    return this.getTileXY(l, w, !0).x;
  },
  GetTileY = function (l, w) {
    return this.getTileXY(l, w, !0).y;
  };
const ODD_R$4 = CONST$3.ODD_R,
  EVEN_R$4 = CONST$3.EVEN_R,
  ODD_Q$3 = CONST$3.ODD_Q,
  EVEN_Q$3 = CONST$3.EVEN_Q;
class Hexagon {
  constructor(l) {
    this.resetFromJSON(l);
  }
  resetFromJSON(l) {
    this.setType(
      GetValue$l(l, "staggeraxis", 1),
      GetValue$l(l, "staggerindex", 1)
    );
    this.setDirectionMode();
    this.setOriginPosition(GetValue$l(l, "x", 0), GetValue$l(l, "y", 0));
    var w = GetValue$l(l, "size", void 0);
    void 0 !== w
      ? this.setCellRadius(w)
      : this.setCellSize(
          GetValue$l(l, "cellWidth", 0),
          GetValue$l(l, "cellHeight", 0)
        );
  }
  setType(l, w) {
    "string" === typeof l && (l = STAGGERAXIS[l]);
    "string" === typeof w && (w = STAGGERINDEX[w]);
    this.staggeraxis = l;
    this.staggerindex = w;
    this.mode =
      0 === l
        ? 0 === w
          ? CONST$3.EVEN_Q
          : CONST$3.ODD_Q
        : 0 === w
        ? CONST$3.EVEN_R
        : CONST$3.ODD_R;
    return this;
  }
  setDirectionMode() {
    this.directions = 6;
    return this;
  }
  setOriginPosition(l, w) {
    this.x = l;
    this.y = w;
    return this;
  }
  get width() {
    return this._width;
  }
  set width(l) {
    this._width = l;
    this._halfWidth = l / 2;
  }
  get height() {
    return this._height;
  }
  set height(l) {
    this._height = l;
    this._halfHeight = l / 2;
  }
  setCellSize(l, w) {
    this.width = l;
    this.height = w;
    return this;
  }
  setCellRadius(l) {
    this.size = l;
    var w = {
      size: this.size,
      type: this.staggeraxis,
    };
    l = Width(w);
    w = Height(w);
    this.setCellSize(l, w);
    return this;
  }
  get cellWidth() {
    return this.width;
  }
  set cellWidth(l) {
    this.width = l;
  }
  get cellHeight() {
    return this.height;
  }
  set cellHeight(l) {
    this.height = l;
  }
}
var methods$6 = {
  getWorldXY: GetWorldXY,
  getWorldX: GetWorldX,
  getWorldY: GetWorldY,
  getTileXY: GetTileXY,
  getTileX: GetTileX,
  getTileY: GetTileY,
};
Object.assign(Hexagon.prototype, methods$6);
const STAGGERAXIS = {
    y: 0,
    x: 1,
  },
  STAGGERINDEX = {
    even: 0,
    odd: 1,
  },
  ODD_R$3 = [
    [
      [1, 0],
      [0, 1],
      [-1, 1],
      [-1, 0],
      [-1, -1],
      [0, -1],
    ],
    [
      [1, 0],
      [1, 1],
      [0, 1],
      [-1, 0],
      [0, -1],
      [1, -1],
    ],
  ],
  EVEN_R$3 = [
    [
      [1, 0],
      [1, 1],
      [0, 1],
      [-1, 0],
      [0, -1],
      [1, -1],
    ],
    [
      [1, 0],
      [0, 1],
      [-1, 1],
      [-1, 0],
      [-1, -1],
      [0, -1],
    ],
  ],
  ODD_Q$2 = [
    [
      [1, 0],
      [0, 1],
      [-1, 0],
      [-1, -1],
      [0, -1],
      [1, -1],
    ],
    [
      [1, 1],
      [0, 1],
      [-1, 1],
      [-1, 0],
      [0, -1],
      [1, 0],
    ],
  ],
  EVEN_Q$2 = [
    [
      [1, 1],
      [0, 1],
      [-1, 1],
      [-1, 0],
      [0, -1],
      [1, 0],
    ],
    [
      [1, 0],
      [0, 1],
      [-1, 0],
      [-1, -1],
      [0, -1],
      [1, -1],
    ],
  ],
  Neighbors$1 = [ODD_R$3, EVEN_R$3, ODD_Q$2, EVEN_Q$2],
  ODD_R$2 = CONST$3.ODD_R,
  EVEN_R$2 = CONST$3.EVEN_R,
  ODD_Q$1 = CONST$3.ODD_Q,
  EVEN_Q$1 = CONST$3.EVEN_Q;
var GetParity = function (l, w, h) {
    switch (l) {
      case CONST$3.ODD_R:
      case CONST$3.EVEN_R:
        var t = h & 1;
        break;
      case CONST$3.ODD_Q:
      case CONST$3.EVEN_Q:
        t = w & 1;
    }
    return t;
  },
  GetTileXAtDirection = function (l, w, h, t, a) {
    void 0 === a ? (a = {}) : !0 === a && (a = globTileXY$4);
    if (1 === t)
      (t = GetParity(this.mode, l, w)),
        (a.x = l + Neighbors$1[this.mode][t][h][0]),
        (a.y = w + Neighbors$1[this.mode][t][h][1]);
    else if (0 === t) (a.x = l), (a.y = w);
    else {
      l = cr2cube(this.mode, l, w, !0);
      switch (h) {
        case 1:
          h = l.x;
          w = l.y - t;
          t = l.z + t;
          break;
        case 2:
          h = l.x - t;
          w = l.y;
          t = l.z + t;
          break;
        case 3:
          h = l.x - t;
          w = l.y + t;
          t = l.z;
          break;
        case 4:
          h = l.x;
          w = l.y + t;
          t = l.z - t;
          break;
        case 5:
          h = l.x + t;
          w = l.y;
          t = l.z - t;
          break;
        default:
          (h = l.x + t), (w = l.y - t), (t = l.z);
      }
      cube2cr(this.mode, h, w, t, a);
    }
    return a;
  },
  globTileXY$4 = {},
  GetNeighborTileXY = function (l, w, h, t) {
    return GetTileXAtDirection.call(this, l, w, h, 1, t);
  },
  ReverseDirMap = function (l) {
    var w = {},
      h;
    for (h in l) {
      var t = l[h];
      var a = t[0];
      t = t[1];
      w.hasOwnProperty(a) || (w[a] = {});
      w[a][t] = parseInt(h);
    }
    return w;
  };
const Neighbors = [
  [ReverseDirMap(Neighbors$1[0][0]), ReverseDirMap(Neighbors$1[0][1])],
  [ReverseDirMap(Neighbors$1[1][0]), ReverseDirMap(Neighbors$1[1][1])],
  [ReverseDirMap(Neighbors$1[2][0]), ReverseDirMap(Neighbors$1[2][1])],
  [ReverseDirMap(Neighbors$1[3][0]), ReverseDirMap(Neighbors$1[3][1])],
];
var GetNeighborTileDirection = function (l, w) {
    var h = GetParity(this.mode, l.x, l.y);
    h = Neighbors[this.mode][h];
    var t = w.x - l.x;
    l = w.y - l.y;
    return h.hasOwnProperty(t) && ((w = h[t]), w.hasOwnProperty(l))
      ? w[l]
      : null;
  },
  GetOppositeDirection = function (l, w, h) {
    return (h + 3) % 6;
  };
const ODD_R$1 = CONST$3.ODD_R,
  EVEN_R$1 = CONST$3.EVEN_R,
  ODD_Q = CONST$3.ODD_Q,
  EVEN_Q = CONST$3.EVEN_Q;
var Offset$1 = function (l, w, h, t) {
    void 0 === t ? (t = {}) : !0 === t && (t = globTileXY$3);
    var a = l.x + w;
    l = l.y + h;
    switch (this.mode) {
      case CONST$3.ODD_R:
        0 !== (h & 1) && 0 === (l & 1) && (a += 1);
        break;
      case CONST$3.EVEN_R:
        0 !== (h & 1) && 0 === (l & 1) && --a;
        break;
      case CONST$3.ODD_Q:
        0 !== (w & 1) && 0 == (a & 1) && (l += 1);
        break;
      case CONST$3.EVEN_Q:
        0 !== (w & 1) && 0 == (a & 1) && --l;
    }
    t.x = a;
    t.y = l;
    return t;
  },
  globTileXY$3 = {};
const ODD_R = CONST$3.ODD_R,
  EVEN_R = CONST$3.EVEN_R;
var Mirror$2 = function (l, w, h) {
    void 0 === h ? (h = {}) : !0 === h && (h = globTileXY$2);
    l = cr2cube(this.mode, l.x, l.y, !0);
    var t = this.mode === CONST$3.ODD_R || this.mode === CONST$3.EVEN_R;
    if (w & 1) {
      if (t) {
        var a = l.y;
        var d = l.x;
        var k = l.z;
      } else (a = -l.x), (d = -l.z), (k = -l.y);
      l.x = a;
      l.y = d;
      l.z = k;
    }
    w & 2 &&
      (t
        ? ((a = -l.y), (d = -l.x), (k = -l.z))
        : ((a = l.x), (d = l.z), (k = l.y)));
    cube2cr(this.mode, a, d, k, h);
    return h;
  },
  globTileXY$2 = {},
  Rotate$3 = function (l, w, h) {
    void 0 === h ? (h = {}) : !0 === h && (h = globTileXY$1);
    w = Wrap(w, 0, 5);
    l = cr2cube(this.mode, l.x, l.y, !0);
    switch (w) {
      case 1:
        w = -l.z;
        var t = -l.x;
        l = -l.y;
        break;
      case 2:
        w = l.y;
        t = l.z;
        l = l.x;
        break;
      case 3:
        w = -l.x;
        t = -l.y;
        l = -l.z;
        break;
      case 4:
        w = l.z;
        t = l.x;
        l = l.y;
        break;
      case 5:
        w = -l.y;
        t = -l.z;
        l = -l.x;
        break;
      default:
        (w = l.x), (t = l.y), (l = l.z);
    }
    cube2cr(this.mode, w, t, l, h);
    return h;
  },
  globTileXY$1 = {},
  GetDistance = function (l, w, h) {
    cr2cube(this.mode, l.x, l.y, globCubeA$1);
    cr2cube(this.mode, w.x, w.y, globCubeB$1);
    return (
      (Math.abs(globCubeB$1.x - globCubeA$1.x) +
        Math.abs(globCubeB$1.y - globCubeA$1.y) +
        Math.abs(globCubeB$1.z - globCubeA$1.z)) /
      2
    );
  },
  globCubeA$1 = {},
  globCubeB$1 = {},
  DirectionBetween = function (l, w, h) {
    void 0 === h && (h = !0);
    cr2cube(this.mode, l.x, l.y, globCubeA);
    cr2cube(this.mode, w.x, w.y, globCubeB);
    l = globCubeB.x - globCubeA.x;
    w = globCubeB.y - globCubeA.y;
    var t = globCubeB.z - globCubeA.z;
    l =
      0 === t
        ? 0 < l
          ? 0
          : 3
        : 0 === l
        ? 0 < t
          ? 1
          : 4
        : 0 === w
        ? 0 < t
          ? 2
          : 5
        : 0 < l && 0 > w && 0 < t
        ? t / -w
        : 0 > l && 0 > w && 0 < t
        ? 1 + -w / t
        : 0 > l && 0 < w && 0 < t
        ? 2 + w / -l
        : 0 > l && 0 < w && 0 > t
        ? 3 + -t / w
        : 0 < l && 0 < w && 0 > t
        ? 4 + l / -t
        : 5 + -w / l;
    h && (l = Math.round(l));
    return l;
  },
  globCubeA = {},
  globCubeB = {};
const DEG_TO_RAD = Math.PI / 180;
var DegToRad$3 = function (l) {
    return l * DEG_TO_RAD;
  },
  SetPoints = function (l, w, h, t, a) {
    void 0 === a && (a = InitPoints(6));
    if (void 0 !== h)
      if ("number" === typeof h) {
        t = 0 === t ? 0 : -30;
        for (var d, k = 0; 6 > k; k++)
          (d = 60 * k + t),
            (d = DegToRad$3(d)),
            (a[k].x = l + h * Math.cos(d)),
            (a[k].y = w + h * Math.sin(d));
      } else {
        d = h.width;
        k = h.height;
        h = d / 2;
        d /= 4;
        var e = k / 2;
        k /= 4;
        0 === t
          ? ((a[0].x = l + h),
            (a[0].y = w),
            (a[1].x = l + d),
            (a[1].y = w + e),
            (a[2].x = l - d),
            (a[2].y = w + e),
            (a[3].x = l - h),
            (a[3].y = w),
            (a[4].x = l - d),
            (a[4].y = w - e),
            (a[5].x = l + d))
          : ((a[0].x = l + h),
            (a[0].y = w - k),
            (a[1].x = l + h),
            (a[1].y = w + k),
            (a[2].x = l),
            (a[2].y = w + e),
            (a[3].x = l - h),
            (a[3].y = w + k),
            (a[4].x = l - h),
            (a[4].y = w - k),
            (a[5].x = l));
        a[5].y = w - e;
      }
    return a;
  },
  GetGridPoints = function (l, w, h) {
    void 0 === h ? (h = InitPoints(6)) : !0 === h && (h = globPoints);
    void 0 === l
      ? ((globWorldXY.x = 0), (globWorldXY.y = 0))
      : this.getWorldXY(l, w, globWorldXY);
    void 0 !== this.size
      ? (l = this.size)
      : ((l = globSize), (l.width = this.width), (l.height = this.height));
    SetPoints(globWorldXY.x, globWorldXY.y, l, this.staggeraxis, h);
    return h;
  },
  globPoints = InitPoints(6),
  globWorldXY = {},
  globSize = {},
  RingToTileXYArray = function (l, w, h) {
    void 0 === h && (h = []);
    var t = cr2cube(this.mode, l.x, l.y, !0);
    l = t.x;
    var a = t.y;
    t = t.z;
    var d;
    var k = w;
    for (d = 0; d >= -w; d--) {
      var e = -d - k;
      h.push(cube2cr(this.mode, l + d, a + e, t + k));
    }
    d = -w;
    for (e = 1; e <= w; e++)
      (k = -d - e), h.push(cube2cr(this.mode, l + d, a + e, t + k));
    e = w;
    for (k = -1; k >= -w; k--)
      (d = -e - k), h.push(cube2cr(this.mode, l + d, a + e, t + k));
    k = -w;
    for (d = 1; d <= w; d++)
      (e = -d - k), h.push(cube2cr(this.mode, l + d, a + e, t + k));
    d = w;
    for (e = -1; e >= -w; e--)
      (k = -d - e), h.push(cube2cr(this.mode, l + d, a + e, t + k));
    e = -w;
    for (k = 1; k <= w - 1; k++)
      (d = -e - k), h.push(cube2cr(this.mode, l + d, a + e, t + k));
    return h;
  };
class HexagonGrid extends Hexagon {
  constructor(l) {
    super(l);
    this.sides = 6;
  }
  get allDirections() {
    return ALLDIR;
  }
  get halfDirections() {
    return HALFDIR;
  }
}
const ALLDIR = [0, 1, 2, 3, 4, 5],
  HALFDIR = [0, 1, 2];
var methods$5 = {
  saveOrigin: SaveOrigin,
  restoreOrigin: RestoreOrigin,
  getTileXYAtDirection: GetTileXAtDirection,
  getNeighborTileXY: GetNeighborTileXY,
  getNeighborTileDirection: GetNeighborTileDirection,
  getOppositeDirection: GetOppositeDirection,
  offset: Offset$1,
  mirror: Mirror$2,
  rotate: Rotate$3,
  getDistance: GetDistance,
  directionBetween: DirectionBetween,
  directionNormalize: DirectionNormalize,
  getGridPoints: GetGridPoints,
  ringToTileXYArray: RingToTileXYArray,
};
Object.assign(HexagonGrid.prototype, methods$5);
var DefaultGrids = {
  quadGrid: QuadGrid,
  hexagonGrid: HexagonGrid,
};
class Board$1 extends EventEmitter {
  constructor(l, w) {
    super();
    this.isShutdown = !1;
    this.scene = l;
    this.boardData = new BoardData();
    this.resetFromJSON(w);
    this.boot();
  }
  resetFromJSON(l) {
    this.isBoard = GetValue$l(l, "isBoard", !0);
    this.setGrid(GetValue$l(l, "grid", void 0));
    this.setWrapMode(GetValue$l(l, "wrap", !1));
    this.setInfinityMode(GetValue$l(l, "infinity", !1));
    this.setBoardWidth(GetValue$l(l, "width", 0));
    this.setBoardHeight(GetValue$l(l, "height", 0));
    return this;
  }
  boot() {
    if (this.scene && this.isBoard)
      this.scene.sys.events.once("shutdown", this.destroy, this);
  }
  shutdown(l) {
    if (!this.isShutdown)
      return (
        this.scene &&
          this.isBoard &&
          this.scene.sys.events.off("shutdown", this.destroy, this),
        this.isBoard && this.removeAllChess(!l, !0),
        super.shutdown(),
        this.boardData.shutdown(l),
        (this.boardData = this.scene = void 0),
        (this.isShutdown = !0),
        this
      );
  }
  destroy(l) {
    this.isShutdown || (this.emit("destroy", this, l), this.shutdown(l));
  }
  setGrid(l) {
    if (IsPlainObject(l)) {
      var w = GetValue$l(l, "gridType", "quadGrid");
      l = new DefaultGrids[w](l);
    }
    this.grid = l;
    return this;
  }
  setWrapMode(l) {
    void 0 === l && (l = !0);
    this.wrapMode = l;
    return this;
  }
  setInfinityMode(l) {
    void 0 === l && (l = !0);
    this.infinityMode = l;
    return this;
  }
  setBoardSize(l, w) {
    this.setBoardWidth(l);
    this.setBoardHeight(w);
    return this;
  }
  exists(l) {
    return this.boardData.exists(this.getChessUID(l));
  }
  get chessCount() {
    return this.boardData.chessCount;
  }
  clear(l) {
    void 0 === l && (l = !0);
    this.removeAllChess(l, !0);
    this.boardData.clear();
    return this;
  }
  static GetBoard(l) {
    return GetBoard(l);
  }
}
Object.assign(Board$1.prototype, LogicMethods);
const Zone$1 = Phaser.GameObjects.Zone;
class TouchZone extends Zone$1 {
  constructor(l) {
    super(l, 0, 0, 1, 1);
    l.add.existing(this);
    this.setScrollFactor(0);
    this.setInteractive({
      hitArea: {},
      hitAreaCallback: function () {
        return !0;
      },
    });
  }
}
const RENDER_MASK = Phaser.GameObjects.GameObject.RENDER_MASK;
var InputCandidate = function (l) {
    if (l.renderFlags !== RENDER_MASK) return !1;
    var w = !0;
    if ((l = l.parentContainer)) {
      do {
        if (l.renderFlags !== RENDER_MASK) {
          w = !1;
          break;
        }
        l = l.parentContainer;
      } while (l);
    }
    return w;
  },
  EmitChessEvent = function (l, w, h, t, a, d) {
    if (null != t && null != a) {
      var k = "string" !== typeof l ? l : void 0,
        e = "string" !== typeof w ? w : void 0;
      t = h.tileXYToChessArray(t, a, globChessArray$3);
      for (var b = 0, c = t.length; b < c; b++)
        (a = t[b]),
          InputCandidate(a) &&
            (a.emit && (e ? e(a) : a.emit(w, d)), k ? k(a) : h.emit(l, d, a));
      globChessArray$3.length = 0;
    }
  },
  globChessArray$3 = [],
  OnPointerDown$1 = function (l) {
    if (this.enable && l.isDown) {
      var w = this.board;
      null === this.pointer && (this.pointer = l);
      var h = w.worldXYToTileXY(l.worldX, l.worldY, !0),
        t = h.x;
      h = h.y;
      this.prevTilePosition.x = this.tilePosition.x;
      this.prevTilePosition.y = this.tilePosition.y;
      this.tilePosition.x = t;
      this.tilePosition.y = h;
      w.contains(t, h) &&
        (w.emit("tiledown", l, this.tilePosition),
        w.emit("tileover", l, this.tilePosition),
        EmitChessEvent(
          function (a) {
            w.emit("gameobjectdown", l, a);
            w.emit("gameobjectover", l, a);
          },
          function (a) {
            a.emit("board.pointerdown", l);
            a.emit("board.pointerover", l);
          },
          w,
          t,
          h,
          l
        ));
    }
  },
  OnPointerUp$1 = function (l) {
    if (this.enable) {
      var w = this.board,
        h = w.worldXYToTileXY(l.worldX, l.worldY, !0),
        t = h.x;
      h = h.y;
      this.prevTilePosition.x = this.tilePosition.x;
      this.prevTilePosition.y = this.tilePosition.y;
      this.tilePosition.x = t;
      this.tilePosition.y = h;
      w.contains(t, h) &&
        (w.emit("tileup", l, this.tilePosition),
        w.emit("tileout", l, this.prevTilePosition),
        EmitChessEvent(
          function (a) {
            w.emit("gameobjectup", l, a);
            w.emit("gameobjectout", l, a);
          },
          function (a) {
            a.emit("board.pointerup", l);
            a.emit("board.pointerout", l);
          },
          w,
          t,
          h,
          l
        ),
        this.pointer === l && (this.pointer = null));
    }
  },
  OnPointerMove$1 = function (l) {
    if (this.enable) {
      var w = this.board,
        h = w.worldXYToTileXY(l.worldX, l.worldY, !0);
      if (!AreTileXYEqual(this.tilePosition, h)) {
        this.prevTilePosition.x = this.tilePosition.x;
        this.prevTilePosition.y = this.tilePosition.y;
        null != this.prevTilePosition.x &&
          null != this.prevTilePosition.y &&
          w.emit("tileout", l, this.prevTilePosition);
        var t = h.x;
        h = h.y;
        this.tilePosition.x = t;
        this.tilePosition.y = h;
        w.contains(t, h)
          ? (null === this.pointer && (this.pointer = l),
            w.emit("tilemove", l, this.tilePosition),
            w.emit("tileover", l, this.tilePosition),
            EmitChessEvent(
              "gameobjectout",
              "board.pointerout",
              w,
              this.prevTilePosition.x,
              this.prevTilePosition.y,
              l
            ),
            EmitChessEvent(
              function (a) {
                w.emit("gameobjectmove", l, a);
                w.emit("gameobjectover", l, a);
              },
              function (a) {
                a.emit("board.pointermove", l);
                a.emit("board.pointerover", l);
              },
              w,
              t,
              h,
              l
            ))
          : this.pointer === l && (this.pointer = null);
      }
    }
  };
const GetValue$j = Phaser.Utils.Objects.GetValue;
class TickTask extends ComponentBase {
  constructor(l, w) {
    super(l, w);
    this.tickingState = this.isPaused = this._isRunning = !1;
    this.setTickingMode(GetValue$j(w, "tickingMode", 1));
  }
  boot() {
    2 !== this.tickingMode || this.tickingState || this.startTicking();
  }
  shutdown(l) {
    this.isShutdown ||
      (this.stop(), this.tickingState && this.stopTicking(), super.shutdown(l));
  }
  setTickingMode(l) {
    "string" === typeof l && (l = TICKINGMODE[l]);
    this.tickingMode = l;
  }
  startTicking() {
    this.tickingState = !0;
  }
  stopTicking() {
    this.tickingState = !1;
  }
  get isRunning() {
    return this._isRunning;
  }
  set isRunning(l) {
    this._isRunning !== l &&
      ((this._isRunning = l),
      1 === this.tickingMode &&
        l != this.tickingState &&
        (l ? this.startTicking() : this.stopTicking()));
  }
  start() {
    this.isPaused = !1;
    this.isRunning = !0;
    return this;
  }
  pause() {
    this.isRunning && ((this.isPaused = !0), (this.isRunning = !1));
    return this;
  }
  resume() {
    this.isPaused && (this.isRunning = !0);
    return this;
  }
  stop() {
    this.isRunning = this.isPaused = !1;
    return this;
  }
  complete() {
    this.isRunning = this.isPaused = !1;
    this.emit("complete", this.parent, this);
  }
}
const TICKINGMODE = {
    no: 0,
    lazy: 1,
    always: 2,
  },
  GetValue$i = Phaser.Utils.Objects.GetValue;
class OnePointerTracer extends TickTask {
  constructor(l, w) {
    var h = GetSceneObject(l);
    h === l && (l = void 0);
    super(h, w);
    (this.gameObject = l) &&
      l.setInteractive(GetValue$i(w, "inputConfig", void 0));
    this._enable = void 0;
    this.resetFromJSON(w);
    this.boot();
  }
  resetFromJSON(l) {
    this.setEnable(GetValue$i(l, "enable", !0));
    this.setDetectBounds();
    void 0 === this.gameObject
      ? this.setDetectBounds(GetValue$i(l, "bounds", void 0))
      : this.setDetectBounds();
    this.tracerState = TOUCH0$1;
    this.lastPointer = this.pointer = void 0;
    this.isTouchingAnyObject = this.movedState = !1;
    return this;
  }
  boot() {
    super.boot();
    if (this.gameObject)
      this.gameObject.on("pointerdown", this.onPointerDown, this);
    else this.scene.input.on("pointerdown", this.onPointerDown, this);
    this.scene.input.on("pointerup", this.onPointerUp, this);
    this.scene.input.on("gameout", this.dragCancel, this);
    this.scene.input.on("pointermove", this.onPointerMove, this);
    this.scene.sys.events.once("shutdown", this.destroy, this);
  }
  shutdown(l) {
    this.scene &&
      (this.gameObject ||
        this.scene.input.off("pointerdown", this.onPointerDown, this),
      this.scene.input.off("pointerup", this.onPointerUp, this),
      this.scene.input.off("gameout", this.dragCancel, this),
      this.scene.input.off("pointermove", this.onPointerMove, this),
      this.scene.sys.events.off("shutdown", this.destroy, this),
      (this.lastPointer =
        this.pointer =
        this.bounds =
        this.gameObject =
          void 0),
      (this.movedState = !1),
      super.shutdown(l));
  }
  get enable() {
    return this._enable;
  }
  set enable(l) {
    if (this._enable !== l)
      return l || this.dragCancel(), (this._enable = l), this;
  }
  setEnable(l) {
    void 0 === l && (l = !0);
    this.enable = l;
    return this;
  }
  setDetectBounds(l) {
    this.bounds = l;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
  onPointerDown(l, w) {
    !this.enable ||
      void 0 !== this.pointer ||
      (this.bounds && !this.bounds.contains(l.x, l.y)) ||
      this.pointer === l ||
      ((this.lastPointer = this.pointer = l),
      (this.movedState = !1),
      (this.tracerState = TOUCH1$1),
      void 0 === this.gameObject && (this.isTouchingAnyObject = 0 < w.length),
      this.onDragStart());
  }
  onPointerUp(l) {
    !this.enable ||
      (this.bounds && !this.bounds.contains(l.x, l.y)) ||
      this.pointer !== l ||
      ((this.pointer = void 0),
      (this.movedState = !1),
      (this.tracerState = TOUCH0$1),
      this.onDragEnd());
  }
  onPointerMove(l) {
    if (this.enable && l.isDown) {
      var w = this.bounds ? this.bounds.contains(l.x, l.y) : !0,
        h = this.pointer === l;
      if (h || !w)
        if (h && !w) this.onPointerUp(l);
        else if (
          (this.movedState ||
            (this.movedState = l.x !== l.downX || l.y !== l.downY),
          this.movedState)
        )
          this.onDrag();
    }
  }
  dragCancel() {
    if (this.tracerState === TOUCH1$1) this.onDragEnd();
    this.pointer = void 0;
    this.tracerState = TOUCH0$1;
    return this;
  }
  onDragStart() {
    this.emit("dragstart", this);
  }
  onDragEnd() {
    this.emit("dragend", this);
  }
  onDrag() {
    this.emit("drag", this);
  }
  preUpdate(l, w) {}
  postUpdate(l, w) {}
  startTicking() {
    super.startTicking();
    this.scene.sys.events.on("preupdate", this.preUpdate, this);
    this.scene.sys.events.on("postupdate", this.postUpdate, this);
  }
  stopTicking() {
    super.stopTicking();
    this.scene &&
      (this.scene.sys.events.off("preupdate", this.preUpdate, this),
      this.scene.sys.events.off("postupdate", this.postUpdate, this));
  }
  setRecongizedStateObject(l) {
    this.recongizedState = l;
    return this;
  }
  get state() {
    return this.recongizedState.state;
  }
  set state(l) {
    this.recongizedState.state = l;
  }
  cancel() {
    this.state = IDLE$8;
    return this;
  }
}
const TOUCH0$1 = 0,
  TOUCH1$1 = 1,
  IDLE$8 = "IDLE";
class FSM {
  constructor(l) {
    var w = GetValue$l(l, "states", void 0);
    w && this.addStates(w);
    if ((w = GetValue$l(l, "extend", void 0)))
      for (var h in w)
        (this.hasOwnProperty(h) && void 0 !== this[h]) || (this[h] = w[h]);
    h = GetValue$l(l, "eventEmitter", void 0);
    w = GetValue$l(l, "EventEmitterClass", void 0);
    this.setEventEmitter(h, w);
    this._stateLock = !1;
    this.resetFromJSON(l);
  }
  shutdown() {
    this.destroyEventEmitter();
  }
  destroy() {
    this.shutdown();
  }
  resetFromJSON(l) {
    this.setEnable(GetValue$l(l, "enable", !0));
    this.start(GetValue$l(l, "start", void 0));
    (l = GetValue$l(l, "init", void 0)) && l.call(this);
    return this;
  }
  toJSON() {
    return {
      curState: this.state,
      prevState: this.prevState,
      enable: this.enable,
      start: this._start,
    };
  }
  setEnable(l) {
    void 0 === l && (l = !0);
    this.enable = l;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
  set state(l) {
    if (this.enable && !this._stateLock && this._state !== l) {
      this._prevState = this._state;
      this._state = l;
      this._stateLock = !0;
      this.emit("statechange", this);
      if (null != this._prevState) {
        l = "exit_" + this._prevState;
        var w = this[l];
        w && w.call(this);
        this.emit(l, this);
      }
      this._stateLock = !1;
      null != this._state &&
        ((l = "enter_" + this._state),
        (w = this[l]) && w.call(this),
        this.emit(l, this));
    }
  }
  get state() {
    return this._state;
  }
  get prevState() {
    return this._prevState;
  }
  start(l) {
    this._start = l;
    this._prevState = void 0;
    this._state = l;
    return this;
  }
  goto(l) {
    null != l && (this.state = l);
    return this;
  }
  next() {
    var l,
      w = this["next_" + this.state];
    w && (l = "string" === typeof w ? w : w.call(this));
    this.goto(l);
    return this;
  }
  addState(l, w) {
    "string" !== typeof l && ((w = l), (l = w.name));
    var h = w.next;
    h && (this["next_" + l] = h);
    (h = w.exit) && (this["exit_" + l] = h);
    (w = w.enter) && (this["enter_" + l] = w);
    return this;
  }
  addStates(l) {
    if (Array.isArray(l))
      for (var w = 0, h = l.length; w < h; w++) this.addState(l[w]);
    else for (w in l) this.addState(w, l[w]);
    return this;
  }
  runMethod(l, w, h, t, a, d) {
    var k = this[l + "_" + this.state];
    if (k) {
      var e = arguments.length;
      switch (e) {
        case 1:
          return k.call(this);
        case 2:
          return k.call(this, w);
        case 3:
          return k.call(this, w, h);
        case 4:
          return k.call(this, w, h, t);
        case 5:
          return k.call(this, w, h, t, a);
        case 6:
          return k.call(this, w, h, t, a, d);
      }
      for (var b = Array(e - 1), c = 1; c < e; c++) b[c - 1] = arguments[c];
      return k.apply(this, b);
    }
  }
  update(l, w) {
    this.runMethod("update", l, w);
  }
  preupdate(l, w) {
    this.runMethod("preupdate", l, w);
  }
  postupdate(l, w) {
    this.runMethod("postupdate", l, w);
  }
}
Object.assign(FSM.prototype, EventEmitterMethods);
const GetValue$h = Phaser.Utils.Objects.GetValue,
  DistanceBetween$3 = Phaser.Math.Distance.Between;
class Tap extends OnePointerTracer {
  constructor(l, w) {
    super(l, w);
    var h = this;
    this.setRecongizedStateObject(
      new FSM({
        states: {
          IDLE: {
            enter: function () {
              h.stop();
              h.tapsCount = 0;
              h.x = 0;
              h.y = 0;
              h.worldX = 0;
              h.worldY = 0;
            },
            exit: function () {
              var t = h.lastPointer;
              h.x = t.x;
              h.y = t.y;
              h.worldX = t.worldX;
              h.worldY = t.worldY;
            },
          },
          BEGIN: {
            enter: function () {
              h.start();
              h.tapsCount = 0;
              h.emit("tappingstart", h, h.gameObject, h.lastPointer);
            },
          },
          RECOGNIZED: {
            enter: function () {
              h.start();
              h.emit("tap", h, h.gameObject, h.lastPointer);
              h.emit(`${h.tapsCount}tap`, h, h.gameObject, h.lastPointer);
            },
          },
        },
        init: function () {
          this.state = IDLE$7;
        },
        eventEmitter: !1,
      })
    );
  }
  resetFromJSON(l) {
    super.resetFromJSON(l);
    this.setHoldTime(GetValue$h(l, "time", 250));
    this.setTapInterval(GetValue$h(l, "tapInterval", 200));
    this.setDragThreshold(GetValue$h(l, "threshold", 9));
    this.setTapOffset(GetValue$h(l, "tapOffset", 10));
    var w = GetValue$h(l, "taps", void 0);
    void 0 !== w
      ? this.setTaps(w)
      : (this.setMaxTaps(GetValue$h(l, "maxTaps", void 0)),
        this.setMinTaps(GetValue$h(l, "minTaps", void 0)));
    return this;
  }
  onDragStart() {
    switch (this.state) {
      case IDLE$7:
        this.state = BEGIN$5;
        break;
      case BEGIN$5:
        var l = this.lastPointer;
        DistanceBetween$3(l.upX, l.upY, l.x, l.y) > this.tapOffset &&
          ((this.state = RECOGNIZED$5), (this.state = BEGIN$5));
        break;
      case RECOGNIZED$5:
        this.state = BEGIN$5;
    }
  }
  onDragEnd() {
    this.state === BEGIN$5 &&
      (this.tapsCount++,
      this.emit("tapping", this, this.gameObject, this.lastPointer),
      void 0 !== this.maxTaps &&
        this.tapsCount === this.maxTaps &&
        (this.state = RECOGNIZED$5));
  }
  onDrag() {
    this.state !== IDLE$7 &&
      this.pointer.getDistance() > this.dragThreshold &&
      (this.state = IDLE$7);
  }
  preUpdate(l, w) {
    this.isRunning &&
      this.enable &&
      this.state === BEGIN$5 &&
      ((w = this.lastPointer),
      w.isDown
        ? l - w.downTime > this.holdTime && (this.state = IDLE$7)
        : l - w.upTime > this.tapInterval &&
          (this.state =
            void 0 === this.minTaps || this.tapsCount >= this.minTaps
              ? RECOGNIZED$5
              : IDLE$7));
  }
  postUpdate(l, w) {
    this.isRunning &&
      this.enable &&
      this.state === RECOGNIZED$5 &&
      (this.state = IDLE$7);
  }
  get isTapped() {
    return this.state === RECOGNIZED$5;
  }
  setHoldTime(l) {
    this.holdTime = l;
    return this;
  }
  setTapInterval(l) {
    this.tapInterval = l;
    return this;
  }
  setDragThreshold(l) {
    this.dragThreshold = l;
    return this;
  }
  setTapOffset(l) {
    this.tapOffset = l;
    return this;
  }
  setMaxTaps(l) {
    this.maxTaps = l;
    return this;
  }
  setMinTaps(l) {
    this.minTaps = l;
    return this;
  }
  setTaps(l, w) {
    void 0 === w && (w = l);
    this.setMinTaps(l).setMaxTaps(w);
    return this;
  }
}
const IDLE$7 = "IDLE",
  BEGIN$5 = "BEGIN",
  RECOGNIZED$5 = "RECOGNIZED";
var InstallTap = function () {
    var l = new Tap(this.touchZone ? this.touchZone : this.board.scene);
    l.on("tap", OnTap, this);
    return l;
  },
  OnTap = function (l) {
    var w = this.board,
      h = w.worldXYToTileXY(l.worldX, l.worldY),
      t = h.x,
      a = h.y;
    w.contains(t, a) &&
      (w.emit("tiletap", l, h),
      w.emit(`tile${l.tapsCount}tap`, l, h),
      EmitChessEvent(
        function (d) {
          w.emit("gameobjecttap", l, d);
          w.emit(`gameobject${l.tapsCount}tap`, l, d);
        },
        function (d) {
          d.emit("board.tap", l);
          d.emit(`board.${l.tapsCount}tap`, l);
        },
        w,
        t,
        a,
        l
      ));
  };
const GetValue$g = Phaser.Utils.Objects.GetValue;
class Press extends OnePointerTracer {
  constructor(l, w) {
    super(l, w);
    var h = this;
    this.setRecongizedStateObject(
      new FSM({
        states: {
          IDLE: {
            enter: function () {
              h.x = 0;
              h.y = 0;
              h.worldX = 0;
              h.worldY = 0;
            },
            exit: function () {
              var t = h.lastPointer;
              h.x = t.x;
              h.y = t.y;
              h.worldX = t.worldX;
              h.worldY = t.worldY;
            },
          },
          BEGIN: {
            enter: function () {
              h.start();
            },
            exit: function () {
              h.stop();
            },
          },
          RECOGNIZED: {
            enter: function () {
              h.emit("pressstart", h, h.gameObject, h.lastPointer);
            },
            exit: function () {
              h.emit("pressend", h, h.gameObject, h.lastPointer);
            },
          },
        },
        init: function () {
          this.state = IDLE$6;
        },
        eventEmitter: !1,
      })
    );
  }
  resetFromJSON(l) {
    super.resetFromJSON(l);
    this.setDragThreshold(GetValue$g(l, "threshold", 9));
    this.setHoldTime(GetValue$g(l, "time", 251));
    return this;
  }
  onDragStart() {
    this.state = BEGIN$4;
    0 === this.holdTime && (this.state = RECOGNIZED$4);
  }
  onDragEnd() {
    this.state = IDLE$6;
  }
  onDrag() {
    this.state !== IDLE$6 &&
      this.pointer.getDistance() > this.dragThreshold &&
      (this.state = IDLE$6);
  }
  preUpdate(l, w) {
    this.isRunning &&
      this.enable &&
      this.state === BEGIN$4 &&
      l - this.pointer.downTime >= this.holdTime &&
      (this.state = RECOGNIZED$4);
  }
  get isPressed() {
    return this.state === RECOGNIZED$4;
  }
  setHoldTime(l) {
    this.holdTime = l;
    return this;
  }
  setDragThreshold(l) {
    this.dragThreshold = l;
    return this;
  }
}
const IDLE$6 = "IDLE",
  BEGIN$4 = "BEGIN",
  RECOGNIZED$4 = "RECOGNIZED";
var InstallPress = function () {
    var l = new Press(this.touchZone ? this.touchZone : this.board.scene);
    l.on("pressstart", OnPressStart, this).on("pressend", OnPressEnd, this);
    return l;
  },
  OnPressStart = function (l) {
    var w = this.board,
      h = w.worldXYToTileXY(l.worldX, l.worldY),
      t = h.x,
      a = h.y;
    w.contains(t, a) &&
      (w.emit("tilepressstart", l, h),
      EmitChessEvent("gameobjectpressstart", "board.pressstart", w, t, a, l));
  },
  OnPressEnd = function (l) {
    var w = this.board,
      h = w.worldXYToTileXY(l.worldX, l.worldY),
      t = h.x,
      a = h.y;
    w.contains(t, a) &&
      (w.emit("tilepressend", l, h),
      EmitChessEvent("gameobjectpressend", "board.pressend", w, t, a, l));
  };
const DistanceBetween$2 = Phaser.Math.Distance.Between,
  AngleBetween$3 = Phaser.Math.Angle.Between;
var VelocityMethods = {
    getDt: function () {
      return this.scene.sys.game.loop.delta;
    },
    getVelocity: function () {
      var l = this.pointer.position,
        w = this.pointer.prevPosition;
      return DistanceBetween$2(w.x, w.y, l.x, l.y) / (0.001 * this.getDt());
    },
    getVelocityX: function () {
      return (
        Math.abs(this.pointer.position.x - this.pointer.prevPosition.x) /
        (0.001 * this.getDt())
      );
    },
    getVelocityY: function () {
      return (
        Math.abs(this.pointer.position.y - this.pointer.prevPosition.y) /
        (0.001 * this.getDt())
      );
    },
    getVelocityAngle: function () {
      var l = this.pointer.position,
        w = this.pointer.prevPosition;
      return AngleBetween$3(w.x, w.y, l.x, l.y);
    },
  },
  DIRMODE$1 = {
    "up&down": 0,
    "left&right": 1,
    "4dir": 2,
    "8dir": 3,
  },
  AngleToDirections = function (l, w, h) {
    void 0 === h ? (h = {}) : !0 === h && (h = globOut);
    h.left = !1;
    h.right = !1;
    h.up = !1;
    h.down = !1;
    l = (l + 360) % 360;
    switch (w) {
      case 0:
        180 > l ? (h.down = !0) : (h.up = !0);
        break;
      case 1:
        90 < l && 270 >= l ? (h.left = !0) : (h.right = !0);
        break;
      case 2:
        45 < l && 135 >= l
          ? (h.down = !0)
          : 135 < l && 225 >= l
          ? (h.left = !0)
          : 225 < l && 315 >= l
          ? (h.up = !0)
          : (h.right = !0);
        break;
      case 3:
        22.5 < l && 67.5 >= l
          ? ((h.down = !0), (h.right = !0))
          : 67.5 < l && 112.5 >= l
          ? (h.down = !0)
          : 112.5 < l && 157.5 >= l
          ? ((h.down = !0), (h.left = !0))
          : 157.5 < l && 202.5 >= l
          ? (h.left = !0)
          : 202.5 < l && 247.5 >= l
          ? ((h.left = !0), (h.up = !0))
          : 247.5 < l && 292.5 >= l
          ? (h.up = !0)
          : (292.5 < l && 337.5 >= l && (h.up = !0), (h.right = !0));
    }
    return h;
  },
  globOut = {};
const GetValue$f = Phaser.Utils.Objects.GetValue,
  RadToDeg$2 = Phaser.Math.RadToDeg;
class Swipe extends OnePointerTracer {
  constructor(l, w) {
    super(l, w);
    var h = this;
    this.setRecongizedStateObject(
      new FSM({
        states: {
          IDLE: {
            enter: function () {
              h.x = 0;
              h.y = 0;
              h.worldX = 0;
              h.worldY = 0;
            },
            exit: function () {
              var t = h.lastPointer;
              h.x = t.x;
              h.y = t.y;
              h.worldX = t.worldX;
              h.worldY = t.worldY;
            },
          },
          BEGIN: {
            enter: function () {
              h.validDrag = !1;
            },
          },
          RECOGNIZED: {
            enter: function () {
              h.start();
              h.updateDirectionStates();
              h.emit("swipe", h, h.gameObject, h.lastPointer);
            },
            exit: function () {
              h.stop();
              h.clearDirectionStates();
            },
          },
        },
        init: function () {
          this.state = IDLE$5;
        },
        eventEmitter: !1,
      })
    );
    this.clearDirectionStates();
  }
  resetFromJSON(l) {
    super.resetFromJSON(l);
    this.setDragThreshold(GetValue$f(l, "threshold", 10));
    this.setVelocityThreshold(GetValue$f(l, "velocityThreshold", 1e3));
    this.setDirectionMode(GetValue$f(l, "dir", "8dir"));
    return this;
  }
  onDragStart() {
    this.state = BEGIN$3;
  }
  onDragEnd() {
    this.state = IDLE$5;
  }
  onDrag() {
    this.state === BEGIN$3 &&
      (this.validDrag ||
        (this.validDrag =
          0 === this.dragThreshold ||
          this.pointer.getDistance() >= this.dragThreshold),
      this.validDrag &&
        this.dragVelocity > this.velocityThreshold &&
        (this.state = RECOGNIZED$3));
  }
  postUpdate(l, w) {
    this.isRunning &&
      this.enable &&
      this.state === RECOGNIZED$3 &&
      (this.state = IDLE$5);
  }
  get isSwiped() {
    return this.state === RECOGNIZED$3;
  }
  get dragVelocity() {
    switch (this.dirMode) {
      case 0:
        var l = this.getVelocityY();
        break;
      case 1:
        l = this.getVelocityX();
        break;
      default:
        l = this.getVelocity();
    }
    return l;
  }
  setDragThreshold(l) {
    this.dragThreshold = l;
    return this;
  }
  setVelocityThreshold(l) {
    this.velocityThreshold = l;
    return this;
  }
  setDirectionMode(l) {
    "string" === typeof l && (l = DIRMODE$1[l]);
    this.dirMode = l;
    return this;
  }
  updateDirectionStates() {
    var l = RadToDeg$2(this.getVelocityAngle());
    AngleToDirections(l, this.dirMode, this);
    return this;
  }
  clearDirectionStates() {
    this.down = this.up = this.right = this.left = !1;
    return this;
  }
}
Object.assign(Swipe.prototype, VelocityMethods);
const IDLE$5 = "IDLE",
  BEGIN$3 = "BEGIN",
  RECOGNIZED$3 = "RECOGNIZED";
var InstallSwipe = function () {
    var l = new Swipe(this.touchZone ? this.touchZone : this.board.scene);
    l.on("swipe", OnSwipe, this);
    return l;
  },
  OnSwipe = function (l) {
    var w = this.board,
      h = w.worldXYToTileXY(l.worldX, l.worldY),
      t = h.x,
      a = h.y;
    w.contains(t, a) &&
      ((l.direction = w.angleSnapToDirection(h, l.getVelocityAngle())),
      w.emit("tileswipe", l, h),
      EmitChessEvent("gameobjectswipe", "board.swipe", w, t, a, l));
  };
class Input {
  constructor(l, w) {
    var h = GetValue$l(w, "enable", !0);
    w = GetValue$l(w, "useTouchZone", !0);
    var t = l.scene;
    this.board = l;
    this.touchZone = void 0;
    this._enable = !0;
    this.pointer = null;
    this.tilePosition = {
      x: void 0,
      y: void 0,
    };
    this.prevTilePosition = {
      x: void 0,
      y: void 0,
    };
    w
      ? ((w = new TouchZone(t)),
        w.on("pointerdown", OnPointerDown$1, this),
        w.on("pointerup", OnPointerUp$1, this),
        w.on("pointermove", OnPointerMove$1, this),
        (this.touchZone = w))
      : (t.input.on("pointerdown", OnPointerDown$1, this),
        t.input.on("pointerup", OnPointerUp$1, this),
        t.input.on("pointermove", OnPointerMove$1, this));
    this.tap = InstallTap.call(this);
    this.press = InstallPress.call(this);
    this.swipe = InstallSwipe.call(this);
    l.once("destroy", this.onBoardDestroy, this);
    this.setEnable(h);
  }
  destroy(l) {
    this.tap.destroy(l);
    this.press.destroy(l);
    this.swipe.destroy(l);
    if (this.touchZone) this.touchZone.destroy(l), (this.touchZone = void 0);
    else if ((l = this.board.scene))
      l.input.off("pointerdown", OnPointerDown$1, this),
        l.input.off("pointerup", OnPointerUp$1, this),
        l.input.off("pointermove", OnPointerMove$1, this);
    this.board = void 0;
  }
  onBoardDestroy(l, w) {
    this.destroy(w);
  }
  get enable() {
    return this._enable;
  }
  set enable(l) {
    this._enable !== l &&
      (l || (this.pointer = null),
      (this._enable = l),
      this.touchZone &&
        (l
          ? this.touchZone.setInteractive()
          : this.touchZone.disableInteractive()),
      this.tap.setEnable(l),
      this.press.setEnable(l),
      this.swipe.setEnable(l));
  }
  setEnable(l) {
    void 0 === l && (l = !0);
    this.enable = l;
    return this;
  }
}
var SetInteractive$1 = function (l) {
  this.input
    ? this.input.setEnable(!1 === l ? !1 : !0)
    : (this.input = new Input(this, l));
  return this;
};
class Board extends Board$1 {
  get touchZone() {
    return this.input ? this.input.touchZone : null;
  }
  getTouchZone() {
    return this.touchZone;
  }
}
var methods$4 = {
  setInteractive: SetInteractive$1,
};
Object.assign(Board.prototype, methods$4);
var IsInValidKey = function (l) {
    return null == l || "" === l || 0 === l.length;
  },
  GetEntry = function (l, w, h) {
    if (!IsInValidKey(w)) {
      "string" === typeof w && (w = w.split("."));
      for (var t, a = 0, d = w.length; a < d; a++) {
        t = w[a];
        if (null == l[t] || "object" !== typeof l[t])
          l[t] = a === d - 1 ? (void 0 === h ? {} : h) : {};
        l = l[t];
      }
    }
    return l;
  },
  SetValue = function (l, w, h, t) {
    void 0 === t && (t = ".");
    if ("object" === typeof l) {
      if (IsInValidKey(w)) {
        if (null == h) return;
        "object" === typeof h && (l = h);
      } else
        "string" === typeof w && (w = w.split(t)),
          (t = w.pop()),
          (GetEntry(l, w)[t] = h);
      return l;
    }
  };
ObjectFactory$1.register("board", function (l) {
  return new Board(this.scene, l);
});
SetValue(window, "RexPlugins.Board.Board", Board);
ObjectFactory$1.register("hexagonGrid", function (l) {
  return new HexagonGrid(l);
});
ObjectFactory$1.register("quadGrid", function (l) {
  return new QuadGrid(l);
});
var IsMiniBoardObject = function (l) {
  return "rexMiniBoard" === l.type;
};
const Base$1 = Phaser.GameObjects.Polygon;
class Shape extends Base$1 {
  constructor(l, w, h, t, a, d, k) {
    void 0 === k && (k = !0);
    var e = IsMiniBoardObject(l);
    if (e) {
      var b = l;
      l = b.board;
    }
    var c = l.scene,
      f;
    if (k) var g = (f = 0);
    else (f = w), (g = h);
    var m = l.getGridPoints(void 0, void 0, !0);
    ShiftToO(m);
    super(c, f, g, m, a, d);
    k
      ? e
        ? b.addChess(this, w, h, t)
        : l.addChess(this, w, h, t, !0)
      : GetChessData(this);
  }
}
var ShiftToO = function (l) {
  for (var w = Infinity, h = Infinity, t, a = 0, d = l.length; a < d; a++)
    (t = l[a]), (w = Math.min(w, t.x)), (h = Math.min(h, t.y));
  if (0 === w && 0 === h) return l;
  a = 0;
  for (d = l.length; a < d; a++) (t = l[a]), (t.x -= w), (t.y -= h);
  return l;
};
ObjectFactory$1.register("shape", function (l, w, h, t, a, d, k) {
  w = new Shape(l, w, h, t, a, d, k);
  l.scene.add.existing(w);
  return w;
});
SetValue(window, "RexPlugins.Board.Shape", Shape);
class SceneUpdateTickTask extends TickTask {
  startTicking() {
    super.startTicking();
    this.scene.sys.events.on("update", this.update, this);
  }
  stopTicking() {
    super.stopTicking();
    this.scene && this.scene.sys.events.off("update", this.update, this);
  }
}
var CanMoveToTile$1 = function (l, w, h) {
    var t = this.chessData.board;
    if (null == t) return !1;
    var a = this.chessData.tileXYZ,
      d = a.y,
      k = a.z;
    return l === a.x && w === d
      ? !0
      : !t.contains(l, w) ||
        (this.blockerTest && t.hasBlocker(l, w)) ||
        (this.moveableTestCallback &&
          (void 0 === h && (h = this.chessData.getTileDirection(l, w)),
          (targetTileXY$3.x = l),
          (targetTileXY$3.y = w),
          (targetTileXY$3.z = k),
          this.moveableTestScope
            ? !this.moveableTestCallback.call(
                this.moveableTestScope,
                a,
                targetTileXY$3,
                h,
                t
              )
            : !this.moveableTestCallback(a, targetTileXY$3, h, t))) ||
        (this.occupiedTest &&
          !this.sneakMode &&
          (h = t.tileXYZToChess(l, w, k)) &&
          (this.emit("occupy", h, this.parent, this), t.contains(l, w, k)))
      ? !1
      : !0;
  },
  targetTileXY$3 = {
    x: 0,
    y: 0,
    z: 0,
  },
  GetSneakTileZ = function (l, w, h, t) {
    l = l.chessData.board;
    t = t.toString();
    do t += ".";
    while (l.contains(w, h, t));
    return t;
  },
  MoveToTile$1 = function (l, w, h) {
    var t = this.chessData.board;
    if (null === t) return (this.lastMoveResult = !1), this;
    if (null != l && "number" !== typeof l) {
      var a = l;
      l = GetValue$l(a, "x", void 0);
      w = GetValue$l(a, "y", void 0);
      h = GetValue$l(a, "direction", void 0);
    }
    a = this.chessData.tileXYZ;
    if ((void 0 !== h && null == l) || null == w)
      (w = t.getNeighborTileXY(a, h, !0)),
        null !== w ? ((l = w.x), (w = w.y)) : (w = l = null);
    if (null == l || null == w) return (this.lastMoveResult = !1), this;
    void 0 === h &&
      ((globTileXYZ.x = l),
      (globTileXYZ.y = w),
      (h = t.getNeighborTileDirection(a, globTileXYZ)));
    if (!this.canMoveTo(l, w, h)) return (this.lastMoveResult = !1), this;
    this.destinationTileX = l;
    this.destinationTileY = w;
    this.destinationDirection = h;
    if (t.wrapMode && null !== h)
      if (
        (t.grid.getNeighborTileXY(a.x, a.y, h, neighborTileXY),
        neighborTileXY.x === l && neighborTileXY.y === w)
      ) {
        var d = t.tileXYToWorldXY(l, w, !0);
        this.moveAlongLine(void 0, void 0, d.x, d.y);
      } else {
        d = t.tileXYToWorldXY(neighborTileXY.x, neighborTileXY.y, !0);
        var k = d.x,
          e = d.y;
        d = t.tileXYToWorldXY(a.x, a.y, !0);
        var b = d.x;
        d = d.y;
        this.moveAlongLine(void 0, void 0, (b + k) / 2, (d + e) / 2);
        k = t.getOppositeDirection(l, w, h);
        t.grid.getNeighborTileXY(l, w, k, neighborTileXY);
        d = t.tileXYToWorldXY(neighborTileXY.x, neighborTileXY.y, !0);
        k = d.x;
        e = d.y;
        d = t.tileXYToWorldXY(l, w, !0);
        h = d.x;
        d = d.y;
        this.addMoveLine((k + h) / 2, (e + d) / 2, h, d);
      }
    else
      (d = t.tileXYToWorldXY(l, w, !0)),
        this.moveAlongLine(void 0, void 0, d.x, d.y);
    a = a.z;
    this.sneakMode &&
      (void 0 === this.tileZSave
        ? t.contains(l, w, a) &&
          ((this.tileZSave = a),
          (a = GetSneakTileZ(this, l, w, this.tileZSave)))
        : t.contains(l, w, this.tileZSave)
        ? (a = GetSneakTileZ(this, l, w, this.tileZSave))
        : ((a = this.tileZSave), (this.tileZSave = void 0)));
    t.moveChess(this.parent, l, w, a, !1);
    this.lastMoveResult = this.isRunning = !0;
    return this;
  },
  globTileXYZ = {},
  neighborTileXY = {},
  MoveToward$1 = function (l) {
    this.moveTo(void 0, void 0, l);
    return this;
  },
  Clone = function (l, w) {
    var h = Array.isArray(l);
    void 0 === w ? (w = h ? [] : {}) : Clear(w);
    if (h) {
      w.length = l.length;
      h = 0;
      for (var t = l.length; h < t; h++) w[h] = l[h];
    } else for (t in l) w[t] = l[t];
    return w;
  },
  Shuffle = function (l) {
    for (var w = l.length - 1; 0 < w; w--) {
      var h = Math.floor(Math.random() * (w + 1)),
        t = l[w];
      l[w] = l[h];
      l[h] = t;
    }
    return l;
  },
  MoveToRandomNeighbor$1 = function () {
    var l = this.chessData.board;
    if (null === l) return (this.lastMoveResult = !1), this;
    l = l.grid.allDirections;
    globDirections$1.length !== l.length && Clone(l, globDirections$1);
    Shuffle(globDirections$1);
    l = 0;
    for (
      var w = globDirections$1.length;
      l < w && (this.moveToward(globDirections$1[l]), !this.lastMoveResult);
      l++
    );
    return this;
  },
  globDirections$1 = [],
  MoveAway = function (l, w, h) {
    var t = this.chessData.board;
    if (null === t) return (this.lastMoveResult = !1), this;
    "number" !== typeof l && ((w = l), (l = w.x), (w = w.y));
    targetTileXY$2.x = l;
    targetTileXY$2.y = w;
    void 0 === h && (h = !0);
    l = this.chessData.tileXYZ;
    var a = t.grid.allDirections;
    if (globChessInfo.length !== a.length + 1) {
      w = globChessInfo.length = 0;
      for (var d = a.length; w < d; w++)
        globChessInfo.push({
          direction: w,
        });
      globChessInfo.push({
        direction: null,
      });
    }
    w = 0;
    for (d = globChessInfo.length; w < d; w++) {
      a = globChessInfo[w];
      var k = a.direction;
      if (null === k) (a.x = l.x), (a.y = l.y);
      else if (((k = t.getNeighborTileXY(l, k, a)), null === k)) {
        a.x = null;
        a.y = null;
        a.distance = null;
        continue;
      }
      a.distance = t.getDistance(a, targetTileXY$2, !0);
    }
    var e = this.destinationDirection;
    globChessInfo.sort(function (b, c) {
      return null === b.distance
        ? 1
        : null === c.distance
        ? -1
        : b.distance > c.distance
        ? h
          ? -1
          : 1
        : b.distance < c.distance
        ? h
          ? 1
          : -1
        : b.direction === e
        ? 1
        : c.direction === e
        ? -1
        : null === b.direction
        ? 1
        : null === c.direction
        ? -1
        : 0;
    });
    w = 0;
    for (d = globChessInfo.length; w < d; w++) {
      a = globChessInfo[w];
      if (null === a.distance) break;
      this.moveTo(a);
      if (this.lastMoveResult) break;
    }
    return this;
  },
  targetTileXY$2 = {
    x: 0,
    y: 0,
  },
  globChessInfo = [],
  MoveCloser = function (l, w) {
    this.moveAway(l, w, !1);
    return this;
  },
  Methods$5 = {
    canMoveTo: CanMoveToTile$1,
    moveTo: MoveToTile$1,
    moveToward: MoveToward$1,
    moveToRandomNeighbor: MoveToRandomNeighbor$1,
    moveAway: MoveAway,
    moveCloser: MoveCloser,
  };
const GetValue$e = Phaser.Utils.Objects.GetValue,
  DistanceBetween$1 = Phaser.Math.Distance.Between,
  Lerp = Phaser.Math.Linear,
  AngleBetween$2 = Phaser.Math.Angle.Between;
class MoveTo$2 extends SceneUpdateTickTask {
  constructor(l, w) {
    super(l, w);
    this.resetFromJSON(w);
    this.boot();
  }
  resetFromJSON(l) {
    this.isRunning = GetValue$e(l, "isRunning", !1);
    this.setEnable(GetValue$e(l, "enable", !0));
    this.timeScale = GetValue$e(l, "timeScale", 1);
    this.setSpeed(GetValue$e(l, "speed", 400));
    this.setRotateToTarget(GetValue$e(l, "rotateToTarget", !1));
    this.targetX = GetValue$e(l, "targetX", 0);
    this.targetY = GetValue$e(l, "targetY", 0);
    return this;
  }
  toJSON() {
    return {
      isRunning: this.isRunning,
      enable: this.enable,
      timeScale: this.timeScale,
      speed: this.speed,
      rotateToTarget: this.rotateToTarget,
      targetX: this.targetX,
      targetY: this.targetY,
      tickingMode: this.tickingMode,
    };
  }
  setEnable(l) {
    void 0 == l && (l = !0);
    this.enable = l;
    return this;
  }
  setSpeed(l) {
    this.speed = l;
    return this;
  }
  setRotateToTarget(l) {
    this.rotateToTarget = l;
    return this;
  }
  moveTo(l, w) {
    "number" !== typeof l && ((w = l), (l = w.x), (w = w.y));
    this.targetX = l;
    this.targetY = w;
    super.start();
    return this;
  }
  moveFrom(l, w) {
    "number" !== typeof l && ((w = l), (l = w.x), (w = w.y));
    var h = this.parent,
      t = h.x,
      a = h.y;
    h.setPosition(l, w);
    this.moveTo(t, a);
    return this;
  }
  moveToward(l, w) {
    var h = this.parent;
    this.moveTo(h.x + Math.cos(l) * w, h.y + Math.sin(l) * w);
    return this;
  }
  update(l, w) {
    if (!this.isRunning || !this.enable) return this;
    l = this.parent;
    if (!l.active) return this;
    var h = l.x,
      t = l.y,
      a = this.targetX,
      d = this.targetY;
    if (h === a && t === d) return this.complete(), this;
    if (0 === this.speed || 0 === w || 0 === this.timeScale) return this;
    w = ((w * this.timeScale) / 1e3) * this.speed;
    var k = DistanceBetween$1(h, t, a, d);
    w < k && ((w /= k), (a = Lerp(h, a, w)), (d = Lerp(t, d, w)));
    l.setPosition(a, d);
    this.rotateToTarget && (l.rotation = AngleBetween$2(h, t, a, d));
    return this;
  }
}
class MoveTo$1 extends SceneUpdateTickTask {
  constructor(l, w) {
    super(l, w);
    this.chessData = GetChessData(l);
    this.scene = l.scene;
    this.moveToTask = new MoveTo$2(l, {
      tickingMode: 0,
    });
    this.resetFromJSON(w);
    this.boot();
  }
  resetFromJSON(l) {
    this.isRunning = GetValue$l(l, "isRunning", !1);
    this.setEnable(GetValue$l(l, "enable", !0));
    this.timeScale = GetValue$l(l, "timeScale", 1);
    this.setSpeed(GetValue$l(l, "speed", 400));
    this.setRotateToTarget(GetValue$l(l, "rotateToTarget", !1));
    this.setOccupiedTest(GetValue$l(l, "occupiedTest", !1));
    this.setBlockerTest(GetValue$l(l, "blockerTest", !1));
    this.setEdgeBlockerTest(GetValue$l(l, "edgeBlockerTest", !1));
    this.setMoveableTestCallback(
      GetValue$l(l, "moveableTest", void 0),
      GetValue$l(l, "moveableTestScope", void 0)
    );
    this.setSneakEnable(GetValue$l(l, "sneak", !1));
    this.destinationTileX = GetValue$l(l, "destinationTileX", null);
    this.destinationTileY = GetValue$l(l, "destinationTileY", null);
    this.destinationDirection = GetValue$l(l, "destinationDirection", null);
    this.lastMoveResult = GetValue$l(l, "lastMoveResult", void 0);
    return this;
  }
  toJSON() {
    return {
      isRunning: this.isRunning,
      enable: this.enable,
      timeScale: this.timeScale,
      speed: this.speed,
      occupiedTest: this.occupiedTest,
      blockerTest: this.blockerTest,
      edgeBlockerTest: this.edgeBlockerTest,
      moveableTest: this.moveableTestCallback,
      moveableTestScope: this.moveableTestScope,
      rotateToTarget: this.rotateToTarget,
      destinationTileX: this.destinationTileX,
      destinationTileY: this.destinationTileY,
      destinationDirection: this.destinationDirection,
      lastMoveResult: this.lastMoveResult,
      tickingMode: this.tickingMode,
    };
  }
  shutdown(l) {
    this.moveToTask.shutdown(l);
    super.shutdown(l);
  }
  set enable(l) {
    this.moveToTask.setEnable(l);
  }
  get enable() {
    return this.moveToTask.enable;
  }
  setEnable(l) {
    void 0 == l && (l = !0);
    this.enable = l;
    return this;
  }
  get timeScale() {
    return this.moveToTask.timeScale;
  }
  set timeScale(l) {
    this.moveToTask.timeScale = l;
  }
  set speed(l) {
    this.moveToTask.setSpeed(l);
  }
  get speed() {
    return this.moveToTask.speed;
  }
  setSpeed(l) {
    this.speed = l;
    return this;
  }
  set rotateToTarget(l) {
    this.moveToTask.setRotateToTarget(l);
  }
  get rotateToTarget() {
    return this.moveToTask.rotateToTarget;
  }
  setRotateToTarget(l) {
    void 0 === l && (l = !0);
    this.rotateToTarget = l;
    return this;
  }
  setOccupiedTest(l) {
    void 0 === l && (l = !0);
    this.occupiedTest = l;
    return this;
  }
  setBlockerTest(l) {
    void 0 === l && (l = !0);
    this.blockerTest = l;
    return this;
  }
  setEdgeBlockerTest(l) {
    void 0 === l && (l = !0);
    this.edgeBlockerTest = l;
    return this;
  }
  setMoveableTestCallback(l, w) {
    this.moveableTestCallback = l;
    this.moveableTestScope = w;
    return this;
  }
  setSneakEnable(l) {
    void 0 === l && (l = !0);
    this.sneakMode = l;
    this.tileZSave = void 0;
    return this;
  }
  moveAlongLine(l, w, h, t) {
    void 0 !== l && (this.parent.x = l);
    void 0 !== w && (this.parent.y = w);
    this.moveToTask.moveTo(h, t);
    return this;
  }
  addMoveLine(l, w, h, t) {
    this.moveToTask.hasOwnProperty("nextlines") ||
      (this.moveToTask.nextlines = []);
    this.moveToTask.nextlines.push([l, w, h, t]);
    return this;
  }
  moveNextLine() {
    var l = this.moveToTask.nextlines;
    if (!l || 0 === l.length) return !1;
    this.moveAlongLine.apply(this, l[0]);
    l.length = 0;
    return !0;
  }
  update(l, w) {
    if (!this.isRunning || !this.enable) return this;
    var h = this.moveToTask;
    h.update(l, w);
    h.isRunning || this.moveNextLine() || this.complete();
    return this;
  }
}
Object.assign(MoveTo$1.prototype, Methods$5);
var CanMoveToTile = function (l, w, h) {
    var t = this.parent,
      a = t.mainBoard;
    if (null == a) return !1;
    myTileXYZ.x = t.tileX;
    myTileXYZ.y = t.tileY;
    targetTileXYZ.x = l;
    targetTileXYZ.y = w;
    if (targetTileXYZ.x === myTileXYZ.x && targetTileXYZ.y === myTileXYZ.y)
      return !0;
    t.pullOutFromMainBoard();
    if (
      !t.canPutOnMainBoard(a, targetTileXYZ.x, targetTileXYZ.y) ||
      (this.moveableTestCallback &&
        (void 0 === h &&
          (h = a.getNeighborTileDirection(myTileXYZ, targetTileXYZ)),
        this.moveableTestScope
          ? !this.moveableTestCallback.call(
              this.moveableTestScope,
              myTileXYZ,
              targetTileXYZ,
              h,
              a
            )
          : !this.moveableTestCallback(myTileXYZ, targetTileXYZ, h, a)))
    )
      return t.putBack(), !1;
    t.putBack();
    return !0;
  },
  myTileXYZ = {
    x: 0,
    y: 0,
    z: 0,
  },
  targetTileXYZ = {
    x: 0,
    y: 0,
    z: 0,
  },
  MoveToTile = function (l, w, h) {
    var t = this.parent,
      a = t.mainBoard;
    if (null == a) return (this.lastMoveResult = !1), this;
    null != l &&
      "number" !== typeof l &&
      ((h = l),
      (l = GetValue$l(h, "x", void 0)),
      (w = GetValue$l(h, "y", void 0)),
      (h = GetValue$l(h, "direction", void 0)));
    myTileXY.x = t.tileX;
    myTileXY.y = t.tileY;
    if ((void 0 !== h && null == l) || null == w) {
      var d = a.getNeighborTileXY(myTileXY, h, !0);
      null !== d ? ((l = d.x), (w = d.y)) : (w = l = null);
    }
    if (null == l || null == w) return (this.lastMoveResult = !1), this;
    void 0 === h &&
      ((targetTileXY$1.x = l),
      (targetTileXY$1.y = w),
      (h = board.getNeighborTileDirection(myTileXY, targetTileXY$1)));
    if (!this.canMoveTo(l, w, h)) return (this.lastMoveResult = !1), this;
    this.destinationTileX = l;
    this.destinationTileY = w;
    this.destinationDirection = h;
    d = a.tileXYToWorldXY(l, w, !0);
    this.moveToTask.moveTo(d.x, d.y);
    t.putOnMainBoard(a, l, w, !1);
    this.lastMoveResult = this.isRunning = !0;
    return this;
  },
  myTileXY = {},
  targetTileXY$1 = {},
  MoveToward = function (l) {
    this.moveTo(void 0, void 0, l);
    return this;
  },
  MoveToRandomNeighbor = function () {
    var l = this.parent.mainBoard;
    if (null == l) return (this.lastMoveResult = !1), this;
    l = l.grid.allDirections;
    globDirections.length !== l.length && Clone(l, globDirections);
    Shuffle(globDirections);
    l = 0;
    for (
      var w = globDirections.length;
      l < w && (this.moveToward(globDirections[l]), !this.lastMoveResult);
      l++
    );
    return this;
  },
  globDirections = [];
class MoveTo extends SceneUpdateTickTask {
  constructor(l, w) {
    super(l, w);
    this.moveToTask = new MoveTo$2(l, {
      tickingMode: 0,
    });
    this.resetFromJSON(w);
    this.boot();
  }
  resetFromJSON(l) {
    this.isRunning = GetValue$l(l, "isRunning", !1);
    this.setEnable(GetValue$l(l, "enable", !0));
    this.timeScale = GetValue$l(l, "timeScale", 1);
    this.setSpeed(GetValue$l(l, "speed", 400));
    this.destinationTileX = GetValue$l(l, "destinationTileX", null);
    this.destinationTileY = GetValue$l(l, "destinationTileY", null);
    this.destinationDirection = GetValue$l(l, "destinationDirection", null);
    this.lastMoveResult = GetValue$l(l, "lastMoveResult", void 0);
    return this;
  }
  toJSON() {
    return {
      isRunning: this.isRunning,
      enable: this.enable,
      timeScale: this.timeScale,
      speed: this.speed,
      moveableTest: this.moveableTestCallback,
      moveableTestScope: this.moveableTestScope,
      destinationTileX: this.destinationTileX,
      destinationTileY: this.destinationTileY,
      destinationDirection: this.destinationDirection,
      lastMoveResult: this.lastMoveResult,
      tickingMode: this.tickingMode,
    };
  }
  shutdown(l) {
    this.isShutdown || (this.moveToTask.shutdown(l), super.shutdown(l));
  }
  set enable(l) {
    this.moveToTask.setEnable(l);
  }
  get enable() {
    return this.moveToTask.enable;
  }
  setEnable(l) {
    void 0 == l && (l = !0);
    this.enable = l;
    return this;
  }
  get timeScale() {
    return this.moveToTask.timeScale;
  }
  set timeScale(l) {
    this.moveToTask.timeScale = l;
  }
  set speed(l) {
    this.moveToTask.setSpeed(l);
  }
  get speed() {
    return this.moveToTask.speed;
  }
  setSpeed(l) {
    this.speed = l;
    return this;
  }
  moveAlongLine(l, w, h, t) {
    void 0 !== l && (this.parent.x = l);
    void 0 !== w && (this.parent.y = w);
    this.moveToTask.moveTo(h, t);
    return this;
  }
  update(l, w) {
    if (!this.isRunning || !this.enable) return this;
    var h = this.moveToTask;
    h.update(l, w);
    h.isRunning || this.complete();
    return this;
  }
}
var methods$3 = {
  canMoveTo: CanMoveToTile,
  moveTo: MoveToTile,
  moveToward: MoveToward,
  moveToRandomNeighbor: MoveToRandomNeighbor,
};
Object.assign(MoveTo.prototype, methods$3);
ObjectFactory$1.register("moveTo", function (l, w) {
  return new (IsMiniBoardObject(l) ? MoveTo : MoveTo$1)(l, w);
});
SetValue(window, "RexPlugins.Board.MoveTo", MoveTo$1);
SetValue(window, "RexPlugins.Board.MiniBoardMoveTo", MoveTo);
var MatchBoard = function (l, w, h, t) {
    for (
      var a = this.board,
        d = a.grid.halfDirections,
        k,
        e = this.dirMask,
        b = a.width,
        c = a.height,
        f,
        g,
        m = 0,
        n = d.length;
      m < n;
      m++
    )
      if (((k = d[m]), !1 !== e[k]))
        for (var q = 0; q < c; q++) {
          for (var r = 0; r < b; r++)
            if (((f = this.matchAtDir(l, r, q, k)), !1 !== f)) {
              w && (g = h ? w.call(h, f, a) : w(f, a));
              if (t) return f;
              if (g) break;
            }
          if (g) break;
        }
    return this;
  },
  MatchAtDir = function (l, w, h, t) {
    var a = "number" === typeof l;
    if (a) {
      var d = l;
      l = null;
    } else d = l.length;
    for (
      var k,
        e = this.wildcard,
        b,
        c = this.board,
        f = result.tileXY,
        g = (f.length = 0);
      g < d;
      g++
    ) {
      if (void 0 === b)
        b = {
          x: w,
          y: h,
        };
      else if (((b = c.getNeighborTileXY(b, t, b)), null === b)) return !1;
      k = this.getSymbol(b.x, b.y);
      if (null == k) return !1;
      if (k !== e)
        if (a)
          if (null === l) l = k;
          else {
            if (l !== k) return !1;
          }
        else if (l[g] !== k) return !1;
      f.push({
        x: b.x,
        y: b.y,
      });
    }
    result.direction = t;
    result.pattern = l;
    return result;
  },
  result = {
    tileXY: [],
    direction: void 0,
    pattern: void 0,
  },
  Group = function (l, w, h) {
    void 0 === h && (h = []);
    var t = this.board,
      a = this.wildcard,
      d = this.getSymbol(l, w);
    if (null == d || d === a) return h;
    void 0 === globalQueue && (globalQueue = new Queue());
    for (globalQueue.push(l, w); globalQueue.length; )
      if (
        ((l = globalQueue.pop()),
        (w = this.getSymbol(l.x, l.y)),
        w === d || w === a)
      )
        h.push(l), globalQueue.push(t.getNeighborTileXY(l));
    globalQueue.clear();
    return h;
  };
class Queue {
  constructor() {
    this.data = [];
    this.visited = {};
  }
  push(l, w) {
    if (IsArray(l)) {
      w = 0;
      for (var h = l.length; w < h; w++) this.push(l[w]);
      return this;
    }
    IsPlainObject(l) && ((w = l), (l = w.x), (w = w.y));
    h = `${l},${w}`;
    if (this.visited.hasOwnProperty(h)) return this;
    this.data.push({
      x: l,
      y: w,
    });
    this.visited[h] = !0;
    return this;
  }
  pop() {
    return this.data.pop();
  }
  get length() {
    return this.data.length;
  }
  clear() {
    Clear(this.data);
    Clear(this.visited);
    return this;
  }
}
var globalQueue,
  Methods$4 = {
    match: MatchBoard,
    matchAtDir: MatchAtDir,
    group: Group,
  },
  IsFunction = function (l) {
    return l && "function" === typeof l;
  };
class Match {
  constructor(l) {
    this.symbols = [];
    this.dirMask = {};
    this.resetFromJSON(l);
    this.boot();
  }
  resetFromJSON(l) {
    this.setBoard(GetValue$l(l, "board", void 0));
    this.setWildcard(GetValue$l(l, "wildcard", void 0));
    l = GetValue$l(l, "dirMask", void 0);
    void 0 !== l && this.setDirMask(l);
    return this;
  }
  boot() {}
  shutdown() {
    this.dirMask = this.symbols = this.board = void 0;
    return this;
  }
  destroy() {
    this.shutdown();
    return this;
  }
  setBoard(l) {
    (this.board = l) && this.clearSymbols();
    return this;
  }
  setDirMask(l, w) {
    if (IsPlainObject(l)) for (l in ((w = l), w)) this.dirMask[l] = w[l];
    else this.dirMask[l] = w;
    return this;
  }
  setDirectionMode(l) {
    this.board.grid.setDirectionMode(l);
    return this;
  }
  clearSymbols() {
    this.refreshSymbols(null);
    return this;
  }
  setSymbol(l, w, h) {
    if (!this.board.contains(l, w)) return this;
    this.symbols[this.tileXYToKey(l, w)] = h;
    return this;
  }
  getSymbol(l, w) {
    return this.symbols[this.tileXYToKey(l, w)];
  }
  forEach(l, w) {
    for (
      var h = this.board, t, a, d = 0, k = this.symbols.length;
      d < k &&
      !((a = this.symbols[d]),
      (t = this.keyToTileXY(d)),
      (t = w ? l.call(w, t, a, h) : l(t, a, h)));
      d++
    );
    return this;
  }
  refreshSymbols(l, w) {
    var h = this.board;
    this.symbols.length = h.width * h.height;
    if (IsFunction(l))
      for (var t = 0, a = this.symbols.length; t < a; t++) {
        var d = this.keyToTileXY(t, !0);
        d = w ? l.call(w, d, h) : l(d, h);
        this.symbols[t] = d;
      }
    else
      for (d = l, t = 0, a = this.symbols.length; t < a; t++)
        this.symbols[t] = d;
    return this;
  }
  setWildcard(l) {
    this.wildcard = l;
    return this;
  }
  tileXYToKey(l, w) {
    return l + w * this.board.width;
  }
  keyToTileXY(l, w) {
    void 0 === w ? (w = {}) : !0 === w && (w = globTileXY);
    var h = this.board.width;
    w.x = l % h;
    w.y = Math.floor(l / h);
    return w;
  }
  anyMatch(l) {
    return this.match(l, null, null, !0);
  }
}
var globTileXY = {
  x: 0,
  y: 0,
};
Object.assign(Match.prototype, Methods$4);
ObjectFactory$1.register("match", function (l) {
  return new Match(l);
});
SetValue(window, "RexPlugins.Board.Match", Match);
class Stack {
  constructor() {
    this.items = [];
  }
  destroy() {
    this.clear();
    this.items = void 0;
  }
  pop() {
    return 0 < this.items.length ? this.items.pop() : null;
  }
  push(l) {
    this.items.push(l);
    return this;
  }
  pushMultiple(l) {
    this.items.push.apply(this.items, l);
    l.length = 0;
    return this;
  }
  clear() {
    this.items.length = 0;
    return this;
  }
}
class _Node {
  constructor() {
    this.preNodes = [];
    this.manager = void 0;
  }
  reset(l) {
    this.manager = l;
    this.y = this.x = this.key = this.sn = void 0;
    this.isTileXYZ = !0;
    this.cost = this._py = this._px = void 0;
    this.closerH = this.h = this.g = this.f = 0;
    this.closed = this.visited = !1;
    this.preNodes.length = 0;
  }
  destroy() {
    this.preNodes.length = 0;
    this.manager = void 0;
  }
  heuristic(l, w, h) {
    if (null === w) return 0;
    var t = this.board.getDistance(l, this, !0) * this.pathFinder.weight;
    1 === w && void 0 !== h
      ? ((l = l.angleTo(h) - this.angleTo(h)), (t += Math.abs(l)))
      : (t = 2 === w ? t + Math.random() : t);
    return t;
  }
  getNeighborNodes() {
    var l = this.board.getNeighborTileXY(this);
    this.pathFinder.shuffleNeighbors && Shuffle(l);
    for (var w, h = [], t = 0, a = l.length; t < a; t++)
      (w = this.manager.getNode(l[t], !0)), h.push(w);
    return h;
  }
  getCost(l) {
    this.pathFinder.cacheCost
      ? void 0 === this.cost && (this.cost = this.pathFinder.getCost(this, l))
      : (this.cost = this.pathFinder.getCost(this, l));
    return this.cost;
  }
  angleTo(l) {
    return Between$1(this.worldX, this.wroldY, l.worldX, l.wroldY);
  }
  get pathFinder() {
    return this.manager.pathFinder;
  }
  get board() {
    return this.manager.pathFinder.board;
  }
  get worldX() {
    void 0 === this._px &&
      (this._px = this.board.tileXYToWroldX(this.x, this.y));
    return this._px;
  }
  get wroldY() {
    void 0 === this._py &&
      (this._py = this.board.tileXYToWroldY(this.x, this.y));
    return this._py;
  }
  get pathCost() {
    return this.g;
  }
}
var NodesPool = new Stack();
class NodeCache {
  constructor(l) {
    this.sn = 0;
    this.pool = NodesPool;
    this.nodes = {};
    this.pathFinder = l;
    this.closestNode = null;
  }
  destroy() {
    this.freeAllNodes();
    this.pathFinder = null;
    this.pool = void 0;
    return this;
  }
  getNode(l, w, h) {
    switch (typeof l) {
      case "number":
        var t = TileXYToKey(l, w);
        break;
      case "string":
        t = l;
        h = w;
        break;
      default:
        (t = l), (h = w), (l = t.x), (w = t.y), (t = TileXYToKey(l, w));
    }
    void 0 === h && (h = !1);
    this.sn++;
    if (!this.nodes.hasOwnProperty(t)) {
      if (!h) return null;
      h = this.pool.pop();
      null === h && (h = new Node());
      h.reset(this);
      h.sn = this.sn;
      h.key = t;
      h.x = l;
      h.y = w;
      this.nodes[t] = h;
    }
    return this.nodes[t];
  }
  freeAllNodes() {
    this.closestNode = null;
    var l = this.nodes,
      w = this.pool,
      h;
    for (h in l) {
      var t = l[h];
      t.destroy();
      w.push(t);
      delete l[h];
    }
    this.sn = 0;
    return this;
  }
  getAllNodes() {
    return this.nodes;
  }
}
class BinaryHeap {
  constructor(l) {
    this.content = [];
    this.scoreFunction = l;
  }
  clear() {
    this.content.length = 0;
  }
  push(l) {
    this.content.push(l);
    this.sinkDown(this.content.length - 1);
  }
  pop() {
    var l = this.content[0],
      w = this.content.pop();
    0 < this.content.length && ((this.content[0] = w), this.bubbleUp(0));
    return l;
  }
  remove(l) {
    var w = this.content.indexOf(l),
      h = this.content.pop();
    w !== this.content.length - 1 &&
      ((this.content[w] = h),
      this.scoreFunction(h) < this.scoreFunction(l)
        ? this.sinkDown(w)
        : this.bubbleUp(w));
  }
  size() {
    return this.content.length;
  }
  rescoreElement(l) {
    this.sinkDown(this.content.indexOf(l));
  }
  sinkDown(l) {
    for (var w = this.content[l]; 0 < l; ) {
      var h = ((l + 1) >> 1) - 1,
        t = this.content[h];
      if (this.scoreFunction(w) < this.scoreFunction(t))
        (this.content[h] = w), (this.content[l] = t), (l = h);
      else break;
    }
  }
  bubbleUp(l) {
    for (
      var w = this.content.length,
        h = this.content[l],
        t = this.scoreFunction(h);
      ;

    ) {
      var a = (l + 1) << 1,
        d = a - 1,
        k = null;
      if (d < w) {
        var e = this.scoreFunction(this.content[d]);
        e < t && (k = d);
      }
      a < w &&
        this.scoreFunction(this.content[a]) < (null === k ? t : e) &&
        (k = a);
      if (null !== k)
        (this.content[l] = this.content[k]), (this.content[k] = h), (l = k);
      else break;
    }
  }
}
var CONST$2 = {
  AREA_MODE: 16,
  PATH_MODE: 0,
  random: 0,
  diagonal: 1,
  straight: 2,
  line: 3,
  "A*": 10,
  "A*-random": 11,
  "A*-line": 12,
  BLOCKER: null,
  INFINITY: void 0,
};
const PATH_MODE$1 = CONST$2.PATH_MODE,
  ASTAR$1 = CONST$2["A*"],
  ASTAR_LINE$1 = CONST$2["A*-line"],
  ASTAR_RANDOM$1 = CONST$2["A*-random"],
  BLOCKER$5 = CONST$2.BLOCKER,
  INFINITY$6 = CONST$2.INFINITY;
var gOpenHeap = new BinaryHeap(function (l) {
    return l.f;
  }),
  AStarSerach = function (l, w, h, t) {
    void 0 === this.nodeManager && (this.nodeManager = new NodeCache(this));
    var a = this.nodeManager;
    a.freeAllNodes();
    t = t === PATH_MODE$1;
    var d =
      this.pathMode === ASTAR$1 ||
      this.pathMode === ASTAR_LINE$1 ||
      this.pathMode === ASTAR_RANDOM$1;
    const k = t && !d;
    d =
      t && d
        ? this.pathMode == ASTAR$1
          ? 0
          : this.pathMode == ASTAR_LINE$1
          ? 1
          : this.pathMode == ASTAR_RANDOM$1
          ? 2
          : null
        : null;
    w = null !== w ? a.getNode(w.x, w.y, !0) : null;
    l = a.getNode(l.x, l.y, !0);
    l.h = l.heuristic(w, d);
    if (t) {
      var e = l;
      e.closerH = e.h || e.heuristic(w, 0);
    }
    for (gOpenHeap.push(l); 0 < gOpenHeap.size(); ) {
      var b = gOpenHeap.pop();
      if (t && b === w) {
        e = w;
        break;
      }
      b.closed = !0;
      for (
        var c = b.getNeighborNodes(), f, g, m, n = 0, q = c.length;
        n < q;
        ++n
      )
        (f = c[n]),
          (g = f.getCost(b)),
          f.closed ||
            g === BLOCKER$5 ||
            ((m = b.g + g),
            (g = f.visited),
            (h != INFINITY$6 && m > h) ||
              (!g || m < f.g
                ? ((f.visited = !0),
                  (f.preNodes.length = 0),
                  f.preNodes.push(b),
                  (f.h = f.h || f.heuristic(w, d, l)),
                  (f.g = m),
                  (f.f = f.g + f.h),
                  t &&
                    ((f.closerH = f.h || f.heuristic(w, 0)),
                    (m =
                      f.closerH < e.closerH ||
                      (f.closerH === e.closerH && f.g < e.g)) && (e = f)),
                  g ? gOpenHeap.rescoreElement(f) : gOpenHeap.push(f))
                : k && m == f.g && f.preNodes.push(b)));
    }
    a.closestNode = t ? e : null;
    gOpenHeap.clear();
    return this;
  };
const BLOCKER$4 = CONST$2.BLOCKER;
var GetCost$2 = function (l, w) {
  if (
    (this.occupiedTest &&
      this.board.contains(l.x, l.y, this.chessData.tileXYZ.z)) ||
    (this.blockerTest && this.board.hasBlocker(l.x, l.y))
  )
    return BLOCKER$4;
  if ("number" === typeof this.costCallback) return this.costCallback;
  l = this.costCallbackScope
    ? this.costCallback.call(this.costCallbackScope, l, w, this)
    : this.costCallback(l, w, this);
  void 0 === l && (l = BLOCKER$4);
  return l;
};
const AREA_MODE = CONST$2.AREA_MODE,
  INFINITY$5 = CONST$2.INFINITY;
var FindArea = function (l, w) {
  void 0 === w && (w = []);
  if (null === this.board || (l !== INFINITY$5 && 0 >= l)) return w;
  var h = this.chessData.tileXYZ,
    t = h.x,
    a = h.y;
  this.aStarSearch(h, null, l, AREA_MODE);
  var d = this.nodeManager.getAllNodes();
  h = [];
  for (var k in d)
    (l = d[k]), (l.x !== t || l.y !== a) && l.closed && h.push(l);
  h.sort(function (e, b) {
    e = e.sn;
    b = b.sn;
    return e > b ? 1 : e < b ? -1 : 0;
  });
  t = 0;
  for (a = h.length; t < a; t++)
    (l = h[t]),
      w.push({
        x: l.x,
        y: l.y,
        cost: l.g,
      });
  return w;
};
const RANDOM = CONST$2.random,
  DIAGONAL = CONST$2.diagonal,
  STRAIGN = CONST$2.straight,
  LINE = CONST$2.line,
  ASTAR = CONST$2["A*"],
  ASTAR_LINE = CONST$2["A*-line"],
  ASTAR_RANDOM = CONST$2["A*-random"];
var GetNodePath = function (l, w, h) {
    for (var t = l.board, a, d, k, e = w, b, c, f = []; 0 < e.preNodes.length; )
      switch ((f.push(e), (c = e.preNodes.length), h)) {
        case ASTAR:
        case ASTAR_LINE:
        case ASTAR_RANDOM:
          e = b = e.preNodes[0];
          break;
        case RANDOM:
          e = b = 1 === c ? e.preNodes[0] : e.preNodes[Between(0, c - 1)];
          break;
        case DIAGONAL:
          for (var g = 0; g < c; g++)
            if (
              ((b = e.preNodes[g]),
              (d = t.getNeighborTileDirection(e, b)),
              d !== a)
            ) {
              a = d;
              break;
            }
          e = b;
          break;
        case STRAIGN:
          for (
            g = 0;
            g < c &&
            ((b = e.preNodes[g]),
            (d = t.getNeighborTileDirection(e, b)),
            d !== a);
            g++
          );
          a = d;
          e = b;
          break;
        case LINE:
          if ((void 0 === k && (k = w.angleTo(l)), 1 === c))
            (e = b = e.preNodes[0]), (k = w.angleTo(e));
          else {
            b = e.preNodes[0];
            var m = Math.abs(w.angleTo(b) - k);
            for (g = 1; g < c; g++) {
              var n = e.preNodes[g];
              var q = Math.abs(w.angleTo(n) - k);
              q < m && (b = n);
            }
            e = b;
          }
      }
    return f.reverse();
  },
  GetPath$1 = function (l, w) {
    void 0 === w && (w = []);
    if (void 0 === this.board) return w;
    var h = this.nodeManager;
    if (void 0 === h) return w;
    var t = h.getNode(this.chessData.tileXYZ, !1);
    l = h.getNode(l, !1);
    if (null === t || null === l) return w;
    t = GetNodePath(t, l, this.pathMode);
    h = 0;
    for (var a = t.length; h < a; h++)
      (l = t[h]),
        w.push({
          x: l.x,
          y: l.y,
          cost: l.g,
        });
    return w;
  };
const PATH_MODE = CONST$2.PATH_MODE,
  INFINITY$4 = CONST$2.INFINITY;
var FindPath = function (l, w, h, t) {
    void 0 === h && (h = !0);
    void 0 === t && (t = []);
    if (null === this.board || (w !== INFINITY$4 && 0 >= w)) return t;
    this.aStarSearch(this.chessData.tileXYZ, l, w, PATH_MODE);
    w = this.nodeManager;
    l = h ? w.closestNode : w.getNode(l);
    return null === l ? t : this.getPath(l, t);
  },
  TileXYToCost = function (l, w, h) {
    if (void 0 === this.nodeManager) return null;
    l = this.nodeManager.getNode(l, w);
    if (null === l) return null;
    void 0 === h && (h = !0);
    return h ? l.g : l.cost;
  },
  Methods$3 = {
    aStarSearch: AStarSerach,
    getCost: GetCost$2,
    findArea: FindArea,
    getPath: GetPath$1,
    findPath: FindPath,
    tileXYToCost: TileXYToCost,
  };
const BLOCKER$3 = CONST$2.BLOCKER,
  INFINITY$3 = CONST$2.INFINITY;
class PathFinder extends ComponentBase {
  constructor(l, w) {
    IsPlainObject(l) && ((w = l), (l = void 0));
    super(l, {
      eventEmitter: !1,
    });
    this.setChess(l);
    this.nodeManager = void 0;
    this.resetFromJSON(w);
  }
  resetFromJSON(l) {
    var w = GetValue$l(l, "costCallback", void 0),
      h = GetValue$l(l, "costCallbackScope", void 0);
    void 0 === w && (w = GetValue$l(l, "cost", 1));
    this.setOccupiedTest(GetValue$l(l, "occupiedTest", !1));
    this.setBlockerTest(GetValue$l(l, "blockerTest", !1));
    this.setEdgeBlockerTest(GetValue$l(l, "edgeBlockerTest", !1));
    this.setCostFunction(w, h);
    this.setPathMode(GetValue$l(l, "pathMode", 0));
    this.setCacheCostMode(GetValue$l(l, "cacheCost", !0));
    this.setWeight(GetValue$l(l, "weight", 10));
    this.setShuffleNeighborsMode(GetValue$l(l, "shuffleNeighbors", !1));
    return this;
  }
  shutdown(l) {
    this.isShutdown ||
      (void 0 !== this.nodeManager && this.nodeManager.destroy(),
      (this.chessData = void 0),
      super.shutdown(l));
  }
  get gameObject() {
    return this.parent;
  }
  setChess(l) {
    if (l) {
      if (
        ((this.chessData = GetChessData(l)),
        this.parent !== l &&
          (this.parent &&
            this.parent.once &&
            this.parent.off("destroy", this.onParentDestroy, this),
          (this.parent = l) && this.parent.once))
      )
        this.parent.once("destroy", this.onParentDestroy, this);
    } else this.chessData = this.parent = void 0;
    return this;
  }
  setCostFunction(l, w) {
    this.costCallback = l;
    this.costCallbackScope = w;
    return this;
  }
  setPathMode(l) {
    "string" === typeof l && (l = CONST$2[l]);
    this.pathMode = l;
    return this;
  }
  setCacheCostMode(l) {
    void 0 === l && (l = !0);
    this.cacheCost = l;
    return this;
  }
  setOccupiedTest(l) {
    void 0 === l && (l = !0);
    this.occupiedTest = l;
    return this;
  }
  setBlockerTest(l) {
    void 0 === l && (l = !0);
    this.blockerTest = l;
    return this;
  }
  setEdgeBlockerTest(l) {
    void 0 === l && (l = !0);
    this.edgeBlockerTest = l;
    return this;
  }
  setWeight(l) {
    this.weight = l;
    return this;
  }
  setShuffleNeighborsMode(l) {
    void 0 === l && (l = !0);
    this.shuffleNeighbors = l;
    return this;
  }
  get BLOCKER() {
    return BLOCKER$3;
  }
  get INFINITY() {
    return INFINITY$3;
  }
  get board() {
    return this.chessData.board;
  }
}
Object.assign(PathFinder.prototype, Methods$3);
ObjectFactory$1.register("pathFinder", function (l, w) {
  return new PathFinder(l, w);
});
SetValue(window, "RexPlugins.Board.PathFinder", PathFinder);
var PreTest = function (l, w) {
    if (this.occupiedTest || this.blockerTest || this.edgeBlockerTest)
      for (var h = this.chessData.tileXYZ.z, t, a = 1, d = l.length; a < d; a++)
        if (
          ((t = l[a]),
          (this.occupiedTest && this.board.contains(t.x, t.y, h)) ||
            (this.blockerTest && this.board.hasBlocker(t.x, t.y)))
        )
          return !1;
    return this.preTestCallback
      ? this.preTestCallbackScope
        ? this.preTestCallback.call(this.preTestCallbackScope, l, w, this)
        : this.preTestCallback(l, w, this)
      : !0;
  },
  GetCost$1 = function (l, w) {
    return "number" === typeof this.costCallback
      ? this.costCallback
      : this.costCallbackScope
      ? this.costCallback.call(this.costCallbackScope, l, this, w)
      : this.costCallback(l, this, w);
  },
  IsInCone = function (l) {
    if (void 0 === this.cone) return !0;
    var w = this.board,
      h = this.chessData.tileXYZ;
    return 0 === this.coneMode
      ? w.isDirectionInCone(h, l, this.face, this.cone)
      : w.isAngleInCone(h, l, this.faceAngle, this.coneRad);
  },
  CONST$1 = {
    BLOCKER: null,
    INFINITY: void 0,
  };
const BLOCKER$2 = CONST$1.BLOCKER,
  INFINITY$2 = CONST$1.INFINITY;
var IsPathVisible = function (l, w) {
    if (!1 === this.preTest(l, w)) return !1;
    if (void 0 === this.costCallback) return !0;
    for (
      var h = this.chessData.tileXYZ, t, a = !1, d = 1, k = l.length;
      d < k;
      d++
    )
      if (((t = l[d]), !AreTileXYEqual(h, t))) {
        if (a) return !1;
        t = this.getCost(t, l);
        if (t === CONST$1.BLOCKER) a = !0;
        else if (w !== CONST$1.INFINITY && ((w -= t), 0 > w)) return !1;
      }
    return !0;
  },
  AreTileXYArrayEqual = function (l, w) {
    if (l.length !== w.length) return !1;
    for (var h = 0, t = l.length; h < t; h++)
      if (!AreTileXYEqual(l[h], w[h])) return !1;
    return !0;
  };
const INFINITY$1 = CONST$1.INFINITY,
  LINEOFFSET = 0.001;
var IsInLOS = function (l, w, h) {
    if (w !== CONST$1.INFINITY && 0 >= w) return !1;
    var t = this.board,
      a = t.chessToTileXYZ(l);
    if (!this.isInCone(a)) return !1;
    void 0 === h && (h = this.chessData.tileXYZ);
    var d = t.tileXYToWorldXY(h.x, h.y, !0);
    h = d.x;
    l = d.y;
    d = t.tileXYToWorldXY(a.x, a.y, !0);
    a = d.x;
    d = d.y;
    var k = Between$1(h, l, a, d),
      e;
    k += Math.PI / 2;
    var b = LINEOFFSET * Math.cos(k);
    var c = LINEOFFSET * Math.sin(k);
    t.lineToTileXYArray(h + b, l + c, a + b, d + c, globTileXYArray0);
    if ((e = this.isPathVisible(globTileXYArray0, w)))
      return (
        (globTileXYArray0.length = 0),
        drawLine(this.debugGraphics, this.debugVisibleLineColor, h, l, a, d),
        !0
      );
    k += Math.PI;
    b = LINEOFFSET * Math.cos(k);
    c = LINEOFFSET * Math.sin(k);
    t.lineToTileXYArray(h + b, l + c, a + b, d + c, globTileXYArray1);
    AreTileXYArrayEqual(globTileXYArray0, globTileXYArray1) ||
      (e = this.isPathVisible(globTileXYArray1, w));
    globTileXYArray0.length = 0;
    globTileXYArray1.length = 0;
    drawLine(
      this.debugGraphics,
      e ? this.debugVisibleLineColor : this.debugInvisibleLineColor,
      h,
      l,
      a,
      d
    );
    return e;
  },
  drawLine = function (l, w, h, t, a, d) {
    l && void 0 !== w && l.lineStyle(1, w, 1).lineBetween(h, t, a, d);
  },
  globTileXYArray0 = [],
  globTileXYArray1 = [],
  LOS = function (l, w, h, t) {
    if (IsArray(l)) {
      IsPlainObject(w)
        ? ((t = h), (h = w), (w = void 0))
        : IsArray(w) && ((t = w), (h = w = void 0));
      IsArray(h) && ((t = h), (h = void 0));
      void 0 === t && (t = []);
      for (var a = 0, d = l.length; a < d; a++) {
        var k = l[a];
        this.isInLOS(k, w, h) && t.push(k);
      }
      return t;
    }
    return this.isInLOS(l, w, h);
  },
  FindFOV = function (l, w, h) {
    IsPlainObject(l)
      ? ((h = w), (w = l), (l = void 0))
      : IsArray(l) && ((h = l), (l = w = void 0));
    IsArray(w) && ((h = w), (w = void 0));
    void 0 === h && (h = []);
    var t = this.board,
      a = this.chessData.tileXYZ,
      d = 1;
    do {
      var k = !1;
      t.ringToTileXYArray(a, d, globRing);
      for (var e = 0, b = globRing.length; e < b; e++) {
        var c = globRing[e];
        this.isInLOS(c, l, w) && ((k = !0), h.push(c));
      }
      d++;
      globRing.length = 0;
    } while (k);
    return h;
  },
  globRing = [],
  Methods$2 = {
    preTest: PreTest,
    getCost: GetCost$1,
    isInCone: IsInCone,
    isPathVisible: IsPathVisible,
    isInLOS: IsInLOS,
    LOS,
    findFOV: FindFOV,
  };
const BLOCKER$1 = CONST$1.BLOCKER,
  INFINITY = CONST$1.INFINITY;
class FieldOfView extends ComponentBase {
  constructor(l, w) {
    super(l, {
      eventEmitter: !1,
    });
    this.chessData = GetChessData(l);
    this.resetFromJSON(w);
  }
  resetFromJSON(l) {
    var w = GetValue$l(l, "occupiedTest", !1),
      h = GetValue$l(l, "blockerTest", !1),
      t = GetValue$l(l, "edgeBlockerTest", !1),
      a = GetValue$l(l, "preTestCallback", void 0),
      d = GetValue$l(l, "preTestCallbackScope", void 0),
      k = GetValue$l(l, "costCallback", void 0),
      e = GetValue$l(l, "costCallbackScope", void 0);
    void 0 === k && (k = GetValue$l(l, "cost", void 0));
    this.setFace(GetValue$l(l, "face", 0));
    this.setConeMode(GetValue$l(l, "coneMode", 0));
    this.setCone(GetValue$l(l, "cone", void 0));
    this.setOccupiedTest(w);
    this.setBlockerTest(h);
    this.setEdgeBlockerTest(t);
    this.setPreTestFunction(a, d);
    this.setCostFunction(k, e);
    this.setDebugGraphics(GetValue$l(l, "debug.graphics", void 0));
    this.setDebugLineColor(
      GetValue$l(l, "debug.visibleLineColor", 65280),
      GetValue$l(l, "debug.invisibleLineColor", 16711680)
    );
    this.setDebugLog(GetValue$l(l, "debug.log", !1));
    return this;
  }
  shutdown(l) {
    this.isShutdown ||
      ((this.chessData = this.debugGraphics = void 0), super.shutdown(l));
  }
  get face() {
    return this._face;
  }
  set face(l) {
    this._face = l = this.board.grid.directionNormalize(l);
    0 !== this.coneMode &&
      ((l = this.board.angleToward(this.chessData.tileXYZ, l)),
      (this.faceAngle = Normalize(l)));
  }
  setFace(l) {
    this.face = l;
    return this;
  }
  get cone() {
    return this._cone;
  }
  set cone(l) {
    this._cone = l;
    void 0 !== l && 0 !== this.coneMode && (this.coneRad = DegToRad$3(l));
  }
  setConeMode(l) {
    "string" === typeof l && (l = CONEMODE[l]);
    this.coneMode = l;
    return this;
  }
  setCone(l) {
    this.cone = l;
    return this;
  }
  setOccupiedTest(l) {
    void 0 === l && (l = !0);
    this.occupiedTest = l;
    return this;
  }
  setBlockerTest(l) {
    void 0 === l && (l = !0);
    this.blockerTest = l;
    return this;
  }
  setEdgeBlockerTest(l) {
    void 0 === l && (l = !0);
    this.edgeBlockerTest = l;
    return this;
  }
  setCostFunction(l, w) {
    this.costCallback = l;
    this.costCallbackScope = w;
    return this;
  }
  setPreTestFunction(l, w) {
    this.preTestCallback = l;
    this.preTestCallbackScope = w;
    return this;
  }
  setDebugGraphics(l) {
    this.debugGraphics = l;
    return this;
  }
  setDebugLineColor(l, w) {
    this.debugVisibleLineColor = l;
    this.debugInvisibleLineColor = w;
    return this;
  }
  setDebugLog(l) {
    void 0 === l && (l = !0);
    this.debugLog = l;
    return this;
  }
  clearDebugGraphics() {
    this.debugGraphics && this.debugGraphics.clear();
    return this;
  }
  get BLOCKER() {
    return CONST$1.BLOCKER;
  }
  get INFINITY() {
    return CONST$1.INFINITY;
  }
  get board() {
    return this.chessData.board;
  }
}
const CONEMODE = {
  direction: 0,
  angle: 1,
};
Object.assign(FieldOfView.prototype, Methods$2);
ObjectFactory$1.register("fieldOfView", function (l, w) {
  return new FieldOfView(l, w);
});
SetValue(window, "RexPlugins.Board.FieldOfView", FieldOfView);
var CreateTileData = function (l, w, h) {
    return {
      x: l,
      y: w,
      direction: h,
    };
  },
  CONST = {
    BLOCKER: null,
    STOP: -1,
  };
const STOP$1 = CONST.STOP;
var GetPath = function (l, w) {
    void 0 === w && (w = []);
    if (null === this.board) return w;
    var h = this.chessData.tileXYZ;
    h = CreateTileData(h.x, h.y, this.face);
    for (var t, a; 0 < l; ) {
      t = this.getNextTile(h, this.preTileXY);
      if (null === t) break;
      a = this.getCost(t, h);
      a === CONST.STOP && (a = l);
      t.cost = a;
      l >= a && w.push(t);
      l -= a;
      this.preTileXY = h;
      h = t;
    }
    for (l = w.length - 1; 0 <= l; l--)
      if (0 === w[l].cost) w.length = l;
      else break;
    return w;
  },
  GetNextTile = function (l, w) {
    for (
      var h = this.board,
        t = h.grid.allDirections,
        a = null,
        d = null,
        k = [],
        e,
        b,
        c = 0,
        f = t.length;
      c < f;
      c++
    )
      (e = h.getNeighborTileXY(l, t[c], !0)),
        null !== e &&
          h.contains(e.x, e.y, this.pathTileZ) &&
          ((b = CreateTileData(e.x, e.y, t[c])),
          t[c] === l.direction && (a = b),
          void 0 !== w && AreTileXYEqual(e, w) ? (d = b) : k.push(b));
    if (null === d && 0 === k.length) l = null;
    else if (null === d && 1 === k.length) l = k[0];
    else if (null !== d && 0 === k.length) l = d;
    else
      switch (this.pickMode) {
        case 1:
          null !== d && k.push(d);
          l = GetRandom(k);
          break;
        default:
          l = null !== a ? a : GetRandom(k);
      }
    return l;
  },
  GetCost = function (l, w) {
    return "number" === typeof this.costCallback
      ? this.costCallback
      : this.costCallbackScope
      ? this.costCallback.call(this.costCallbackScope, l, w, this)
      : this.costCallback(l, w, this);
  },
  Methods$1 = {
    getPath: GetPath,
    getNextTile: GetNextTile,
    getCost: GetCost,
  };
const BLOCKER = CONST.BLOCKER,
  STOP = CONST.STOP;
class Monopoly extends ComponentBase {
  constructor(l, w) {
    super(l, {
      eventEmitter: !1,
    });
    this.chessData = GetChessData(l);
    this.resetFromJSON(w);
  }
  resetFromJSON(l) {
    this.preTileXY = GetValue$l(l, "preTileXY", void 0);
    var w = GetValue$l(l, "costCallback", void 0),
      h = GetValue$l(l, "costCallbackScope", void 0);
    void 0 === w && (w = GetValue$l(l, "cost", 1));
    this.setFace(GetValue$l(l, "face", 0));
    this.setPathMode(GetValue$l(l, "pathMode", 0));
    this.setPathTileZ(GetValue$l(l, "pathTileZ", 0));
    this.setCostFunction(w, h);
    return this;
  }
  shutdown(l) {
    this.isShutdown || ((this.chessData = void 0), super.shutdown(l));
  }
  setFace(l) {
    this.face = l = this.board.grid.directionNormalize(l);
    return this;
  }
  setPathMode(l) {
    "string" === typeof l && (l = PATHMODE[l]);
    this.pathMode = l;
    return this;
  }
  setCostFunction(l, w) {
    this.costCallback = l;
    this.costCallbackScope = w;
    return this;
  }
  setPathTileZ(l) {
    void 0 === l && (l = !0);
    this.pathTileZ = l;
    return this;
  }
  get BLOCKER() {
    return CONST.BLOCKER;
  }
  get STOP() {
    return CONST.STOP;
  }
  get board() {
    return this.chessData.board;
  }
}
Object.assign(Monopoly.prototype, Methods$1);
const PATHMODE = {
  forward: 0,
  random: 1,
};
ObjectFactory$1.register("monopoly", function (l, w) {
  return new Monopoly(l, w);
});
SetValue(window, "RexPlugins.Board.Monopoly", Monopoly);
const Zone = Phaser.GameObjects.Zone,
  AddItem = Phaser.Utils.Array.Add,
  RemoveItem = Phaser.Utils.Array.Remove;
class Base extends Zone {
  constructor(l, w, h, t, a) {
    void 0 === w && (w = 0);
    void 0 === h && (h = 0);
    void 0 === t && (t = 1);
    void 0 === a && (a = 1);
    super(l, w, h, t, a);
    this.children = [];
  }
  destroy(l) {
    if (this.scene) {
      if (l)
        for (var w, h = this.children.length - 1; 0 <= h; h--)
          (w = this.children[h]),
            w.parentContainer || w.displayList || w.destroy(l);
      this.clear(!l);
      super.destroy(l);
    }
  }
  contains(l) {
    return -1 !== this.children.indexOf(l);
  }
  add(l) {
    var w = this;
    AddItem(
      this.children,
      l,
      0,
      function (h) {
        h.once("destroy", w.onChildDestroy, w);
      },
      this
    );
    return this;
  }
  remove(l, w) {
    var h = this;
    RemoveItem(this.children, l, function (t) {
      t.off("destroy", h.onChildDestroy, h);
      w && t.destroy();
    });
    return this;
  }
  onChildDestroy(l, w) {
    this.remove(l, !1);
  }
  clear(l) {
    for (var w, h = 0, t = this.children.length; h < t; h++)
      (w = this.children[h]),
        w.off("destroy", this.onChildDestroy, this),
        l && w.destroy();
    this.children.length = 0;
    return this;
  }
}
const Components = Phaser.GameObjects.Components;
Phaser.Class.mixin(Base, [Components.Alpha, Components.Flip]);
var GetParent = function (l, w) {
    if (void 0 === w) {
      if (l.hasOwnProperty("rexContainer")) var h = l.rexContainer.parent;
    } else for (h = GetParent(l); h && h.name !== w; ) h = GetParent(h);
    return h;
  },
  GetTopmostParent = function (l) {
    for (var w = GetParent(l); w; ) (l = w), (w = GetParent(w));
    return l;
  };
const DegToRad$2 = Phaser.Math.DegToRad,
  RadToDeg$1 = Phaser.Math.RadToDeg;
var GetLocalState = function (l) {
    if (!l.hasOwnProperty("rexContainer")) {
      var w = {
        parent: null,
        self: null,
        x: 0,
        y: 0,
        syncPosition: !0,
        rotation: 0,
        syncRotation: !0,
        scaleX: 0,
        scaleY: 0,
        syncScale: !0,
        alpha: 0,
        syncAlpha: !0,
        visible: !0,
        active: !0,
      };
      Object.defineProperty(w, "angle", {
        get: function () {
          return RadToDeg$1(this.rotation);
        },
        set: function (h) {
          this.rotation = DegToRad$2(h);
        },
      });
      Object.defineProperty(w, "displayWidth", {
        get: function () {
          return l.width * this.scaleX;
        },
        set: function (h) {
          this.scaleX = h / l.width;
        },
      });
      Object.defineProperty(w, "displayHeight", {
        get: function () {
          return l.height * this.scaleY;
        },
        set: function (h) {
          this.scaleY = h / l.height;
        },
      });
      l.rexContainer = w;
    }
    return l.rexContainer;
  },
  Parent = {
    setParent(l, w) {
      void 0 === w && (w = this);
      var h = GetLocalState(l);
      w ? ((h.parent = w), (h.self = l)) : ((h.parent = null), (h.self = null));
      return this;
    },
    getParent(l, w) {
      "string" === typeof l && ((w = l), (l = void 0));
      void 0 === l && (l = this);
      return GetParent(l, w);
    },
    getTopmostParent(l) {
      void 0 === l && (l = this);
      return GetTopmostParent(l);
    },
  };
const GetValue$d = Phaser.Utils.Objects.GetValue,
  BaseAdd = Base.prototype.add;
var Add = function (l, w) {
    this.setParent(l);
    var h = GetLocalState(l);
    SetupSyncFlags(h, w);
    this.resetChildState(l)
      .updateChildVisible(l)
      .updateChildActive(l)
      .updateChildScrollFactor(l)
      .updateChildMask(l);
    BaseAdd.call(this, l);
    return this;
  },
  AddLocal = function (l, w) {
    this.setParent(l);
    var h = GetLocalState(l);
    SetupSyncFlags(h, w);
    h.x = l.x;
    h.y = l.y;
    h.rotation = l.rotation;
    h.scaleX = l.scaleX;
    h.scaleY = l.scaleY;
    h.alpha = l.alpha;
    h.visible = l.visible;
    h.active = l.active;
    this.updateChildPosition(l)
      .updateChildAlpha(l)
      .updateChildVisible(l)
      .updateChildActive(l)
      .updateChildScrollFactor(l)
      .updateChildMask(l);
    BaseAdd.call(this, l);
    return this;
  },
  SetupSyncFlags = function (l, w) {
    l.syncPosition = GetValue$d(w, "syncPosition", !0);
    l.syncRotation = GetValue$d(w, "syncRotation", !0);
    l.syncScale = GetValue$d(w, "syncScale", !0);
    l.syncAlpha = GetValue$d(w, "syncAlpha", !0);
  },
  AddChild = {
    add(l) {
      Array.isArray(l) ? this.addMultiple(l) : Add.call(this, l);
      return this;
    },
    pin(l, w) {
      Array.isArray(l) ? this.addMultiple(l, w) : Add.call(this, l, w);
      return this;
    },
    addMultiple(l) {
      for (var w = 0, h = l.length; w < h; w++) Add.call(this, l[w]);
      return this;
    },
    addLocal(l) {
      Array.isArray(l) ? this.addMultiple(l) : AddLocal.call(this, l);
      return this;
    },
    pinLocal(l, w) {
      Array.isArray(l) ? this.addMultiple(l, w) : AddLocal.call(this, l, w);
      return this;
    },
    addLocalMultiple(l) {
      for (var w = 0, h = l.length; w < h; w++) AddLocal.call(this, l[w]);
      return this;
    },
  };
const BaseRemove = Base.prototype.remove,
  BaseClear = Base.prototype.clear;
var RemoveChild = {
    remove(l, w) {
      if (GetParent(l) !== this) return this;
      this.setParent(l, null);
      BaseRemove.call(this, l, w);
      return this;
    },
    clear(l) {
      for (var w = 0, h = this.children.length; w < h; w++)
        this.setParent(this.children[w], null);
      BaseClear.call(this, l);
      return this;
    },
  },
  ChildState = {
    getLocalState(l) {
      return GetLocalState(l);
    },
    resetChildState(l) {
      this.resetChildPositionState(l)
        .resetChildVisibleState(l)
        .resetChildAlphaState(l)
        .resetChildActiveState(l);
      return this;
    },
    resetChildrenState(l) {
      for (var w = 0, h = l.length; w < h; w++) this.resetChildState(l[w]);
      return this;
    },
    syncProperties() {
      this.syncPosition()
        .syncVisible()
        .syncAlpha()
        .syncActive()
        .syncScrollFactor()
        .syncMask();
      return this;
    },
  };
const RotateAround$2 = Phaser.Math.RotateAround;
var Transform = {
    worldToLocal(l) {
      l.x -= this.x;
      l.y -= this.y;
      RotateAround$2(l, 0, 0, -this.rotation);
      l.x /= this.scaleX;
      l.y /= this.scaleY;
      return l;
    },
    localToWorld(l) {
      l.x *= this.scaleX;
      l.y *= this.scaleY;
      RotateAround$2(l, 0, 0, this.rotation);
      l.x += this.x;
      l.y += this.y;
      return l;
    },
  },
  GetScale = function (l, w) {
    return l === w ? 1 : l / w;
  },
  Position = {
    updateChildPosition(l) {
      l.isRexContainerLite && (l.syncChildrenEnable = !1);
      var w = GetLocalState(l),
        h = w.parent;
      w.syncPosition && ((l.x = w.x), (l.y = w.y), h.localToWorld(l));
      w.syncRotation && (l.rotation = w.rotation + h.rotation);
      w.syncScale &&
        ((l.scaleX = w.scaleX * h.scaleX), (l.scaleY = w.scaleY * h.scaleY));
      l.isRexContainerLite && ((l.syncChildrenEnable = !0), l.syncPosition());
      return this;
    },
    syncPosition() {
      this.syncChildrenEnable &&
        this.children.forEach(this.updateChildPosition, this);
      return this;
    },
    resetChildPositionState(l) {
      var w = GetLocalState(l),
        h = w.parent;
      w.x = l.x;
      w.y = l.y;
      h.worldToLocal(w);
      w.scaleX = GetScale(l.scaleX, h.scaleX);
      w.scaleY = GetScale(l.scaleY, h.scaleY);
      w.rotation = l.rotation - h.rotation;
      return this;
    },
    setChildPosition(l, w, h) {
      l.x = w;
      l.y = h;
      this.resetChildPositionState(l);
      return this;
    },
    setChildLocalPosition(l, w, h) {
      var t = GetLocalState(l);
      t.x = w;
      t.y = h;
      this.updateChildPosition(l);
      return this;
    },
    resetLocalPositionState() {
      var l = GetLocalState(this).parent;
      l && l.resetChildPositionState(this);
      return this;
    },
  };
const DegToRad$1 = Phaser.Math.DegToRad;
var Rotation = {
    updateChildRotation(l) {
      var w = GetLocalState(l),
        h = w.parent;
      w.syncRotation && (l.rotation = h.rotation + w.rotation);
      return this;
    },
    syncRotation() {
      this.syncChildrenEnable &&
        this.children.forEach(this.updateChildRotation, this);
      return this;
    },
    resetChildRotationState(l) {
      var w = GetLocalState(l);
      w.rotation = l.rotation - w.parent.rotation;
      return this;
    },
    setChildRotation(l, w) {
      l.rotation = w;
      this.resetChildRotationState(l);
      return this;
    },
    setChildAngle(l, w) {
      l.angle = w;
      this.resetChildRotationState(l);
      return this;
    },
    setChildLocalRotation(l, w) {
      GetLocalState(l).rotation = w;
      this.updateChildRotation(l);
      return this;
    },
    setChildLocalAngle(l, w) {
      GetLocalState(l).rotation = DegToRad$1(w);
      this.updateChildRotation(l);
      return this;
    },
    resetLocalRotationState() {
      var l = GetLocalState(this).parent;
      l && l.resetChildRotationState(this);
      return this;
    },
  },
  Scale = {
    updateChildScale(l) {
      var w = GetLocalState(l),
        h = w.parent;
      w.syncScale &&
        ((l.scaleX = h.scaleX * w.scaleX), (l.scaleY = h.scaleY * w.scaleY));
      return this;
    },
    syncScale() {
      this.syncChildrenEnable &&
        this.children.forEach(this.updateChildScale, this);
      return this;
    },
    resetChildScaleState(l) {
      var w = GetLocalState(l),
        h = w.parent;
      w.scaleX = GetScale(l.scaleX, h.scaleX);
      w.scaleY = GetScale(l.scaleY, h.scaleY);
      return this;
    },
    setChildScale(l, w, h) {
      void 0 === h && (h = w);
      l.scaleX = w;
      l.scaleY = h;
      this.resetChildScaleState(l);
      return this;
    },
    setChildLocalScale(l, w, h) {
      void 0 === h && (h = w);
      var t = GetLocalState(l);
      t.scaleX = w;
      t.scaleY = h;
      this.updateChildScale(l);
      return this;
    },
    setChildDisplaySize(l, w, h) {
      l.setDisplaySize(w, h);
      this.resetChildScaleState(l);
      return this;
    },
    resetLocalScaleState() {
      var l = GetLocalState(this).parent;
      l && l.resetChildScaleState(this);
      return this;
    },
  },
  Visible = {
    updateChildVisible(l) {
      var w = GetLocalState(l),
        h = w.parent,
        t = w.hasOwnProperty("maskVisible") ? w.maskVisible : !0;
      l.visible = h.visible && w.visible && t;
      return this;
    },
    syncVisible() {
      this.syncChildrenEnable &&
        this.children.forEach(this.updateChildVisible, this);
      return this;
    },
    resetChildVisibleState(l) {
      var w = GetLocalState(l);
      w.hasOwnProperty("maskVisible") && delete w.maskVisible;
      w.visible = l.visible;
      return this;
    },
    setChildVisible(l, w) {
      this.setChildLocalVisible(l, w);
      return this;
    },
    setChildLocalVisible(l, w) {
      void 0 === w && (w = !0);
      GetLocalState(l).visible = w;
      this.updateChildVisible(l);
      return this;
    },
    setChildMaskVisible(l, w) {
      void 0 === w && (w = !0);
      GetLocalState(l).maskVisible = w;
      this.updateChildVisible(l);
      return this;
    },
    resetLocalVisibleState() {
      var l = GetLocalState(this).parent;
      l && l.resetChildVisibleState(this);
      return this;
    },
  },
  Alpha = {
    updateChildAlpha(l) {
      var w = GetLocalState(l),
        h = w.parent;
      w.syncAlpha && (l.alpha = h.alpha * w.alpha);
      return this;
    },
    syncAlpha() {
      this.syncChildrenEnable &&
        this.children.forEach(this.updateChildAlpha, this);
      return this;
    },
    resetChildAlphaState(l) {
      var w = GetLocalState(l);
      w.alpha = GetScale(l.alpha, w.parent.alpha);
      return this;
    },
    setChildAlpha(l, w) {
      l.alpha = w;
      this.resetChildAlphaState(l);
      return this;
    },
    setChildLocalAlpha(l, w) {
      GetLocalState(l).alpha = w;
      this.updateChildAlpha(l);
      return this;
    },
    resetLocalAlphaState() {
      var l = GetLocalState(this).parent;
      l && l.resetChildAlphaState(this);
      return this;
    },
  },
  Active = {
    updateChildActive(l) {
      var w = GetLocalState(l);
      l.active = w.parent.active && w.active;
      return this;
    },
    syncActive() {
      this.syncChildrenEnable &&
        this.children.forEach(this.updateChildActive, this);
      return this;
    },
    resetChildActiveState(l) {
      GetLocalState(l).active = l.active;
      return this;
    },
    setChildActive(l, w) {
      l.active = w;
      this.resetChildActiveState(l);
      return this;
    },
    setChildLocalActive(l, w) {
      void 0 === w && (w = !0);
      GetLocalState(l).active = w;
      this.updateChildActive(l);
      return this;
    },
    resetLocalActiveState() {
      var l = GetLocalState(this).parent;
      l && l.resetChildActiveState(this);
      return this;
    },
  },
  ScrollFactor = {
    updateChildScrollFactor(l) {
      var w = GetLocalState(l).parent;
      l.setScrollFactor(w.scrollFactorX, w.scrollFactorY);
      return this;
    },
    syncScrollFactor() {
      this.syncChildrenEnable &&
        this.children.forEach(this.updateChildScrollFactor, this);
      return this;
    },
  },
  Mask = {
    updateChildMask(l) {
      if (null == this.mask) return this;
      (this.mask.hasOwnProperty("geometryMask")
        ? this.mask.geometryMask
        : this.mask.bitmapMask) !== l && (l.mask = this.mask);
      return this;
    },
    syncMask() {
      this.syncChildrenEnable &&
        this.children.forEach(this.updateChildMask, this);
      return this;
    },
    setMask(l) {
      this.mask = l;
      return this;
    },
    clearMask(l) {
      void 0 === l && (l = !1);
      l && this.mask && this.mask.destroy();
      this.mask = null;
      return this;
    },
  },
  SortGameObjectsByDepth = function (l, w) {
    if (0 === l.length) return l;
    void 0 === w && (w = !1);
    var h = l[0].scene.sys.displayList;
    h.depthSort();
    w
      ? l.sort(function (t, a) {
          return h.getIndex(a) - h.getIndex(t);
        })
      : l.sort(function (t, a) {
          return h.getIndex(t) - h.getIndex(a);
        });
    return l;
  },
  Depth = {
    setDepth(l, w) {
      this.depth = l;
      if (!w && this.children) {
        w = this.getAllChildren();
        for (var h = 0, t = w.length; h < t; h++) w[h].depth = l;
      }
      return this;
    },
    swapDepth(l) {
      var w = this.depth;
      this.setDepth(l.depth);
      l.setDepth(w);
      return this;
    },
    incDepth(l) {
      this.depth += l;
      if (this.children)
        for (var w = this.getAllChildren(), h = 0, t = w.length; h < t; h++)
          w[h].depth += l;
      return this;
    },
    moveDepthBelow(l) {
      var w = l.scene.children,
        h = this.getAllChildren([this]);
      SortGameObjectsByDepth(h);
      for (var t = 0, a = h.length; t < a; t++) {
        var d = h[t];
        if (w.exists(d)) {
          w.moveBelow(l, d);
          break;
        }
      }
      return this;
    },
    moveDepthAbove(l) {
      var w = l.scene.children,
        h = this.getAllChildren([this]);
      SortGameObjectsByDepth(h, !0);
      for (var t = 0, a = h.length; t < a; t++) {
        var d = h[t];
        if (w.exists(d)) {
          w.moveAbove(l, d);
          break;
        }
      }
      return this;
    },
  },
  DepthFirstSearch = function (l, w) {
    if (!w(l) && l.isRexContainerLite) {
      l = l.children;
      for (var h = 0, t = l.length; h < t; h++) DepthFirstSearch(l[h], w);
    }
  },
  BreadthFirstSearch = function (l, w) {
    for (l = [l]; 0 < l.length; ) {
      var h = l.shift();
      !w(h) && h.isRexContainerLite && l.push(...h.children);
    }
  };
const ArrayUtils = Phaser.Utils.Array;
var Children = {
    getChildren(l) {
      if (l)
        for (var w = 0, h = this.children.length; w < h; w++)
          l.push(this.children[w]);
      else l = this.children;
      return l;
    },
    getAllChildren(l) {
      void 0 === l && (l = []);
      var w = this;
      BreadthFirstSearch(w, function (h) {
        h !== w && l.push(h);
      });
      return l;
    },
    getAllVisibleChildren(l) {
      void 0 === l && (l = []);
      var w = this;
      BreadthFirstSearch(w, function (h) {
        if (h !== w) {
          if (!h.visible) return !0;
          l.push(h);
        }
      });
      return l;
    },
    bfs(l, w) {
      void 0 === w && (w = this);
      BreadthFirstSearch(w, l);
      return this;
    },
    dfs(l, w) {
      void 0 === w && (w = this);
      DepthFirstSearch(w, l);
      return this;
    },
    contains(l) {
      return (l = GetParent(l)) ? (l === this ? !0 : this.contains(l)) : !1;
    },
    getByName(l, w) {
      if (w) {
        w = [this];
        for (var h, t; w.length; ) {
          h = w.shift();
          for (var a = 0, d = h.children.length; a < d; a++) {
            t = h.children[a];
            if (t.name === l) return t;
            t.isRexContainerLite && w.push(t);
          }
        }
        return null;
      }
      return ArrayUtils.GetFirst(this.children, "name", l);
    },
    getRandom(l, w) {
      return ArrayUtils.GetRandom(this.children, l, w);
    },
    getFirst(l, w, h, t) {
      return ArrayUtils.GetFirstElement(this.children, l, w, h, t);
    },
    getAll(l, w, h, t) {
      return ArrayUtils.GetAll(this.children, l, w, h, t);
    },
    count(l, w, h, t) {
      return ArrayUtils.CountAllMatching(this.children, l, w, h, t);
    },
    swap(l, w) {
      ArrayUtils.Swap(this.children, l, w);
      return this;
    },
    setAll(l, w, h, t) {
      ArrayUtils.SetAll(this.children, l, w, h, t);
      return this;
    },
  },
  GetLocalStates = function (l) {
    for (var w = [], h = 0, t = l.length; h < t; h++) {
      var a = l[h];
      a.hasOwnProperty("rexContainer") && w.push(a.rexContainer);
    }
    return w;
  },
  GetScene = function (l) {
    for (var w = 0, h = l.length; w < h; w++) {
      var t = l[w].scene;
      if (t) return t;
    }
    return null;
  },
  UpdateChild = function (l, w, h) {
    if (h.parent)
      switch (((l = h.parent), (h = h.self), w)) {
        case "x":
        case "y":
          l.updateChildPosition(h);
          break;
        case "angle":
        case "rotation":
          l.updateChildRotation(h);
          break;
        case "scaleX":
        case "scaleY":
        case "displayWidth":
        case "displayHeight":
          l.updateChildScale(h);
          break;
        case "alpha":
          l.updateChildAlpha(h);
          break;
        default:
          l.updateChildPosition(h),
            l.updateChildRotation(h),
            l.updateChildScale(h),
            l.updateChildAlpha(h);
      }
    else l.remove();
  },
  Tween = {
    tweenChild(l) {
      var w = l.targets;
      Array.isArray(w) || (w = [w]);
      var h = this.scene || GetScene(w);
      if (h)
        return (
          (l.targets = GetLocalStates(w)),
          (l = h.tweens.add(l)),
          l.on("update", UpdateChild),
          l
        );
    },
    createTweenChildConfig(l) {
      var w = l.targets;
      w && (Array.isArray(w) || (w = [w]), (l.targets = GetLocalStates(w)));
      var h = l.onUpdate;
      l.onUpdate = function (t, a) {
        h && h(t, a);
        UpdateChild(t, void 0, a);
      };
      return l;
    },
    tween(l) {
      var w = this.scene;
      l.targets || (l.targets = this);
      return w.tweens.add(l);
    },
    timelineChild(l) {
      var w = l.targets;
      w && (Array.isArray(w) || (w = [w]), (l.targets = GetLocalStates(w)));
      w = l.tweens;
      for (var h = 0, t = w.length; h < t; h++)
        w[h] = this.createTweenChildConfig(w[h]);
      return this.scene.tweens.timeline(l);
    },
  },
  AddToLayer = function (l) {
    var w = this.getAllChildren([this]);
    SortGameObjectsByDepth(w);
    l.add(w);
    return this;
  },
  AddToContainer = {
    addToLayer: AddToLayer,
    addToContainer: AddToLayer,
  };
const RotateAround$1 = Phaser.Math.RotateAround;
var ChangeOrigin$1 = function (l, w, h) {
    void 0 === h && (h = w);
    var t = {
      x: (w - l.originX) * l.displayWidth,
      y: (h - l.originY) * l.displayHeight,
    };
    RotateAround$1(t, 0, 0, l.rotation);
    l.originX = w;
    l.originY = h;
    l.x += t.x;
    l.y += t.y;
    return l;
  },
  ChangeOrigin = function (l, w) {
    this.syncChildrenEnable = !1;
    ChangeOrigin$1(this, l, w);
    this.syncChildrenEnable = !0;
    l = this.getAllChildren();
    w = 0;
    for (var h = l.length; w < h; w++) this.resetChildPositionState(l[w]);
    return this;
  },
  methods$2 = {
    changeOrigin: ChangeOrigin,
  };
Object.assign(
  methods$2,
  Parent,
  AddChild,
  RemoveChild,
  ChildState,
  Transform,
  Position,
  Rotation,
  Scale,
  Visible,
  Alpha,
  Active,
  ScrollFactor,
  Mask,
  Depth,
  Children,
  Tween,
  AddToContainer
);
class ContainerLite extends Base {
  constructor(l, w, h, t, a, d) {
    super(l, w, h, t, a);
    this.type = "rexContainerLite";
    this._active = this.syncChildrenEnable = this.isRexContainerLite = !0;
    this._mask = null;
    this._scrollFactorY = this._scrollFactorX = 1;
    d && this.add(d);
  }
  destroy(l) {
    this.scene && ((this.syncChildrenEnable = !1), super.destroy(l));
  }
  resize(l, w) {
    this.setSize(l, w);
    return this;
  }
  get x() {
    return this._x;
  }
  set x(l) {
    this._x !== l && ((this._x = l), this.syncPosition());
  }
  get y() {
    return this._y;
  }
  set y(l) {
    this._y !== l && ((this._y = l), this.syncPosition());
  }
  get rotation() {
    return super.rotation;
  }
  set rotation(l) {
    this.rotation !== l && ((super.rotation = l), this.syncPosition());
  }
  get scaleX() {
    return super.scaleX;
  }
  set scaleX(l) {
    this.scaleX !== l && ((super.scaleX = l), this.syncPosition());
  }
  get scaleY() {
    return super.scaleY;
  }
  set scaleY(l) {
    this.scaleY !== l && ((super.scaleY = l), this.syncPosition());
  }
  get scale() {
    return super.scale;
  }
  set scale(l) {
    this.scale !== l && ((super.scale = l), this.syncPosition());
  }
  get visible() {
    return super.visible;
  }
  set visible(l) {
    super.visible !== l && ((super.visible = l), this.syncVisible());
  }
  get alpha() {
    return super.alpha;
  }
  set alpha(l) {
    super.alpha !== l && ((super.alpha = l), this.syncAlpha());
  }
  get active() {
    return this._active;
  }
  set active(l) {
    this._active !== l && ((this._active = l), this.syncActive());
  }
  get mask() {
    return this._mask;
  }
  set mask(l) {
    this._mask !== l && ((this._mask = l), this.syncMask());
  }
  get scrollFactorX() {
    return this._scrollFactorX;
  }
  set scrollFactorX(l) {
    this._scrollFactorX !== l &&
      ((this._scrollFactorX = l), this.syncScrollFactor());
  }
  get scrollFactorY() {
    return this._scrollFactorY;
  }
  set scrollFactorY(l) {
    this._scrollFactorY !== l &&
      ((this._scrollFactorY = l), this.syncScrollFactor());
  }
  get list() {
    return this.children;
  }
  static GetParent(l) {
    return GetParent(l);
  }
}
Object.assign(ContainerLite.prototype, methods$2);
var AddChess = function (l, w, h, t) {
    var a = this.grid;
    a.saveOrigin();
    a.setOriginPosition(this.x, this.y);
    this.board.addChess(l, w, h, t, !0);
    IsUID(l) && (l = this.board.uidToChess(l));
    this.add(l);
    a.restoreOrigin();
    return this;
  },
  RemoveChess = function (l, w, h, t, a) {
    this.board.removeChess(l, w, h, t, a);
    return this;
  },
  RemoveAllChess = function (l) {
    this.board.removeAllChess(l);
    return this;
  },
  SetMainBoard = function (l, w, h) {
    this.mainBoardRef.set(l, w, h);
    l && this.lastMainBoardRef.set(l, w, h);
    return this;
  },
  CanPutOnMainBoard = function (l, w, h, t) {
    if (!l) return !1;
    void 0 === t && (t = this.tileXYZMap);
    var a;
    for (a in t) {
      var d = t[a];
      var k = l.offset(d, w, h, !0);
      if (!l.contains(k.x, k.y)) return !1;
      this.putTestCallback
        ? ((targetTileXY.x = k.x),
          (targetTileXY.y = k.x),
          (targetTileXY.z = d.z),
          (d = this.board.uidToChess(a)),
          (d = this.putTestCallbackScpe
            ? this.putTestCallback.call(
                this.putTestCallbackScpe,
                targetTileXY,
                l,
                d
              )
            : this.putTestCallback(targetTileXY, l, d)))
        : (d = l.contains(k.x, k.y, d.z));
      if (d) return !1;
    }
    return !0;
  },
  targetTileXY = {
    x: 0,
    y: 0,
    z: 0,
  },
  PutOnMainBoard = function (l, w, h, t) {
    if (!l) return this;
    void 0 === w &&
      ((h = l.worldXYToTileXY(this.x, this.y, !0)), (w = h.x), (h = h.y));
    void 0 === t && (t = !0);
    this.pullOutFromMainBoard();
    if (!this.canPutOnMainBoard(l, w, h)) return this;
    this.setMainBoard(l, w, h);
    var a = this.tileXYZMap;
    for (k in a) {
      var d = a[k];
      var k = parseInt(k);
      var e = l.offset(d, w, h, !0);
      l.addChess(k, e.x, e.y, d.z, !1);
    }
    t && this.alignToMainBoard(l, w, h);
    return this;
  },
  PullOutFromMainBoard = function () {
    var l = this.mainBoard;
    if (null === l) return this;
    var w = this.tileXYZMap,
      h;
    for (h in w) l.removeChess(parseInt(h));
    this.setMainBoard(null);
    return this;
  },
  PutBack = function () {
    this.putOnMainBoard(
      this.lastMainBoardRef.mainBoard,
      this.lastMainBoardRef.tileX,
      this.lastMainBoardRef.tileY,
      !1
    );
    return this;
  },
  IsOverlapping = function (l, w) {
    if (!l) return !1;
    var h;
    for (h in this.tileXYZMap) {
      var t = this.board.uidToChess(h);
      if (l.isOverlappingPoint(t.x, t.y, w)) return !0;
    }
    return !1;
  },
  AlignToMainBoard = function (l, w, h) {
    if (!l) return this;
    void 0 === w &&
      ((h = l.worldXYToTileXY(this.x, this.y, !0)), (w = h.x), (h = h.y));
    l.gridAlign(this, w, h);
    return this;
  },
  OnPointerDown = function (l) {
    this.input.enable &&
      l.isDown &&
      (null === this.input.pointer && (this.input.pointer = l),
      OnTouchTileStart.call(this, l) && OnDragStart.call(this, l));
  },
  OnTouchTileStart = function (l) {
    var w = this.grid;
    w.saveOrigin();
    w.setOriginPosition(this.x, this.y);
    var h = this.board.worldXYToTileXY(l.x, l.y, !0),
      t = h.x;
    h = h.y;
    w.restoreOrigin();
    this.input.tilePosition.x = t;
    this.input.tilePosition.y = h;
    w = this.board.tileXYToChessArray(t, h, globChessArray$2);
    if ((t = 0 < w.length)) {
      for (var a = 0, d = w.length; a < d; a++)
        (h = w[a]),
          h.emit && h.emit("miniboard.pointerdown", l),
          this.emit("gameobjectdown", l, h);
      this.emit("pointerdown", l, this);
    }
    globChessArray$2.length = 0;
    return t;
  },
  OnDragStart = function (l) {
    var w = this.input.drag;
    if (1 !== w.state) {
      var h = w.position;
      h.x = l.x - this.x;
      h.y = l.y - this.y;
      w.state = 1;
      this.emit("dragstart", l, h.x, h.y);
    }
  },
  globChessArray$2 = [],
  DragEnd = function (l) {
    var w = this.input.drag;
    if (0 !== w.state) {
      void 0 === l && (l = this.input.pointer);
      var h = w.position,
        t = l.x - h.x;
      h = l.y - h.y;
      w.state = 0;
      this.emit("dragend", l, t, h);
      return this;
    }
  },
  OnPointerUp = function (l) {
    this.input.enable &&
      (OnTouchTileEnd.call(this, l),
      DragEnd.call(this, l),
      this.input.pointer === l && (this.input.pointer = null));
  },
  OnTouchTileEnd = function (l) {
    var w = this.grid;
    w.saveOrigin();
    w.setOriginPosition(this.x, this.y);
    var h = this.board.worldXYToTileXY(l.x, l.y, !0),
      t = h.x;
    h = h.y;
    w.restoreOrigin();
    this.input.tilePosition.x = t;
    this.input.tilePosition.y = h;
    w = this.board.tileXYToChessArray(t, h, globChessArray$1);
    if ((t = 0 < w.length)) {
      for (var a = 0, d = w.length; a < d; a++)
        (h = w[a]),
          h.emit && h.emit("miniboard.pointerup", l),
          this.emit("gameobjectup", l, h);
      this.emit("pointerup", l, this);
    }
    globChessArray$1.length = 0;
    return t;
  },
  globChessArray$1 = [],
  OnPointerMove = function (l) {
    this.input.enable && (OnTouchTileMove.call(this, l), OnDrag.call(this, l));
  },
  OnTouchTileMove = function (l) {
    var w = this.grid;
    w.saveOrigin();
    w.setOriginPosition(this.x, this.y);
    var h = this.board.worldXYToTileXY(l.x, l.y, !0),
      t = h.x;
    h = h.y;
    w.restoreOrigin();
    if (this.input.tilePosition.x !== t || this.input.tilePosition.y !== h) {
      this.input.tilePosition.x = t;
      this.input.tilePosition.y = h;
      w = this.board.tileXYToChessArray(t, h, globChessArray);
      if ((t = 0 < w.length)) {
        for (var a = 0, d = w.length; a < d; a++)
          (h = w[a]),
            h.emit && h.emit("miniboard.pointermove", l),
            this.emit("gameobjectmove", l, h);
        this.emit("pointermove", l, this);
      } else this.input.pointer === l && (this.input.pointer = null);
      globChessArray.length = 0;
      0 === this.input.drag.state &&
        (this.input.pointer === l
          ? t || (this.input.pointer = null)
          : null === this.input.pointer && (this.input.pointer = l));
    }
  },
  OnDrag = function (l) {
    var w = this.input.drag;
    0 !== w.state &&
      ((w = w.position), this.emit("drag", l, l.x - w.x, l.y - w.y));
  },
  globChessArray = [],
  SetInteractive = function (l) {
    void 0 === l && (l = !0);
    this.input ||
      ((this.input = {
        enable: !0,
        tilePosition: {
          x: void 0,
          y: void 0,
        },
        pointer: void 0,
        drag: {
          enable: !1,
          state: 0,
          position: {
            x: void 0,
            y: void 0,
          },
        },
      }),
      this.scene.input.on("pointerdown", OnPointerDown, this),
      this.scene.input.on("pointerup", OnPointerUp, this),
      this.scene.input.on("pointermove", OnPointerMove, this),
      this.once(
        "destroy",
        function () {
          this.scene &&
            (this.scene.input.off("pointerdown", OnPointerDown, this),
            this.scene.input.off("pointerup", OnPointerUp, this),
            this.scene.input.off("pointermove", OnPointerMove, this));
        },
        this
      ));
    this.input.enable = l;
    l || (this.input.pointer = null);
    return this;
  },
  SetDraggable = function (l) {
    void 0 === l && (l = !0);
    this.setInteractive();
    this.input.drag.enable = l;
    l || (this.input.drag.state = 0);
    return this;
  },
  Mirror$1 = function (l, w, h) {
    void 0 === l ? (l = 1) : "string" === typeof l && (l = MODE$1[l]);
    void 0 === w && (w = this.tileXYZMap);
    void 0 === h && (h = {});
    var t;
    for (t in w) {
      var a = w[t];
      var d = this.board.mirror(a, l);
      d.z = a.z;
      h[t] = d;
    }
    return h;
  };
const MODE$1 = {
  x: 1,
  y: 2,
  "x&y": 3,
};
var CanMirror = function (l) {
    if (null === this.mainBoard) return !0;
    l = Mirror$1.call(this, l);
    return this.canPutOnMainBoard(this.mainBoard, tileX, tileY, l);
  },
  ResetChessTileXYZ = function (l) {
    this.removeAllChess();
    for (h in l) {
      var w = l[h];
      var h = parseInt(h);
      this.addChess(h, w.x, w.y, w.z, !1);
    }
    return this;
  },
  Mirror = function (l) {
    var w = null != this.mainBoard;
    w && this.pullOutFromMainBoard();
    l = Mirror$1.call(this, l);
    w
      ? ((this.lastTransferResult = this.canPutOnMainBoard(
          this.lastMainBoardRef.mainBoard,
          this.lastMainBoardRef.tileX,
          this.lastMainBoardRef.tileY,
          l
        )) && ResetChessTileXYZ.call(this, l),
        this.putBack())
      : ((this.lastTransferResult = !0), ResetChessTileXYZ.call(this, l));
    return this;
  },
  Rotate$2 = function (l, w, h) {
    void 0 === l && (l = 0);
    void 0 === w && (w = this.tileXYZMap);
    void 0 === h && (h = {});
    var t;
    for (t in w) {
      var a = w[t];
      var d = this.board.rotate(a, l);
      d.z = a.z;
      h[t] = d;
    }
    return h;
  },
  CanRotate = function (l) {
    if (null === this.mainBoard) return !0;
    l = Rotate$2.call(this, l);
    return this.canPutOnMainBoard(this.mainBoard, tileX, tileY, l);
  },
  Rotate$1 = function (l) {
    if (0 === l) return this;
    var w = null != this.mainBoard;
    w && this.pullOutFromMainBoard();
    var h = Rotate$2.call(this, l);
    w
      ? ((this.lastTransferResult = this.canPutOnMainBoard(
          this.lastMainBoardRef.mainBoard,
          this.lastMainBoardRef.tileX,
          this.lastMainBoardRef.tileY,
          h
        )) && ResetChessTileXYZ.call(this, h),
        this.putBack())
      : ((this.lastTransferResult = !0), ResetChessTileXYZ.call(this, h));
    this.lastTransferResult && this.setFace(this.face + l);
    return this;
  },
  CanRotateTo = function (l) {
    l -= this.face;
    return this.canRotate(l);
  },
  RotateTo$1 = function (l) {
    l -= this.face;
    this.rotate(l);
    return this;
  },
  GetMinMaxTileXY = function (l, w) {
    void 0 === w ? (w = {}) : !0 === w && (w = globResult);
    l = Infinity;
    var h = -Infinity,
      t = Infinity,
      a = -Infinity,
      d;
    for (d in this.tileXYZMap) {
      var k = this.tileXYZMap[d];
      k.x < l && (l = k.x);
      k.x > h && (h = k.x);
      k.y < t && (t = k.y);
      k.y > a && (a = k.y);
    }
    w.minX = l;
    w.minY = t;
    w.maxX = h;
    w.maxY = a;
    return w;
  },
  globResult = {},
  Offset = function (l, w, h, t) {
    void 0 === h && (h = this.tileXYZMap);
    void 0 === t && (t = {});
    var a;
    for (a in h) {
      var d = h[a];
      var k = this.board.offset(d, l, w);
      k.z = d.z;
      t[a] = k;
    }
    return t;
  },
  SetOrigin = function (l, w) {
    switch (l) {
      case "center":
        w = l = 0.5;
        break;
      case "top-left":
      case "left-top":
        w = l = 0;
    }
    void 0 === l && (l = 0.5);
    void 0 === w && (w = l);
    var h = GetMinMaxTileXY.call(this, void 0, !0);
    l = -Math.floor(Linear$1(h.minX, h.maxX, l));
    w = -Math.floor(Linear$1(h.minY, h.maxY, w));
    if (0 !== l || 0 !== w)
      (h = Offset.call(this, l, w)),
        ResetChessTileXYZ.call(this, h),
        (l = this.board.tileXYToWorldXY(l, w)),
        (w = this.board.tileXYToWorldXY(0, 0)),
        this.setPosition(this.x + (w.x - l.x), this.y + (w.y - l.y));
    return this;
  },
  Methods = {
    addChess: AddChess,
    removeChess: RemoveChess,
    removeAllChess: RemoveAllChess,
    pullOutFromMainBoard: PullOutFromMainBoard,
    canPutOnMainBoard: CanPutOnMainBoard,
    putOnMainBoard: PutOnMainBoard,
    putBack: PutBack,
    isOverlapping: IsOverlapping,
    alignToMainBoard: AlignToMainBoard,
    setInteractive: SetInteractive,
    setDraggable: SetDraggable,
    dragEnd: DragEnd,
    setMainBoard: SetMainBoard,
    canMirror: CanMirror,
    mirror: Mirror,
    canRotate: CanRotate,
    rotate: Rotate$1,
    canRotateTo: CanRotateTo,
    rotateTo: RotateTo$1,
    setOrigin: SetOrigin,
  };
class MainBoardReference {
  constructor(l) {
    this.miniBoard = l;
    this.set(null);
  }
  set(l, w, h) {
    l || (h = w = l = null);
    this.mainBoard = l;
    this.tileX = w;
    this.tileY = h;
  }
}
class MiniBoard extends ContainerLite {
  constructor(l, w, h, t) {
    super(l, w, h, 0, 0);
    this.type = "rexMiniBoard";
    w = {
      isBoard: !1,
      grid: GetValue$l(t, "grid", void 0),
      infinity: !0,
      wrap: !1,
    };
    this.board = new Board$1(l, w);
    this.mainBoardRef = new MainBoardReference();
    this.lastMainBoardRef = new MainBoardReference();
    this.resetFromJSON(t);
  }
  resetFromJSON(l) {
    this.setFace(GetValue$l(l, "face", 0));
    var w = GetValue$l(l, "draggable", void 0);
    void 0 !== w && this.setDraggable(w);
    this.setPutTestCallback(
      GetValue$l(l, "putTestCallback", void 0),
      GetValue$l(l, "putTestCallbackScpe", void 0)
    );
    this.lastTransferResult = GetValue$l(l, "lastTransferResult", void 0);
    return this;
  }
  destroy(l) {
    this.scene &&
      (this.clear(!l),
      this.board.shutdown(l),
      (this.board = void 0),
      this.setPutTestCallback(void 0, void 0),
      super.destroy(l));
  }
  setFace(l) {
    this.face = this.board.grid.directionNormalize(l);
    return this;
  }
  get mainBoard() {
    return this.mainBoardRef.mainBoard;
  }
  get tileX() {
    return this.mainBoardRef.tileX;
  }
  get tileY() {
    return this.mainBoardRef.tileY;
  }
  get grid() {
    return this.board.grid;
  }
  get tileXYZMap() {
    return this.board.boardData.UIDToXYZ;
  }
  setPutTestCallback(l, w) {
    this.putTestCallback = l;
    this.putTestCallbackScpe = w;
    return this;
  }
}
Object.assign(MiniBoard.prototype, Methods);
ObjectFactory$1.register("miniBoard", function (l, w, h) {
  l = new MiniBoard(this.scene, l, w, h);
  this.scene.add.existing(l);
  return l;
});
SetValue(window, "RexPlugins.Board.MiniBoard", MiniBoard);
var GetHexagonMap = function (l, w, h) {
    void 0 === h && (h = []);
    l = l.grid.mode;
    for (var t, a, d = -w; d <= w; d++)
      for (t = Math.max(-w, -d - w), a = Math.min(w, -d + w); t <= a; t++)
        h.push(cube2cr(l, d, t, -d - t));
    return h;
  },
  GetTriangleMap = function (l, w, h, t) {
    void 0 === t && (t = []);
    l = l.grid.mode;
    for (var a, d, k = 0; k <= h; k++)
      for (
        1 === w ? ((a = h - k), (d = h)) : ((a = 0), (d = h - k));
        a <= d;
        a++
      )
        t.push(cube2cr(l, k, a, -k - a));
    return t;
  },
  GetParallelogramMap = function (l, w, h, t, a) {
    void 0 === a && (a = []);
    l = l.grid.mode;
    switch (w) {
      case 1:
        for (w = 0; w <= h; w++)
          for (var d = 0; d <= t; d++) a.push(cube2cr(l, d, -d - w, w));
        break;
      case 2:
        for (var k = 0; k <= h; k++)
          for (w = 0; w <= t; w++) a.push(cube2cr(l, -k - w, k, w));
        break;
      default:
        for (d = 0; d <= h; d++)
          for (k = 0; k <= t; k++) a.push(cube2cr(l, d, k, -d - k));
    }
    return a;
  },
  HexagonMap = {
    hexagon: GetHexagonMap,
    triangle: GetTriangleMap,
    parallelogram: GetParallelogramMap,
  };
const Pad = Phaser.Utils.String.Pad;
var GetStyle = function (l, w, h) {
    if (null == l) return l;
    switch (typeof l) {
      case "string":
        return l;
      case "number":
        return `#${Pad(Math.floor(l).toString(16), 6, "0", 1)}`;
      case "function":
        return l(w, h);
      case "object":
        return l.hasOwnProperty("r")
          ? l.hasOwnProperty("a")
            ? `rgba(${l.r},${l.g},${l.b},${l.a})`
            : `rgb(${l.r},${l.g},${l.b})`
          : l.hasOwnProperty("h")
          ? l.hasOwnProperty("a")
            ? `hsla(${l.h},${l.s},${l.l},${l.a})`
            : `hsl(${l.h},${l.s},${l.l})`
          : l;
      default:
        return l;
    }
  },
  DrawPolygon = function (l, w, h, t, a, d, k) {
    void 0 === k && (k = "round");
    w.beginPath();
    w.lineJoin = k;
    l = h[0];
    w.moveTo(l.x, l.y);
    k = 1;
    for (var e = h.length; k < e; k++) (l = h[k]), w.lineTo(l.x, l.y);
    w.closePath();
    null != t && ((w.fillStyle = t), w.fill());
    null != a && ((w.strokeStyle = a), (w.lineWidth = d), w.stroke());
  },
  CreatePolygonTexture = function (l, w, h, t, a, d, k) {
    void 0 === t && void 0 === a && (t = 16777215);
    void 0 === a ? (d = 0) : void 0 === d && (d = 2);
    for (
      var e = Infinity,
        b = Infinity,
        c = -Infinity,
        f = -Infinity,
        g = 0,
        m = h.length;
      g < m;
      g++
    ) {
      var n = h[g],
        q = n.x;
      n = n.y;
      e = Math.min(e, q);
      b = Math.min(b, n);
      c = Math.max(c, q);
      f = Math.max(f, n);
    }
    g = c - e;
    m = f - b;
    l = l.sys.textures.createCanvas(w, Math.ceil(g), Math.ceil(m));
    w = l.getCanvas();
    f = l.getContext();
    c = g / 2;
    q = m / 2;
    var r = d / 2,
      u = [];
    g = 0;
    for (m = h.length; g < m; g++)
      (n = h[g]),
        u.push({
          x: Indent(n.x - e, c, r),
          y: Indent(n.y - b, q, r),
        });
    DrawPolygon(w, f, u, GetStyle(t, w, f), GetStyle(a, w, f), d, k);
    l.refresh();
  },
  Indent = function (l, w, h) {
    return l < w ? l + h : l > w ? l - h : l;
  },
  CreateTileTexture = function (l, w, h, t, a, d) {
    void 0 === d && (d = "miter");
    CreatePolygonTexture(l.scene, w, l.getGridPoints(0, 0, !0), h, t, a, d);
  };
class BoardPlugin extends Phaser.Plugins.ScenePlugin {
  constructor(l, w) {
    super(l, w);
    this.add = new ObjectFactory$1(l);
    this.hexagonMap = HexagonMap;
    this.createTileTexture = CreateTileTexture;
  }
  start() {
    this.scene.sys.events.on("destroy", this.destroy, this);
  }
}
var SetVelocity = function (l, w, h, t) {
  l = l.body;
  var a = l.velocity.x,
    d = l.velocity.y;
  if (w !== a || h !== d) l.setVelocity(w, h), t && t(w, h, a, d);
};
const GetValue$c = Phaser.Utils.Objects.GetValue;
class Bullet extends SceneUpdateTickTask {
  constructor(l, w) {
    super(l, w);
    this.resetFromJSON(w);
    this.boot();
  }
  resetFromJSON(l) {
    this.parent.body || this.scene.physics.add.existing(this.parent, !1);
    this.setWrapMode(GetValue$c(l, "wrap", !1), GetValue$c(l, "padding", 0));
    this.setEnable(GetValue$c(l, "enable", !0));
    this.setSpeed(GetValue$c(l, "speed", 200));
    return this;
  }
  get enable() {
    return this.isRunning;
  }
  set enable(l) {
    (this.isRunning = l) || SetVelocity(this.parent, 0, 0);
  }
  setEnable(l) {
    void 0 == l && (l = !0);
    this.enable = l;
    return this;
  }
  setSpeed(l) {
    this.speed = l;
    return this;
  }
  setWrapMode(l, w) {
    void 0 === l && (l = !0);
    this.wrap = l;
    this.padding = w;
    return this;
  }
  update(l, w) {
    l = this.parent;
    if (!this.enable) return SetVelocity(l, 0, 0), this;
    if (!l.active) return this;
    w = l.rotation;
    SetVelocity(l, this.speed * Math.cos(w), this.speed * Math.sin(w));
    this.wrap && l.body.world.wrap(l, this.padding);
    return this;
  }
}
class BulletPlugin extends Phaser.Plugins.BasePlugin {
  constructor(l) {
    super(l);
  }
  start() {
    this.game.events.on("destroy", this.destroy, this);
  }
  add(l, w) {
    return new Bullet(l, w);
  }
}
const GetValue$b = Phaser.Utils.Objects.GetValue,
  Clamp = Phaser.Math.Clamp;
class Timer {
  constructor(l) {
    this.resetFromJSON(l);
  }
  resetFromJSON(l) {
    this.state = GetValue$b(l, "state", IDLE$4);
    this.timeScale = GetValue$b(l, "timeScale", 1);
    this.delay = GetValue$b(l, "delay", 0);
    this.repeat = GetValue$b(l, "repeat", 0);
    this.repeatCounter = GetValue$b(l, "repeatCounter", 0);
    this.duration = GetValue$b(l, "duration", 0);
    this.nowTime = GetValue$b(l, "nowTime", 0);
    this.justRestart = GetValue$b(l, "justRestart", !1);
  }
  toJSON() {
    return {
      state: this.state,
      timeScale: this.timeScale,
      delay: this.delay,
      repeat: this.repeat,
      repeatCounter: this.repeatCounter,
      duration: this.duration,
      nowTime: this.nowTime,
      justRestart: this.justRestart,
    };
  }
  destroy() {}
  setTimeScale(l) {
    this.timeScale = l;
    return this;
  }
  setDelay(l) {
    void 0 === l && (l = 0);
    this.delay = l;
    return this;
  }
  setDuration(l) {
    this.duration = l;
    return this;
  }
  setRepeat(l) {
    this.repeat = l;
    return this;
  }
  setRepeatInfinity() {
    this.repeat = -1;
    return this;
  }
  start() {
    this.nowTime = 0 < this.delay ? -this.delay : 0;
    this.state = 0 <= this.nowTime ? COUNTDOWN : DELAY;
    this.repeatCounter = 0;
    return this;
  }
  stop() {
    this.state = IDLE$4;
    return this;
  }
  update(l, w) {
    this.state !== IDLE$4 &&
      this.state !== DONE &&
      0 !== w &&
      0 !== this.timeScale &&
      ((this.nowTime += w * this.timeScale),
      (this.state = 0 <= this.nowTime ? COUNTDOWN : DELAY),
      (this.justRestart = !1),
      this.nowTime >= this.duration &&
        (-1 === this.repeat || this.repeatCounter < this.repeat
          ? (this.repeatCounter++,
            (this.justRestart = !0),
            (this.nowTime -= this.duration))
          : ((this.nowTime = this.duration), (this.state = DONE))));
  }
  get t() {
    switch (this.state) {
      case IDLE$4:
      case DELAY:
        var l = 0;
        break;
      case COUNTDOWN:
        l = this.nowTime / this.duration;
        break;
      case DONE:
        l = 1;
    }
    return Clamp(l, 0, 1);
  }
  set t(l) {
    l = Clamp(l, -1, 1);
    0 > l
      ? ((this.state = DELAY), (this.nowTime = -this.delay * l))
      : ((this.state = COUNTDOWN),
        (this.nowTime = this.duration * l),
        1 === l && 0 !== this.repeat && this.repeatCounter++);
  }
  setT(l) {
    this.t = l;
    return this;
  }
  get isIdle() {
    return this.state === IDLE$4;
  }
  get isDelay() {
    return this.state === DELAY;
  }
  get isCountDown() {
    return this.state === COUNTDOWN;
  }
  get isRunning() {
    return this.state === DELAY || this.state === COUNTDOWN;
  }
  get isDone() {
    return this.state === DONE;
  }
  get isOddIteration() {
    return 1 === (this.repeatCounter & 1);
  }
  get isEvenIteration() {
    return 0 === (this.repeatCounter & 1);
  }
}
const IDLE$4 = 0,
  DELAY = 1,
  COUNTDOWN = 2,
  DONE = -1;
class TimerTickTask extends SceneUpdateTickTask {
  constructor(l, w) {
    super(l, w);
    this.timer = new Timer();
  }
  shutdown(l) {
    this.isShutdown ||
      (super.shutdown(l), this.timer.destroy(), (this.timer = void 0));
  }
  start() {
    this.timer.start();
    super.start();
    return this;
  }
  stop() {
    this.timer.stop();
    super.stop();
    return this;
  }
  complete() {
    this.timer.stop();
    super.complete();
    return this;
  }
}
const GetValue$a = Phaser.Utils.Objects.GetValue,
  GetAdvancedValue$1 = Phaser.Utils.Objects.GetAdvancedValue,
  GetEaseFunction = Phaser.Tweens.Builders.GetEaseFunction;
class EaseValueTaskBase extends TimerTickTask {
  resetFromJSON(l) {
    this.timer.resetFromJSON(GetValue$a(l, "timer"));
    this.setEnable(GetValue$a(l, "enable", !0));
    this.setTarget(GetValue$a(l, "target", this.parent));
    this.setDelay(GetAdvancedValue$1(l, "delay", 0));
    this.setDuration(GetAdvancedValue$1(l, "duration", 1e3));
    this.setEase(GetValue$a(l, "ease", "Linear"));
    this.setRepeat(GetValue$a(l, "repeat", 0));
    return this;
  }
  setEnable(l) {
    void 0 == l && (l = !0);
    this.enable = l;
    return this;
  }
  setTarget(l) {
    void 0 === l && (l = this.parent);
    this.target = l;
    return this;
  }
  setDelay(l) {
    this.delay = l;
    return this;
  }
  setDuration(l) {
    this.duration = l;
    return this;
  }
  setEase(l) {
    void 0 === l && (l = "Linear");
    this.ease = l;
    this.easeFn = GetEaseFunction(l);
    return this;
  }
  setRepeat(l) {
    this.repeat = l;
    return this;
  }
  start() {
    if (this.timer.isRunning) return this;
    super.start();
    return this;
  }
  restart() {
    this.timer.stop();
    this.start.apply(this, arguments);
    return this;
  }
  stop(l) {
    void 0 === l && (l = !1);
    super.stop();
    l &&
      (this.timer.setT(1),
      this.updateGameObject(this.target, this.timer),
      this.complete());
    return this;
  }
  update(l, w) {
    if (!this.isRunning || !this.enable || !this.parent.active) return this;
    var h = this.target,
      t = this.timer;
    t.update(l, w);
    t.isDelay || this.updateGameObject(h, t);
    this.emit("update", h, this);
    t.isDone && this.complete();
    return this;
  }
  updateGameObject(l, w) {}
}
const GetValue$9 = Phaser.Utils.Objects.GetValue,
  GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue,
  Linear = Phaser.Math.Linear;
class EaseMove extends EaseValueTaskBase {
  constructor(l, w) {
    super(l, w);
    this.resetFromJSON(w);
    this.boot();
  }
  resetFromJSON(l) {
    super.resetFromJSON(l);
    this.setMode(GetValue$9(l, "mode", 0));
    if (l && (l.hasOwnProperty("x") || l.hasOwnProperty("y"))) {
      var w = GetAdvancedValue(l, "x", void 0);
      l = GetAdvancedValue(l, "y", void 0);
      this.setTargetPosition(w, l);
    } else this.setTargetPosition(l);
    return this;
  }
  setMode(l) {
    "string" === typeof l && (l = MODE[l]);
    this.mode = l;
    return this;
  }
  setTargetPosition(l, w) {
    "number" === typeof l || "number" === typeof w
      ? ((this.startX = this.parent.x),
        (this.startY = this.parent.y),
        (this.endX = l),
        (this.endY = w))
      : ((this.startX = GetAdvancedValue(l, "startX", void 0)),
        (this.startY = GetAdvancedValue(l, "startY", void 0)),
        (this.endX = GetAdvancedValue(l, "endX", void 0)),
        (this.endY = GetAdvancedValue(l, "endY", void 0)));
    this.hasMoveX = void 0 !== this.startX && void 0 !== this.endX;
    this.hasMoveY = void 0 !== this.startY && void 0 !== this.endY;
    return this;
  }
  start() {
    if (this.timer.isRunning) return this;
    var l = this.parent;
    this.hasMoveX && (l.x = this.startX);
    this.hasMoveY && (l.y = this.startY);
    this.timer
      .setDelay(this.delay)
      .setDuration(this.duration)
      .setRepeat(2 === this.mode ? -1 : 0);
    super.start();
    return this;
  }
  updateGameObject(l, w) {
    var h = w.t;
    w.isOddIteration && (h = 1 - h);
    h = this.easeFn(h);
    this.hasMoveX && (l.x = Linear(this.startX, this.endX, h));
    this.hasMoveY && (l.y = Linear(this.startY, this.endY, h));
  }
  complete() {
    super.complete();
    1 === this.mode && this.parent.destroy();
    return this;
  }
}
const MODE = {
  stop: 0,
  destroy: 1,
  yoyo: 2,
};
var ParseValue = function (l, w) {
    if ("number" === typeof l) return l;
    var h = l[0];
    l = parseFloat(l.substr(2));
    switch (h) {
      case "+":
        return w + l;
      case "-":
        return w - l;
      case "*":
        return w * l;
      case "/":
        return w / l;
    }
  },
  EaseMoveTo = function (l, w, h, t, a, d, k) {
    d instanceof EaseMove && ((k = d), (d = void 0));
    void 0 === d && (d = !1);
    var e = {};
    e.mode = d ? 1 : 0;
    void 0 !== h && ((e.startX = l.x), (e.endX = ParseValue(h, l.x)));
    void 0 !== t && ((e.startY = l.y), (e.endY = ParseValue(t, l.y)));
    e.duration = w;
    e.ease = void 0 === a ? "Linear" : a;
    void 0 === k ? (k = new EaseMove(l, e)) : k.resetFromJSON(e);
    k.restart();
    return k;
  },
  EaseMoveFrom = function (l, w, h, t, a, d, k) {
    d instanceof EaseMove && ((k = d), (d = void 0));
    void 0 === d && (d = !1);
    var e = {};
    e.mode = d ? 1 : 0;
    void 0 !== h && ((e.startX = ParseValue(h, l.x)), (e.endX = l.x));
    void 0 !== t && ((e.startY = ParseValue(t, l.y)), (e.endY = l.y));
    e.duration = w;
    e.ease = void 0 === a ? "Linear" : a;
    void 0 === k ? (k = new EaseMove(l, e)) : k.resetFromJSON(e);
    k.restart();
    return k;
  },
  EaseMoveToDestroy = function (l, w, h, t, a, d) {
    return EaseMoveTo(l, w, h, t, a, !0, d);
  },
  EaseMoveFromDestroy = function (l, w, h, t, a, d) {
    return EaseMoveFrom(l, w, h, t, a, !0, d);
  };
class EaseMovePlugin extends Phaser.Plugins.BasePlugin {
  constructor(l) {
    super(l);
  }
  start() {
    this.game.events.on("destroy", this.destroy, this);
  }
  add(l, w) {
    return new EaseMove(l, w);
  }
}
var methods$1 = {
  moveTo: EaseMoveTo,
  moveFrom: EaseMoveFrom,
  moveToDestroy: EaseMoveToDestroy,
  moveFromDestroy: EaseMoveFromDestroy,
};
Object.assign(EaseMovePlugin.prototype, methods$1);
class ObjectFactory {
  constructor(l) {
    this.scene = l;
  }
  static register(l, w) {
    ObjectFactory.prototype[l] = w;
  }
}
const GameObjectClass = Phaser.GameObjects.GameObject;
var IsGameObject = function (l) {
  return l.skeleton ? !0 : l instanceof GameObjectClass;
};
ObjectFactory.register("tap", function (l, w) {
  IsGameObject(l) || ((w = l), (l = this.scene));
  return new Tap(l, w);
});
SetValue(window, "RexPlugins.Gestures.Tap", Tap);
ObjectFactory.register("press", function (l, w) {
  IsGameObject(l) || ((w = l), (l = this.scene));
  return new Press(l, w);
});
SetValue(window, "RexPlugins.Gestures.Press", Press);
const GetValue$8 = Phaser.Utils.Objects.GetValue;
class Pan extends OnePointerTracer {
  constructor(l, w) {
    super(l, w);
    var h = this;
    this.setRecongizedStateObject(
      new FSM({
        states: {
          IDLE: {},
          BEGIN: {
            enter: function () {
              var t = h.pointer;
              h.startX = t.x;
              h.startY = t.y;
              h.startWorldX = t.worldX;
              h.startWorldY = t.worldY;
            },
          },
          RECOGNIZED: {
            enter: function () {
              h.emit("panstart", h, h.gameObject, h.lastPointer);
            },
            exit: function () {
              var t = h.lastPointer;
              h.endX = t.x;
              h.endY = t.y;
              h.endWorldX = t.worldX;
              h.endWorldY = t.worldY;
              h.emit("panend", h, h.gameObject, h.lastPointer);
            },
          },
        },
        init: function () {
          this.state = IDLE$3;
        },
        eventEmitter: !1,
      })
    );
  }
  resetFromJSON(l) {
    super.resetFromJSON(l);
    this.setDragThreshold(GetValue$8(l, "threshold", 10));
    return this;
  }
  onDragStart() {
    this.state = BEGIN$2;
    0 === this.dragThreshold && (this.state = RECOGNIZED$2);
  }
  onDragEnd() {
    this.state = IDLE$3;
  }
  onDrag() {
    switch (this.state) {
      case BEGIN$2:
        this.pointer.getDistance() >= this.dragThreshold &&
          (this.state = RECOGNIZED$2);
        break;
      case RECOGNIZED$2:
        var l = this.pointer.position,
          w = this.pointer.prevPosition;
        this.dx = l.x - w.x;
        this.dy = l.y - w.y;
        l = this.pointer;
        this.x = l.x;
        this.y = l.y;
        this.worldX = l.worldX;
        this.worldY = l.worldY;
        this.emit("pan", this, this.gameObject, this.lastPointer);
    }
  }
  get isPanned() {
    return this.state === RECOGNIZED$2;
  }
  setDragThreshold(l) {
    this.dragThreshold = l;
    return this;
  }
}
const IDLE$3 = "IDLE",
  BEGIN$2 = "BEGIN",
  RECOGNIZED$2 = "RECOGNIZED";
ObjectFactory.register("pan", function (l, w) {
  IsGameObject(l) || ((w = l), (l = this.scene));
  return new Pan(l, w);
});
SetValue(window, "RexPlugins.Gestures.Pan", Pan);
ObjectFactory.register("swipe", function (l, w) {
  IsGameObject(l) || ((w = l), (l = this.scene));
  return new Swipe(l, w);
});
SetValue(window, "RexPlugins.Gestures.Swipe", Swipe);
const GetValue$7 = Phaser.Utils.Objects.GetValue,
  SpliceOne$1 = Phaser.Utils.Array.SpliceOne,
  DistanceBetween = Phaser.Math.Distance.Between,
  AngleBetween$1 = Phaser.Math.Angle.Between;
class TwoPointersTracer {
  constructor(l, w) {
    var h = l.input.manager.pointersTotal - 1;
    2 > h && l.input.addPointer(2 - h);
    this.scene = l;
    this.setEventEmitter(GetValue$7(w, "eventEmitter", void 0));
    this._enable = void 0;
    this.pointers = [];
    this.movedState = {};
    this.resetFromJSON(w);
    this.boot();
  }
  resetFromJSON(l) {
    this.setEnable(GetValue$7(l, "enable", !0));
    this.bounds = GetValue$7(l, "bounds", void 0);
    this.tracerState = TOUCH0;
    this.pointers.length = 0;
    Clear(this.movedState);
    return this;
  }
  boot() {
    this.scene.input.on("pointerdown", this.onPointerDown, this);
    this.scene.input.on("pointerup", this.onPointerUp, this);
    this.scene.input.on("gameout", this.dragCancel, this);
    this.scene.input.on("pointermove", this.onPointerMove, this);
    this.scene.sys.events.once("shutdown", this.destroy, this);
  }
  shutdown() {
    this.scene &&
      (this.destroyEventEmitter(),
      (this.pointers.length = 0),
      Clear(this.movedState),
      this.scene.input.off("pointerdown", this.onPointerDown, this),
      this.scene.input.off("pointerup", this.onPointerUp, this),
      this.scene.input.off("gameout", this.dragCancel, this),
      this.scene.input.off("pointermove", this.onPointerMove, this),
      this.scene.sys.events.off("shutdown", this.destroy, this),
      (this.scene = void 0));
  }
  destroy() {
    this.shutdown();
  }
  get enable() {
    return this._enable;
  }
  set enable(l) {
    if (this._enable !== l)
      return l || this.dragCancel(), (this._enable = l), this;
  }
  setEnable(l) {
    void 0 === l && (l = !0);
    this.enable = l;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
  onPointerDown(l) {
    if (
      this.enable &&
      2 !== this.pointers.length &&
      (!this.bounds || this.bounds.contains(l.x, l.y)) &&
      -1 === this.pointers.indexOf(l)
    )
      switch (
        ((this.movedState[l.id] = !1), this.pointers.push(l), this.tracerState)
      ) {
        case TOUCH0:
          this.tracerState = TOUCH1;
          this.onDrag1Start();
          break;
        case TOUCH1:
          (this.tracerState = TOUCH2), this.onDrag2Start();
      }
  }
  onPointerUp(l) {
    if (this.enable && (!this.bounds || this.bounds.contains(l.x, l.y))) {
      var w = this.pointers.indexOf(l);
      if (-1 !== w)
        switch (
          (delete this.movedState[l.id],
          SpliceOne$1(this.pointers, w),
          this.tracerState)
        ) {
          case TOUCH1:
            this.tracerState = TOUCH0;
            this.onDrag1End();
            break;
          case TOUCH2:
            (this.tracerState = TOUCH1), this.onDrag2End(), this.onDrag1Start();
        }
    }
  }
  onPointerMove(l) {
    if (this.enable && l.isDown) {
      var w = this.bounds ? this.bounds.contains(l.x, l.y) : !0,
        h = -1 !== this.pointers.indexOf(l);
      if (h || !w)
        if (h && !w) this.onPointerUp(l);
        else if (
          (this.movedState[l.id] ||
            (this.movedState[l.id] = l.x !== l.downX || l.y !== l.downY),
          this.movedState[l.id])
        )
          switch (this.tracerState) {
            case TOUCH1:
              this.onDrag1();
              break;
            case TOUCH2:
              this.onDrag2();
          }
    }
  }
  dragCancel() {
    if (this.tracerState === TOUCH2) this.onDrag2End();
    this.pointers.length = 0;
    Clear(this.movedState);
    this.tracerState = TOUCH0;
    return this;
  }
  onDrag1Start() {
    this.emit("drag1start", this);
  }
  onDrag1End() {
    this.emit("drag1end", this);
  }
  onDrag1() {
    this.emit("drag1", this);
  }
  onDrag2Start() {
    this.emit("drag2start", this);
  }
  onDrag2End() {
    this.emit("drag2end", this);
  }
  onDrag2() {
    this.emit("drag2", this);
  }
  get distanceBetween() {
    if (this.tracerState !== TOUCH2) return 0;
    var l = this.pointers[0],
      w = this.pointers[1];
    return DistanceBetween(l.x, l.y, w.x, w.y);
  }
  get angleBetween() {
    if (this.tracerState !== TOUCH2) return 0;
    var l = this.pointers[0],
      w = this.pointers[1];
    return AngleBetween$1(l.x, l.y, w.x, w.y);
  }
  get drag1Vector() {
    var l = this.pointers[0];
    if (l && this.movedState[l.id]) {
      var w = l.position;
      l = l.prevPosition;
      tmpDragVector.x = w.x - l.x;
      tmpDragVector.y = w.y - l.y;
    } else (tmpDragVector.x = 0), (tmpDragVector.y = 0);
    return tmpDragVector;
  }
  get centerX() {
    return this.tracerState !== TOUCH2
      ? 0
      : (this.pointers[0].position.x + this.pointers[1].position.x) / 2;
  }
  get centerY() {
    return this.tracerState !== TOUCH2
      ? 0
      : (this.pointers[0].position.y + this.pointers[1].position.y) / 2;
  }
  get prevCenterX() {
    return this.tracerState !== TOUCH2
      ? 0
      : ((this.movedState[this.pointers[0].id]
          ? this.pointers[0].prevPosition
          : this.pointers[0].position
        ).x +
          (this.movedState[this.pointers[1].id]
            ? this.pointers[1].prevPosition
            : this.pointers[1].position
          ).x) /
          2;
  }
  get prevCenterY() {
    return this.tracerState !== TOUCH2
      ? 0
      : ((this.movedState[this.pointers[0].id]
          ? this.pointers[0].prevPosition
          : this.pointers[0].position
        ).y +
          (this.movedState[this.pointers[1].id]
            ? this.pointers[1].prevPosition
            : this.pointers[1].position
          ).y) /
          2;
  }
  get movementCenterX() {
    return this.centerX - this.prevCenterX;
  }
  get movementCenterY() {
    return this.centerY - this.prevCenterY;
  }
  setRecongizedStateObject(l) {
    this.recongizedState = l;
    return this;
  }
  get state() {
    return this.recongizedState.state;
  }
  set state(l) {
    this.recongizedState.state = l;
  }
  cancel() {
    this.state = IDLE$2;
    return this;
  }
}
Object.assign(TwoPointersTracer.prototype, EventEmitterMethods);
var tmpDragVector = {};
const TOUCH0 = 0,
  TOUCH1 = 1,
  TOUCH2 = 2,
  IDLE$2 = "IDLE",
  GetValue$6 = Phaser.Utils.Objects.GetValue;
class Pinch extends TwoPointersTracer {
  constructor(l, w) {
    super(l, w);
    var h = this;
    this.setRecongizedStateObject(
      new FSM({
        states: {
          IDLE: {
            enter: function () {
              h.prevDistance = void 0;
              h.scaleFactor = 1;
            },
          },
          BEGIN: {},
          RECOGNIZED: {
            enter: function () {
              h.emit("pinchstart", h);
            },
            exit: function () {
              h.emit("pinchend", h);
            },
          },
        },
        init: function () {
          this.state = IDLE$1;
        },
        eventEmitter: !1,
      })
    );
  }
  resetFromJSON(l) {
    super.resetFromJSON(l);
    this.setDragThreshold(GetValue$6(l, "threshold", 0));
    return this;
  }
  onDrag2Start() {
    this.scaleFactor = 1;
    this.prevDistance = this.distanceBetween;
    this.state = BEGIN$1;
    0 === this.dragThreshold && (this.state = RECOGNIZED$1);
  }
  onDrag2End() {
    this.state = IDLE$1;
  }
  onDrag2() {
    switch (this.state) {
      case BEGIN$1:
        if (
          this.pointers[0].getDistance() >= this.dragThreshold &&
          this.pointers[1].getDistance() >= this.dragThreshold
        ) {
          var l = this.distanceBetween;
          this.scaleFactor = l / this.prevDistance;
          this.prevDistance = l;
          this.state = RECOGNIZED$1;
        }
        break;
      case RECOGNIZED$1:
        (l = this.distanceBetween),
          (this.scaleFactor = l / this.prevDistance),
          this.emit("pinch", this),
          (this.prevDistance = l);
    }
  }
  get isPinched() {
    return this.state === RECOGNIZED$1;
  }
  setDragThreshold(l) {
    this.dragThreshold = l;
    return this;
  }
}
const IDLE$1 = "IDLE",
  BEGIN$1 = "BEGIN",
  RECOGNIZED$1 = "RECOGNIZED";
ObjectFactory.register("pinch", function (l) {
  return new Pinch(this.scene, l);
});
SetValue(window, "RexPlugins.Gestures.Pinch", Pinch);
const RotateAround = Phaser.Math.RotateAround;
var RotateObjectAround = function (l, w, h, t) {
    RotateAround(l, w, h, t);
    l.rotation += t;
    return l;
  },
  ScreenXYToWorldXY = function (l, w, h, t) {
    void 0 === t ? (t = {}) : !0 === t && (t = globalOut);
    h.getWorldPoint(l, w, t);
    return t;
  },
  globalOut = {},
  SpinObject = function (l, w) {
    if (!this.isRotation) return this;
    void 0 === w && (w = this.pointers[0].camera);
    var h = this.movementCenterX,
      t = this.movementCenterY,
      a = ScreenXYToWorldXY(this.centerX, this.centerY, w, !0);
    w = a.x;
    a = a.y;
    var d = this.rotation;
    if (Array.isArray(l))
      for (var k = l, e = 0, b = k.length; e < b; e++)
        (l = k[e]), (l.x += h), (l.y += t), RotateObjectAround(l, w, a, d);
    else (l.x += h), (l.y += t), RotateObjectAround(l, w, a, d);
    return this;
  };
const GetValue$5 = Phaser.Utils.Objects.GetValue,
  WrapDegrees = Phaser.Math.Angle.WrapDegrees,
  ShortestBetween = Phaser.Math.Angle.ShortestBetween,
  RadToDeg = Phaser.Math.RadToDeg,
  DegToRad = Phaser.Math.DegToRad;
class Rotate extends TwoPointersTracer {
  constructor(l, w) {
    super(l, w);
    var h = this;
    this.setRecongizedStateObject(
      new FSM({
        states: {
          IDLE: {
            enter: function () {
              h.prevAngle = void 0;
              h.angle = 0;
            },
          },
          BEGIN: {},
          RECOGNIZED: {
            enter: function () {
              h.emit("rotatestart", h);
            },
            exit: function () {
              h.emit("rotateend", h);
            },
          },
        },
        init: function () {
          this.state = IDLE;
        },
        eventEmitter: !1,
      })
    );
  }
  resetFromJSON(l) {
    super.resetFromJSON(l);
    this.setDragThreshold(GetValue$5(l, "threshold", 0));
    return this;
  }
  onDrag2Start() {
    this.prevAngle = WrapDegrees(RadToDeg(this.angleBetween));
    this.state = BEGIN;
    0 === this.dragThreshold && (this.state = RECOGNIZED);
  }
  onDrag2End() {
    this.state = IDLE;
  }
  onDrag2() {
    switch (this.state) {
      case BEGIN:
        if (
          this.pointers[0].getDistance() >= this.dragThreshold &&
          this.pointers[1].getDistance() >= this.dragThreshold
        ) {
          var l = WrapDegrees(RadToDeg(this.angleBetween));
          this.angle = ShortestBetween(this.prevAngle, l);
          this.prevAngle = l;
          this.state = RECOGNIZED;
        }
        break;
      case RECOGNIZED:
        (l = WrapDegrees(RadToDeg(this.angleBetween))),
          (this.angle = ShortestBetween(this.prevAngle, l)),
          (this.prevAngle = l),
          this.emit("rotate", this);
    }
  }
  get isRotated() {
    return this.state === RECOGNIZED;
  }
  get rotation() {
    return DegToRad(this.angle);
  }
  setDragThreshold(l) {
    this.dragThreshold = l;
    return this;
  }
}
var methods = {
  spinObject: SpinObject,
};
Object.assign(Rotate.prototype, methods);
const IDLE = "IDLE",
  BEGIN = "BEGIN",
  RECOGNIZED = "RECOGNIZED";
ObjectFactory.register("rotate", function (l) {
  return new Rotate(this.scene, l);
});
SetValue(window, "RexPlugins.Gestures.Rotate", Rotate);
class GesturesPlugin extends Phaser.Plugins.ScenePlugin {
  constructor(l, w) {
    super(l, w);
    this.add = new ObjectFactory(l);
  }
}
class MoveToPlugin extends Phaser.Plugins.BasePlugin {
  constructor(l) {
    super(l);
  }
  start() {
    this.game.events.on("destroy", this.destroy, this);
  }
  add(l, w) {
    return new MoveTo$2(l, w);
  }
}
const GetValue$4 = Phaser.Utils.Objects.GetValue,
  MathWrap = Phaser.Math.Wrap,
  WrapAngle = Phaser.Math.Angle.Wrap,
  AngleBetween = Phaser.Math.Angle.Between;
class RotateTo extends SceneUpdateTickTask {
  constructor(l, w) {
    super(l, w);
    this.resetFromJSON(w);
    this.boot();
  }
  resetFromJSON(l) {
    this.isRunning = GetValue$4(l, "isRunning", !1);
    this.setEnable(GetValue$4(l, "enable", !0));
    this.timeScale = GetValue$4(l, "timeScale", 1);
    this.setSpeed(GetValue$4(l, "speed", 180));
    this.target = GetValue$4(l, "target", 0);
    this.dir = GetValue$4(l, "dir", 0);
    return this;
  }
  toJSON() {
    return {
      isRunning: this.isRunning,
      timeScale: this.timeScale,
      speed: this.speed,
      target: this.target,
      dir: this.dir,
      tickingMode: this.tickingMode,
    };
  }
  setEnable(l) {
    void 0 == l && (l = !0);
    this.enable = l;
    return this;
  }
  setSpeed(l) {
    this.speed = l;
    return this;
  }
  rotateTo(l, w, h) {
    "number" !== typeof l &&
      ((w = l),
      (l = GetValue$4(w, "angle", void 0)),
      (w = GetValue$4(w, "dir", void 0)));
    this.target = MathWrap(l, 0, 360);
    void 0 === w && (w = 0);
    this.dir = "string" === typeof w ? DIRMODE[w] : w;
    void 0 !== h && this.setSpeed(h);
    super.start();
    return this;
  }
  rotateTowardsPosition(l, w, h, t) {
    var a = this.parent;
    l = AngleBetween(a.x, a.y, l, w);
    l = RadToDeg$3(l);
    this.rotateTo(l, h, t);
    return this;
  }
  update(l, w) {
    if (!this.isRunning || !this.enable) return this;
    l = this.parent;
    if (!l.active) return this;
    var h = this.target;
    if (WrapAngle(DegToRad$3(h)) === l.rotation) return this.complete(), this;
    if (0 === this.speed || 0 === w || 0 === this.timeScale) return this;
    var t = (360 + l.angle) % 360;
    w = ((w * this.timeScale) / 1e3) * this.speed;
    var a = this.dir;
    switch (a) {
      case 0:
        var d = diffAngle(t, h, !0);
        var k = 360 - d;
        d < k ? (a = 1) : ((a = 2), (d = k));
        break;
      case 1:
        d = diffAngle(t, h, !0);
        break;
      case 2:
        d = diffAngle(t, h, !1);
    }
    l.rotation = DegToRad$3(w < d ? (1 === a ? t + w : t - w) : h);
    return this;
  }
}
var diffAngle = function (l, w, h) {
  return MathWrap(h ? w - l : l - w, 0, 360);
};
const DIRMODE = {
  shortest: 0,
  cw: 1,
  ccw: 2,
};
class RotateToPlugin extends Phaser.Plugins.BasePlugin {
  constructor(l) {
    super(l);
  }
  start() {
    this.game.events.on("destroy", this.destroy, this);
  }
  add(l, w) {
    return new RotateTo(l, w);
  }
}
var papaparse_min = {
  exports: {},
};
(function (l, w) {
  !(function (h, t) {
    l.exports = t();
  })(commonjsGlobal, function t() {
    function a(C) {
      this._handle = null;
      this._halted = this._completed = this._finished = !1;
      this._input = null;
      this._baseIndex = 0;
      this._partialLine = "";
      this._start = this._rowCount = 0;
      this._nextChunk = null;
      this.isFirstChunk = !0;
      this._completeResults = {
        data: [],
        errors: [],
        meta: {},
      };
      (function (F) {
        var G = r(F);
        G.chunkSize = parseInt(G.chunkSize);
        F.step || F.chunk || (G.chunkSize = null);
        this._handle = new c(G);
        (this._handle.streamer = this)._config = G;
      }).call(this, C);
      this.parseChunk = function (F, G) {
        if (this.isFirstChunk && v(this._config.beforeFirstChunk)) {
          var H = this._config.beforeFirstChunk(F);
          void 0 !== H && (F = H);
        }
        this._halted = this.isFirstChunk = !1;
        H = this._partialLine + F;
        this._partialLine = "";
        F = this._handle.parse(H, this._baseIndex, !this._finished);
        if (!this._handle.paused() && !this._handle.aborted()) {
          var K = F.meta.cursor;
          this._finished ||
            ((this._partialLine = H.substring(K - this._baseIndex)),
            (this._baseIndex = K));
          F && F.data && (this._rowCount += F.data.length);
          H =
            this._finished ||
            (this._config.preview && this._rowCount >= this._config.preview);
          if (z)
            x.postMessage({
              results: F,
              workerId: D.WORKER_ID,
              finished: H,
            });
          else if (v(this._config.chunk) && !G) {
            if (
              (this._config.chunk(F, this._handle),
              this._handle.paused() || this._handle.aborted())
            )
              return void (this._halted = !0);
            this._completeResults = F = void 0;
          }
          return (
            this._config.step ||
              this._config.chunk ||
              ((this._completeResults.data = this._completeResults.data.concat(
                F.data
              )),
              (this._completeResults.errors =
                this._completeResults.errors.concat(F.errors)),
              (this._completeResults.meta = F.meta)),
            this._completed ||
              !H ||
              !v(this._config.complete) ||
              (F && F.meta.aborted) ||
              (this._config.complete(this._completeResults, this._input),
              (this._completed = !0)),
            H || (F && F.meta.paused) || this._nextChunk(),
            F
          );
        }
        this._halted = !0;
      };
      this._sendError = function (F) {
        v(this._config.error)
          ? this._config.error(F)
          : z &&
            this._config.error &&
            x.postMessage({
              workerId: D.WORKER_ID,
              error: F,
              finished: !1,
            });
      };
    }

    function d(C) {
      var F;
      (C = C || {}).chunkSize || (C.chunkSize = D.RemoteChunkSize);
      a.call(this, C);
      this._nextChunk = y
        ? function () {
            this._readChunk();
            this._chunkLoaded();
          }
        : function () {
            this._readChunk();
          };
      this.stream = function (G) {
        this._input = G;
        this._nextChunk();
      };
      this._readChunk = function () {
        if (this._finished) this._chunkLoaded();
        else {
          if (
            ((F = new XMLHttpRequest()),
            this._config.withCredentials &&
              (F.withCredentials = this._config.withCredentials),
            y ||
              ((F.onload = u(this._chunkLoaded, this)),
              (F.onerror = u(this._chunkError, this))),
            F.open(
              this._config.downloadRequestBody ? "POST" : "GET",
              this._input,
              !y
            ),
            this._config.downloadRequestHeaders)
          ) {
            var G = this._config.downloadRequestHeaders,
              H;
            for (H in G) F.setRequestHeader(H, G[H]);
          }
          this._config.chunkSize &&
            F.setRequestHeader(
              "Range",
              "bytes=" +
                this._start +
                "-" +
                (this._start + this._config.chunkSize - 1)
            );
          try {
            F.send(this._config.downloadRequestBody);
          } catch (K) {
            this._chunkError(K.message);
          }
          y && 0 === F.status && this._chunkError();
        }
      };
      this._chunkLoaded = function () {
        if (4 === F.readyState)
          if (200 > F.status || 400 <= F.status) this._chunkError();
          else {
            this._start += this._config.chunkSize
              ? this._config.chunkSize
              : F.responseText.length;
            var G;
            if (!(G = !this._config.chunkSize)) {
              G = this._start;
              var H = F.getResponseHeader("Content-Range");
              H =
                null === H ? -1 : parseInt(H.substring(H.lastIndexOf("/") + 1));
              G = G >= H;
            }
            this._finished = G;
            this.parseChunk(F.responseText);
          }
      };
      this._chunkError = function (G) {
        this._sendError(Error(F.statusText || G));
      };
    }

    function k(C) {
      var F, G;
      (C = C || {}).chunkSize || (C.chunkSize = D.LocalChunkSize);
      a.call(this, C);
      var H = "undefined" != typeof FileReader;
      this.stream = function (K) {
        this._input = K;
        G = K.slice || K.webkitSlice || K.mozSlice;
        H
          ? (((F = new FileReader()).onload = u(this._chunkLoaded, this)),
            (F.onerror = u(this._chunkError, this)))
          : (F = new FileReaderSync());
        this._nextChunk();
      };
      this._nextChunk = function () {
        this._finished ||
          (this._config.preview && !(this._rowCount < this._config.preview)) ||
          this._readChunk();
      };
      this._readChunk = function () {
        var K = this._input;
        this._config.chunkSize &&
          (K = G.call(
            K,
            this._start,
            Math.min(this._start + this._config.chunkSize, this._input.size)
          ));
        K = F.readAsText(K, this._config.encoding);
        H ||
          this._chunkLoaded({
            target: {
              result: K,
            },
          });
      };
      this._chunkLoaded = function (K) {
        this._start += this._config.chunkSize;
        this._finished =
          !this._config.chunkSize || this._start >= this._input.size;
        this.parseChunk(K.target.result);
      };
      this._chunkError = function () {
        this._sendError(F.error);
      };
    }

    function e(C) {
      var F;
      a.call(this, (C = C || {}));
      this.stream = function (G) {
        return (F = G), this._nextChunk();
      };
      this._nextChunk = function () {
        if (!this._finished) {
          var G,
            H = this._config.chunkSize;
          return (
            H
              ? ((G = F.substring(0, H)), (F = F.substring(H)))
              : ((G = F), (F = "")),
            (this._finished = !F),
            this.parseChunk(G)
          );
        }
      };
    }

    function b(C) {
      a.call(this, (C = C || {}));
      var F = [],
        G = !0,
        H = !1;
      this.pause = function () {
        a.prototype.pause.apply(this, arguments);
        this._input.pause();
      };
      this.resume = function () {
        a.prototype.resume.apply(this, arguments);
        this._input.resume();
      };
      this.stream = function (K) {
        this._input = K;
        this._input.on("data", this._streamData);
        this._input.on("end", this._streamEnd);
        this._input.on("error", this._streamError);
      };
      this._checkIsFinished = function () {
        H && 1 === F.length && (this._finished = !0);
      };
      this._nextChunk = function () {
        this._checkIsFinished();
        F.length ? this.parseChunk(F.shift()) : (G = !0);
      };
      this._streamData = u(function (K) {
        try {
          F.push("string" == typeof K ? K : K.toString(this._config.encoding)),
            G &&
              ((G = !1), this._checkIsFinished(), this.parseChunk(F.shift()));
        } catch (I) {
          this._streamError(I);
        }
      }, this);
      this._streamError = u(function (K) {
        this._streamCleanUp();
        this._sendError(K);
      }, this);
      this._streamEnd = u(function () {
        this._streamCleanUp();
        H = !0;
        this._streamData("");
      }, this);
      this._streamCleanUp = u(function () {
        this._input.removeListener("data", this._streamData);
        this._input.removeListener("end", this._streamEnd);
        this._input.removeListener("error", this._streamError);
      }, this);
    }

    function c(C) {
      function F(W) {
        return "greedy" === C.skipEmptyLines
          ? "" === W.join("").trim()
          : 1 === W.length && 0 === W[0].length;
      }

      function G() {
        return (
          V &&
            M &&
            (H(
              "Delimiter",
              "UndetectableDelimiter",
              "Unable to auto-detect delimiting character; defaulted to '" +
                D.DefaultDelimiter +
                "'"
            ),
            (M = !1)),
          C.skipEmptyLines &&
            (V.data = V.data.filter(function (W) {
              return !F(W);
            })),
          C.header &&
            0 === U.length &&
            (function () {
              function W(aa, Y) {
                v(C.transformHeader) && (aa = C.transformHeader(aa, Y));
                U.push(aa);
              }
              if (V)
                if (Array.isArray(V.data[0])) {
                  for (
                    var Z = 0;
                    C.header && 0 === U.length && Z < V.data.length;
                    Z++
                  )
                    V.data[Z].forEach(W);
                  V.data.splice(0, 1);
                } else V.data.forEach(W);
            })(),
          (function () {
            function W(aa, Y) {
              var ba,
                da = C.header ? {} : [];
              for (ba = 0; ba < aa.length; ba++) {
                var ea = ba,
                  fa = aa[ba];
                C.header && (ea = ba >= U.length ? "__parsed_extra" : U[ba]);
                C.transform && (fa = C.transform(fa, ea));
                var ca = ea;
                C.dynamicTypingFunction &&
                  void 0 === C.dynamicTyping[ca] &&
                  (C.dynamicTyping[ca] = C.dynamicTypingFunction(ca));
                if (!0 === (C.dynamicTyping[ca] || C.dynamicTyping)) {
                  if (
                    !(ca = "true" === fa || "TRUE" === fa) &&
                    (ca = "false" !== fa && "FALSE" !== fa)
                  ) {
                    a: {
                      if (
                        J.test(fa) &&
                        ((ca = parseFloat(fa)), P < ca && ca < N)
                      ) {
                        ca = !0;
                        break a;
                      }
                      ca = !1;
                    }
                    ca = ca
                      ? parseFloat(fa)
                      : L.test(fa)
                      ? new Date(fa)
                      : "" === fa
                      ? null
                      : fa;
                  }
                  fa = ca;
                }
                "__parsed_extra" === ea
                  ? ((da[ea] = da[ea] || []), da[ea].push(fa))
                  : (da[ea] = fa);
              }
              return (
                C.header &&
                  (ba > U.length
                    ? H(
                        "FieldMismatch",
                        "TooManyFields",
                        "Too many fields: expected " +
                          U.length +
                          " fields but parsed " +
                          ba,
                        S + Y
                      )
                    : ba < U.length &&
                      H(
                        "FieldMismatch",
                        "TooFewFields",
                        "Too few fields: expected " +
                          U.length +
                          " fields but parsed " +
                          ba,
                        S + Y
                      )),
                da
              );
            }
            if (!V || (!C.header && !C.dynamicTyping && !C.transform)) return V;
            var Z = 1;
            !V.data.length || Array.isArray(V.data[0])
              ? ((V.data = V.data.map(W)), (Z = V.data.length))
              : (V.data = W(V.data, 0));
            C.header && V.meta && (V.meta.fields = U);
            return (S += Z), V;
          })()
        );
      }

      function H(W, Z, aa, Y) {
        W = {
          type: W,
          code: Z,
          message: aa,
        };
        void 0 !== Y && (W.row = Y);
        V.errors.push(W);
      }
      var K,
        I,
        M,
        N = Math.pow(2, 53),
        P = -N,
        J = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,
        L =
          /^(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))$/,
        O = this,
        Q = 0,
        S = 0,
        R = !1,
        T = !1,
        U = [],
        V = {
          data: [],
          errors: [],
          meta: {},
        };
      if (v(C.step)) {
        var X = C.step;
        C.step = function (W) {
          if (((V = W), C.header && 0 === U.length)) G();
          else if ((G(), 0 !== V.data.length))
            (Q += W.data.length),
              C.preview && Q > C.preview
                ? I.abort()
                : ((V.data = V.data[0]), X(V, O));
        };
      }
      this.parse = function (W, Z, aa) {
        var Y = C.quoteChar || '"';
        (C.newline ||
          (C.newline = (function (ba, da) {
            ba = ba.substring(0, 1048576);
            da = new RegExp(f(da) + "([^]*?)" + f(da), "gm");
            da = (ba = ba.replace(da, "")).split("\r");
            ba = ba.split("\n");
            ba = 1 < ba.length && ba[0].length < da[0].length;
            if (1 === da.length || ba) return "\n";
            for (var ea = (ba = 0); ea < da.length; ea++)
              "\n" === da[ea][0] && ba++;
            return ba >= da.length / 2 ? "\r\n" : "\r";
          })(W, Y)),
        (M = !1),
        C.delimiter)
          ? v(C.delimiter) &&
            ((C.delimiter = C.delimiter(W)), (V.meta.delimiter = C.delimiter))
          : ((Y = (function (ba, da, ea, fa, ca) {
              var la, ja, ia;
              ca = ca || [",", "\t", "|", ";", D.RECORD_SEP, D.UNIT_SEP];
              for (var na = 0; na < ca.length; na++) {
                var ha = ca[na],
                  ma = 0,
                  ka = 0,
                  oa = 0;
                var ra = void 0;
                for (
                  var pa = new g({
                      comments: fa,
                      delimiter: ha,
                      newline: da,
                      preview: 10,
                    }).parse(ba),
                    sa = 0;
                  sa < pa.data.length;
                  sa++
                )
                  if (ea && F(pa.data[sa])) oa++;
                  else {
                    var qa = pa.data[sa].length;
                    ka += qa;
                    void 0 !== ra
                      ? 0 < qa && ((ma += Math.abs(qa - ra)), (ra = qa))
                      : (ra = qa);
                  }
                0 < pa.data.length && (ka /= pa.data.length - oa);
                (void 0 === ja || ma <= ja) &&
                  (void 0 === ia || ia < ka) &&
                  1.99 < ka &&
                  ((ja = ma), (la = ha), (ia = ka));
              }
              return {
                successful: !!(C.delimiter = la),
                bestDelimiter: la,
              };
            })(
              W,
              C.newline,
              C.skipEmptyLines,
              C.comments,
              C.delimitersToGuess
            )),
            Y.successful
              ? (C.delimiter = Y.bestDelimiter)
              : ((M = !0), (C.delimiter = D.DefaultDelimiter)),
            (V.meta.delimiter = C.delimiter));
        Y = r(C);
        return (
          C.preview && C.header && Y.preview++,
          (K = W),
          (I = new g(Y)),
          (V = I.parse(K, Z, aa)),
          G(),
          R
            ? {
                meta: {
                  paused: !0,
                },
              }
            : V || {
                meta: {
                  paused: !1,
                },
              }
        );
      };
      this.paused = function () {
        return R;
      };
      this.pause = function () {
        R = !0;
        I.abort();
        K = v(C.chunk) ? "" : K.substring(I.getCharIndex());
      };
      this.resume = function () {
        O.streamer._halted
          ? ((R = !1), O.streamer.parseChunk(K, !0))
          : setTimeout(O.resume, 3);
      };
      this.aborted = function () {
        return T;
      };
      this.abort = function () {
        T = !0;
        I.abort();
        V.meta.aborted = !0;
        v(C.complete) && C.complete(V);
        K = "";
      };
    }

    function f(C) {
      return C.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function g(C) {
      var F,
        G = (C = C || {}).delimiter,
        H = C.newline,
        K = C.comments,
        I = C.step,
        M = C.preview,
        N = C.fastMode,
        P = (F =
          void 0 === C.quoteChar || null === C.quoteChar ? '"' : C.quoteChar);
      if (
        (void 0 !== C.escapeChar && (P = C.escapeChar),
        ("string" != typeof G || -1 < D.BAD_DELIMITERS.indexOf(G)) && (G = ","),
        K === G)
      )
        throw Error("Comment character same as delimiter");
      !0 === K
        ? (K = "#")
        : ("string" != typeof K || -1 < D.BAD_DELIMITERS.indexOf(K)) &&
          (K = !1);
      "\n" !== H && "\r" !== H && "\r\n" !== H && (H = "\n");
      var J = 0,
        L = !1;
      this.parse = function (O, Q, S) {
        function R(ka) {
          ea.push(ka);
          la = J;
        }

        function T(ka) {
          var oa = 0;
          -1 !== ka &&
            (ka = O.substring(ha + 1, ka)) &&
            "" === ka.trim() &&
            (oa = ka.length);
          return oa;
        }

        function U(ka) {
          return (
            S ||
              (void 0 === ka && (ka = O.substring(J)),
              ca.push(ka),
              (J = Z),
              R(ca),
              da && W()),
            X()
          );
        }

        function V(ka) {
          J = ka;
          R(ca);
          ca = [];
          ia = O.indexOf(H, J);
        }

        function X(ka) {
          return {
            data: ea,
            errors: fa,
            meta: {
              delimiter: G,
              linebreak: H,
              aborted: L,
              truncated: !!ka,
              cursor: la + (Q || 0),
            },
          };
        }

        function W() {
          I(X());
          ea = [];
          fa = [];
        }
        if ("string" != typeof O) throw Error("Input must be a string");
        var Z = O.length,
          aa = G.length,
          Y = H.length,
          ba = K.length,
          da = v(I),
          ea = [],
          fa = [],
          ca = [],
          la = (J = 0);
        if (!O) return X();
        if (N || (!1 !== N && -1 === O.indexOf(F))) {
          aa = O.split(H);
          for (Y = 0; Y < aa.length; Y++) {
            if (((ca = aa[Y]), (J += ca.length), Y !== aa.length - 1))
              J += H.length;
            else if (S) break;
            if (!K || ca.substring(0, ba) !== K) {
              if (da) {
                if (((ea = []), R(ca.split(G)), W(), L)) break;
              } else R(ca.split(G));
              if (M && M <= Y) return (ea = ea.slice(0, M)), X(!0);
            }
          }
          return X();
        }
        for (
          var ja = O.indexOf(G, J),
            ia = O.indexOf(H, J),
            na = new RegExp(f(P) + f(F), "g"),
            ha = O.indexOf(F, J);
          ;

        )
          if (O[J] !== F)
            if (K && 0 === ca.length && O.substring(J, J + ba) === K) {
              if (-1 === ia) return X();
              J = ia + Y;
              ia = O.indexOf(H, J);
              ja = O.indexOf(G, J);
            } else if (-1 !== ja && (ja < ia || -1 === ia))
              ca.push(O.substring(J, ja)),
                (J = ja + aa),
                (ja = O.indexOf(G, J));
            else {
              if (-1 === ia) break;
              if ((ca.push(O.substring(J, ia)), V(ia + Y), da && (W(), L)))
                return X();
              if (M && ea.length >= M) return X(!0);
            }
          else
            for (ha = J, J++; ; ) {
              if (-1 === (ha = O.indexOf(F, ha + 1)))
                return (
                  S ||
                    fa.push({
                      type: "Quotes",
                      code: "MissingQuotes",
                      message: "Quoted field unterminated",
                      row: ea.length,
                      index: J,
                    }),
                  U()
                );
              if (ha === Z - 1) return U(O.substring(J, ha).replace(na, F));
              if (F !== P || O[ha + 1] !== P) {
                if (F === P || 0 === ha || O[ha - 1] !== P) {
                  -1 !== ja && ja < ha + 1 && (ja = O.indexOf(G, ha + 1));
                  -1 !== ia && ia < ha + 1 && (ia = O.indexOf(H, ha + 1));
                  var ma = T(-1 === ia ? ja : Math.min(ja, ia));
                  if (O.substr(ha + 1 + ma, aa) === G) {
                    ca.push(O.substring(J, ha).replace(na, F));
                    O[(J = ha + 1 + ma + aa)] !== F && (ha = O.indexOf(F, J));
                    ja = O.indexOf(G, J);
                    ia = O.indexOf(H, J);
                    break;
                  }
                  ma = T(ia);
                  if (O.substring(ha + 1 + ma, ha + 1 + ma + Y) === H) {
                    if (
                      (ca.push(O.substring(J, ha).replace(na, F)),
                      V(ha + 1 + ma + Y),
                      (ja = O.indexOf(G, J)),
                      (ha = O.indexOf(F, J)),
                      da && (W(), L))
                    )
                      return X();
                    if (M && ea.length >= M) return X(!0);
                    break;
                  }
                  fa.push({
                    type: "Quotes",
                    code: "InvalidQuotes",
                    message: "Trailing quote on quoted field is malformed",
                    row: ea.length,
                    index: J,
                  });
                  ha++;
                }
              } else ha++;
            }
        return U();
      };
      this.abort = function () {
        L = !0;
      };
      this.getCharIndex = function () {
        return J;
      };
    }

    function m(C) {
      var F = C.data;
      C = A[F.workerId];
      var G = !1;
      if (F.error) C.userError(F.error, F.file);
      else if (F.results && F.results.data) {
        var H = {
          abort: function () {
            G = !0;
            n(F.workerId, {
              data: [],
              errors: [],
              meta: {
                aborted: !0,
              },
            });
          },
          pause: q,
          resume: q,
        };
        if (v(C.userStep)) {
          for (
            var K = 0;
            K < F.results.data.length &&
            (C.userStep(
              {
                data: F.results.data[K],
                errors: F.results.errors,
                meta: F.results.meta,
              },
              H
            ),
            !G);
            K++
          );
          delete F.results;
        } else
          v(C.userChunk) &&
            (C.userChunk(F.results, H, F.file), delete F.results);
      }
      F.finished && !G && n(F.workerId, F.results);
    }

    function n(C, F) {
      var G = A[C];
      v(G.userComplete) && G.userComplete(F);
      G.terminate();
      delete A[C];
    }

    function q() {
      throw Error("Not implemented.");
    }

    function r(C) {
      if ("object" != typeof C || null === C) return C;
      var F = Array.isArray(C) ? [] : {},
        G;
      for (G in C) F[G] = r(C[G]);
      return F;
    }

    function u(C, F) {
      return function () {
        C.apply(F, arguments);
      };
    }

    function v(C) {
      return "function" == typeof C;
    }
    var x =
        "undefined" != typeof self
          ? self
          : "undefined" != typeof window
          ? window
          : void 0 !== x
          ? x
          : {},
      y = !x.document && !!x.postMessage,
      z = y && /blob:/i.test((x.location || {}).protocol),
      A = {},
      B = 0,
      D = {
        parse: function (C, F) {
          var G = (F = F || {}).dynamicTyping || !1;
          v(G) && ((F.dynamicTypingFunction = G), (G = {}));
          if (
            ((F.dynamicTyping = G),
            (F.transform = !!v(F.transform) && F.transform),
            F.worker && D.WORKERS_SUPPORTED)
          ) {
            var H;
            if (D.WORKERS_SUPPORTED) {
              G =
                ((H = x.URL || x.webkitURL || null),
                (K = t.toString()),
                D.BLOB_URL ||
                  (D.BLOB_URL = H.createObjectURL(
                    new Blob(["(", K, ")();"], {
                      type: "text/javascript",
                    })
                  )));
              H = new x.Worker(G);
              var K;
              H = ((H.onmessage = m), (H.id = B++), (A[H.id] = H));
            } else H = !1;
            return (
              (H.userStep = F.step),
              (H.userChunk = F.chunk),
              (H.userComplete = F.complete),
              (H.userError = F.error),
              (F.step = v(F.step)),
              (F.chunk = v(F.chunk)),
              (F.complete = v(F.complete)),
              (F.error = v(F.error)),
              delete F.worker,
              void H.postMessage({
                input: C,
                config: F,
                workerId: H.id,
              })
            );
          }
          H = null;
          D.NODE_STREAM_INPUT;
          "string" == typeof C
            ? (H = F.download ? new d(F) : new e(F))
            : !0 === C.readable && v(C.read) && v(C.on)
            ? (H = new b(F))
            : ((x.File && C instanceof File) || C instanceof Object) &&
              (H = new k(F));
          return H.stream(C);
        },
        unparse: function (C, F) {
          function G(R, T, U) {
            var V = "";
            "string" == typeof R && (R = JSON.parse(R));
            "string" == typeof T && (T = JSON.parse(T));
            var X = Array.isArray(R) && 0 < R.length,
              W = !Array.isArray(T[0]);
            if (X && I) {
              for (var Z = 0; Z < R.length; Z++)
                0 < Z && (V += M), (V += H(R[Z], Z));
              0 < T.length && (V += N);
            }
            for (Z = 0; Z < T.length; Z++) {
              var aa = X ? R.length : T[Z].length,
                Y = !1,
                ba = X ? 0 === Object.keys(T[Z]).length : 0 === T[Z].length;
              if (
                (U &&
                  !X &&
                  (Y =
                    "greedy" === U
                      ? "" === T[Z].join("").trim()
                      : 1 === T[Z].length && 0 === T[Z][0].length),
                "greedy" === U && X)
              ) {
                Y = [];
                for (var da = 0; da < aa; da++) Y.push(T[Z][W ? R[da] : da]);
                Y = "" === Y.join("").trim();
              }
              if (!Y) {
                for (Y = 0; Y < aa; Y++)
                  0 < Y && !ba && (V += M),
                    (V += H(T[Z][X && W ? R[Y] : Y], Y));
                Z < T.length - 1 && (!U || (0 < aa && !ba)) && (V += N);
              }
            }
            return V;
          }

          function H(R, T) {
            if (null == R) return "";
            if (R.constructor === Date) return JSON.stringify(R).slice(1, 25);
            var U = !1;
            Q && "string" == typeof R && Q.test(R) && ((R = "'" + R), (U = !0));
            var V = R.toString().replace(S, J);
            if (
              !(R =
                U ||
                !0 === K ||
                ("function" == typeof K && K(R, T)) ||
                (Array.isArray(K) && K[T]))
            )
              a: {
                R = D.BAD_DELIMITERS;
                for (T = 0; T < R.length; T++)
                  if (-1 < V.indexOf(R[T])) {
                    R = !0;
                    break a;
                  }
                R = !1;
              }
            return R ||
              -1 < V.indexOf(M) ||
              " " === V.charAt(0) ||
              " " === V.charAt(V.length - 1)
              ? P + V + P
              : V;
          }
          var K = !1,
            I = !0,
            M = ",",
            N = "\r\n",
            P = '"',
            J = P + P,
            L = !1,
            O = null,
            Q = !1;
          !(function () {
            if ("object" == typeof F) {
              "string" != typeof F.delimiter ||
                D.BAD_DELIMITERS.filter(function (R) {
                  return -1 !== F.delimiter.indexOf(R);
                }).length ||
                (M = F.delimiter);
              ("boolean" == typeof F.quotes ||
                "function" == typeof F.quotes ||
                Array.isArray(F.quotes)) &&
                (K = F.quotes);
              ("boolean" != typeof F.skipEmptyLines &&
                "string" != typeof F.skipEmptyLines) ||
                (L = F.skipEmptyLines);
              "string" == typeof F.newline && (N = F.newline);
              "string" == typeof F.quoteChar && (P = F.quoteChar);
              "boolean" == typeof F.header && (I = F.header);
              if (Array.isArray(F.columns)) {
                if (0 === F.columns.length)
                  throw Error("Option columns is empty");
                O = F.columns;
              }
              void 0 !== F.escapeChar && (J = F.escapeChar + P);
              ("boolean" == typeof F.escapeFormulae ||
                F.escapeFormulae instanceof RegExp) &&
                (Q =
                  F.escapeFormulae instanceof RegExp
                    ? F.escapeFormulae
                    : /^[=+\-@\t\r].*$/);
            }
          })();
          var S = new RegExp(f(P), "g");
          "string" == typeof C && (C = JSON.parse(C));
          if (Array.isArray(C)) {
            if (!C.length || Array.isArray(C[0])) return G(null, C, L);
            if ("object" == typeof C[0]) return G(O || Object.keys(C[0]), C, L);
          } else if ("object" == typeof C)
            return (
              "string" == typeof C.data && (C.data = JSON.parse(C.data)),
              Array.isArray(C.data) &&
                (C.fields || (C.fields = (C.meta && C.meta.fields) || O),
                C.fields ||
                  (C.fields = Array.isArray(C.data[0])
                    ? C.fields
                    : "object" == typeof C.data[0]
                    ? Object.keys(C.data[0])
                    : []),
                Array.isArray(C.data[0]) ||
                  "object" == typeof C.data[0] ||
                  (C.data = [C.data])),
              G(C.fields || [], C.data || [], L)
            );
          throw Error("Unable to serialize unrecognized input");
        },
      };
    if (
      ((D.RECORD_SEP = String.fromCharCode(30)),
      (D.UNIT_SEP = String.fromCharCode(31)),
      (D.BYTE_ORDER_MARK = "\ufeff"),
      (D.BAD_DELIMITERS = ["\r", "\n", '"', D.BYTE_ORDER_MARK]),
      (D.WORKERS_SUPPORTED = !y && !!x.Worker),
      (D.NODE_STREAM_INPUT = 1),
      (D.LocalChunkSize = 10485760),
      (D.RemoteChunkSize = 5242880),
      (D.DefaultDelimiter = ","),
      (D.Parser = g),
      (D.ParserHandle = c),
      (D.NetworkStreamer = d),
      (D.FileStreamer = k),
      (D.StringStreamer = e),
      (D.ReadableStreamStreamer = b),
      x.jQuery)
    ) {
      var E = x.jQuery;
      E.fn.parse = function (C) {
        function F() {
          if (0 !== K.length) {
            var I,
              M,
              N,
              P = K[0];
            if (v(C.before)) {
              var J = C.before(P.file, P.inputElem);
              if ("object" == typeof J) {
                if ("abort" === J.action)
                  return (
                    (I = P.file),
                    (M = P.inputElem),
                    (N = J.reason),
                    void (
                      v(C.error) &&
                      C.error(
                        {
                          name: "AbortError",
                        },
                        I,
                        M,
                        N
                      )
                    )
                  );
                if ("skip" === J.action) return void G();
                "object" == typeof J.config &&
                  (P.instanceConfig = E.extend(P.instanceConfig, J.config));
              } else if ("skip" === J) return void G();
            }
            var L = P.instanceConfig.complete;
            P.instanceConfig.complete = function (O) {
              v(L) && L(O, P.file, P.inputElem);
              G();
            };
            D.parse(P.file, P.instanceConfig);
          } else v(C.complete) && C.complete();
        }

        function G() {
          K.splice(0, 1);
          F();
        }
        var H = C.config || {},
          K = [];
        return (
          this.each(function (I) {
            if (
              "INPUT" !== E(this).prop("tagName").toUpperCase() ||
              "file" !== E(this).attr("type").toLowerCase() ||
              !x.FileReader ||
              !this.files ||
              0 === this.files.length
            )
              return !0;
            for (I = 0; I < this.files.length; I++)
              K.push({
                file: this.files[I],
                inputElem: this,
                instanceConfig: E.extend({}, H),
              });
          }),
          F(),
          this
        );
      };
    }
    return (
      z &&
        (x.onmessage = function (C) {
          C = C.data;
          void 0 === D.WORKER_ID && C && (D.WORKER_ID = C.workerId);
          "string" == typeof C.input
            ? x.postMessage({
                workerId: D.WORKER_ID,
                results: D.parse(C.input, C.config),
                finished: !0,
              })
            : ((x.File && C.input instanceof File) ||
                C.input instanceof Object) &&
              (C = D.parse(C.input, C.config)) &&
              x.postMessage({
                workerId: D.WORKER_ID,
                results: C,
                finished: !0,
              });
        }),
      ((d.prototype = Object.create(a.prototype)).constructor = d),
      ((k.prototype = Object.create(a.prototype)).constructor = k),
      ((e.prototype = Object.create(e.prototype)).constructor = e),
      ((b.prototype = Object.create(a.prototype)).constructor = b),
      D
    );
  });
})(papaparse_min);
var CSVParser = papaparse_min.exports;
const GetValue$3 = Phaser.Utils.Objects.GetValue;
class InstMem {
  constructor(l) {
    this.scenario = l;
    this.queue = [];
    this.currentIdx = -1;
    this.nextIdx = 0;
  }
  resetFromJSON(l) {
    var w = GetValue$3(l, "queue", void 0);
    void 0 === w ? Clear(this.queue) : Clone(w, this.queue);
    this.currentIdx = GetValue$3(l, "curIdx", -1);
    this.nextIdx = GetValue$3(l, "nextIdx", 0);
    return this;
  }
  clear() {
    this.currentIdx = -1;
    this.nextIdx = 0;
    this.queue.length = 0;
    return this;
  }
  append(l) {
    this.queue.push(l);
    return this;
  }
  setNextIndex(l) {
    void 0 === l && (l = this.currentIdx + 1);
    this.nextIdx = l;
    return this;
  }
  get(l) {
    void 0 === l && (l = this.nextIdx);
    this.currentIdx = l;
    return this.queue[l];
  }
  get length() {
    return this.queue.length;
  }
}
class BaseCmd {
  constructor(l, w) {
    this.scenario = l;
    this.type = w;
  }
  resetFromJSON(l) {}
  toJSON() {
    return {};
  }
  parse(l, w) {
    return l;
  }
  run(l) {}
}
var Copy = function (l, w, h, t) {
    void 0 === h && (h = 0);
    void 0 === t && (t = w.length);
    l.length = t - h;
    t = 0;
    for (var a = l.length; t < a; t++) l[t] = w[t + h];
    return l;
  },
  FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i,
  convert = function (l) {
    if ("string" !== typeof l) return l;
    "" === l
      ? (l = null)
      : FLOAT.test(l)
      ? (l = parseFloat(l))
      : "false" === l
      ? (l = !1)
      : "true" === l && (l = !0);
    return l;
  };
const GetValue$2 = Phaser.Utils.Objects.GetValue;
var RunCommands = function (l, w, h) {
    var t = GetValue$2(h, "reverse", !1);
    if (IsArray(l[0]))
      if (t)
        for (d = l.length, t = d - 1; 0 <= t; t--)
          var a = RunCommands(l[t], w, h);
      else {
        t = 0;
        for (var d = l.length; t < d; t++) a = RunCommands(l[t], w, h);
      }
    else a = RunCommand(l, w, h);
    return a;
  },
  RunCommand = function (l, w, h) {
    var t = GetValue$2(h, "argsConvert", void 0),
      a = GetValue$2(h, "argsConvertScope", void 0);
    h = l[0];
    ARGS = Copy(ARGS, l, 1);
    if (t) {
      !0 === t && ((t = convert), (a = void 0));
      for (var d = 0, k = ARGS.length; d < k; d++)
        ARGS[d] = a ? t.call(a, ARGS[d], l) : t(ARGS[d], l);
    }
    "string" === typeof h
      ? ((l = w[h]), null == l && (l = GetValue$2(w, h, null)))
      : (l = h);
    return l.apply(w, ARGS);
  },
  ARGS = [];
const SpliceOne = Phaser.Utils.Array.SpliceOne;
class CustomCmd extends BaseCmd {
  constructor(l) {
    super(l, "-");
    this.task = void 0;
  }
  resetFromJSON(l) {
    this.task &&
      (this.task.off("complete", this.resume, this), (this.task = void 0));
  }
  parse(l, w) {
    w = SpliceOne(l, 0);
    var h = this.scenario,
      t = h.argsConvert;
    h = h.argsConvertScope;
    if (t) {
      !0 === t && ((t = convert), (h = void 0));
      for (var a = 1, d = l.length; a < d; a++)
        l[a] = h ? t.call(h, l[a], l) : t(l[a], l);
    }
    return (l = [w, l]);
  }
  run(l) {
    (l = RunCommands(l[1], this.scenario.scope)) && "function" === typeof l.once
      ? (l.once("complete", this.resume, this), this.pause(), (this.task = l))
      : (this.task = void 0);
  }
  pause() {
    this.scenario.pause();
  }
  resume() {
    this.task = void 0;
    var l = this.scenario;
    l.resume();
    l.runNextCmd();
  }
}
class WaitCmd extends BaseCmd {
  constructor(l) {
    super(l, "wait");
  }
  parse(l, w) {
    l.length = 2;
    w = this.getEventName(l);
    isNaN(w) || (l[1] = parseFloat(w));
    return l;
  }
  run(l) {
    l = this.getEventName(l);
    "number" === typeof l ? this.waitTime(l) : this.waitEvent(l);
  }
  waitTime(l) {
    l > this.scenario.offset
      ? ((l -= this.scenario.offset),
        (this.scenario.offset = 0),
        this.scenario.isDebugMode && this.scenario.log("#WAIT: " + l),
        this.scenario.wait(l))
      : (this.scenario.offset -= l);
  }
  waitEvent(l) {
    this.scenario.isDebugMode && this.scenario.log("#WAIT: " + l);
    this.scenario.wait(l);
  }
  getEventName(l) {
    var w = l[1];
    null == w && ((w = ""), (l[1] = w));
    return w;
  }
}
const GetValue$1 = Phaser.Utils.Objects.GetValue;
class LabelCmd extends BaseCmd {
  constructor(l) {
    super(l, "label");
    this.labels = {};
    this.lastLabel = this.prevLabel = "";
  }
  resetFromJSON(l) {
    this.prevLabel = GetValue$1(l, "preLabel", "");
    this.lastLabel = GetValue$1(l, "lastLabel", "");
    l = GetValue$1(l, "labels", void 0);
    void 0 === l ? Clear(this.labels) : Clone(l, this.labels);
  }
  toJSON() {
    return {
      preLabel: this.prevLabel,
      lastLabel: this.lastLabel,
      labels: this.labels,
    };
  }
  parse(l, w) {
    l.length = 2;
    var h = this.getLabel(l);
    this.addLabel(h, w);
    return l;
  }
  run(l) {
    l = this.getLabel(l);
    this.scenario.isDebugMode && this.scenario.log("#LABEL: " + l);
    this.prevLabel = this.lastLabel;
    this.lastLabel = l;
    l = this.scenario;
    l.emit("labelchange", this.lastLabel, this.prevLabel, l.scope, l);
  }
  getLabel(l) {
    var w = l[1];
    null == w && ((w = ""), (l[1] = w));
    return w;
  }
  addLabel(l, w) {
    this.labels[l] = w;
  }
  getIndex(l) {
    return "" !== l && this.hasLabel(l) ? this.labels[l] : 0;
  }
  hasLabel(l) {
    return this.labels.hasOwnProperty(l);
  }
}
class ExitCmd extends BaseCmd {
  constructor(l) {
    super(l, "exit");
  }
  parse(l, w) {
    l.length = 1;
    return l;
  }
  run(l) {
    this.scenario.log("#EXIT");
    this.scenario.complete();
  }
}
class GotoCmd extends BaseCmd {
  constructor(l) {
    super(l, "goto");
  }
  parse(l, w) {
    l.length = 2;
    return l;
  }
  run(l) {
    l = this.getLabel(l);
    this.scenario.isDebugMode && this.scenario.log("#GOTO label: " + l);
    this.scenario.goto(l);
  }
  getLabel(l) {
    var w = l[1];
    null == w && ((w = ""), (l[1] = w));
    return w;
  }
}
class IfCmd extends BaseCmd {
  constructor(l) {
    super(l, "if");
  }
  parse(l, w) {
    l.length = 4;
    w = "(" + this.getCond(l) + ")";
    l[1] = new Function("return " + w);
    return l;
  }
  run(l) {
    var w = this.getCond(l).call(this.scenario.scope);
    l = w ? this.getTrueLabel(l) : this.getFalseLabel(l);
    "" !== l &&
      (this.scenario.isDebugMode &&
        this.scenario.log("#IF " + w + "- GOTO label: " + l),
      this.scenario.goto(l));
  }
  getCond(l) {
    var w = l[1];
    if (null == w || "" === w) (w = "true"), (l[1] = w);
    return w;
  }
  getTrueLabel(l) {
    var w = l[2];
    null == w && ((w = ""), (l[2] = w));
    return w;
  }
  getFalseLabel(l) {
    var w = l[3];
    null == w && ((w = ""), (l[3] = w));
    return w;
  }
}
const GetValue = Phaser.Utils.Objects.GetValue;
class CmdHandlers {
  constructor(l) {
    this.cmds = {
      "-": new CustomCmd(l),
      wait: new WaitCmd(l),
      label: new LabelCmd(l),
      exit: new ExitCmd(l),
      goto: new GotoCmd(l),
      if: new IfCmd(l),
    };
  }
  resetFromJSON(l) {
    for (var w in this.cmds) this.cmds[w].resetFromJSON(GetValue(l, w, void 0));
    return this;
  }
  toJSON() {
    var l = {},
      w;
    for (w in this.cmds) l[w] = this.cmds[w].toJSON();
    return l;
  }
  get(l) {
    return this.cmds[l];
  }
  isValidCmdName(l) {
    return this.cmds.hasOwnProperty(l);
  }
}
class CSVScenario {
  constructor(l, w) {
    this.setEventEmitter(GetValue$l(w, "eventEmitter", void 0));
    this.scene = l;
    this.timer = void 0;
    this.instMem = new InstMem(this);
    this.cmdHandlers = new CmdHandlers(this);
    this.resetFromJSON(w);
    this.boot();
  }
  resetFromJSON(l) {
    this._inRunCmdLoop = !1;
    this.isRunning = GetValue$l(l, "state", !1);
    this.isPaused = GetValue$l(l, "pause", !1);
    this.waitEvent = GetValue$l(l, "wait", void 0);
    this.scope = GetValue$l(l, "scope", void 0);
    this.timeUnit = GetValue$l(l, "timeUnit", 0);
    this.cmdPrefix = GetValue$l(l, "prefix", DEFAULT_PREFIX);
    this.argsConvert = GetValue$l(l, "argsConvert", !0);
    this.argsConvertScope = GetValue$l(l, "argsConvertScope", void 0);
    this.cmdHandlers.resetFromJSON(GetValue$l(l, "handlers", void 0));
    this.instMem.resetFromJSON(GetValue$l(l, "instMem", void 0));
    this.delimiter = GetValue$l(l, "delimiter", ",");
    return this;
  }
  toJSON() {
    return {
      state: this.isRunning,
      pause: this.isPaused,
      wait: this.waitEvent,
      scope: this.scope,
      timeUnit: this.timeUnit,
      prefix: this.cmdPrefix,
      argsConvert: this.argsConvert,
      argsConvertScope: this.argsConvertScope,
      handlers: this.cmdHandlers.toJSON(),
      instMem: this.instMem.toJSON(),
      delimiter: this.delimiter,
    };
  }
  boot() {
    this.scene.sys.events.once("shutdown", this.destroy, this);
  }
  shutdown() {
    this.scene &&
      (this.destroyEventEmitter(),
      this.clear(),
      this.scene.sys.events.off("shutdown", this.destroy, this),
      (this.scene = void 0));
  }
  destroy() {
    this.shutdown();
  }
  load(l, w, h) {
    this.clear();
    this.timeUnit = GetValue$l(h, "timeUnit", this.timeUnit);
    "string" === typeof this.timeUnit &&
      (this.timeUnit = TIMEUNITMODE[this.timeUnit]);
    this.cmdPrefix = GetValue$l(h, "prefix", this.cmdPrefix);
    "string" === typeof this.cmdPrefix &&
      (this.cmdPrefix = new RegExp(this.cmdPrefix));
    this.argsConvert = GetValue$l(h, "argsConvert", this.argsConvert);
    this.argsConvertScope = GetValue$l(
      h,
      "argsConvertScope",
      this.argsConvertScope
    );
    this.scope = w;
    this.delimiter = GetValue$l(h, "delimiter", this.delimiter);
    this.append(l);
    return this;
  }
  clear() {
    this.stop();
    this.instMem.resetFromJSON();
    this.cmdHandlers.resetFromJSON();
  }
  start(l) {
    this.stop();
    var w = GetValue$l(l, "label", "");
    this.offset = GetValue$l(l, "offset", 0);
    this.isDebugMode && this.log("Start at Label: " + w);
    if (!this.goto(w)) return !1;
    this.isRunning = !0;
    this.runNextCmd();
    return !0;
  }
  getIndex(l) {
    var w = this.getCmdHandler("label").getIndex(l);
    null == w && this.error("Label: " + l + " is not found");
    return w;
  }
  goto(l) {
    l = "string" === typeof l ? this.getIndex(l) : l;
    if (null == l) return !1;
    this.instMem.setNextIndex(l);
    return !0;
  }
  wait(l) {
    this.waitEvent = l;
    if ("number" === typeof l) {
      var w = l;
      1 === this.timeUnit && (w *= 1e3);
      this.timer = this.scene.time.delayedCall(w, this.continue, [l], this);
    }
    return this;
  }
  stop() {
    if (!this.isRunning) return this;
    this.isPaused = this.isRunning = !1;
    this.waitEvent = void 0;
    this.timer && (this.timer.remove(), (this.timer = void 0));
    return this;
  }
  complete() {
    this.emit("complete", this.scope, this);
    this.stop();
    return this;
  }
  append(l) {
    l = CSVParser.parse(l, {
      delimiter: this.delimiter,
    }).data;
    this.parse(l);
    return this;
  }
  pause() {
    if (!this.isRunning || this.isPaused) return this;
    this.isPaused = !0;
    this.timer && (this.timer.paused = !0);
    return this;
  }
  resume() {
    if (!this.isRunning || !this.isPaused) return this;
    this.isPaused = !1;
    this.timer && (this.timer.paused = !1);
    return this;
  }
  continue(l) {
    if (!this.isRunning || this.isPaused || void 0 === this.waitEvent)
      return this;
    l === this.waitEvent &&
      ((this.waitEvent = this.timer = void 0), this.runNextCmd());
    return this;
  }
  get lastLabel() {
    return this.cmdHandlers.labelCmd.lastLabel;
  }
  get previousLabel() {
    return this.cmdHandlers.labelCmd.preLabel;
  }
  getCmdHandler(l) {
    "string" !== typeof l && (l = l[0]);
    return this.cmdHandlers.get(l);
  }
  parse(l) {
    for (var w, h, t = this.cmdPrefix, a = 0, d = l.length; a < d; a++)
      (w = l[a]),
        (h = w[0]),
        "-" === h
          ? this.appendCommand(w)
          : isNaN(h)
          ? t.test(h)
            ? ((h = h.match(t)),
              (w[0] = h[1].toLowerCase()),
              this.appendCommand(w) ||
                this.error(
                  "Line " +
                    a +
                    ": " +
                    JSON.stringify(w) +
                    " is not a valid command"
                ))
            : (this.appendCommand(["wait", h]),
              (w[0] = "-"),
              this.appendCommand(w))
          : ((h = parseFloat(h)),
            0 < h && this.appendCommand(["wait", h]),
            (w[0] = "-"),
            this.appendCommand(w));
    return this;
  }
  appendCommand(l) {
    var w = this.getCmdHandler(l);
    if (null == w) return !1;
    (l = w.parse(l, this.instMem.length)) && this.instMem.append(l);
    return !0;
  }
  runNextCmd() {
    if (!this._inRunCmdLoop) {
      this.threadId;
      var l = this.instMem;
      for (
        this._inRunCmdLoop = !0;
        this.isRunning && !this.isPaused && void 0 === this.waitEvent;

      ) {
        var w = l.get();
        l.setNextIndex();
        if (null == w) {
          this.complete();
          break;
        }
        this.getCmdHandler(w).run(w);
      }
      this._inRunCmdLoop = !1;
      return this;
    }
  }
  log(l) {
    this.emit("log", l, this.scope, this);
    return this;
  }
  get isDebugMode() {
    return 0 < this.listenerCount("log");
  }
  error(l) {
    this.emit("error", l, this.scope, this);
    return this;
  }
}
Object.assign(CSVScenario.prototype, EventEmitterMethods);
const TIMEUNITMODE = {
    ms: 0,
    s: 1,
    sec: 1,
  },
  DEFAULT_PREFIX = /^#([a-zA-Z]+)/;
class CSVScenarioPlugin extends Phaser.Plugins.BasePlugin {
  constructor(l) {
    super(l);
  }
  start() {
    this.game.events.on("destroy", this.destroy, this);
  }
  add(l, w) {
    return new CSVScenario(l, w);
  }
}
window.SpinePlugin = (function (l) {
  function w(t) {
    if (h[t]) return h[t].exports;
    var a = (h[t] = {
      i: t,
      l: !1,
      exports: {},
    });
    l[t].call(a.exports, a, a.exports, w);
    a.l = !0;
    return a.exports;
  }
  var h = {};
  w.m = l;
  w.c = h;
  w.d = function (t, a, d) {
    w.o(t, a) ||
      Object.defineProperty(t, a, {
        enumerable: !0,
        get: d,
      });
  };
  w.r = function (t) {
    "undefined" !== typeof Symbol &&
      Symbol.toStringTag &&
      Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module",
      });
    Object.defineProperty(t, "__esModule", {
      value: !0,
    });
  };
  w.t = function (t, a) {
    a & 1 && (t = w(t));
    if (a & 8 || (a & 4 && "object" === typeof t && t && t.__esModule))
      return t;
    var d = Object.create(null);
    w.r(d);
    Object.defineProperty(d, "default", {
      enumerable: !0,
      value: t,
    });
    if (a & 2 && "string" != typeof t)
      for (var k in t)
        w.d(
          d,
          k,
          function (e) {
            return t[e];
          }.bind(null, k)
        );
    return d;
  };
  w.n = function (t) {
    var a =
      t && t.__esModule
        ? function () {
            return t["default"];
          }
        : function () {
            return t;
          };
    w.d(a, "a", a);
    return a;
  };
  w.o = function (t, a) {
    return Object.prototype.hasOwnProperty.call(t, a);
  };
  w.p = "";
  return w((w.s = 63));
})([
  function (l, w) {
    function h(d, k, e, b) {
      for (var c in k)
        if (k.hasOwnProperty(c)) {
          var f;
          var g = (f = e) ? k[c] : Object.getOwnPropertyDescriptor(k, c);
          !f && g.value && "object" === typeof g.value && (g = g.value);
          g &&
          ((g.get && "function" === typeof g.get) ||
            (g.set && "function" === typeof g.set))
            ? ("undefined" === typeof g.enumerable && (g.enumerable = !0),
              "undefined" === typeof g.configurable && (g.configurable = !0),
              (f = g))
            : (f = !1);
          if (!1 !== f) {
            (g = Object.getOwnPropertyDescriptor((b || d).prototype, c))
              ? (g.value && "object" === typeof g.value && (g = g.value),
                (g = !1 === g.configurable ? !0 : !1))
              : (g = !1);
            if (g) {
              if (a.ignoreFinals) continue;
              throw Error(
                "cannot override final property '" +
                  c +
                  "', set Class.ignoreFinals = true to skip"
              );
            }
            Object.defineProperty(d.prototype, c, f);
          } else d.prototype[c] = k[c];
        }
    }

    function t(d, k) {
      if (k) {
        Array.isArray(k) || (k = [k]);
        for (var e = 0; e < k.length; e++) h(d, k[e].prototype || k[e]);
      }
    }

    function a(d) {
      d || (d = {});
      if (d.initialize) {
        if ("function" !== typeof d.initialize)
          throw Error("initialize must be a function");
        var k = d.initialize;
        delete d.initialize;
      } else if (d.Extends) {
        var e = d.Extends;
        k = function () {
          e.apply(this, arguments);
        };
      } else k = function () {};
      if (d.Extends) {
        k.prototype = Object.create(d.Extends.prototype);
        k.prototype.constructor = k;
        var b = d.Extends;
        delete d.Extends;
      } else k.prototype.constructor = k;
      var c = null;
      d.Mixins && ((c = d.Mixins), delete d.Mixins);
      t(k, c);
      h(k, d, !0, b);
      return k;
    }
    a.extend = h;
    a.mixin = t;
    a.ignoreFinals = !1;
    l.exports = a;
  },
  function (l, w) {
    l.exports = function () {};
  },
  function (l, w, h) {
    w = h(0);
    var t = h(32),
      a = new w({
        initialize: function (d, k) {
          this.y = this.x = 0;
          "object" === typeof d
            ? ((this.x = d.x || 0), (this.y = d.y || 0))
            : (void 0 === k && (k = d), (this.x = d || 0), (this.y = k || 0));
        },
        clone: function () {
          return new a(this.x, this.y);
        },
        copy: function (d) {
          this.x = d.x || 0;
          this.y = d.y || 0;
          return this;
        },
        setFromObject: function (d) {
          this.x = d.x || 0;
          this.y = d.y || 0;
          return this;
        },
        set: function (d, k) {
          void 0 === k && (k = d);
          this.x = d;
          this.y = k;
          return this;
        },
        setTo: function (d, k) {
          return this.set(d, k);
        },
        setToPolar: function (d, k) {
          null == k && (k = 1);
          this.x = Math.cos(d) * k;
          this.y = Math.sin(d) * k;
          return this;
        },
        equals: function (d) {
          return this.x === d.x && this.y === d.y;
        },
        fuzzyEquals: function (d, k) {
          return t(this.x, d.x, k) && t(this.y, d.y, k);
        },
        angle: function () {
          var d = Math.atan2(this.y, this.x);
          0 > d && (d += 2 * Math.PI);
          return d;
        },
        setAngle: function (d) {
          return this.setToPolar(d, this.length());
        },
        add: function (d) {
          this.x += d.x;
          this.y += d.y;
          return this;
        },
        subtract: function (d) {
          this.x -= d.x;
          this.y -= d.y;
          return this;
        },
        multiply: function (d) {
          this.x *= d.x;
          this.y *= d.y;
          return this;
        },
        scale: function (d) {
          isFinite(d) ? ((this.x *= d), (this.y *= d)) : (this.y = this.x = 0);
          return this;
        },
        divide: function (d) {
          this.x /= d.x;
          this.y /= d.y;
          return this;
        },
        negate: function () {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        },
        distance: function (d) {
          var k = d.x - this.x;
          d = d.y - this.y;
          return Math.sqrt(k * k + d * d);
        },
        distanceSq: function (d) {
          var k = d.x - this.x;
          d = d.y - this.y;
          return k * k + d * d;
        },
        length: function () {
          var d = this.x,
            k = this.y;
          return Math.sqrt(d * d + k * k);
        },
        setLength: function (d) {
          return this.normalize().scale(d);
        },
        lengthSq: function () {
          var d = this.x,
            k = this.y;
          return d * d + k * k;
        },
        normalize: function () {
          var d = this.x,
            k = this.y,
            e = d * d + k * k;
          0 < e && ((e = 1 / Math.sqrt(e)), (this.x = d * e), (this.y = k * e));
          return this;
        },
        normalizeRightHand: function () {
          var d = this.x;
          this.x = -1 * this.y;
          this.y = d;
          return this;
        },
        normalizeLeftHand: function () {
          var d = this.x;
          this.x = this.y;
          this.y = -1 * d;
          return this;
        },
        dot: function (d) {
          return this.x * d.x + this.y * d.y;
        },
        cross: function (d) {
          return this.x * d.y - this.y * d.x;
        },
        lerp: function (d, k) {
          void 0 === k && (k = 0);
          var e = this.x,
            b = this.y;
          this.x = e + k * (d.x - e);
          this.y = b + k * (d.y - b);
          return this;
        },
        transformMat3: function (d) {
          var k = this.x,
            e = this.y;
          d = d.val;
          this.x = d[0] * k + d[3] * e + d[6];
          this.y = d[1] * k + d[4] * e + d[7];
          return this;
        },
        transformMat4: function (d) {
          var k = this.x,
            e = this.y;
          d = d.val;
          this.x = d[0] * k + d[4] * e + d[12];
          this.y = d[1] * k + d[5] * e + d[13];
          return this;
        },
        reset: function () {
          this.y = this.x = 0;
          return this;
        },
        limit: function (d) {
          var k = this.length();
          k && k > d && this.scale(d / k);
          return this;
        },
        reflect: function (d) {
          d = d.clone().normalize();
          return this.subtract(d.scale(2 * this.dot(d)));
        },
        mirror: function (d) {
          return this.reflect(d).negate();
        },
        rotate: function (d) {
          var k = Math.cos(d);
          d = Math.sin(d);
          return this.set(k * this.x - d * this.y, d * this.x + k * this.y);
        },
      });
    a.ZERO = new a();
    a.RIGHT = new a(1, 0);
    a.LEFT = new a(-1, 0);
    a.UP = new a(0, -1);
    a.DOWN = new a(0, 1);
    a.ONE = new a(1, 1);
    l.exports = a;
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      return Math.max(t, Math.min(a, h));
    };
  },
  function (l, w) {
    l.exports = {
      PI2: 2 * Math.PI,
      TAU: 0.5 * Math.PI,
      EPSILON: 1e-6,
      DEG_TO_RAD: Math.PI / 180,
      RAD_TO_DEG: 180 / Math.PI,
      RND: null,
      MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,
      MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      h = h.length;
      if (0 > t || t > h || t >= a || a > h || t + a > h) {
        if (d) throw Error("Range Error: Values outside acceptable range");
        return !1;
      }
      return !0;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      a -= t;
      return t + ((((h - t) % a) + a) % a);
    };
  },
  function (l, w) {
    l.exports = function (h) {
      if ("object" !== typeof h || h.nodeType || h === h.window) return !1;
      try {
        if (
          h.constructor &&
          !{}.hasOwnProperty.call(h.constructor.prototype, "isPrototypeOf")
        )
          return !1;
      } catch (t) {
        return !1;
      }
      return !0;
    };
  },
  function (l, w, h) {
    var t = h(4);
    l.exports = function (a) {
      a > Math.PI && (a -= t.PI2);
      return Math.abs((((a + t.TAU) % t.PI2) - t.PI2) % t.PI2);
    };
  },
  function (l, w, h) {
    var t = h(4);
    l.exports = function (a) {
      return a * t.RAD_TO_DEG;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      if (h && "number" !== typeof h) {
        if (h.hasOwnProperty(t)) return h[t];
        if (-1 !== t.indexOf(".")) {
          t = t.split(".");
          for (var d = a, k = 0; k < t.length; k++)
            if (h.hasOwnProperty(t[k])) (d = h[t[k]]), (h = h[t[k]]);
            else {
              d = a;
              break;
            }
          return d;
        }
      }
      return a;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      var d = typeof h;
      return h && "number" !== d && "string" !== d
        ? h.hasOwnProperty(t) && void 0 !== h[t]
          ? h[t]
          : a
        : a;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      if (!(t >= h.length)) {
        for (var a = h.length - 1, d = h[t]; t < a; t++) h[t] = h[t + 1];
        h.length = a;
        return d;
      }
    };
  },
  function (l, w, h) {
    w = h(0);
    var t = h(26);
    h = new w({
      initialize: function (a, d) {
        void 0 === a && (a = 0);
        void 0 === d && (d = a);
        this.type = t.POINT;
        this.x = a;
        this.y = d;
      },
      setTo: function (a, d) {
        void 0 === a && (a = 0);
        void 0 === d && (d = a);
        this.x = a;
        this.y = d;
        return this;
      },
    });
    l.exports = h;
  },
  function (l, w, h) {
    var t = new (h(0))({
      initialize: function (a, d, k) {
        this.z = this.y = this.x = 0;
        "object" === typeof a
          ? ((this.x = a.x || 0), (this.y = a.y || 0), (this.z = a.z || 0))
          : ((this.x = a || 0), (this.y = d || 0), (this.z = k || 0));
      },
      up: function () {
        this.x = 0;
        this.y = 1;
        this.z = 0;
        return this;
      },
      min: function (a) {
        this.x = Math.min(this.x, a.x);
        this.y = Math.min(this.y, a.y);
        this.z = Math.min(this.z, a.z);
        return this;
      },
      max: function (a) {
        this.x = Math.max(this.x, a.x);
        this.y = Math.max(this.y, a.y);
        this.z = Math.max(this.z, a.z);
        return this;
      },
      clone: function () {
        return new t(this.x, this.y, this.z);
      },
      addVectors: function (a, d) {
        this.x = a.x + d.x;
        this.y = a.y + d.y;
        this.z = a.z + d.z;
        return this;
      },
      crossVectors: function (a, d) {
        var k = a.x,
          e = a.y;
        a = a.z;
        var b = d.x,
          c = d.y;
        d = d.z;
        this.x = e * d - a * c;
        this.y = a * b - k * d;
        this.z = k * c - e * b;
        return this;
      },
      equals: function (a) {
        return this.x === a.x && this.y === a.y && this.z === a.z;
      },
      copy: function (a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z || 0;
        return this;
      },
      set: function (a, d, k) {
        "object" === typeof a
          ? ((this.x = a.x || 0), (this.y = a.y || 0), (this.z = a.z || 0))
          : ((this.x = a || 0), (this.y = d || 0), (this.z = k || 0));
        return this;
      },
      setFromMatrixPosition: function (a) {
        return this.fromArray(a.val, 12);
      },
      setFromMatrixColumn: function (a, d) {
        return this.fromArray(a.val, 4 * d);
      },
      fromArray: function (a, d) {
        void 0 === d && (d = 0);
        this.x = a[d];
        this.y = a[d + 1];
        this.z = a[d + 2];
        return this;
      },
      add: function (a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z || 0;
        return this;
      },
      addScalar: function (a) {
        this.x += a;
        this.y += a;
        this.z += a;
        return this;
      },
      addScale: function (a, d) {
        this.x += a.x * d;
        this.y += a.y * d;
        this.z += a.z * d || 0;
        return this;
      },
      subtract: function (a) {
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z || 0;
        return this;
      },
      multiply: function (a) {
        this.x *= a.x;
        this.y *= a.y;
        this.z *= a.z || 1;
        return this;
      },
      scale: function (a) {
        isFinite(a)
          ? ((this.x *= a), (this.y *= a), (this.z *= a))
          : (this.z = this.y = this.x = 0);
        return this;
      },
      divide: function (a) {
        this.x /= a.x;
        this.y /= a.y;
        this.z /= a.z || 1;
        return this;
      },
      negate: function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      },
      distance: function (a) {
        var d = a.x - this.x,
          k = a.y - this.y;
        a = a.z - this.z || 0;
        return Math.sqrt(d * d + k * k + a * a);
      },
      distanceSq: function (a) {
        var d = a.x - this.x,
          k = a.y - this.y;
        a = a.z - this.z || 0;
        return d * d + k * k + a * a;
      },
      length: function () {
        var a = this.x,
          d = this.y,
          k = this.z;
        return Math.sqrt(a * a + d * d + k * k);
      },
      lengthSq: function () {
        var a = this.x,
          d = this.y,
          k = this.z;
        return a * a + d * d + k * k;
      },
      normalize: function () {
        var a = this.x,
          d = this.y,
          k = this.z,
          e = a * a + d * d + k * k;
        0 < e &&
          ((e = 1 / Math.sqrt(e)),
          (this.x = a * e),
          (this.y = d * e),
          (this.z = k * e));
        return this;
      },
      dot: function (a) {
        return this.x * a.x + this.y * a.y + this.z * a.z;
      },
      cross: function (a) {
        var d = this.x,
          k = this.y,
          e = this.z,
          b = a.x,
          c = a.y;
        a = a.z;
        this.x = k * a - e * c;
        this.y = e * b - d * a;
        this.z = d * c - k * b;
        return this;
      },
      lerp: function (a, d) {
        void 0 === d && (d = 0);
        var k = this.x,
          e = this.y,
          b = this.z;
        this.x = k + d * (a.x - k);
        this.y = e + d * (a.y - e);
        this.z = b + d * (a.z - b);
        return this;
      },
      applyMatrix3: function (a) {
        var d = this.x,
          k = this.y,
          e = this.z;
        a = a.val;
        this.x = a[0] * d + a[3] * k + a[6] * e;
        this.y = a[1] * d + a[4] * k + a[7] * e;
        this.z = a[2] * d + a[5] * k + a[8] * e;
        return this;
      },
      applyMatrix4: function (a) {
        var d = this.x,
          k = this.y,
          e = this.z;
        a = a.val;
        var b = 1 / (a[3] * d + a[7] * k + a[11] * e + a[15]);
        this.x = (a[0] * d + a[4] * k + a[8] * e + a[12]) * b;
        this.y = (a[1] * d + a[5] * k + a[9] * e + a[13]) * b;
        this.z = (a[2] * d + a[6] * k + a[10] * e + a[14]) * b;
        return this;
      },
      transformMat3: function (a) {
        var d = this.x,
          k = this.y,
          e = this.z;
        a = a.val;
        this.x = d * a[0] + k * a[3] + e * a[6];
        this.y = d * a[1] + k * a[4] + e * a[7];
        this.z = d * a[2] + k * a[5] + e * a[8];
        return this;
      },
      transformMat4: function (a) {
        var d = this.x,
          k = this.y,
          e = this.z;
        a = a.val;
        this.x = a[0] * d + a[4] * k + a[8] * e + a[12];
        this.y = a[1] * d + a[5] * k + a[9] * e + a[13];
        this.z = a[2] * d + a[6] * k + a[10] * e + a[14];
        return this;
      },
      transformCoordinates: function (a) {
        var d = this.x,
          k = this.y,
          e = this.z;
        a = a.val;
        var b = d * a[1] + k * a[5] + e * a[9] + a[13],
          c = d * a[2] + k * a[6] + e * a[10] + a[14],
          f = d * a[3] + k * a[7] + e * a[11] + a[15];
        this.x = (d * a[0] + k * a[4] + e * a[8] + a[12]) / f;
        this.y = b / f;
        this.z = c / f;
        return this;
      },
      transformQuat: function (a) {
        var d = this.x,
          k = this.y,
          e = this.z,
          b = a.x,
          c = a.y,
          f = a.z;
        a = a.w;
        var g = a * d + c * e - f * k,
          m = a * k + f * d - b * e,
          n = a * e + b * k - c * d;
        d = -b * d - c * k - f * e;
        this.x = g * a + d * -b + m * -f - n * -c;
        this.y = m * a + d * -c + n * -b - g * -f;
        this.z = n * a + d * -f + g * -c - m * -b;
        return this;
      },
      project: function (a) {
        var d = this.x,
          k = this.y,
          e = this.z;
        a = a.val;
        var b = a[1],
          c = a[2],
          f = a[5],
          g = a[6],
          m = a[9],
          n = a[10],
          q = a[13],
          r = a[14],
          u = 1 / (d * a[3] + k * a[7] + e * a[11] + a[15]);
        this.x = (d * a[0] + k * a[4] + e * a[8] + a[12]) * u;
        this.y = (d * b + k * f + e * m + q) * u;
        this.z = (d * c + k * g + e * n + r) * u;
        return this;
      },
      projectViewMatrix: function (a, d) {
        return this.applyMatrix4(a).applyMatrix4(d);
      },
      unprojectViewMatrix: function (a, d) {
        return this.applyMatrix4(a).applyMatrix4(d);
      },
      unproject: function (a, d) {
        var k = a.w,
          e = k - this.y - 1 - a.y,
          b = this.z;
        this.x = (2 * (this.x - a.x)) / a.z - 1;
        this.y = (2 * e) / k - 1;
        this.z = 2 * b - 1;
        return this.project(d);
      },
      reset: function () {
        this.z = this.y = this.x = 0;
        return this;
      },
    });
    t.ZERO = new t();
    t.RIGHT = new t(1, 0, 0);
    t.LEFT = new t(-1, 0, 0);
    t.UP = new t(0, -1, 0);
    t.DOWN = new t(0, 1, 0);
    t.FORWARD = new t(0, 0, 1);
    t.BACK = new t(0, 0, -1);
    t.ONE = new t(1, 1, 1);
    l.exports = t;
  },
  function (l, w) {
    l.exports = {
      LOADER_IDLE: 0,
      LOADER_LOADING: 1,
      LOADER_PROCESSING: 2,
      LOADER_COMPLETE: 3,
      LOADER_SHUTDOWN: 4,
      LOADER_DESTROYED: 5,
      FILE_PENDING: 10,
      FILE_LOADING: 11,
      FILE_LOADED: 12,
      FILE_FAILED: 13,
      FILE_PROCESSING: 14,
      FILE_ERRORED: 16,
      FILE_COMPLETE: 17,
      FILE_DESTROYED: 18,
      FILE_POPULATED: 19,
    };
  },
  function (l, w, h) {
    var t = h(24),
      a = h(57);
    l.exports = function (d, k) {
      void 0 === k && (k = 90);
      if (!t(d)) return null;
      "string" !== typeof k && (k = ((k % 360) + 360) % 360);
      if (90 === k || -270 === k || "rotateLeft" === k) (d = a(d)), d.reverse();
      else if (-90 === k || 270 === k || "rotateRight" === k)
        d.reverse(), (d = a(d));
      else if (180 === Math.abs(k) || "rotate180" === k) {
        for (k = 0; k < d.length; k++) d[k].reverse();
        d.reverse();
      }
      return d;
    };
  },
  function (l, w) {
    l.exports = {
      SKIP_CHECK: -1,
      NORMAL: 0,
      ADD: 1,
      MULTIPLY: 2,
      SCREEN: 3,
      OVERLAY: 4,
      DARKEN: 5,
      LIGHTEN: 6,
      COLOR_DODGE: 7,
      COLOR_BURN: 8,
      HARD_LIGHT: 9,
      SOFT_LIGHT: 10,
      DIFFERENCE: 11,
      EXCLUSION: 12,
      HUE: 13,
      SATURATION: 14,
      COLOR: 15,
      LUMINOSITY: 16,
      ERASE: 17,
      SOURCE_IN: 18,
      SOURCE_OUT: 19,
      SOURCE_ATOP: 20,
      DESTINATION_OVER: 21,
      DESTINATION_IN: 22,
      DESTINATION_OUT: 23,
      DESTINATION_ATOP: 24,
      LIGHTER: 25,
      COPY: 26,
      XOR: 27,
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      return Math.random() * (t - h) + h;
    };
  },
  function (l, w, h) {
    var t = h(4);
    l.exports = function (a) {
      return a * t.DEG_TO_RAD;
    };
  },
  function (l, w, h) {
    w = h(0);
    h = h(14);
    var t = new w({
        initialize: function (c) {
          this.val = new Float32Array(16);
          c ? this.copy(c) : this.identity();
        },
        clone: function () {
          return new t(this);
        },
        set: function (c) {
          return this.copy(c);
        },
        setValues: function (c, f, g, m, n, q, r, u, v, x, y, z, A, B, D, E) {
          var C = this.val;
          C[0] = c;
          C[1] = f;
          C[2] = g;
          C[3] = m;
          C[4] = n;
          C[5] = q;
          C[6] = r;
          C[7] = u;
          C[8] = v;
          C[9] = x;
          C[10] = y;
          C[11] = z;
          C[12] = A;
          C[13] = B;
          C[14] = D;
          C[15] = E;
          return this;
        },
        copy: function (c) {
          c = c.val;
          return this.setValues(
            c[0],
            c[1],
            c[2],
            c[3],
            c[4],
            c[5],
            c[6],
            c[7],
            c[8],
            c[9],
            c[10],
            c[11],
            c[12],
            c[13],
            c[14],
            c[15]
          );
        },
        fromArray: function (c) {
          return this.setValues(
            c[0],
            c[1],
            c[2],
            c[3],
            c[4],
            c[5],
            c[6],
            c[7],
            c[8],
            c[9],
            c[10],
            c[11],
            c[12],
            c[13],
            c[14],
            c[15]
          );
        },
        zero: function () {
          return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        },
        transform: function (c, f, g) {
          g = a.fromQuat(g).val;
          var m = f.x,
            n = f.y;
          f = f.z;
          return this.setValues(
            g[0] * m,
            g[1] * m,
            g[2] * m,
            0,
            g[4] * n,
            g[5] * n,
            g[6] * n,
            0,
            g[8] * f,
            g[9] * f,
            g[10] * f,
            0,
            c.x,
            c.y,
            c.z,
            1
          );
        },
        xyz: function (c, f, g) {
          this.identity();
          var m = this.val;
          m[12] = c;
          m[13] = f;
          m[14] = g;
          return this;
        },
        scaling: function (c, f, g) {
          this.zero();
          var m = this.val;
          m[0] = c;
          m[5] = f;
          m[10] = g;
          m[15] = 1;
          return this;
        },
        identity: function () {
          return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        },
        transpose: function () {
          var c = this.val,
            f = c[1],
            g = c[2],
            m = c[3],
            n = c[6],
            q = c[7],
            r = c[11];
          c[1] = c[4];
          c[2] = c[8];
          c[3] = c[12];
          c[4] = f;
          c[6] = c[9];
          c[7] = c[13];
          c[8] = g;
          c[9] = n;
          c[11] = c[14];
          c[12] = m;
          c[13] = q;
          c[14] = r;
          return this;
        },
        getInverse: function (c) {
          this.copy(c);
          return this.invert();
        },
        invert: function () {
          var c = this.val,
            f = c[0],
            g = c[1],
            m = c[2],
            n = c[3],
            q = c[4],
            r = c[5],
            u = c[6],
            v = c[7],
            x = c[8],
            y = c[9],
            z = c[10],
            A = c[11],
            B = c[12],
            D = c[13],
            E = c[14];
          c = c[15];
          var C = f * r - g * q,
            F = f * u - m * q,
            G = f * v - n * q,
            H = g * u - m * r,
            K = g * v - n * r,
            I = m * v - n * u,
            M = x * D - y * B,
            N = x * E - z * B,
            P = x * c - A * B,
            J = y * E - z * D,
            L = y * c - A * D,
            O = z * c - A * E,
            Q = C * O - F * L + G * J + H * P - K * N + I * M;
          if (!Q) return this;
          Q = 1 / Q;
          return this.setValues(
            (r * O - u * L + v * J) * Q,
            (m * L - g * O - n * J) * Q,
            (D * I - E * K + c * H) * Q,
            (z * K - y * I - A * H) * Q,
            (u * P - q * O - v * N) * Q,
            (f * O - m * P + n * N) * Q,
            (E * G - B * I - c * F) * Q,
            (x * I - z * G + A * F) * Q,
            (q * L - r * P + v * M) * Q,
            (g * P - f * L - n * M) * Q,
            (B * K - D * G + c * C) * Q,
            (y * G - x * K - A * C) * Q,
            (r * N - q * J - u * M) * Q,
            (f * J - g * N + m * M) * Q,
            (D * F - B * H - E * C) * Q,
            (x * H - y * F + z * C) * Q
          );
        },
        adjoint: function () {
          var c = this.val,
            f = c[0],
            g = c[1],
            m = c[2],
            n = c[3],
            q = c[4],
            r = c[5],
            u = c[6],
            v = c[7],
            x = c[8],
            y = c[9],
            z = c[10],
            A = c[11],
            B = c[12],
            D = c[13],
            E = c[14];
          c = c[15];
          return this.setValues(
            r * (z * c - A * E) - y * (u * c - v * E) + D * (u * A - v * z),
            -(g * (z * c - A * E) - y * (m * c - n * E) + D * (m * A - n * z)),
            g * (u * c - v * E) - r * (m * c - n * E) + D * (m * v - n * u),
            -(g * (u * A - v * z) - r * (m * A - n * z) + y * (m * v - n * u)),
            -(q * (z * c - A * E) - x * (u * c - v * E) + B * (u * A - v * z)),
            f * (z * c - A * E) - x * (m * c - n * E) + B * (m * A - n * z),
            -(f * (u * c - v * E) - q * (m * c - n * E) + B * (m * v - n * u)),
            f * (u * A - v * z) - q * (m * A - n * z) + x * (m * v - n * u),
            q * (y * c - A * D) - x * (r * c - v * D) + B * (r * A - v * y),
            -(f * (y * c - A * D) - x * (g * c - n * D) + B * (g * A - n * y)),
            f * (r * c - v * D) - q * (g * c - n * D) + B * (g * v - n * r),
            -(f * (r * A - v * y) - q * (g * A - n * y) + x * (g * v - n * r)),
            -(q * (y * E - z * D) - x * (r * E - u * D) + B * (r * z - u * y)),
            f * (y * E - z * D) - x * (g * E - m * D) + B * (g * z - m * y),
            -(f * (r * E - u * D) - q * (g * E - m * D) + B * (g * u - m * r)),
            f * (r * z - u * y) - q * (g * z - m * y) + x * (g * u - m * r)
          );
        },
        determinant: function () {
          var c = this.val,
            f = c[0],
            g = c[1],
            m = c[2],
            n = c[3],
            q = c[4],
            r = c[5],
            u = c[6],
            v = c[7],
            x = c[8],
            y = c[9],
            z = c[10],
            A = c[11],
            B = c[12],
            D = c[13],
            E = c[14];
          c = c[15];
          return (
            (f * r - g * q) * (z * c - A * E) -
            (f * u - m * q) * (y * c - A * D) +
            (f * v - n * q) * (y * E - z * D) +
            (g * u - m * r) * (x * c - A * B) -
            (g * v - n * r) * (x * E - z * B) +
            (m * v - n * u) * (x * D - y * B)
          );
        },
        multiply: function (c) {
          var f = this.val,
            g = f[0],
            m = f[1],
            n = f[2],
            q = f[3],
            r = f[4],
            u = f[5],
            v = f[6],
            x = f[7],
            y = f[8],
            z = f[9],
            A = f[10],
            B = f[11],
            D = f[12],
            E = f[13],
            C = f[14],
            F = f[15];
          c = c.val;
          var G = c[0],
            H = c[1],
            K = c[2],
            I = c[3];
          f[0] = G * g + H * r + K * y + I * D;
          f[1] = G * m + H * u + K * z + I * E;
          f[2] = G * n + H * v + K * A + I * C;
          f[3] = G * q + H * x + K * B + I * F;
          G = c[4];
          H = c[5];
          K = c[6];
          I = c[7];
          f[4] = G * g + H * r + K * y + I * D;
          f[5] = G * m + H * u + K * z + I * E;
          f[6] = G * n + H * v + K * A + I * C;
          f[7] = G * q + H * x + K * B + I * F;
          G = c[8];
          H = c[9];
          K = c[10];
          I = c[11];
          f[8] = G * g + H * r + K * y + I * D;
          f[9] = G * m + H * u + K * z + I * E;
          f[10] = G * n + H * v + K * A + I * C;
          f[11] = G * q + H * x + K * B + I * F;
          G = c[12];
          H = c[13];
          K = c[14];
          I = c[15];
          f[12] = G * g + H * r + K * y + I * D;
          f[13] = G * m + H * u + K * z + I * E;
          f[14] = G * n + H * v + K * A + I * C;
          f[15] = G * q + H * x + K * B + I * F;
          return this;
        },
        multiplyLocal: function (c) {
          var f = this.val;
          c = c.val;
          return this.setValues(
            f[0] * c[0] + f[1] * c[4] + f[2] * c[8] + f[3] * c[12],
            f[0] * c[1] + f[1] * c[5] + f[2] * c[9] + f[3] * c[13],
            f[0] * c[2] + f[1] * c[6] + f[2] * c[10] + f[3] * c[14],
            f[0] * c[3] + f[1] * c[7] + f[2] * c[11] + f[3] * c[15],
            f[4] * c[0] + f[5] * c[4] + f[6] * c[8] + f[7] * c[12],
            f[4] * c[1] + f[5] * c[5] + f[6] * c[9] + f[7] * c[13],
            f[4] * c[2] + f[5] * c[6] + f[6] * c[10] + f[7] * c[14],
            f[4] * c[3] + f[5] * c[7] + f[6] * c[11] + f[7] * c[15],
            f[8] * c[0] + f[9] * c[4] + f[10] * c[8] + f[11] * c[12],
            f[8] * c[1] + f[9] * c[5] + f[10] * c[9] + f[11] * c[13],
            f[8] * c[2] + f[9] * c[6] + f[10] * c[10] + f[11] * c[14],
            f[8] * c[3] + f[9] * c[7] + f[10] * c[11] + f[11] * c[15],
            f[12] * c[0] + f[13] * c[4] + f[14] * c[8] + f[15] * c[12],
            f[12] * c[1] + f[13] * c[5] + f[14] * c[9] + f[15] * c[13],
            f[12] * c[2] + f[13] * c[6] + f[14] * c[10] + f[15] * c[14],
            f[12] * c[3] + f[13] * c[7] + f[14] * c[11] + f[15] * c[15]
          );
        },
        premultiply: function (c) {
          return this.multiplyMatrices(c, this);
        },
        multiplyMatrices: function (c, f) {
          var g = c.val,
            m = f.val;
          f = g[0];
          c = g[4];
          var n = g[8],
            q = g[12],
            r = g[1],
            u = g[5],
            v = g[9],
            x = g[13],
            y = g[2],
            z = g[6],
            A = g[10],
            B = g[14],
            D = g[3],
            E = g[7],
            C = g[11];
          g = g[15];
          var F = m[0],
            G = m[4],
            H = m[8],
            K = m[12],
            I = m[1],
            M = m[5],
            N = m[9],
            P = m[13],
            J = m[2],
            L = m[6],
            O = m[10],
            Q = m[14],
            S = m[3],
            R = m[7],
            T = m[11];
          m = m[15];
          return this.setValues(
            f * F + c * I + n * J + q * S,
            r * F + u * I + v * J + x * S,
            y * F + z * I + A * J + B * S,
            D * F + E * I + C * J + g * S,
            f * G + c * M + n * L + q * R,
            r * G + u * M + v * L + x * R,
            y * G + z * M + A * L + B * R,
            D * G + E * M + C * L + g * R,
            f * H + c * N + n * O + q * T,
            r * H + u * N + v * O + x * T,
            y * H + z * N + A * O + B * T,
            D * H + E * N + C * O + g * T,
            f * K + c * P + n * Q + q * m,
            r * K + u * P + v * Q + x * m,
            y * K + z * P + A * Q + B * m,
            D * K + E * P + C * Q + g * m
          );
        },
        translate: function (c) {
          return this.translateXYZ(c.x, c.y, c.z);
        },
        translateXYZ: function (c, f, g) {
          var m = this.val;
          m[12] = m[0] * c + m[4] * f + m[8] * g + m[12];
          m[13] = m[1] * c + m[5] * f + m[9] * g + m[13];
          m[14] = m[2] * c + m[6] * f + m[10] * g + m[14];
          m[15] = m[3] * c + m[7] * f + m[11] * g + m[15];
          return this;
        },
        scale: function (c) {
          return this.scaleXYZ(c.x, c.y, c.z);
        },
        scaleXYZ: function (c, f, g) {
          var m = this.val;
          m[0] *= c;
          m[1] *= c;
          m[2] *= c;
          m[3] *= c;
          m[4] *= f;
          m[5] *= f;
          m[6] *= f;
          m[7] *= f;
          m[8] *= g;
          m[9] *= g;
          m[10] *= g;
          m[11] *= g;
          return this;
        },
        makeRotationAxis: function (c, f) {
          var g = Math.cos(f);
          f = Math.sin(f);
          var m = 1 - g,
            n = c.x,
            q = c.y;
          c = c.z;
          var r = m * n,
            u = m * q;
          return this.setValues(
            r * n + g,
            r * q - f * c,
            r * c + f * q,
            0,
            r * q + f * c,
            u * q + g,
            u * c - f * n,
            0,
            r * c - f * q,
            u * c + f * n,
            m * c * c + g,
            0,
            0,
            0,
            0,
            1
          );
        },
        rotate: function (c, f) {
          var g = this.val,
            m = f.x,
            n = f.y;
          f = f.z;
          var q = Math.sqrt(m * m + n * n + f * f);
          if (1e-6 > Math.abs(q)) return this;
          q = 1 / q;
          m *= q;
          n *= q;
          f *= q;
          var r = Math.sin(c),
            u = Math.cos(c),
            v = 1 - u;
          c = g[0];
          q = g[1];
          var x = g[2],
            y = g[3],
            z = g[4],
            A = g[5],
            B = g[6],
            D = g[7],
            E = g[8],
            C = g[9],
            F = g[10],
            G = g[11],
            H = m * m * v + u,
            K = n * m * v + f * r,
            I = f * m * v - n * r,
            M = m * n * v - f * r,
            N = n * n * v + u,
            P = f * n * v + m * r,
            J = m * f * v + n * r;
          m = n * f * v - m * r;
          n = f * f * v + u;
          return this.setValues(
            c * H + z * K + E * I,
            q * H + A * K + C * I,
            x * H + B * K + F * I,
            y * H + D * K + G * I,
            c * M + z * N + E * P,
            q * M + A * N + C * P,
            x * M + B * N + F * P,
            y * M + D * N + G * P,
            c * J + z * m + E * n,
            q * J + A * m + C * n,
            x * J + B * m + F * n,
            y * J + D * m + G * n,
            g[12],
            g[13],
            g[14],
            g[15]
          );
        },
        rotateX: function (c) {
          var f = this.val,
            g = Math.sin(c);
          c = Math.cos(c);
          var m = f[4],
            n = f[5],
            q = f[6],
            r = f[7],
            u = f[8],
            v = f[9],
            x = f[10],
            y = f[11];
          f[4] = m * c + u * g;
          f[5] = n * c + v * g;
          f[6] = q * c + x * g;
          f[7] = r * c + y * g;
          f[8] = u * c - m * g;
          f[9] = v * c - n * g;
          f[10] = x * c - q * g;
          f[11] = y * c - r * g;
          return this;
        },
        rotateY: function (c) {
          var f = this.val,
            g = Math.sin(c);
          c = Math.cos(c);
          var m = f[0],
            n = f[1],
            q = f[2],
            r = f[3],
            u = f[8],
            v = f[9],
            x = f[10],
            y = f[11];
          f[0] = m * c - u * g;
          f[1] = n * c - v * g;
          f[2] = q * c - x * g;
          f[3] = r * c - y * g;
          f[8] = m * g + u * c;
          f[9] = n * g + v * c;
          f[10] = q * g + x * c;
          f[11] = r * g + y * c;
          return this;
        },
        rotateZ: function (c) {
          var f = this.val,
            g = Math.sin(c);
          c = Math.cos(c);
          var m = f[0],
            n = f[1],
            q = f[2],
            r = f[3],
            u = f[4],
            v = f[5],
            x = f[6],
            y = f[7];
          f[0] = m * c + u * g;
          f[1] = n * c + v * g;
          f[2] = q * c + x * g;
          f[3] = r * c + y * g;
          f[4] = u * c - m * g;
          f[5] = v * c - n * g;
          f[6] = x * c - q * g;
          f[7] = y * c - r * g;
          return this;
        },
        fromRotationTranslation: function (c, f) {
          var g = c.x,
            m = c.y,
            n = c.z,
            q = c.w,
            r = g + g,
            u = m + m,
            v = n + n;
          c = g * r;
          var x = g * u;
          g *= v;
          var y = m * u;
          m *= v;
          n *= v;
          r *= q;
          u *= q;
          q *= v;
          return this.setValues(
            1 - (y + n),
            x + q,
            g - u,
            0,
            x - q,
            1 - (c + n),
            m + r,
            0,
            g + u,
            m - r,
            1 - (c + y),
            0,
            f.x,
            f.y,
            f.z,
            1
          );
        },
        fromQuat: function (c) {
          var f = c.x,
            g = c.y,
            m = c.z,
            n = c.w,
            q = f + f,
            r = g + g,
            u = m + m;
          c = f * q;
          var v = f * r;
          f *= u;
          var x = g * r;
          g *= u;
          m *= u;
          q *= n;
          r *= n;
          n *= u;
          return this.setValues(
            1 - (x + m),
            v + n,
            f - r,
            0,
            v - n,
            1 - (c + m),
            g + q,
            0,
            f + r,
            g - q,
            1 - (c + x),
            0,
            0,
            0,
            0,
            1
          );
        },
        frustum: function (c, f, g, m, n, q) {
          var r = 1 / (f - c),
            u = 1 / (m - g),
            v = 1 / (n - q);
          return this.setValues(
            2 * n * r,
            0,
            0,
            0,
            0,
            2 * n * u,
            0,
            0,
            (f + c) * r,
            (m + g) * u,
            (q + n) * v,
            -1,
            0,
            0,
            q * n * 2 * v,
            0
          );
        },
        perspective: function (c, f, g, m) {
          c = 1 / Math.tan(c / 2);
          var n = 1 / (g - m);
          return this.setValues(
            c / f,
            0,
            0,
            0,
            0,
            c,
            0,
            0,
            0,
            0,
            (m + g) * n,
            -1,
            0,
            0,
            2 * m * g * n,
            0
          );
        },
        perspectiveLH: function (c, f, g, m) {
          return this.setValues(
            (2 * g) / c,
            0,
            0,
            0,
            0,
            (2 * g) / f,
            0,
            0,
            0,
            0,
            -m / (g - m),
            1,
            0,
            0,
            (g * m) / (g - m),
            0
          );
        },
        ortho: function (c, f, g, m, n, q) {
          var r = c - f,
            u = g - m,
            v = n - q;
          r = 0 === r ? r : 1 / r;
          u = 0 === u ? u : 1 / u;
          v = 0 === v ? v : 1 / v;
          return this.setValues(
            -2 * r,
            0,
            0,
            0,
            0,
            -2 * u,
            0,
            0,
            0,
            0,
            2 * v,
            0,
            (c + f) * r,
            (m + g) * u,
            (q + n) * v,
            1
          );
        },
        lookAtRH: function (c, f, g) {
          var m = this.val;
          b.subVectors(c, f);
          0 === b.getLengthSquared() && (b.z = 1);
          b.normalize();
          k.crossVectors(g, b);
          0 === k.getLengthSquared() &&
            (1 === Math.abs(g.z) ? (b.x += 1e-4) : (b.z += 1e-4),
            b.normalize(),
            k.crossVectors(g, b));
          k.normalize();
          e.crossVectors(b, k);
          m[0] = k.x;
          m[1] = k.y;
          m[2] = k.z;
          m[4] = e.x;
          m[5] = e.y;
          m[6] = e.z;
          m[8] = b.x;
          m[9] = b.y;
          m[10] = b.z;
          return this;
        },
        lookAt: function (c, f, g) {
          var m = c.x,
            n = c.y;
          c = c.z;
          var q = g.x,
            r = g.y,
            u = g.z,
            v = f.x;
          g = f.y;
          var x = f.z;
          if (
            1e-6 > Math.abs(m - v) &&
            1e-6 > Math.abs(n - g) &&
            1e-6 > Math.abs(c - x)
          )
            return this.identity();
          f = m - v;
          g = n - g;
          x = c - x;
          v = 1 / Math.sqrt(f * f + g * g + x * x);
          f *= v;
          g *= v;
          x *= v;
          var y = r * x - u * g;
          u = u * f - q * x;
          q = q * g - r * f;
          (v = Math.sqrt(y * y + u * u + q * q))
            ? ((v = 1 / v), (y *= v), (u *= v), (q *= v))
            : (q = u = y = 0);
          r = g * q - x * u;
          var z = x * y - f * q,
            A = f * u - g * y;
          (v = Math.sqrt(r * r + z * z + A * A))
            ? ((v = 1 / v), (r *= v), (z *= v), (A *= v))
            : (A = z = r = 0);
          return this.setValues(
            y,
            r,
            f,
            0,
            u,
            z,
            g,
            0,
            q,
            A,
            x,
            0,
            -(y * m + u * n + q * c),
            -(r * m + z * n + A * c),
            -(f * m + g * n + x * c),
            1
          );
        },
        yawPitchRoll: function (c, f, g) {
          this.zero();
          a.zero();
          d.zero();
          var m = this.val,
            n = a.val,
            q = d.val,
            r = Math.sin(g);
          g = Math.cos(g);
          m[10] = 1;
          m[15] = 1;
          m[0] = g;
          m[1] = r;
          m[4] = -r;
          m[5] = g;
          r = Math.sin(f);
          g = Math.cos(f);
          n[0] = 1;
          n[15] = 1;
          n[5] = g;
          n[10] = g;
          n[9] = -r;
          n[6] = r;
          r = Math.sin(c);
          g = Math.cos(c);
          q[5] = 1;
          q[15] = 1;
          q[0] = g;
          q[2] = -r;
          q[8] = r;
          q[10] = g;
          this.multiplyLocal(a);
          this.multiplyLocal(d);
          return this;
        },
        setWorldMatrix: function (c, f, g, m, n) {
          this.yawPitchRoll(c.y, c.x, c.z);
          a.scaling(g.x, g.y, g.z);
          d.xyz(f.x, f.y, f.z);
          this.multiplyLocal(a);
          this.multiplyLocal(d);
          m && this.multiplyLocal(m);
          n && this.multiplyLocal(n);
          return this;
        },
        multiplyToMat4: function (c, f) {
          var g = this.val;
          c = c.val;
          var m = g[0],
            n = g[1],
            q = g[2],
            r = g[3],
            u = g[4],
            v = g[5],
            x = g[6],
            y = g[7],
            z = g[8],
            A = g[9],
            B = g[10],
            D = g[11],
            E = g[12],
            C = g[13],
            F = g[14];
          g = g[15];
          var G = c[1],
            H = c[2],
            K = c[3],
            I = c[4],
            M = c[5],
            N = c[6],
            P = c[7],
            J = c[8],
            L = c[9],
            O = c[10],
            Q = c[11],
            S = c[12],
            R = c[13],
            T = c[14],
            U = c[15];
          return f.setValues(
            c[0] * m + G * u + H * z + K * E,
            G * n + G * v + H * A + K * C,
            H * q + G * x + H * B + K * F,
            K * r + G * y + H * D + K * g,
            I * m + M * u + N * z + P * E,
            I * n + M * v + N * A + P * C,
            I * q + M * x + N * B + P * F,
            I * r + M * y + N * D + P * g,
            J * m + L * u + O * z + Q * E,
            J * n + L * v + O * A + Q * C,
            J * q + L * x + O * B + Q * F,
            J * r + L * y + O * D + Q * g,
            S * m + R * u + T * z + U * E,
            S * n + R * v + T * A + U * C,
            S * q + R * x + T * B + U * F,
            S * r + R * y + T * D + U * g
          );
        },
        fromRotationXYTranslation: function (c, f, g) {
          var m = f.x,
            n = f.y;
          f = f.z;
          var q = Math.sin(c.x),
            r = Math.cos(c.x),
            u = Math.sin(c.y);
          c = Math.cos(c.y);
          var v = m,
            x = n,
            y = f,
            z = -q,
            A = -(z * u),
            B = -(r * u);
          z *= c;
          var D = r * c;
          g ||
            ((v = c * m + u * f),
            (x = A * m + r * n + z * f),
            (y = B * m + q * n + D * f));
          return this.setValues(c, A, B, 0, 0, r, q, 0, u, z, D, 0, v, x, y, 1);
        },
        getMaxScaleOnAxis: function () {
          var c = this.val;
          return Math.sqrt(
            Math.max(
              c[0] * c[0] + c[1] * c[1] + c[2] * c[2],
              c[4] * c[4] + c[5] * c[5] + c[6] * c[6],
              c[8] * c[8] + c[9] * c[9] + c[10] * c[10]
            )
          );
        },
      }),
      a = new t(),
      d = new t(),
      k = new h(),
      e = new h(),
      b = new h();
    l.exports = t;
  },
  function (l, w, h) {
    w = h(0);
    var t = h(15),
      a = h(205),
      d = h(11),
      k = h(216),
      e = h(45),
      b = h(217),
      c = h(46);
    h = new w({
      initialize: function (f, g) {
        this.loader = f;
        this.cache = d(g, "cache", !1);
        this.type = d(g, "type", !1);
        var m = (this.key = d(g, "key", !1));
        f.prefix && "" !== f.prefix && (this.key = f.prefix + m);
        if (!this.type || !this.key)
          throw Error("Invalid Loader." + this.type + " key");
        var n = d(g, "url");
        void 0 === n
          ? (n = f.path + m + "." + d(g, "extension", ""))
          : "string" !== typeof n ||
            n.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ||
            (n = f.path + n);
        this.url = n;
        this.src = "";
        this.xhrSettings = c(d(g, "responseType", void 0));
        d(g, "xhrSettings", !1) &&
          (this.xhrSettings = e(this.xhrSettings, d(g, "xhrSettings", {})));
        this.xhrLoader = null;
        this.state =
          "function" === typeof this.url ? t.FILE_POPULATED : t.FILE_PENDING;
        this.bytesTotal = 0;
        this.percentComplete = this.bytesLoaded = -1;
        this.data = this.crossOrigin = void 0;
        this.config = d(g, "config", {});
        this.multiFile;
        this.linkFile;
      },
      setLink: function (f) {
        this.linkFile = f;
        f.linkFile = this;
      },
      resetXHR: function () {
        this.xhrLoader &&
          ((this.xhrLoader.onload = void 0),
          (this.xhrLoader.onerror = void 0),
          (this.xhrLoader.onprogress = void 0));
      },
      load: function () {
        this.state === t.FILE_POPULATED
          ? this.loader.nextFile(this, !0)
          : ((this.state = t.FILE_LOADING),
            (this.src = k(this, this.loader.baseURL)),
            0 === this.src.indexOf("data:")
              ? console.warn("Local data URIs are not supported: " + this.key)
              : (this.xhrLoader = b(this, this.loader.xhr)));
      },
      onLoad: function (f, g) {
        var m =
          f.responseURL &&
          0 === f.responseURL.indexOf("file://") &&
          0 === g.target.status;
        g = !(g.target && 200 !== g.target.status) || m;
        4 === f.readyState && 400 <= f.status && 599 >= f.status && (g = !1);
        this.state = t.FILE_LOADED;
        this.resetXHR();
        this.loader.nextFile(this, g);
      },
      onError: function () {
        this.resetXHR();
        this.loader.nextFile(this, !1);
      },
      onProgress: function (f) {
        f.lengthComputable &&
          ((this.bytesLoaded = f.loaded),
          (this.bytesTotal = f.total),
          (this.percentComplete = Math.min(
            this.bytesLoaded / this.bytesTotal,
            1
          )),
          this.loader.emit(a.FILE_PROGRESS, this, this.percentComplete));
      },
      onProcess: function () {
        this.state = t.FILE_PROCESSING;
        this.onProcessComplete();
      },
      onProcessComplete: function () {
        this.state = t.FILE_COMPLETE;
        if (this.multiFile) this.multiFile.onFileComplete(this);
        this.loader.fileProcessComplete(this);
      },
      onProcessError: function () {
        this.state = t.FILE_ERRORED;
        if (this.multiFile) this.multiFile.onFileFailed(this);
        this.loader.fileProcessComplete(this);
      },
      hasCacheConflict: function () {
        return this.cache && this.cache.exists(this.key);
      },
      addToCache: function () {
        this.cache && this.cache.add(this.key, this.data);
        this.pendingDestroy();
      },
      pendingDestroy: function (f) {
        void 0 === f && (f = this.data);
        var g = this.key,
          m = this.type;
        this.loader.emit(a.FILE_COMPLETE, g, m, f);
        this.loader.emit(a.FILE_KEY_COMPLETE + m + "-" + g, g, m, f);
        this.loader.flagForRemoval(this);
      },
      destroy: function () {
        this.data =
          this.linkFile =
          this.multiFile =
          this.xhrSettings =
          this.cache =
          this.loader =
            null;
      },
    });
    h.createObjectURL = function (f, g, m) {
      if ("function" === typeof URL) f.src = URL.createObjectURL(g);
      else {
        var n = new FileReader();
        n.onload = function () {
          f.removeAttribute("crossOrigin");
          f.src = "data:" + (g.type || m) + ";base64," + n.result.split(",")[1];
        };
        n.onerror = f.onerror;
        n.readAsDataURL(g);
      }
    };
    h.revokeObjectURL = function (f) {
      "function" === typeof URL && URL.revokeObjectURL(f.src);
    };
    l.exports = h;
  },
  function (l, w) {
    var h = {};
    l.exports = {
      install: function (t) {
        for (var a in h) t[a] = h[a];
      },
      register: function (t, a) {
        h[t] = a;
      },
      destroy: function () {
        h = {};
      },
    };
  },
  function (l, w, h) {
    w = h(0);
    var t = h(4),
      a = h(2);
    h = new w({
      initialize: function (d, k, e, b, c, f) {
        void 0 === d && (d = 1);
        void 0 === k && (k = 0);
        void 0 === e && (e = 0);
        void 0 === b && (b = 1);
        void 0 === c && (c = 0);
        void 0 === f && (f = 0);
        this.matrix = new Float32Array([d, k, e, b, c, f, 0, 0, 1]);
        this.decomposedMatrix = {
          translateX: 0,
          translateY: 0,
          scaleX: 1,
          scaleY: 1,
          rotation: 0,
        };
      },
      a: {
        get: function () {
          return this.matrix[0];
        },
        set: function (d) {
          this.matrix[0] = d;
        },
      },
      b: {
        get: function () {
          return this.matrix[1];
        },
        set: function (d) {
          this.matrix[1] = d;
        },
      },
      c: {
        get: function () {
          return this.matrix[2];
        },
        set: function (d) {
          this.matrix[2] = d;
        },
      },
      d: {
        get: function () {
          return this.matrix[3];
        },
        set: function (d) {
          this.matrix[3] = d;
        },
      },
      e: {
        get: function () {
          return this.matrix[4];
        },
        set: function (d) {
          this.matrix[4] = d;
        },
      },
      f: {
        get: function () {
          return this.matrix[5];
        },
        set: function (d) {
          this.matrix[5] = d;
        },
      },
      tx: {
        get: function () {
          return this.matrix[4];
        },
        set: function (d) {
          this.matrix[4] = d;
        },
      },
      ty: {
        get: function () {
          return this.matrix[5];
        },
        set: function (d) {
          this.matrix[5] = d;
        },
      },
      rotation: {
        get: function () {
          return (
            Math.acos(this.a / this.scaleX) *
            (0 > Math.atan(-this.c / this.a) ? -1 : 1)
          );
        },
      },
      rotationNormalized: {
        get: function () {
          var d = this.matrix,
            k = d[0],
            e = d[1],
            b = d[2];
          d = d[3];
          return k || e
            ? 0 < e
              ? Math.acos(k / this.scaleX)
              : -Math.acos(k / this.scaleX)
            : b || d
            ? t.TAU -
              (0 < d
                ? Math.acos(-b / this.scaleY)
                : -Math.acos(b / this.scaleY))
            : 0;
        },
      },
      scaleX: {
        get: function () {
          return Math.sqrt(this.a * this.a + this.b * this.b);
        },
      },
      scaleY: {
        get: function () {
          return Math.sqrt(this.c * this.c + this.d * this.d);
        },
      },
      loadIdentity: function () {
        var d = this.matrix;
        d[0] = 1;
        d[1] = 0;
        d[2] = 0;
        d[3] = 1;
        d[4] = 0;
        d[5] = 0;
        return this;
      },
      translate: function (d, k) {
        var e = this.matrix;
        e[4] = e[0] * d + e[2] * k + e[4];
        e[5] = e[1] * d + e[3] * k + e[5];
        return this;
      },
      scale: function (d, k) {
        var e = this.matrix;
        e[0] *= d;
        e[1] *= d;
        e[2] *= k;
        e[3] *= k;
        return this;
      },
      rotate: function (d) {
        var k = Math.sin(d);
        d = Math.cos(d);
        var e = this.matrix,
          b = e[0],
          c = e[1],
          f = e[2],
          g = e[3];
        e[0] = b * d + f * k;
        e[1] = c * d + g * k;
        e[2] = b * -k + f * d;
        e[3] = c * -k + g * d;
        return this;
      },
      multiply: function (d, k) {
        var e = this.matrix,
          b = d.matrix;
        d = e[0];
        var c = e[1],
          f = e[2],
          g = e[3],
          m = e[4];
        e = e[5];
        var n = b[0],
          q = b[1],
          r = b[2],
          u = b[3],
          v = b[4];
        b = b[5];
        k = void 0 === k ? this : k;
        k.a = n * d + q * f;
        k.b = n * c + q * g;
        k.c = r * d + u * f;
        k.d = r * c + u * g;
        k.e = v * d + b * f + m;
        k.f = v * c + b * g + e;
        return k;
      },
      multiplyWithOffset: function (d, k, e) {
        var b = this.matrix,
          c = d.matrix;
        d = b[0];
        var f = b[1],
          g = b[2],
          m = b[3],
          n = b[4],
          q = b[5],
          r = c[0],
          u = c[1],
          v = c[2],
          x = c[3],
          y = c[4];
        c = c[5];
        b[0] = r * d + u * g;
        b[1] = r * f + u * m;
        b[2] = v * d + x * g;
        b[3] = v * f + x * m;
        b[4] = y * d + c * g + (k * d + e * g + n);
        b[5] = y * f + c * m + (k * f + e * m + q);
        return this;
      },
      transform: function (d, k, e, b, c, f) {
        var g = this.matrix,
          m = g[0],
          n = g[1],
          q = g[2],
          r = g[3],
          u = g[4],
          v = g[5];
        g[0] = d * m + k * q;
        g[1] = d * n + k * r;
        g[2] = e * m + b * q;
        g[3] = e * n + b * r;
        g[4] = c * m + f * q + u;
        g[5] = c * n + f * r + v;
        return this;
      },
      transformPoint: function (d, k, e) {
        void 0 === e &&
          (e = {
            x: 0,
            y: 0,
          });
        var b = this.matrix,
          c = b[1],
          f = b[3],
          g = b[5];
        e.x = d * b[0] + k * b[2] + b[4];
        e.y = d * c + k * f + g;
        return e;
      },
      invert: function () {
        var d = this.matrix,
          k = d[0],
          e = d[1],
          b = d[2],
          c = d[3],
          f = d[4],
          g = d[5],
          m = k * c - e * b;
        d[0] = c / m;
        d[1] = -e / m;
        d[2] = -b / m;
        d[3] = k / m;
        d[4] = (b * g - c * f) / m;
        d[5] = -(k * g - e * f) / m;
        return this;
      },
      copyFrom: function (d) {
        var k = this.matrix;
        k[0] = d.a;
        k[1] = d.b;
        k[2] = d.c;
        k[3] = d.d;
        k[4] = d.e;
        k[5] = d.f;
        return this;
      },
      copyFromArray: function (d) {
        var k = this.matrix;
        k[0] = d[0];
        k[1] = d[1];
        k[2] = d[2];
        k[3] = d[3];
        k[4] = d[4];
        k[5] = d[5];
        return this;
      },
      copyToContext: function (d) {
        var k = this.matrix;
        d.transform(k[0], k[1], k[2], k[3], k[4], k[5]);
        return d;
      },
      setToContext: function (d) {
        var k = this.matrix;
        d.setTransform(k[0], k[1], k[2], k[3], k[4], k[5]);
        return d;
      },
      copyToArray: function (d) {
        var k = this.matrix;
        void 0 === d
          ? (d = [k[0], k[1], k[2], k[3], k[4], k[5]])
          : ((d[0] = k[0]),
            (d[1] = k[1]),
            (d[2] = k[2]),
            (d[3] = k[3]),
            (d[4] = k[4]),
            (d[5] = k[5]));
        return d;
      },
      setTransform: function (d, k, e, b, c, f) {
        var g = this.matrix;
        g[0] = d;
        g[1] = k;
        g[2] = e;
        g[3] = b;
        g[4] = c;
        g[5] = f;
        return this;
      },
      decomposeMatrix: function () {
        var d = this.decomposedMatrix,
          k = this.matrix,
          e = k[0],
          b = k[1],
          c = k[2],
          f = k[3],
          g = e * f - b * c;
        d.translateX = k[4];
        d.translateY = k[5];
        e || b
          ? ((c = Math.sqrt(e * e + b * b)),
            (d.rotation = 0 < b ? Math.acos(e / c) : -Math.acos(e / c)),
            (d.scaleX = c),
            (d.scaleY = g / c))
          : c || f
          ? ((e = Math.sqrt(c * c + f * f)),
            (d.rotation =
              0.5 * Math.PI - (0 < f ? Math.acos(-c / e) : -Math.acos(c / e))),
            (d.scaleX = g / e),
            (d.scaleY = e))
          : ((d.rotation = 0), (d.scaleX = 0), (d.scaleY = 0));
        return d;
      },
      applyITRS: function (d, k, e, b, c) {
        var f = this.matrix,
          g = Math.sin(e);
        e = Math.cos(e);
        f[4] = d;
        f[5] = k;
        f[0] = e * b;
        f[1] = g * b;
        f[2] = -g * c;
        f[3] = e * c;
        return this;
      },
      applyInverse: function (d, k, e) {
        void 0 === e && (e = new a());
        var b = this.matrix,
          c = b[0],
          f = b[1],
          g = b[2],
          m = b[3],
          n = b[4];
        b = b[5];
        var q = 1 / (c * m + g * -f);
        e.x = m * q * d + -g * q * k + (b * g - n * m) * q;
        e.y = c * q * k + -f * q * d + (-b * c + n * f) * q;
        return e;
      },
      getX: function (d, k) {
        return d * this.a + k * this.c + this.e;
      },
      getY: function (d, k) {
        return d * this.b + k * this.d + this.f;
      },
      getXRound: function (d, k, e) {
        d = this.getX(d, k);
        e && (d = Math.round(d));
        return d;
      },
      getYRound: function (d, k, e) {
        d = this.getY(d, k);
        e && (d = Math.round(d));
        return d;
      },
      getCSSMatrix: function () {
        var d = this.matrix;
        return (
          "matrix(" +
          d[0] +
          "," +
          d[1] +
          "," +
          d[2] +
          "," +
          d[3] +
          "," +
          d[4] +
          "," +
          d[5] +
          ")"
        );
      },
      destroy: function () {
        this.decomposedMatrix = this.matrix = null;
      },
    });
    l.exports = h;
  },
  function (l, w) {
    l.exports = function (h) {
      if (!Array.isArray(h) || 2 > h.length || !Array.isArray(h[0])) return !1;
      for (var t = h[0].length, a = 1; a < h.length; a++)
        if (h[a].length !== t) return !1;
      return !0;
    };
  },
  function (l, w, h) {
    w = h(0);
    var t = h(299),
      a = h(61),
      d = h(300),
      k = h(26),
      e = h(301),
      b = h(306);
    h = new w({
      initialize: function (c, f, g, m) {
        void 0 === c && (c = 0);
        void 0 === f && (f = 0);
        void 0 === g && (g = 0);
        void 0 === m && (m = 0);
        this.type = k.RECTANGLE;
        this.x = c;
        this.y = f;
        this.width = g;
        this.height = m;
      },
      contains: function (c, f) {
        return t(this, c, f);
      },
      getPoint: function (c, f) {
        return a(this, c, f);
      },
      getPoints: function (c, f, g) {
        return d(this, c, f, g);
      },
      getRandomPoint: function (c) {
        return b(this, c);
      },
      setTo: function (c, f, g, m) {
        this.x = c;
        this.y = f;
        this.width = g;
        this.height = m;
        return this;
      },
      setEmpty: function () {
        return this.setTo(0, 0, 0, 0);
      },
      setPosition: function (c, f) {
        void 0 === f && (f = c);
        this.x = c;
        this.y = f;
        return this;
      },
      setSize: function (c, f) {
        void 0 === f && (f = c);
        this.width = c;
        this.height = f;
        return this;
      },
      isEmpty: function () {
        return 0 >= this.width || 0 >= this.height;
      },
      getLineA: function (c) {
        void 0 === c && (c = new e());
        c.setTo(this.x, this.y, this.right, this.y);
        return c;
      },
      getLineB: function (c) {
        void 0 === c && (c = new e());
        c.setTo(this.right, this.y, this.right, this.bottom);
        return c;
      },
      getLineC: function (c) {
        void 0 === c && (c = new e());
        c.setTo(this.right, this.bottom, this.x, this.bottom);
        return c;
      },
      getLineD: function (c) {
        void 0 === c && (c = new e());
        c.setTo(this.x, this.bottom, this.x, this.y);
        return c;
      },
      left: {
        get: function () {
          return this.x;
        },
        set: function (c) {
          this.width = c >= this.right ? 0 : this.right - c;
          this.x = c;
        },
      },
      right: {
        get: function () {
          return this.x + this.width;
        },
        set: function (c) {
          this.width = c <= this.x ? 0 : c - this.x;
        },
      },
      top: {
        get: function () {
          return this.y;
        },
        set: function (c) {
          this.height = c >= this.bottom ? 0 : this.bottom - c;
          this.y = c;
        },
      },
      bottom: {
        get: function () {
          return this.y + this.height;
        },
        set: function (c) {
          this.height = c <= this.y ? 0 : c - this.y;
        },
      },
      centerX: {
        get: function () {
          return this.x + this.width / 2;
        },
        set: function (c) {
          this.x = c - this.width / 2;
        },
      },
      centerY: {
        get: function () {
          return this.y + this.height / 2;
        },
        set: function (c) {
          this.y = c - this.height / 2;
        },
      },
    });
    l.exports = h;
  },
  function (l, w) {
    l.exports = {
      CIRCLE: 0,
      ELLIPSE: 1,
      LINE: 2,
      POINT: 3,
      POLYGON: 4,
      RECTANGLE: 5,
      TRIANGLE: 6,
    };
  },
  function (l, w, h) {
    var t = h(7),
      a = function () {
        var d,
          k,
          e,
          b = arguments[0] || {},
          c = 1,
          f = arguments.length,
          g = !1;
        "boolean" === typeof b && ((g = b), (b = arguments[1] || {}), (c = 2));
        f === c && ((b = this), --c);
        for (; c < f; c++)
          if (null != (d = arguments[c]))
            for (k in d) {
              var m = b[k];
              var n = d[k];
              b !== n &&
                (g && n && (t(n) || (e = Array.isArray(n)))
                  ? (e
                      ? ((e = !1), (m = m && Array.isArray(m) ? m : []))
                      : (m = m && t(m) ? m : {}),
                    (b[k] = a(g, m, n)))
                  : void 0 !== n && (b[k] = n));
            }
        return b;
      };
    l.exports = a;
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      return Math.atan2(d - t, a - h);
    };
  },
  function (l, w) {
    l.exports = function (h) {
      h %= 2 * Math.PI;
      return 0 <= h ? h : h + 2 * Math.PI;
    };
  },
  function (l, w, h) {
    var t = h(6);
    l.exports = function (a) {
      return t(a, -Math.PI, Math.PI);
    };
  },
  function (l, w, h) {
    var t = h(6);
    l.exports = function (a) {
      return t(a, -180, 180);
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      void 0 === a && (a = 1e-4);
      return Math.abs(h - t) < a;
    };
  },
  function (l, w, h) {
    var t = h(34);
    l.exports = function (a, d) {
      return t(a) / t(d) / t(a - d);
    };
  },
  function (l, w) {
    l.exports = function (h) {
      if (0 === h) return 1;
      for (var t = h; --h; ) t *= h;
      return t;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d, k) {
      t = 0.5 * (d - t);
      k = 0.5 * (k - a);
      var e = h * h;
      return (
        (2 * a - 2 * d + t + k) * h * e +
        (-3 * a + 3 * d - 2 * t - k) * e +
        t * h +
        a
      );
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      return (t - h) * a + h;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      if (h <= t) return 0;
      if (h >= a) return 1;
      h = (h - t) / (a - t);
      return h * h * (3 - 2 * h);
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      h = Math.max(0, Math.min(1, (h - t) / (a - t)));
      return h * h * h * (h * (6 * h - 15) + 10);
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      var k = Math.cos(d);
      d = Math.sin(d);
      var e = h.x - t,
        b = h.y - a;
      h.x = e * k - b * d + t;
      h.y = e * d + b * k + a;
      return h;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 0 < h ? Math.ceil(h) : Math.floor(h);
    };
  },
  function (l, w, h) {
    var t = h(2);
    l.exports = function (a, d, k, e, b, c, f, g) {
      void 0 === g && (g = new t());
      var m = Math.sin(b),
        n = Math.cos(b);
      b = n * c;
      c *= m;
      m = -m * f;
      f *= n;
      n = 1 / (b * f + m * -c);
      g.x = f * n * a + -m * n * d + (e * m - k * f) * n;
      g.y = b * n * d + -c * n * a + (-e * b + k * c) * n;
      return g;
    };
  },
  function (l, w, h) {
    var t = new (h(0))({
      initialize: function (a) {
        this.val = new Float32Array(9);
        a ? this.copy(a) : this.identity();
      },
      clone: function () {
        return new t(this);
      },
      set: function (a) {
        return this.copy(a);
      },
      copy: function (a) {
        var d = this.val;
        a = a.val;
        d[0] = a[0];
        d[1] = a[1];
        d[2] = a[2];
        d[3] = a[3];
        d[4] = a[4];
        d[5] = a[5];
        d[6] = a[6];
        d[7] = a[7];
        d[8] = a[8];
        return this;
      },
      fromMat4: function (a) {
        a = a.val;
        var d = this.val;
        d[0] = a[0];
        d[1] = a[1];
        d[2] = a[2];
        d[3] = a[4];
        d[4] = a[5];
        d[5] = a[6];
        d[6] = a[8];
        d[7] = a[9];
        d[8] = a[10];
        return this;
      },
      fromArray: function (a) {
        var d = this.val;
        d[0] = a[0];
        d[1] = a[1];
        d[2] = a[2];
        d[3] = a[3];
        d[4] = a[4];
        d[5] = a[5];
        d[6] = a[6];
        d[7] = a[7];
        d[8] = a[8];
        return this;
      },
      identity: function () {
        var a = this.val;
        a[0] = 1;
        a[1] = 0;
        a[2] = 0;
        a[3] = 0;
        a[4] = 1;
        a[5] = 0;
        a[6] = 0;
        a[7] = 0;
        a[8] = 1;
        return this;
      },
      transpose: function () {
        var a = this.val,
          d = a[1],
          k = a[2],
          e = a[5];
        a[1] = a[3];
        a[2] = a[6];
        a[3] = d;
        a[5] = a[7];
        a[6] = k;
        a[7] = e;
        return this;
      },
      invert: function () {
        var a = this.val,
          d = a[0],
          k = a[1],
          e = a[2],
          b = a[3],
          c = a[4],
          f = a[5],
          g = a[6],
          m = a[7],
          n = a[8],
          q = n * c - f * m,
          r = -n * b + f * g,
          u = m * b - c * g,
          v = d * q + k * r + e * u;
        if (!v) return null;
        v = 1 / v;
        a[0] = q * v;
        a[1] = (-n * k + e * m) * v;
        a[2] = (f * k - e * c) * v;
        a[3] = r * v;
        a[4] = (n * d - e * g) * v;
        a[5] = (-f * d + e * b) * v;
        a[6] = u * v;
        a[7] = (-m * d + k * g) * v;
        a[8] = (c * d - k * b) * v;
        return this;
      },
      adjoint: function () {
        var a = this.val,
          d = a[0],
          k = a[1],
          e = a[2],
          b = a[3],
          c = a[4],
          f = a[5],
          g = a[6],
          m = a[7],
          n = a[8];
        a[0] = c * n - f * m;
        a[1] = e * m - k * n;
        a[2] = k * f - e * c;
        a[3] = f * g - b * n;
        a[4] = d * n - e * g;
        a[5] = e * b - d * f;
        a[6] = b * m - c * g;
        a[7] = k * g - d * m;
        a[8] = d * c - k * b;
        return this;
      },
      determinant: function () {
        var a = this.val,
          d = a[3],
          k = a[4],
          e = a[5],
          b = a[6],
          c = a[7],
          f = a[8];
        return (
          a[0] * (f * k - e * c) +
          a[1] * (-f * d + e * b) +
          a[2] * (c * d - k * b)
        );
      },
      multiply: function (a) {
        var d = this.val,
          k = d[0],
          e = d[1],
          b = d[2],
          c = d[3],
          f = d[4],
          g = d[5],
          m = d[6],
          n = d[7],
          q = d[8],
          r = a.val;
        a = r[0];
        var u = r[1],
          v = r[2],
          x = r[3],
          y = r[4],
          z = r[5],
          A = r[6],
          B = r[7];
        r = r[8];
        d[0] = a * k + u * c + v * m;
        d[1] = a * e + u * f + v * n;
        d[2] = a * b + u * g + v * q;
        d[3] = x * k + y * c + z * m;
        d[4] = x * e + y * f + z * n;
        d[5] = x * b + y * g + z * q;
        d[6] = A * k + B * c + r * m;
        d[7] = A * e + B * f + r * n;
        d[8] = A * b + B * g + r * q;
        return this;
      },
      translate: function (a) {
        var d = this.val,
          k = a.x;
        a = a.y;
        d[6] = k * d[0] + a * d[3] + d[6];
        d[7] = k * d[1] + a * d[4] + d[7];
        d[8] = k * d[2] + a * d[5] + d[8];
        return this;
      },
      rotate: function (a) {
        var d = this.val,
          k = d[0],
          e = d[1],
          b = d[2],
          c = d[3],
          f = d[4],
          g = d[5],
          m = Math.sin(a);
        a = Math.cos(a);
        d[0] = a * k + m * c;
        d[1] = a * e + m * f;
        d[2] = a * b + m * g;
        d[3] = a * c - m * k;
        d[4] = a * f - m * e;
        d[5] = a * g - m * b;
        return this;
      },
      scale: function (a) {
        var d = this.val,
          k = a.x;
        a = a.y;
        d[0] *= k;
        d[1] *= k;
        d[2] *= k;
        d[3] *= a;
        d[4] *= a;
        d[5] *= a;
        return this;
      },
      fromQuat: function (a) {
        var d = a.x,
          k = a.y,
          e = a.z,
          b = a.w,
          c = d + d,
          f = k + k,
          g = e + e;
        a = d * c;
        var m = d * f;
        d *= g;
        var n = k * f;
        k *= g;
        e *= g;
        c *= b;
        f *= b;
        b *= g;
        g = this.val;
        g[0] = 1 - (n + e);
        g[3] = m + b;
        g[6] = d - f;
        g[1] = m - b;
        g[4] = 1 - (a + e);
        g[7] = k + c;
        g[2] = d + f;
        g[5] = k - c;
        g[8] = 1 - (a + n);
        return this;
      },
      normalFromMat4: function (a) {
        var d = a.val;
        a = this.val;
        var k = d[0],
          e = d[1],
          b = d[2],
          c = d[3],
          f = d[4],
          g = d[5],
          m = d[6],
          n = d[7],
          q = d[8],
          r = d[9],
          u = d[10],
          v = d[11],
          x = d[12],
          y = d[13],
          z = d[14];
        d = d[15];
        var A = k * g - e * f,
          B = k * m - b * f,
          D = k * n - c * f,
          E = e * m - b * g,
          C = e * n - c * g,
          F = b * n - c * m,
          G = q * y - r * x,
          H = q * z - u * x;
        q = q * d - v * x;
        var K = r * z - u * y;
        r = r * d - v * y;
        u = u * d - v * z;
        v = A * u - B * r + D * K + E * q - C * H + F * G;
        if (!v) return null;
        v = 1 / v;
        a[0] = (g * u - m * r + n * K) * v;
        a[1] = (m * q - f * u - n * H) * v;
        a[2] = (f * r - g * q + n * G) * v;
        a[3] = (b * r - e * u - c * K) * v;
        a[4] = (k * u - b * q + c * H) * v;
        a[5] = (e * q - k * r - c * G) * v;
        a[6] = (y * F - z * C + d * E) * v;
        a[7] = (z * D - x * F - d * B) * v;
        a[8] = (x * C - y * D + d * A) * v;
        return this;
      },
    });
    l.exports = t;
  },
  function (l, w, h) {
    w = h(0);
    var t = h(42),
      a = h(1);
    h = h(14);
    var d = new Int8Array([1, 2, 0]),
      k = new Float32Array([0, 0, 0]),
      e = new h(1, 0, 0),
      b = new h(0, 1, 0),
      c = new h(),
      f = new t();
    h = new w({
      initialize: function (g, m, n, q) {
        this.onChangeCallback = a;
        this.set(g, m, n, q);
      },
      x: {
        get: function () {
          return this._x;
        },
        set: function (g) {
          this._x = g;
          this.onChangeCallback(this);
        },
      },
      y: {
        get: function () {
          return this._y;
        },
        set: function (g) {
          this._y = g;
          this.onChangeCallback(this);
        },
      },
      z: {
        get: function () {
          return this._z;
        },
        set: function (g) {
          this._z = g;
          this.onChangeCallback(this);
        },
      },
      w: {
        get: function () {
          return this._w;
        },
        set: function (g) {
          this._w = g;
          this.onChangeCallback(this);
        },
      },
      copy: function (g) {
        return this.set(g);
      },
      set: function (g, m, n, q, r) {
        void 0 === r && (r = !0);
        "object" === typeof g
          ? ((this._x = g.x || 0),
            (this._y = g.y || 0),
            (this._z = g.z || 0),
            (this._w = g.w || 0))
          : ((this._x = g || 0),
            (this._y = m || 0),
            (this._z = n || 0),
            (this._w = q || 0));
        if (r) this.onChangeCallback(this);
        return this;
      },
      add: function (g) {
        this._x += g.x;
        this._y += g.y;
        this._z += g.z;
        this._w += g.w;
        this.onChangeCallback(this);
        return this;
      },
      subtract: function (g) {
        this._x -= g.x;
        this._y -= g.y;
        this._z -= g.z;
        this._w -= g.w;
        this.onChangeCallback(this);
        return this;
      },
      scale: function (g) {
        this._x *= g;
        this._y *= g;
        this._z *= g;
        this._w *= g;
        this.onChangeCallback(this);
        return this;
      },
      length: function () {
        var g = this.x,
          m = this.y,
          n = this.z,
          q = this.w;
        return Math.sqrt(g * g + m * m + n * n + q * q);
      },
      lengthSq: function () {
        var g = this.x,
          m = this.y,
          n = this.z,
          q = this.w;
        return g * g + m * m + n * n + q * q;
      },
      normalize: function () {
        var g = this.x,
          m = this.y,
          n = this.z,
          q = this.w,
          r = g * g + m * m + n * n + q * q;
        0 < r &&
          ((r = 1 / Math.sqrt(r)),
          (this._x = g * r),
          (this._y = m * r),
          (this._z = n * r),
          (this._w = q * r));
        this.onChangeCallback(this);
        return this;
      },
      dot: function (g) {
        return this.x * g.x + this.y * g.y + this.z * g.z + this.w * g.w;
      },
      lerp: function (g, m) {
        void 0 === m && (m = 0);
        var n = this.x,
          q = this.y,
          r = this.z,
          u = this.w;
        return this.set(
          n + m * (g.x - n),
          q + m * (g.y - q),
          r + m * (g.z - r),
          u + m * (g.w - u)
        );
      },
      rotationTo: function (g, m) {
        var n = g.x * m.x + g.y * m.y + g.z * m.z;
        if (-0.999999 > n)
          return (
            1e-6 > c.copy(e).cross(g).length() && c.copy(b).cross(g),
            c.normalize(),
            this.setAxisAngle(c, Math.PI)
          );
        if (0.999999 < n) return this.set(0, 0, 0, 1);
        c.copy(g).cross(m);
        this._x = c.x;
        this._y = c.y;
        this._z = c.z;
        this._w = 1 + n;
        return this.normalize();
      },
      setAxes: function (g, m, n) {
        var q = f.val;
        q[0] = m.x;
        q[3] = m.y;
        q[6] = m.z;
        q[1] = n.x;
        q[4] = n.y;
        q[7] = n.z;
        q[2] = -g.x;
        q[5] = -g.y;
        q[8] = -g.z;
        return this.fromMat3(f).normalize();
      },
      identity: function () {
        return this.set(0, 0, 0, 1);
      },
      setAxisAngle: function (g, m) {
        m *= 0.5;
        var n = Math.sin(m);
        return this.set(n * g.x, n * g.y, n * g.z, Math.cos(m));
      },
      multiply: function (g) {
        var m = this.x,
          n = this.y,
          q = this.z,
          r = this.w,
          u = g.x,
          v = g.y,
          x = g.z;
        g = g.w;
        return this.set(
          m * g + r * u + n * x - q * v,
          n * g + r * v + q * u - m * x,
          q * g + r * x + m * v - n * u,
          r * g - m * u - n * v - q * x
        );
      },
      slerp: function (g, m) {
        var n = this.x,
          q = this.y,
          r = this.z,
          u = this.w,
          v = g.x,
          x = g.y,
          y = g.z;
        g = g.w;
        var z = n * v + q * x + r * y + u * g;
        0 > z && ((z = -z), (v = -v), (x = -x), (y = -y), (g = -g));
        var A = 1 - m,
          B = m;
        1e-6 < 1 - z &&
          ((z = Math.acos(z)),
          (B = Math.sin(z)),
          (A = Math.sin((1 - m) * z) / B),
          (B = Math.sin(m * z) / B));
        return this.set(
          A * n + B * v,
          A * q + B * x,
          A * r + B * y,
          A * u + B * g
        );
      },
      invert: function () {
        var g = this.x,
          m = this.y,
          n = this.z,
          q = this.w,
          r = g * g + m * m + n * n + q * q;
        r = r ? 1 / r : 0;
        return this.set(-g * r, -m * r, -n * r, q * r);
      },
      conjugate: function () {
        this._x = -this.x;
        this._y = -this.y;
        this._z = -this.z;
        this.onChangeCallback(this);
        return this;
      },
      rotateX: function (g) {
        g *= 0.5;
        var m = this.x,
          n = this.y,
          q = this.z,
          r = this.w,
          u = Math.sin(g);
        g = Math.cos(g);
        return this.set(
          m * g + r * u,
          n * g + q * u,
          q * g - n * u,
          r * g - m * u
        );
      },
      rotateY: function (g) {
        g *= 0.5;
        var m = this.x,
          n = this.y,
          q = this.z,
          r = this.w,
          u = Math.sin(g);
        g = Math.cos(g);
        return this.set(
          m * g - q * u,
          n * g + r * u,
          q * g + m * u,
          r * g - n * u
        );
      },
      rotateZ: function (g) {
        g *= 0.5;
        var m = this.x,
          n = this.y,
          q = this.z,
          r = this.w,
          u = Math.sin(g);
        g = Math.cos(g);
        return this.set(
          m * g + n * u,
          n * g - m * u,
          q * g + r * u,
          r * g - q * u
        );
      },
      calculateW: function () {
        var g = this.x,
          m = this.y,
          n = this.z;
        this.w = -Math.sqrt(1 - g * g - m * m - n * n);
        return this;
      },
      setFromEuler: function (g, m) {
        var n = g.x / 2,
          q = g.y / 2,
          r = g.z / 2,
          u = Math.cos(n),
          v = Math.cos(q),
          x = Math.cos(r);
        n = Math.sin(n);
        q = Math.sin(q);
        r = Math.sin(r);
        switch (g.order) {
          case "XYZ":
            this.set(
              n * v * x + u * q * r,
              u * q * x - n * v * r,
              u * v * r + n * q * x,
              u * v * x - n * q * r,
              m
            );
            break;
          case "YXZ":
            this.set(
              n * v * x + u * q * r,
              u * q * x - n * v * r,
              u * v * r - n * q * x,
              u * v * x + n * q * r,
              m
            );
            break;
          case "ZXY":
            this.set(
              n * v * x - u * q * r,
              u * q * x + n * v * r,
              u * v * r + n * q * x,
              u * v * x - n * q * r,
              m
            );
            break;
          case "ZYX":
            this.set(
              n * v * x - u * q * r,
              u * q * x + n * v * r,
              u * v * r - n * q * x,
              u * v * x + n * q * r,
              m
            );
            break;
          case "YZX":
            this.set(
              n * v * x + u * q * r,
              u * q * x + n * v * r,
              u * v * r - n * q * x,
              u * v * x - n * q * r,
              m
            );
            break;
          case "XZY":
            this.set(
              n * v * x - u * q * r,
              u * q * x - n * v * r,
              u * v * r + n * q * x,
              u * v * x + n * q * r,
              m
            );
        }
        return this;
      },
      setFromRotationMatrix: function (g) {
        var m = g.val,
          n = m[0];
        g = m[4];
        var q = m[8],
          r = m[1],
          u = m[5],
          v = m[9],
          x = m[2],
          y = m[6];
        m = m[10];
        var z = n + u + m;
        0 < z
          ? ((n = 0.5 / Math.sqrt(z + 1)),
            this.set((y - v) * n, (q - x) * n, (r - g) * n, 0.25 / n))
          : n > u && n > m
          ? ((n = 2 * Math.sqrt(1 + n - u - m)),
            this.set(0.25 * n, (g + r) / n, (q + x) / n, (y - v) / n))
          : u > m
          ? ((n = 2 * Math.sqrt(1 + u - n - m)),
            this.set((g + r) / n, 0.25 * n, (v + y) / n, (q - x) / n))
          : ((n = 2 * Math.sqrt(1 + m - n - u)),
            this.set((q + x) / n, (v + y) / n, 0.25 * n, (r - g) / n));
        return this;
      },
      fromMat3: function (g) {
        g = g.val;
        var m = g[0] + g[4] + g[8];
        if (0 < m)
          (m = Math.sqrt(m + 1)),
            (this.w = 0.5 * m),
            (m = 0.5 / m),
            (this._x = (g[7] - g[5]) * m),
            (this._y = (g[2] - g[6]) * m),
            (this._z = (g[3] - g[1]) * m);
        else {
          var n = 0;
          g[4] > g[0] && (n = 1);
          g[8] > g[3 * n + n] && (n = 2);
          var q = d[n],
            r = d[q];
          m = Math.sqrt(g[3 * n + n] - g[3 * q + q] - g[3 * r + r] + 1);
          k[n] = 0.5 * m;
          m = 0.5 / m;
          k[q] = (g[3 * q + n] + g[3 * n + q]) * m;
          k[r] = (g[3 * r + n] + g[3 * n + r]) * m;
          this._x = k[0];
          this._y = k[1];
          this._z = k[2];
          this._w = (g[3 * r + q] - g[3 * q + r]) * m;
        }
        this.onChangeCallback(this);
        return this;
      },
    });
    l.exports = h;
  },
  function (l, w, h) {
    l.exports = {
      ADDED_TO_SCENE: h(180),
      BOOT: h(181),
      CREATE: h(182),
      DESTROY: h(183),
      PAUSE: h(184),
      POST_UPDATE: h(185),
      PRE_RENDER: h(186),
      PRE_UPDATE: h(187),
      READY: h(188),
      REMOVED_FROM_SCENE: h(189),
      RENDER: h(190),
      RESUME: h(191),
      SHUTDOWN: h(192),
      SLEEP: h(193),
      START: h(194),
      TRANSITION_COMPLETE: h(195),
      TRANSITION_INIT: h(196),
      TRANSITION_OUT: h(197),
      TRANSITION_START: h(198),
      TRANSITION_WAKE: h(199),
      UPDATE: h(200),
      WAKE: h(201),
    };
  },
  function (l, w, h) {
    var t = h(27),
      a = h(46);
    l.exports = function (d, k) {
      d = void 0 === d ? a() : t({}, d);
      if (k) for (var e in k) void 0 !== k[e] && (d[e] = k[e]);
      return d;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d, k, e) {
      void 0 === h && (h = "");
      void 0 === t && (t = !0);
      void 0 === a && (a = "");
      void 0 === d && (d = "");
      void 0 === k && (k = 0);
      void 0 === e && (e = !1);
      return {
        responseType: h,
        async: t,
        user: a,
        password: d,
        timeout: k,
        headers: void 0,
        header: void 0,
        headerValue: void 0,
        requestedWith: !1,
        overrideMimeType: void 0,
        withCredentials: e,
      };
    };
  },
  function (l, w) {
    l.exports = {
      width: 0,
      height: 0,
      displayWidth: {
        get: function () {
          return this.scaleX * this.width;
        },
        set: function (h) {
          this.scaleX = h / this.width;
        },
      },
      displayHeight: {
        get: function () {
          return this.scaleY * this.height;
        },
        set: function (h) {
          this.scaleY = h / this.height;
        },
      },
      setSize: function (h, t) {
        this.width = h;
        this.height = t;
        return this;
      },
      setDisplaySize: function (h, t) {
        this.displayWidth = h;
        this.displayHeight = t;
        return this;
      },
    };
  },
  function (l, w) {
    l.exports = {
      _depth: 0,
      depth: {
        get: function () {
          return this._depth;
        },
        set: function (h) {
          this.displayList && this.displayList.queueDepthSort();
          this._depth = h;
        },
      },
      setDepth: function (h) {
        void 0 === h && (h = 0);
        this.depth = h;
        return this;
      },
    };
  },
  function (l, w) {
    l.exports = {
      flipX: !1,
      flipY: !1,
      toggleFlipX: function () {
        this.flipX = !this.flipX;
        return this;
      },
      toggleFlipY: function () {
        this.flipY = !this.flipY;
        return this;
      },
      setFlipX: function (h) {
        this.flipX = h;
        return this;
      },
      setFlipY: function (h) {
        this.flipY = h;
        return this;
      },
      setFlip: function (h, t) {
        this.flipX = h;
        this.flipY = t;
        return this;
      },
      resetFlip: function () {
        this.flipY = this.flipX = !1;
        return this;
      },
    };
  },
  function (l, w) {
    l.exports = {
      scrollFactorX: 1,
      scrollFactorY: 1,
      setScrollFactor: function (h, t) {
        void 0 === t && (t = h);
        this.scrollFactorX = h;
        this.scrollFactorY = t;
        return this;
      },
    };
  },
  function (l, w, h) {
    var t = h(4),
      a = h(23),
      d = h(41),
      k = h(30),
      e = h(31),
      b = h(2);
    l.exports = {
      _scaleX: 1,
      _scaleY: 1,
      _rotation: 0,
      x: 0,
      y: 0,
      z: 0,
      w: 0,
      scale: {
        get: function () {
          return (this._scaleX + this._scaleY) / 2;
        },
        set: function (c) {
          this._scaleY = this._scaleX = c;
          this.renderFlags =
            0 === c ? this.renderFlags & -5 : this.renderFlags | 4;
        },
      },
      scaleX: {
        get: function () {
          return this._scaleX;
        },
        set: function (c) {
          this._scaleX = c;
          this.renderFlags =
            0 === c ? this.renderFlags & -5 : this.renderFlags | 4;
        },
      },
      scaleY: {
        get: function () {
          return this._scaleY;
        },
        set: function (c) {
          this._scaleY = c;
          this.renderFlags =
            0 === c ? this.renderFlags & -5 : this.renderFlags | 4;
        },
      },
      angle: {
        get: function () {
          return e(this._rotation * t.RAD_TO_DEG);
        },
        set: function (c) {
          this.rotation = e(c) * t.DEG_TO_RAD;
        },
      },
      rotation: {
        get: function () {
          return this._rotation;
        },
        set: function (c) {
          this._rotation = k(c);
        },
      },
      setPosition: function (c, f, g, m) {
        void 0 === c && (c = 0);
        void 0 === f && (f = c);
        void 0 === g && (g = 0);
        void 0 === m && (m = 0);
        this.x = c;
        this.y = f;
        this.z = g;
        this.w = m;
        return this;
      },
      copyPosition: function (c) {
        void 0 !== c.x && (this.x = c.x);
        void 0 !== c.y && (this.y = c.y);
        void 0 !== c.z && (this.z = c.z);
        void 0 !== c.w && (this.w = c.w);
        return this;
      },
      setRandomPosition: function (c, f, g, m) {
        void 0 === c && (c = 0);
        void 0 === f && (f = 0);
        void 0 === g && (g = this.scene.sys.scale.width);
        void 0 === m && (m = this.scene.sys.scale.height);
        this.x = c + Math.random() * g;
        this.y = f + Math.random() * m;
        return this;
      },
      setRotation: function (c) {
        void 0 === c && (c = 0);
        this.rotation = c;
        return this;
      },
      setAngle: function (c) {
        void 0 === c && (c = 0);
        this.angle = c;
        return this;
      },
      setScale: function (c, f) {
        void 0 === c && (c = 1);
        void 0 === f && (f = c);
        this.scaleX = c;
        this.scaleY = f;
        return this;
      },
      setX: function (c) {
        void 0 === c && (c = 0);
        this.x = c;
        return this;
      },
      setY: function (c) {
        void 0 === c && (c = 0);
        this.y = c;
        return this;
      },
      setZ: function (c) {
        void 0 === c && (c = 0);
        this.z = c;
        return this;
      },
      setW: function (c) {
        void 0 === c && (c = 0);
        this.w = c;
        return this;
      },
      getLocalTransformMatrix: function (c) {
        void 0 === c && (c = new a());
        return c.applyITRS(
          this.x,
          this.y,
          this._rotation,
          this._scaleX,
          this._scaleY
        );
      },
      getWorldTransformMatrix: function (c, f) {
        void 0 === c && (c = new a());
        void 0 === f && (f = new a());
        var g = this.parentContainer;
        if (!g) return this.getLocalTransformMatrix(c);
        for (
          c.applyITRS(
            this.x,
            this.y,
            this._rotation,
            this._scaleX,
            this._scaleY
          );
          g;

        )
          f.applyITRS(g.x, g.y, g._rotation, g._scaleX, g._scaleY),
            f.multiply(c, c),
            (g = g.parentContainer);
        return c;
      },
      getLocalPoint: function (c, f, g, m) {
        g || (g = new b());
        m || (m = this.scene.sys.cameras.main);
        var n = m.scrollX;
        m = m.scrollY;
        c = c + n * this.scrollFactorX - n;
        f = f + m * this.scrollFactorY - m;
        this.parentContainer
          ? this.getWorldTransformMatrix().applyInverse(c, f, g)
          : d(c, f, this.x, this.y, this.rotation, this.scaleX, this.scaleY, g);
        this._originComponent &&
          ((g.x += this._displayOriginX), (g.y += this._displayOriginY));
        return g;
      },
      getParentRotation: function () {
        for (var c = 0, f = this.parentContainer; f; )
          (c += f.rotation), (f = f.parentContainer);
        return c;
      },
    };
  },
  function (l, w) {
    l.exports = {
      _visible: !0,
      visible: {
        get: function () {
          return this._visible;
        },
        set: function (h) {
          h
            ? ((this._visible = !0), (this.renderFlags |= 1))
            : ((this._visible = !1), (this.renderFlags &= -2));
        },
      },
      setVisible: function (h) {
        this.visible = h;
        return this;
      },
    };
  },
  function (l, w, h) {
    w = h(0);
    var t = h(54),
      a = h(222),
      d = h(229),
      k = h(55),
      e = h(44),
      b = new w({
        Extends: d,
        initialize: function (c, f) {
          d.call(this);
          this.scene = c;
          this.displayList = null;
          this.type = f;
          this.state = 0;
          this.parentContainer = null;
          this.name = "";
          this.active = !0;
          this.tabIndex = -1;
          this.data = null;
          this.renderFlags = 15;
          this.cameraFilter = 0;
          this.body = this.input = null;
          this.ignoreDestroy = !1;
          this.on(k.ADDED_TO_SCENE, this.addedToScene, this);
          this.on(k.REMOVED_FROM_SCENE, this.removedFromScene, this);
          c.sys.queueDepthSort();
        },
        setActive: function (c) {
          this.active = c;
          return this;
        },
        setName: function (c) {
          this.name = c;
          return this;
        },
        setState: function (c) {
          this.state = c;
          return this;
        },
        setDataEnabled: function () {
          this.data || (this.data = new a(this));
          return this;
        },
        setData: function (c, f) {
          this.data || (this.data = new a(this));
          this.data.set(c, f);
          return this;
        },
        incData: function (c, f) {
          this.data || (this.data = new a(this));
          this.data.inc(c, f);
          return this;
        },
        toggleData: function (c) {
          this.data || (this.data = new a(this));
          this.data.toggle(c);
          return this;
        },
        getData: function (c) {
          this.data || (this.data = new a(this));
          return this.data.get(c);
        },
        setInteractive: function (c, f, g) {
          this.scene.sys.input.enable(this, c, f, g);
          return this;
        },
        disableInteractive: function () {
          this.input && (this.input.enabled = !1);
          return this;
        },
        removeInteractive: function () {
          this.scene.sys.input.clear(this);
          this.input = void 0;
          return this;
        },
        addedToScene: function () {},
        removedFromScene: function () {},
        update: function () {},
        toJSON: function () {
          return t(this);
        },
        willRender: function (c) {
          return !(
            b.RENDER_MASK !== this.renderFlags ||
            (0 !== this.cameraFilter && this.cameraFilter & c.id)
          );
        },
        getIndexList: function () {
          for (var c = this, f = this.parentContainer, g = []; f; )
            if ((g.unshift(f.getIndex(c)), (c = f), f.parentContainer))
              f = f.parentContainer;
            else break;
          this.displayList
            ? g.unshift(this.displayList.getIndex(c))
            : g.unshift(this.scene.sys.displayList.getIndex(c));
          return g;
        },
        addToDisplayList: function (c) {
          void 0 === c && (c = this.scene.sys.displayList);
          this.displayList &&
            this.displayList !== c &&
            this.removeFromDisplayList();
          c.exists(this) ||
            ((this.displayList = c),
            c.add(this, !0),
            c.queueDepthSort(),
            this.emit(k.ADDED_TO_SCENE, this, this.scene),
            c.events.emit(e.ADDED_TO_SCENE, this, this.scene));
          return this;
        },
        addToUpdateList: function () {
          this.scene && this.preUpdate && this.scene.sys.updateList.add(this);
          return this;
        },
        removeFromDisplayList: function () {
          var c = this.displayList || this.scene.sys.displayList;
          c.exists(this) &&
            (c.remove(this, !0),
            c.queueDepthSort(),
            (this.displayList = null),
            this.emit(k.REMOVED_FROM_SCENE, this, this.scene),
            c.events.emit(e.REMOVED_FROM_SCENE, this, this.scene));
          return this;
        },
        removeFromUpdateList: function () {
          this.scene &&
            this.preUpdate &&
            this.scene.sys.updateList.remove(this);
          return this;
        },
        destroy: function () {
          this.scene &&
            !this.ignoreDestroy &&
            (this.preDestroy && this.preDestroy.call(this),
            this.emit(k.DESTROY, this),
            this.removeAllListeners(),
            this.postPipelines && this.resetPostPipeline(!0),
            this.removeFromDisplayList(),
            this.removeFromUpdateList(),
            this.input &&
              (this.scene.sys.input.clear(this), (this.input = void 0)),
            this.data && (this.data.destroy(), (this.data = void 0)),
            this.body && (this.body.destroy(), (this.body = void 0)),
            (this.visible = this.active = !1),
            (this.parentContainer = this.scene = void 0));
        },
      });
    b.RENDER_MASK = 15;
    l.exports = b;
  },
  function (l, w) {
    l.exports = function (h) {
      var t = {
        name: h.name,
        type: h.type,
        x: h.x,
        y: h.y,
        depth: h.depth,
        scale: {
          x: h.scaleX,
          y: h.scaleY,
        },
        origin: {
          x: h.originX,
          y: h.originY,
        },
        flipX: h.flipX,
        flipY: h.flipY,
        rotation: h.rotation,
        alpha: h.alpha,
        visible: h.visible,
        blendMode: h.blendMode,
        textureKey: "",
        frameKey: "",
        data: {},
      };
      h.texture &&
        ((t.textureKey = h.texture.key), (t.frameKey = h.frame.name));
      return t;
    };
  },
  function (l, w, h) {
    l.exports = {
      ADDED_TO_SCENE: h(230),
      DESTROY: h(231),
      REMOVED_FROM_SCENE: h(232),
      VIDEO_COMPLETE: h(233),
      VIDEO_CREATED: h(234),
      VIDEO_ERROR: h(235),
      VIDEO_LOOP: h(236),
      VIDEO_PLAY: h(237),
      VIDEO_SEEKED: h(238),
      VIDEO_SEEKING: h(239),
      VIDEO_STOP: h(240),
      VIDEO_TIMEOUT: h(241),
      VIDEO_UNLOCKED: h(242),
    };
  },
  function (l, w, h) {
    w = h(23);
    var t = new w(),
      a = new w(),
      d = new w(),
      k = {
        camera: t,
        sprite: a,
        calc: d,
      };
    l.exports = function (e, b, c) {
      a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY);
      t.copyFrom(b.matrix);
      c
        ? (t.multiplyWithOffset(
            c,
            -b.scrollX * e.scrollFactorX,
            -b.scrollY * e.scrollFactorY
          ),
          (a.e = e.x),
          (a.f = e.y))
        : ((a.e -= b.scrollX * e.scrollFactorX),
          (a.f -= b.scrollY * e.scrollFactorY));
      t.multiply(a, d);
      return k;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      for (var t = h.length, a = h[0].length, d = Array(a), k = 0; k < a; k++) {
        d[k] = Array(t);
        for (var e = t - 1; -1 < e; e--) d[k][e] = h[e][k];
      }
      return d;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      void 0 === t && (t = 1);
      for (var a = null, d = 0; d < t; d++) (a = h.shift()), h.push(a);
      return a;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      void 0 === t && (t = 1);
      for (var a = null, d = 0; d < t; d++) (a = h.pop()), h.unshift(a);
      return a;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      for (var t = h.length - 1; 0 < t; t--) {
        var a = Math.floor(Math.random() * (t + 1)),
          d = h[t];
        h[t] = h[a];
        h[a] = d;
      }
      return h;
    };
  },
  function (l, w, h) {
    var t = h(62),
      a = h(13);
    l.exports = function (d, k, e) {
      void 0 === e && (e = new a());
      if (0 >= k || 1 <= k) return (e.x = d.x), (e.y = d.y), e;
      var b = t(d) * k;
      0.5 < k
        ? ((b -= d.width + d.height),
          b <= d.width
            ? ((e.x = d.right - b), (e.y = d.bottom))
            : ((e.x = d.x), (e.y = d.bottom - (b - d.width))))
        : b <= d.width
        ? ((e.x = d.x + b), (e.y = d.y))
        : ((e.x = d.right), (e.y = d.y + (b - d.width)));
      return e;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 2 * (h.width + h.height);
    };
  },
  function (l, w, h) {
    var t = h(64);
    w = h(0);
    var a = h(10),
      d = h(177),
      k = h(178),
      e = h(202),
      b = h(203),
      c = h(221),
      f = h(254),
      g = h(1),
      m;
    h = new w({
      Extends: k,
      initialize: function (n, q, r) {
        k.call(this, n, q, r);
        var u = q.game;
        this.isWebGL = 2 === u.config.renderType;
        this.cache = u.cache.addCustom("spine");
        this.spineTextures = u.cache.addCustom("spineTextures");
        this.json = u.cache.json;
        this.textures = u.textures;
        this.drawDebug = !1;
        this.gl;
        this.renderer;
        this.sceneRenderer;
        this.skeletonRenderer;
        this.skeletonDebugRenderer;
        this.plugin = e;
        this.temp1;
        this.temp2;
        this.isWebGL
          ? ((this.runtime = e.webgl),
            (this.renderer = u.renderer),
            (this.gl = u.renderer.gl),
            (this.getAtlas = this.getAtlasWebGL))
          : ((this.runtime = e.canvas),
            (this.renderer = u.renderer),
            (this.getAtlas = this.getAtlasCanvas));
        this.renderer ||
          (this.renderer = {
            width: u.scale.width,
            height: u.scale.height,
            preRender: g,
            postRender: g,
            render: g,
            destroy: g,
          });
        q.registerFileType("spine", this.spineFileCallback, n);
        q.registerGameObject(
          "spine",
          function (v, x, y, z, A) {
            v = new c(this.scene, this.scene.sys[r], v, x, y, z, A);
            this.displayList.add(v);
            this.updateList.add(v);
            return v;
          },
          function (v, x) {
            void 0 === v && (v = {});
            var y = a(v, "key", null),
              z = a(v, "animationName", null),
              A = a(v, "loop", !1);
            y = new c(this.scene, this.scene.sys[r], 0, 0, y, z, A);
            void 0 !== x && (v.add = x);
            t(this.scene, y, v);
            (x = a(v, "skinName", !1)) && y.setSkinByName(x);
            x = a(v, "slotName", !1);
            v = a(v, "attachmentName", null);
            x && y.setAttachment(x, v);
            return y.refresh();
          }
        );
        q.registerGameObject(
          "spineContainer",
          function (v, x, y) {
            v = new f(this.scene, this.scene.sys[r], v, x, y);
            this.displayList.add(v);
            return v;
          },
          function (v, x) {
            void 0 === v && (v = {});
            var y = a(v, "x", 0),
              z = a(v, "y", 0),
              A = a(v, "children", null);
            y = new f(this.scene, this.scene.sys[r], y, z, A);
            void 0 !== x && (v.add = x);
            t(this.scene, y, v);
            return y;
          }
        );
      },
      boot: function () {
        this.isWebGL
          ? (this.bootWebGL(),
            this.onResize(),
            this.game.scale.on(d, this.onResize, this))
          : this.bootCanvas();
        var n = this.systems.events;
        n.once("shutdown", this.shutdown, this);
        n.once("destroy", this.destroy, this);
        this.game.events.once("destroy", this.gameDestroy, this);
      },
      bootCanvas: function () {
        this.skeletonRenderer = new e.canvas.SkeletonRenderer(
          this.scene.sys.context
        );
      },
      bootWebGL: function () {
        var n = function (q, r) {
          if (q !== this.srcBlend || r !== this.dstBlend) {
            var u = this.context.gl;
            this.srcBlend = q;
            this.dstBlend = r;
            this.isDrawing &&
              (this.flush(), u.blendFunc(this.srcBlend, this.dstBlend));
          }
        };
        m ||
          ((m = new e.webgl.SceneRenderer(this.renderer.canvas, this.gl, !0)),
          (m.batcher.setBlendMode = n),
          (m.shapes.setBlendMode = n));
        this.sceneRenderer = m;
        this.skeletonRenderer = m.skeletonRenderer;
        this.skeletonDebugRenderer = m.skeletonDebugRenderer;
        this.temp1 = new e.webgl.Vector3(0, 0, 0);
        this.temp2 = new e.webgl.Vector3(0, 0, 0);
      },
      getAtlasCanvas: function (n) {
        var q = this.cache.get(n);
        if (q) {
          var r = this.spineTextures;
          if (r.has(n)) n = r.get(n);
          else {
            var u = this.textures;
            n = new e.TextureAtlas(q.data, function (v) {
              return new e.canvas.CanvasTexture(
                u.get(q.prefix + v).getSourceImage()
              );
            });
          }
          return n;
        }
        console.warn("No atlas data for: " + n);
      },
      getAtlasWebGL: function (n) {
        var q = this.cache.get(n);
        if (q) {
          var r = this.spineTextures;
          if (r.has(n)) n = r.get(n);
          else {
            var u = this.textures,
              v = this.sceneRenderer.context.gl;
            v.pixelStorei(v.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1);
            n = new e.TextureAtlas(q.data, function (x) {
              return new e.webgl.GLTexture(
                v,
                u.get(q.prefix + x).getSourceImage(),
                !1
              );
            });
          }
          return n;
        }
        console.warn("No atlas data for: " + n);
      },
      spineFileCallback: function (n, q, r, u, v, x) {
        if (Array.isArray(n))
          for (r = 0; r < n.length; r++)
            (q = new b(this, n[r])), this.addFile(q.files);
        else (q = new b(this, n, q, r, u, v, x)), this.addFile(q.files);
        return this;
      },
      worldToLocal: function (n, q, r, u) {
        var v = this.temp1,
          x = this.temp2,
          y = this.sceneRenderer.camera;
        v.set(n + r.x, q - r.y, 0);
        y.screenToWorld(v, y.viewportWidth, y.viewportHeight);
        return u && null !== u.parent
          ? (u.parent.worldToLocal(x.set(v.x - r.x, v.y - r.y, 0)),
            new e.Vector2(x.x, x.y))
          : u
          ? new e.Vector2(v.x - r.x, v.y - r.y)
          : new e.Vector2(v.x, v.y);
      },
      getVector2: function (n, q) {
        return new e.Vector2(n, q);
      },
      getVector3: function (n, q, r) {
        return new e.webgl.Vector3(n, q, r);
      },
      setDebugBones: function (n) {
        void 0 === n && (n = !0);
        this.skeletonDebugRenderer.drawBones = n;
        return this;
      },
      setDebugRegionAttachments: function (n) {
        void 0 === n && (n = !0);
        this.skeletonDebugRenderer.drawRegionAttachments = n;
        return this;
      },
      setDebugBoundingBoxes: function (n) {
        void 0 === n && (n = !0);
        this.skeletonDebugRenderer.drawBoundingBoxes = n;
        return this;
      },
      setDebugMeshHull: function (n) {
        void 0 === n && (n = !0);
        this.skeletonDebugRenderer.drawMeshHull = n;
        return this;
      },
      setDebugMeshTriangles: function (n) {
        void 0 === n && (n = !0);
        this.skeletonDebugRenderer.drawMeshTriangles = n;
        return this;
      },
      setDebugPaths: function (n) {
        void 0 === n && (n = !0);
        this.skeletonDebugRenderer.drawPaths = n;
        return this;
      },
      setDebugSkeletonXY: function (n) {
        void 0 === n && (n = !0);
        this.skeletonDebugRenderer.drawSkeletonXY = n;
        return this;
      },
      setDebugClipping: function (n) {
        void 0 === n && (n = !0);
        this.skeletonDebugRenderer.drawClipping = n;
        return this;
      },
      setEffect: function (n) {
        this.sceneRenderer.skeletonRenderer.vertexEffect = n;
        return this;
      },
      createSkeleton: function (n, q) {
        var r = n,
          u = n,
          v = -1 !== n.indexOf(".");
        v && ((n = n.split(".")), (r = n.shift()), (u = n.join(".")));
        n = this.cache.get(r);
        var x = this.getAtlas(r);
        if (!x) return null;
        this.spineTextures.has(r) || this.spineTextures.add(r, x);
        n = n.preMultipliedAlpha;
        x = new e.AtlasAttachmentLoader(x);
        x = new e.SkeletonJson(x);
        q ? (v = q) : ((q = this.json.get(r)), (v = v ? a(q, u) : q));
        return v
          ? ((v = x.readSkeletonData(v)),
            (q = new e.Skeleton(v)),
            {
              skeletonData: v,
              skeleton: q,
              preMultipliedAlpha: n,
            })
          : null;
      },
      createAnimationState: function (n) {
        n = new e.AnimationStateData(n.data);
        var q = new e.AnimationState(n);
        return {
          stateData: n,
          state: q,
        };
      },
      getBounds: function (n) {
        var q = new e.Vector2(),
          r = new e.Vector2();
        n.getBounds(q, r, []);
        return {
          offset: q,
          size: r,
        };
      },
      onResize: function () {
        var n = this.renderer,
          q = this.sceneRenderer,
          r = n.width;
        n = n.height;
        q.camera.position.x = r / 2;
        q.camera.position.y = n / 2;
        q.camera.setViewport(r, n);
      },
      shutdown: function () {
        this.systems.events.off("shutdown", this.shutdown, this);
        this.isWebGL && this.game.scale.off(d, this.onResize, this);
      },
      destroy: function () {
        this.shutdown();
        this.gl =
          this.skeletonRenderer =
          this.textures =
          this.json =
          this.spineTextures =
          this.cache =
          this.systems =
          this.scene =
          this.game =
            null;
      },
      gameDestroy: function () {
        this.pluginManager.removeGameObject("spine", !0, !0);
        this.pluginManager.removeGameObject("spineContainer", !0, !0);
        this.pluginManager = null;
        m && (m.dispose(), (m = null));
        this.sceneRenderer = null;
      },
    });
    h.SpineGameObject = c;
    h.SpineContainer = f;
    l.exports = h;
  },
  function (l, w, h) {
    var t = h(17),
      a = h(65);
    l.exports = function (d, k, e) {
      k.x = a(e, "x", 0);
      k.y = a(e, "y", 0);
      k.depth = a(e, "depth", 0);
      k.flipX = a(e, "flipX", !1);
      k.flipY = a(e, "flipY", !1);
      var b = a(e, "scale", null);
      "number" === typeof b
        ? k.setScale(b)
        : null !== b && ((k.scaleX = a(b, "x", 1)), (k.scaleY = a(b, "y", 1)));
      b = a(e, "scrollFactor", null);
      "number" === typeof b
        ? k.setScrollFactor(b)
        : null !== b &&
          ((k.scrollFactorX = a(b, "x", 1)), (k.scrollFactorY = a(b, "y", 1)));
      k.rotation = a(e, "rotation", 0);
      b = a(e, "angle", null);
      null !== b && (k.angle = b);
      k.alpha = a(e, "alpha", 1);
      var c = a(e, "origin", null);
      "number" === typeof c
        ? k.setOrigin(c)
        : null !== c &&
          ((b = a(c, "x", 0.5)), (c = a(c, "y", 0.5)), k.setOrigin(b, c));
      k.blendMode = a(e, "blendMode", t.NORMAL);
      k.visible = a(e, "visible", !0);
      a(e, "add", !0) && d.sys.displayList.add(k);
      k.preUpdate && d.sys.updateList.add(k);
      return k;
    };
  },
  function (l, w, h) {
    var t = h(66),
      a = h(10);
    l.exports = function (d, k, e) {
      d = a(d, k, null);
      if (null === d) return e;
      if (Array.isArray(d)) return t.RND.pick(d);
      if ("object" === typeof d) {
        if (d.hasOwnProperty("randInt"))
          return t.RND.integerInRange(d.randInt[0], d.randInt[1]);
        if (d.hasOwnProperty("randFloat"))
          return t.RND.realInRange(d.randFloat[0], d.randFloat[1]);
      } else if ("function" === typeof d) return d(k);
      return d;
    };
  },
  function (l, w, h) {
    w = h(4);
    var t = h(27);
    h = {
      Angle: h(67),
      Distance: h(76),
      Easing: h(84),
      Fuzzy: h(129),
      Interpolation: h(134),
      Pow2: h(142),
      Snap: h(146),
      RandomDataGenerator: h(150),
      Average: h(151),
      Bernstein: h(33),
      Between: h(152),
      CatmullRom: h(35),
      CeilTo: h(153),
      Clamp: h(3),
      DegToRad: h(19),
      Difference: h(154),
      Euler: h(155),
      Factorial: h(34),
      FloatBetween: h(18),
      FloorTo: h(156),
      FromPercent: h(157),
      GetSpeed: h(158),
      IsEven: h(159),
      IsEvenStrict: h(160),
      Linear: h(36),
      MaxAdd: h(161),
      Median: h(162),
      MinSub: h(163),
      Percent: h(164),
      RadToDeg: h(9),
      RandomXY: h(165),
      RandomXYZ: h(166),
      RandomXYZW: h(167),
      Rotate: h(168),
      RotateAround: h(39),
      RotateAroundDistance: h(169),
      RotateTo: h(170),
      RoundAwayFromZero: h(40),
      RoundTo: h(171),
      SinCosTableGenerator: h(172),
      SmootherStep: h(38),
      SmoothStep: h(37),
      ToXY: h(173),
      TransformXY: h(41),
      Within: h(174),
      Wrap: h(6),
      Vector2: h(2),
      Vector3: h(14),
      Vector4: h(175),
      Matrix3: h(42),
      Matrix4: h(20),
      Quaternion: h(43),
      RotateVec3: h(176),
    };
    h = t(!1, h, w);
    l.exports = h;
  },
  function (l, w, h) {
    l.exports = {
      Between: h(28),
      BetweenPoints: h(68),
      BetweenPointsY: h(69),
      BetweenY: h(70),
      CounterClockwise: h(8),
      Normalize: h(29),
      Random: h(71),
      RandomDegrees: h(72),
      Reverse: h(73),
      RotateTo: h(74),
      ShortestBetween: h(75),
      Wrap: h(30),
      WrapDegrees: h(31),
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      return Math.atan2(t.y - h.y, t.x - h.x);
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      return Math.atan2(t.x - h.x, t.y - h.y);
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      return Math.atan2(a - h, d - t);
    };
  },
  function (l, w, h) {
    var t = h(18);
    l.exports = function () {
      return t(-Math.PI, Math.PI);
    };
  },
  function (l, w, h) {
    var t = h(18);
    l.exports = function () {
      return t(-180, 180);
    };
  },
  function (l, w, h) {
    var t = h(29);
    l.exports = function (a) {
      return t(a + Math.PI);
    };
  },
  function (l, w, h) {
    var t = h(4);
    l.exports = function (a, d, k) {
      void 0 === k && (k = 0.05);
      if (a === d) return a;
      Math.abs(d - a) <= k || Math.abs(d - a) >= t.PI2 - k
        ? (a = d)
        : (Math.abs(d - a) > Math.PI && (d = d < a ? d + t.PI2 : d - t.PI2),
          d > a ? (a += k) : d < a && (a -= k));
      return a;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      h = t - h;
      return 0 === h ? 0 : h - 360 * Math.floor((h - -180) / 360);
    };
  },
  function (l, w, h) {
    l.exports = {
      Between: h(77),
      BetweenPoints: h(78),
      BetweenPointsSquared: h(79),
      Chebyshev: h(80),
      Power: h(81),
      Snake: h(82),
      Squared: h(83),
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      h -= a;
      t -= d;
      return Math.sqrt(h * h + t * t);
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      var a = h.x - t.x;
      h = h.y - t.y;
      return Math.sqrt(a * a + h * h);
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      var a = h.x - t.x;
      h = h.y - t.y;
      return a * a + h * h;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      return Math.max(Math.abs(h - a), Math.abs(t - d));
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d, k) {
      void 0 === k && (k = 2);
      return Math.sqrt(Math.pow(a - h, k) + Math.pow(d - t, k));
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      return Math.abs(h - a) + Math.abs(t - d);
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      h -= a;
      t -= d;
      return h * h + t * t;
    };
  },
  function (l, w, h) {
    l.exports = {
      Back: h(85),
      Bounce: h(89),
      Circular: h(93),
      Cubic: h(97),
      Elastic: h(101),
      Expo: h(105),
      Linear: h(109),
      Quadratic: h(111),
      Quartic: h(115),
      Quintic: h(119),
      Sine: h(123),
      Stepped: h(127),
    };
  },
  function (l, w, h) {
    l.exports = {
      In: h(86),
      Out: h(87),
      InOut: h(88),
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      void 0 === t && (t = 1.70158);
      return h * h * ((t + 1) * h - t);
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      void 0 === t && (t = 1.70158);
      return --h * h * ((t + 1) * h + t) + 1;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      void 0 === t && (t = 1.70158);
      t *= 1.525;
      return 1 > (h *= 2)
        ? 0.5 * h * h * ((t + 1) * h - t)
        : 0.5 * ((h -= 2) * h * ((t + 1) * h + t) + 2);
    };
  },
  function (l, w, h) {
    l.exports = {
      In: h(90),
      Out: h(91),
      InOut: h(92),
    };
  },
  function (l, w) {
    l.exports = function (h) {
      h = 1 - h;
      return h < 1 / 2.75
        ? 1 - 7.5625 * h * h
        : h < 2 / 2.75
        ? 1 - (7.5625 * (h -= 1.5 / 2.75) * h + 0.75)
        : h < 2.5 / 2.75
        ? 1 - (7.5625 * (h -= 2.25 / 2.75) * h + 0.9375)
        : 1 - (7.5625 * (h -= 2.625 / 2.75) * h + 0.984375);
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return h < 1 / 2.75
        ? 7.5625 * h * h
        : h < 2 / 2.75
        ? 7.5625 * (h -= 1.5 / 2.75) * h + 0.75
        : h < 2.5 / 2.75
        ? 7.5625 * (h -= 2.25 / 2.75) * h + 0.9375
        : 7.5625 * (h -= 2.625 / 2.75) * h + 0.984375;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      var t = !1;
      0.5 > h ? ((h = 1 - 2 * h), (t = !0)) : (h = 2 * h - 1);
      h =
        h < 1 / 2.75
          ? 7.5625 * h * h
          : h < 2 / 2.75
          ? 7.5625 * (h -= 1.5 / 2.75) * h + 0.75
          : h < 2.5 / 2.75
          ? 7.5625 * (h -= 2.25 / 2.75) * h + 0.9375
          : 7.5625 * (h -= 2.625 / 2.75) * h + 0.984375;
      return t ? 0.5 * (1 - h) : 0.5 * h + 0.5;
    };
  },
  function (l, w, h) {
    l.exports = {
      In: h(94),
      Out: h(95),
      InOut: h(96),
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 1 - Math.sqrt(1 - h * h);
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return Math.sqrt(1 - --h * h);
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 1 > (h *= 2)
        ? -0.5 * (Math.sqrt(1 - h * h) - 1)
        : 0.5 * (Math.sqrt(1 - (h -= 2) * h) + 1);
    };
  },
  function (l, w, h) {
    l.exports = {
      In: h(98),
      Out: h(99),
      InOut: h(100),
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return h * h * h;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return --h * h * h + 1;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 1 > (h *= 2) ? 0.5 * h * h * h : 0.5 * ((h -= 2) * h * h + 2);
    };
  },
  function (l, w, h) {
    l.exports = {
      In: h(102),
      Out: h(103),
      InOut: h(104),
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      void 0 === t && (t = 0.1);
      void 0 === a && (a = 0.1);
      if (0 === h) return 0;
      if (1 === h) return 1;
      var d = a / 4;
      1 > t ? (t = 1) : (d = (a * Math.asin(1 / t)) / (2 * Math.PI));
      return -(
        t *
        Math.pow(2, 10 * --h) *
        Math.sin((2 * (h - d) * Math.PI) / a)
      );
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      void 0 === t && (t = 0.1);
      void 0 === a && (a = 0.1);
      if (0 === h) return 0;
      if (1 === h) return 1;
      var d = a / 4;
      1 > t ? (t = 1) : (d = (a * Math.asin(1 / t)) / (2 * Math.PI));
      return (
        t * Math.pow(2, -10 * h) * Math.sin((2 * (h - d) * Math.PI) / a) + 1
      );
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      void 0 === t && (t = 0.1);
      void 0 === a && (a = 0.1);
      if (0 === h) return 0;
      if (1 === h) return 1;
      var d = a / 4;
      1 > t ? (t = 1) : (d = (a * Math.asin(1 / t)) / (2 * Math.PI));
      return 1 > (h *= 2)
        ? -0.5 *
            t *
            Math.pow(2, 10 * --h) *
            Math.sin((2 * (h - d) * Math.PI) / a)
        : t *
            Math.pow(2, -10 * --h) *
            Math.sin((2 * (h - d) * Math.PI) / a) *
            0.5 +
            1;
    };
  },
  function (l, w, h) {
    l.exports = {
      In: h(106),
      Out: h(107),
      InOut: h(108),
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return Math.pow(2, 10 * (h - 1)) - 0.001;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 1 - Math.pow(2, -10 * h);
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 1 > (h *= 2)
        ? 0.5 * Math.pow(2, 10 * (h - 1))
        : 0.5 * (2 - Math.pow(2, -10 * (h - 1)));
    };
  },
  function (l, w, h) {
    l.exports = h(110);
  },
  function (l, w) {
    l.exports = function (h) {
      return h;
    };
  },
  function (l, w, h) {
    l.exports = {
      In: h(112),
      Out: h(113),
      InOut: h(114),
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return h * h;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return h * (2 - h);
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 1 > (h *= 2) ? 0.5 * h * h : -0.5 * (--h * (h - 2) - 1);
    };
  },
  function (l, w, h) {
    l.exports = {
      In: h(116),
      Out: h(117),
      InOut: h(118),
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return h * h * h * h;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 1 - --h * h * h * h;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 1 > (h *= 2)
        ? 0.5 * h * h * h * h
        : -0.5 * ((h -= 2) * h * h * h - 2);
    };
  },
  function (l, w, h) {
    l.exports = {
      In: h(120),
      Out: h(121),
      InOut: h(122),
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return h * h * h * h * h;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return --h * h * h * h * h + 1;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 1 > (h *= 2)
        ? 0.5 * h * h * h * h * h
        : 0.5 * ((h -= 2) * h * h * h * h + 2);
    };
  },
  function (l, w, h) {
    l.exports = {
      In: h(124),
      Out: h(125),
      InOut: h(126),
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 0 === h ? 0 : 1 === h ? 1 : 1 - Math.cos((h * Math.PI) / 2);
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 0 === h ? 0 : 1 === h ? 1 : Math.sin((h * Math.PI) / 2);
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 0 === h ? 0 : 1 === h ? 1 : 0.5 * (1 - Math.cos(Math.PI * h));
    };
  },
  function (l, w, h) {
    l.exports = h(128);
  },
  function (l, w) {
    l.exports = function (h, t) {
      void 0 === t && (t = 1);
      return 0 >= h ? 0 : 1 <= h ? 1 : (1 / t) * (((t * h) | 0) + 1);
    };
  },
  function (l, w, h) {
    l.exports = {
      Ceil: h(130),
      Equal: h(32),
      Floor: h(131),
      GreaterThan: h(132),
      LessThan: h(133),
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      void 0 === t && (t = 1e-4);
      return Math.ceil(h - t);
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      void 0 === t && (t = 1e-4);
      return Math.floor(h + t);
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      void 0 === a && (a = 1e-4);
      return h > t - a;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      void 0 === a && (a = 1e-4);
      return h < t + a;
    };
  },
  function (l, w, h) {
    l.exports = {
      Bezier: h(135),
      CatmullRom: h(136),
      CubicBezier: h(137),
      Linear: h(138),
      QuadraticBezier: h(139),
      SmoothStep: h(140),
      SmootherStep: h(141),
    };
  },
  function (l, w, h) {
    var t = h(33);
    l.exports = function (a, d) {
      for (var k = 0, e = a.length - 1, b = 0; b <= e; b++)
        k += Math.pow(1 - d, e - b) * Math.pow(d, b) * a[b] * t(e, b);
      return k;
    };
  },
  function (l, w, h) {
    var t = h(35);
    l.exports = function (a, d) {
      var k = a.length - 1,
        e = k * d,
        b = Math.floor(e);
      return a[0] === a[k]
        ? (0 > d && (b = Math.floor((e = k * (1 + d)))),
          t(e - b, a[(b - 1 + k) % k], a[b], a[(b + 1) % k], a[(b + 2) % k]))
        : 0 > d
        ? a[0] - (t(-e, a[0], a[0], a[1], a[1]) - a[0])
        : 1 < d
        ? a[k] - (t(e - k, a[k], a[k], a[k - 1], a[k - 1]) - a[k])
        : t(
            e - b,
            a[b ? b - 1 : 0],
            a[b],
            a[k < b + 1 ? k : b + 1],
            a[k < b + 2 ? k : b + 2]
          );
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d, k) {
      var e = 1 - h,
        b = 1 - h;
      return (
        e * e * e * t +
        3 * b * b * h * a +
        3 * (1 - h) * h * h * d +
        h * h * h * k
      );
    };
  },
  function (l, w, h) {
    var t = h(36);
    l.exports = function (a, d) {
      var k = a.length - 1,
        e = k * d,
        b = Math.floor(e);
      return 0 > d
        ? t(a[0], a[1], e)
        : 1 < d
        ? t(a[k], a[k - 1], k - e)
        : t(a[b], a[b + 1 > k ? k : b + 1], e - b);
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      var k = 1 - h;
      return k * k * t + 2 * (1 - h) * h * a + h * h * d;
    };
  },
  function (l, w, h) {
    var t = h(37);
    l.exports = function (a, d, k) {
      return d + (k - d) * t(a, 0, 1);
    };
  },
  function (l, w, h) {
    var t = h(38);
    l.exports = function (a, d, k) {
      return d + (k - d) * t(a, 0, 1);
    };
  },
  function (l, w, h) {
    l.exports = {
      GetNext: h(143),
      IsSize: h(144),
      IsValue: h(145),
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 1 << Math.ceil(Math.log(h) / 0.6931471805599453);
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      return 0 < h && 0 === (h & (h - 1)) && 0 < t && 0 === (t & (t - 1));
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return 0 < h && 0 === (h & (h - 1));
    };
  },
  function (l, w, h) {
    l.exports = {
      Ceil: h(147),
      Floor: h(148),
      To: h(149),
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      void 0 === a && (a = 0);
      if (0 === t) return h;
      h = t * Math.ceil((h - a) / t);
      return d ? (a + h) / t : a + h;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      void 0 === a && (a = 0);
      if (0 === t) return h;
      h = t * Math.floor((h - a) / t);
      return d ? (a + h) / t : a + h;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      void 0 === a && (a = 0);
      if (0 === t) return h;
      h = t * Math.round((h - a) / t);
      return d ? (a + h) / t : a + h;
    };
  },
  function (l, w, h) {
    w = new (h(0))({
      initialize: function (t) {
        void 0 === t && (t = [(Date.now() * Math.random()).toString()]);
        this.c = 1;
        this.n = this.s2 = this.s1 = this.s0 = 0;
        this.signs = [-1, 1];
        t && this.init(t);
      },
      rnd: function () {
        var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
        this.c = t | 0;
        this.s0 = this.s1;
        this.s1 = this.s2;
        return (this.s2 = t - this.c);
      },
      hash: function (t) {
        var a = this.n;
        t = t.toString();
        for (var d = 0; d < t.length; d++) {
          a += t.charCodeAt(d);
          var k = 0.02519603282416938 * a;
          a = k >>> 0;
          k -= a;
          k *= a;
          a = k >>> 0;
          k -= a;
          a += 4294967296 * k;
        }
        this.n = a;
        return 2.3283064365386963e-10 * (a >>> 0);
      },
      init: function (t) {
        "string" === typeof t ? this.state(t) : this.sow(t);
      },
      sow: function (t) {
        this.n = 4022871197;
        this.s0 = this.hash(" ");
        this.s1 = this.hash(" ");
        this.s2 = this.hash(" ");
        this.c = 1;
        if (t)
          for (var a = 0; a < t.length && null != t[a]; a++) {
            var d = t[a];
            this.s0 -= this.hash(d);
            this.s0 += ~~(0 > this.s0);
            this.s1 -= this.hash(d);
            this.s1 += ~~(0 > this.s1);
            this.s2 -= this.hash(d);
            this.s2 += ~~(0 > this.s2);
          }
      },
      integer: function () {
        return 4294967296 * this.rnd();
      },
      frac: function () {
        return (
          this.rnd() + 1.1102230246251565e-16 * ((2097152 * this.rnd()) | 0)
        );
      },
      real: function () {
        return this.integer() + this.frac();
      },
      integerInRange: function (t, a) {
        return Math.floor(this.realInRange(0, a - t + 1) + t);
      },
      between: function (t, a) {
        return Math.floor(this.realInRange(0, a - t + 1) + t);
      },
      realInRange: function (t, a) {
        return this.frac() * (a - t) + t;
      },
      normal: function () {
        return 1 - 2 * this.frac();
      },
      uuid: function () {
        var t, a;
        for (
          a = t = "";
          36 > t++;
          a +=
            ~t % 5 | ((3 * t) & 4)
              ? (t ^ 15 ? 8 ^ (this.frac() * (t ^ 20 ? 16 : 4)) : 4).toString(
                  16
                )
              : "-"
        );
        return a;
      },
      pick: function (t) {
        return t[this.integerInRange(0, t.length - 1)];
      },
      sign: function () {
        return this.pick(this.signs);
      },
      weightedPick: function (t) {
        return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + 0.5)];
      },
      timestamp: function (t, a) {
        return this.realInRange(t || 9466848e5, a || 1577862e6);
      },
      angle: function () {
        return this.integerInRange(-180, 180);
      },
      rotation: function () {
        return this.realInRange(-3.1415926, 3.1415926);
      },
      state: function (t) {
        "string" === typeof t &&
          t.match(/^!rnd/) &&
          ((t = t.split(",")),
          (this.c = parseFloat(t[1])),
          (this.s0 = parseFloat(t[2])),
          (this.s1 = parseFloat(t[3])),
          (this.s2 = parseFloat(t[4])));
        return ["!rnd", this.c, this.s0, this.s1, this.s2].join();
      },
      shuffle: function (t) {
        for (var a = t.length - 1; 0 < a; a--) {
          var d = Math.floor(this.frac() * (a + 1)),
            k = t[d];
          t[d] = t[a];
          t[a] = k;
        }
        return t;
      },
    });
    l.exports = w;
  },
  function (l, w) {
    l.exports = function (h) {
      for (var t = 0, a = 0; a < h.length; a++) t += +h[a];
      return t / h.length;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      return Math.floor(Math.random() * (t - h + 1) + h);
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      void 0 === t && (t = 0);
      void 0 === a && (a = 10);
      t = Math.pow(a, -t);
      return Math.ceil(h * t) / t;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      return Math.abs(h - t);
    };
  },
  function (l, w, h) {
    var t = h(3);
    w = h(0);
    var a = h(20),
      d = h(1),
      k = new a();
    h = new w({
      initialize: function m(b, c, f, g) {
        void 0 === b && (b = 0);
        void 0 === c && (c = 0);
        void 0 === f && (f = 0);
        void 0 === g && (g = m.DefaultOrder);
        this._x = b;
        this._y = c;
        this._z = f;
        this._order = g;
        this.onChangeCallback = d;
      },
      x: {
        get: function () {
          return this._x;
        },
        set: function (b) {
          this._x = b;
          this.onChangeCallback(this);
        },
      },
      y: {
        get: function () {
          return this._y;
        },
        set: function (b) {
          this._y = b;
          this.onChangeCallback(this);
        },
      },
      z: {
        get: function () {
          return this._z;
        },
        set: function (b) {
          this._z = b;
          this.onChangeCallback(this);
        },
      },
      order: {
        get: function () {
          return this._order;
        },
        set: function (b) {
          this._order = b;
          this.onChangeCallback(this);
        },
      },
      set: function (b, c, f, g) {
        void 0 === g && (g = this._order);
        this._x = b;
        this._y = c;
        this._z = f;
        this._order = g;
        this.onChangeCallback(this);
        return this;
      },
      copy: function (b) {
        return this.set(b.x, b.y, b.z, b.order);
      },
      setFromQuaternion: function (b, c, f) {
        void 0 === c && (c = this._order);
        void 0 === f && (f = !1);
        k.fromQuat(b);
        return this.setFromRotationMatrix(k, c, f);
      },
      setFromRotationMatrix: function (b, c, f) {
        void 0 === c && (c = this._order);
        void 0 === f && (f = !1);
        var g = b.val;
        b = g[0];
        var m = g[4],
          n = g[8],
          q = g[1],
          r = g[5],
          u = g[9],
          v = g[2],
          x = g[6];
        g = g[10];
        var y = 0,
          z = 0,
          A = 0;
        switch (c) {
          case "XYZ":
            z = Math.asin(t(n, -1, 1));
            0.99999 > Math.abs(n)
              ? ((y = Math.atan2(-u, g)), (A = Math.atan2(-m, b)))
              : (y = Math.atan2(x, r));
            break;
          case "YXZ":
            y = Math.asin(-t(u, -1, 1));
            0.99999 > Math.abs(u)
              ? ((z = Math.atan2(n, g)), (A = Math.atan2(q, r)))
              : (z = Math.atan2(-v, b));
            break;
          case "ZXY":
            y = Math.asin(t(x, -1, 1));
            0.99999 > Math.abs(x)
              ? ((z = Math.atan2(-v, g)), (A = Math.atan2(-m, r)))
              : (A = Math.atan2(q, b));
            break;
          case "ZYX":
            z = Math.asin(-t(v, -1, 1));
            0.99999 > Math.abs(v)
              ? ((y = Math.atan2(x, g)), (A = Math.atan2(q, b)))
              : (A = Math.atan2(-m, r));
            break;
          case "YZX":
            A = Math.asin(t(q, -1, 1));
            0.99999 > Math.abs(q)
              ? ((y = Math.atan2(-u, r)), (z = Math.atan2(-v, b)))
              : (z = Math.atan2(n, g));
            break;
          case "XZY":
            (A = Math.asin(-t(m, -1, 1))),
              0.99999 > Math.abs(m)
                ? ((y = Math.atan2(x, r)), (z = Math.atan2(n, b)))
                : (y = Math.atan2(-u, g));
        }
        this._x = y;
        this._y = z;
        this._z = A;
        this._order = c;
        if (f) this.onChangeCallback(this);
        return this;
      },
    });
    h.RotationOrders = "XYZ YXZ ZXY ZYX YZX XZY".split(" ");
    h.DefaultOrder = "XYZ";
    l.exports = h;
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      void 0 === t && (t = 0);
      void 0 === a && (a = 10);
      t = Math.pow(a, -t);
      return Math.floor(h * t) / t;
    };
  },
  function (l, w, h) {
    var t = h(3);
    l.exports = function (a, d, k) {
      a = t(a, 0, 1);
      return (k - d) * a + d;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      return h / t / 1e3;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return h == parseFloat(h) ? !(h % 2) : void 0;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return h === parseFloat(h) ? !(h % 2) : void 0;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      return Math.min(h + t, a);
    };
  },
  function (l, w) {
    l.exports = function (h) {
      var t = h.length;
      if (0 === t) return 0;
      h.sort(function (d, k) {
        return d - k;
      });
      var a = Math.floor(t / 2);
      return 0 === t % 2 ? (h[a] + h[a - 1]) / 2 : h[a];
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      return Math.max(h - t, a);
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      void 0 === a && (a = t + 1);
      t = (h - t) / (a - t);
      1 < t
        ? void 0 !== d
          ? ((t = (d - h) / (d - a)), 0 > t && (t = 0))
          : (t = 1)
        : 0 > t && (t = 0);
      return t;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      void 0 === t && (t = 1);
      var a = 2 * Math.random() * Math.PI;
      h.x = Math.cos(a) * t;
      h.y = Math.sin(a) * t;
      return h;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      void 0 === t && (t = 1);
      var a = 2 * Math.random() * Math.PI,
        d = 2 * Math.random() - 1,
        k = Math.sqrt(1 - d * d) * t;
      h.x = Math.cos(a) * k;
      h.y = Math.sin(a) * k;
      h.z = d * t;
      return h;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      void 0 === t && (t = 1);
      h.x = (2 * Math.random() - 1) * t;
      h.y = (2 * Math.random() - 1) * t;
      h.z = (2 * Math.random() - 1) * t;
      h.w = (2 * Math.random() - 1) * t;
      return h;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      var a = h.x,
        d = h.y;
      h.x = a * Math.cos(t) - d * Math.sin(t);
      h.y = a * Math.sin(t) + d * Math.cos(t);
      return h;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d, k) {
      d += Math.atan2(h.y - a, h.x - t);
      h.x = t + k * Math.cos(d);
      h.y = a + k * Math.sin(d);
      return h;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d, k) {
      h.x = t + k * Math.cos(d);
      h.y = a + k * Math.sin(d);
      return h;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      void 0 === t && (t = 0);
      void 0 === a && (a = 10);
      t = Math.pow(a, -t);
      return Math.round(h * t) / t;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      void 0 === t && (t = 1);
      void 0 === a && (a = 1);
      void 0 === d && (d = 1);
      d *= Math.PI / h;
      for (var k = [], e = [], b = 0; b < h; b++)
        (a -= t * d), (t += a * d), (k[b] = a), (e[b] = t);
      return {
        sin: e,
        cos: k,
        length: h,
      };
    };
  },
  function (l, w, h) {
    var t = h(2);
    l.exports = function (a, d, k, e) {
      void 0 === e && (e = new t());
      var b = 0;
      0 < a &&
        a <= d * k &&
        (a > d - 1 && ((b = Math.floor(a / d)), (a -= b * d)), e.set(a, b));
      return e;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      return Math.abs(h - t) <= a;
    };
  },
  function (l, w, h) {
    var t = new (h(0))({
      initialize: function (a, d, k, e) {
        this.w = this.z = this.y = this.x = 0;
        "object" === typeof a
          ? ((this.x = a.x || 0),
            (this.y = a.y || 0),
            (this.z = a.z || 0),
            (this.w = a.w || 0))
          : ((this.x = a || 0),
            (this.y = d || 0),
            (this.z = k || 0),
            (this.w = e || 0));
      },
      clone: function () {
        return new t(this.x, this.y, this.z, this.w);
      },
      copy: function (a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z || 0;
        this.w = a.w || 0;
        return this;
      },
      equals: function (a) {
        return (
          this.x === a.x && this.y === a.y && this.z === a.z && this.w === a.w
        );
      },
      set: function (a, d, k, e) {
        "object" === typeof a
          ? ((this.x = a.x || 0),
            (this.y = a.y || 0),
            (this.z = a.z || 0),
            (this.w = a.w || 0))
          : ((this.x = a || 0),
            (this.y = d || 0),
            (this.z = k || 0),
            (this.w = e || 0));
        return this;
      },
      add: function (a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z || 0;
        this.w += a.w || 0;
        return this;
      },
      subtract: function (a) {
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z || 0;
        this.w -= a.w || 0;
        return this;
      },
      scale: function (a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        this.w *= a;
        return this;
      },
      length: function () {
        var a = this.x,
          d = this.y,
          k = this.z,
          e = this.w;
        return Math.sqrt(a * a + d * d + k * k + e * e);
      },
      lengthSq: function () {
        var a = this.x,
          d = this.y,
          k = this.z,
          e = this.w;
        return a * a + d * d + k * k + e * e;
      },
      normalize: function () {
        var a = this.x,
          d = this.y,
          k = this.z,
          e = this.w,
          b = a * a + d * d + k * k + e * e;
        0 < b &&
          ((b = 1 / Math.sqrt(b)),
          (this.x = a * b),
          (this.y = d * b),
          (this.z = k * b),
          (this.w = e * b));
        return this;
      },
      dot: function (a) {
        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
      },
      lerp: function (a, d) {
        void 0 === d && (d = 0);
        var k = this.x,
          e = this.y,
          b = this.z,
          c = this.w;
        this.x = k + d * (a.x - k);
        this.y = e + d * (a.y - e);
        this.z = b + d * (a.z - b);
        this.w = c + d * (a.w - c);
        return this;
      },
      multiply: function (a) {
        this.x *= a.x;
        this.y *= a.y;
        this.z *= a.z || 1;
        this.w *= a.w || 1;
        return this;
      },
      divide: function (a) {
        this.x /= a.x;
        this.y /= a.y;
        this.z /= a.z || 1;
        this.w /= a.w || 1;
        return this;
      },
      distance: function (a) {
        var d = a.x - this.x,
          k = a.y - this.y,
          e = a.z - this.z || 0;
        a = a.w - this.w || 0;
        return Math.sqrt(d * d + k * k + e * e + a * a);
      },
      distanceSq: function (a) {
        var d = a.x - this.x,
          k = a.y - this.y,
          e = a.z - this.z || 0;
        a = a.w - this.w || 0;
        return d * d + k * k + e * e + a * a;
      },
      negate: function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      },
      transformMat4: function (a) {
        var d = this.x,
          k = this.y,
          e = this.z,
          b = this.w;
        a = a.val;
        this.x = a[0] * d + a[4] * k + a[8] * e + a[12] * b;
        this.y = a[1] * d + a[5] * k + a[9] * e + a[13] * b;
        this.z = a[2] * d + a[6] * k + a[10] * e + a[14] * b;
        this.w = a[3] * d + a[7] * k + a[11] * e + a[15] * b;
        return this;
      },
      transformQuat: function (a) {
        var d = this.x,
          k = this.y,
          e = this.z,
          b = a.x,
          c = a.y,
          f = a.z;
        a = a.w;
        var g = a * d + c * e - f * k,
          m = a * k + f * d - b * e,
          n = a * e + b * k - c * d;
        d = -b * d - c * k - f * e;
        this.x = g * a + d * -b + m * -f - n * -c;
        this.y = m * a + d * -c + n * -b - g * -f;
        this.z = n * a + d * -f + g * -c - m * -b;
        return this;
      },
      reset: function () {
        this.w = this.z = this.y = this.x = 0;
        return this;
      },
    });
    t.prototype.sub = t.prototype.subtract;
    t.prototype.mul = t.prototype.multiply;
    t.prototype.div = t.prototype.divide;
    t.prototype.dist = t.prototype.distance;
    t.prototype.distSq = t.prototype.distanceSq;
    t.prototype.len = t.prototype.length;
    t.prototype.lenSq = t.prototype.lengthSq;
    l.exports = t;
  },
  function (l, w, h) {
    w = h(14);
    var t = h(20);
    h = h(43);
    var a = new t(),
      d = new h(),
      k = new w();
    l.exports = function (e, b, c) {
      d.setAxisAngle(b, c);
      a.fromRotationTranslation(d, k.set(0, 0, 0));
      return e.transformMat4(a);
    };
  },
  function (l, w) {
    l.exports = "resize";
  },
  function (l, w, h) {
    var t = h(179);
    w = h(0);
    var a = h(44);
    h = new w({
      Extends: t,
      initialize: function (d, k, e) {
        t.call(this, k);
        this.scene = d;
        this.systems = d.sys;
        this.pluginKey = e;
        d.sys.events.once(a.BOOT, this.boot, this);
      },
      boot: function () {},
      destroy: function () {
        this.systems = this.scene = this.game = this.pluginManager = null;
      },
    });
    l.exports = h;
  },
  function (l, w, h) {
    w = new (h(0))({
      initialize: function (t) {
        this.pluginManager = t;
        this.game = t.game;
      },
      init: function () {},
      start: function () {},
      stop: function () {},
      destroy: function () {
        this.systems = this.scene = this.game = this.pluginManager = null;
      },
    });
    l.exports = w;
  },
  function (l, w) {
    l.exports = "addedtoscene";
  },
  function (l, w) {
    l.exports = "boot";
  },
  function (l, w) {
    l.exports = "create";
  },
  function (l, w) {
    l.exports = "destroy";
  },
  function (l, w) {
    l.exports = "pause";
  },
  function (l, w) {
    l.exports = "postupdate";
  },
  function (l, w) {
    l.exports = "prerender";
  },
  function (l, w) {
    l.exports = "preupdate";
  },
  function (l, w) {
    l.exports = "ready";
  },
  function (l, w) {
    l.exports = "removedfromscene";
  },
  function (l, w) {
    l.exports = "render";
  },
  function (l, w) {
    l.exports = "resume";
  },
  function (l, w) {
    l.exports = "shutdown";
  },
  function (l, w) {
    l.exports = "sleep";
  },
  function (l, w) {
    l.exports = "start";
  },
  function (l, w) {
    l.exports = "transitioncomplete";
  },
  function (l, w) {
    l.exports = "transitioninit";
  },
  function (l, w) {
    l.exports = "transitionout";
  },
  function (l, w) {
    l.exports = "transitionstart";
  },
  function (l, w) {
    l.exports = "transitionwake";
  },
  function (l, w) {
    l.exports = "update";
  },
  function (l, w) {
    l.exports = "wake";
  },
  function (l, w) {
    (function () {
      var h =
          (this && this.__extends) ||
          (function () {
            var a = function (d, k) {
              a =
                Object.setPrototypeOf ||
                ({
                  __proto__: [],
                } instanceof Array &&
                  function (e, b) {
                    e.__proto__ = b;
                  }) ||
                function (e, b) {
                  for (var c in b)
                    Object.prototype.hasOwnProperty.call(b, c) && (e[c] = b[c]);
                };
              return a(d, k);
            };
            return function (d, k) {
              function e() {
                this.constructor = d;
              }
              a(d, k);
              d.prototype =
                null === k
                  ? Object.create(k)
                  : ((e.prototype = k.prototype), new e());
            };
          })(),
        t;
      (function (a) {
        var d = (function () {
          function n(q, r, u) {
            if (null == q) throw Error("name cannot be null.");
            if (null == r) throw Error("timelines cannot be null.");
            this.name = q;
            this.timelines = r;
            this.timelineIds = [];
            for (q = 0; q < r.length; q++)
              this.timelineIds[r[q].getPropertyId()] = !0;
            this.duration = u;
          }
          n.prototype.hasTimeline = function (q) {
            return 1 == this.timelineIds[q];
          };
          n.prototype.apply = function (q, r, u, v, x, y, z, A) {
            if (null == q) throw Error("skeleton cannot be null.");
            v &&
              0 != this.duration &&
              ((u %= this.duration), 0 < r && (r %= this.duration));
            v = this.timelines;
            for (var B = 0, D = v.length; B < D; B++)
              v[B].apply(q, r, u, x, y, z, A);
          };
          n.binarySearch = function (q, r, u) {
            void 0 === u && (u = 1);
            var v = 0,
              x = q.length / u - 2;
            if (0 == x) return u;
            for (var y = x >>> 1; ; ) {
              q[(y + 1) * u] <= r ? (v = y + 1) : (x = y);
              if (v == x) return (v + 1) * u;
              y = (v + x) >>> 1;
            }
          };
          n.linearSearch = function (q, r, u) {
            for (var v = 0, x = q.length - u; v <= x; v += u)
              if (q[v] > r) return v;
            return -1;
          };
          return n;
        })();
        a.Animation = d;
        var k;
        (function (n) {
          n[(n.setup = 0)] = "setup";
          n[(n.first = 1)] = "first";
          n[(n.replace = 2)] = "replace";
          n[(n.add = 3)] = "add";
        })((k = a.MixBlend || (a.MixBlend = {})));
        var e;
        (function (n) {
          n[(n.mixIn = 0)] = "mixIn";
          n[(n.mixOut = 1)] = "mixOut";
        })((e = a.MixDirection || (a.MixDirection = {})));
        var b;
        (function (n) {
          n[(n.rotate = 0)] = "rotate";
          n[(n.translate = 1)] = "translate";
          n[(n.scale = 2)] = "scale";
          n[(n.shear = 3)] = "shear";
          n[(n.attachment = 4)] = "attachment";
          n[(n.color = 5)] = "color";
          n[(n.deform = 6)] = "deform";
          n[(n.event = 7)] = "event";
          n[(n.drawOrder = 8)] = "drawOrder";
          n[(n.ikConstraint = 9)] = "ikConstraint";
          n[(n.transformConstraint = 10)] = "transformConstraint";
          n[(n.pathConstraintPosition = 11)] = "pathConstraintPosition";
          n[(n.pathConstraintSpacing = 12)] = "pathConstraintSpacing";
          n[(n.pathConstraintMix = 13)] = "pathConstraintMix";
          n[(n.twoColor = 14)] = "twoColor";
        })((b = a.TimelineType || (a.TimelineType = {})));
        var c = (function () {
          function n(q) {
            if (0 >= q) throw Error("frameCount must be > 0: " + q);
            this.curves = a.Utils.newFloatArray((q - 1) * n.BEZIER_SIZE);
          }
          n.prototype.getFrameCount = function () {
            return this.curves.length / n.BEZIER_SIZE + 1;
          };
          n.prototype.setLinear = function (q) {
            this.curves[q * n.BEZIER_SIZE] = n.LINEAR;
          };
          n.prototype.setStepped = function (q) {
            this.curves[q * n.BEZIER_SIZE] = n.STEPPED;
          };
          n.prototype.getCurveType = function (q) {
            q *= n.BEZIER_SIZE;
            if (q == this.curves.length) return n.LINEAR;
            q = this.curves[q];
            return q == n.LINEAR
              ? n.LINEAR
              : q == n.STEPPED
              ? n.STEPPED
              : n.BEZIER;
          };
          n.prototype.setCurve = function (q, r, u, v, x) {
            var y = 0.03 * (2 * -r + v),
              z = 0.03 * (2 * -u + x);
            v = 0.006 * (3 * (r - v) + 1);
            x = 0.006 * (3 * (u - x) + 1);
            var A = 2 * y + v,
              B = 2 * z + x;
            r = 0.3 * r + y + 0.16666667 * v;
            u = 0.3 * u + z + 0.16666667 * x;
            q *= n.BEZIER_SIZE;
            z = this.curves;
            z[q++] = n.BEZIER;
            y = r;
            for (var D = u, E = q + n.BEZIER_SIZE - 1; q < E; q += 2)
              (z[q] = y),
                (z[q + 1] = D),
                (r += A),
                (u += B),
                (A += v),
                (B += x),
                (y += r),
                (D += u);
          };
          n.prototype.getCurvePercent = function (q, r) {
            r = a.MathUtils.clamp(r, 0, 1);
            var u = this.curves;
            q *= n.BEZIER_SIZE;
            var v = u[q];
            if (v == n.LINEAR) return r;
            if (v == n.STEPPED) return 0;
            q++;
            v = 0;
            for (var x = q, y = q + n.BEZIER_SIZE - 1; q < y; q += 2)
              if (((v = u[q]), v >= r))
                return (
                  q == x ? (y = x = 0) : ((x = u[q - 2]), (y = u[q - 1])),
                  y + ((u[q + 1] - y) * (r - x)) / (v - x)
                );
            u = u[q - 1];
            return u + ((1 - u) * (r - v)) / (1 - v);
          };
          n.LINEAR = 0;
          n.STEPPED = 1;
          n.BEZIER = 2;
          n.BEZIER_SIZE = 19;
          return n;
        })();
        a.CurveTimeline = c;
        var f = (function (n) {
          function q(r) {
            var u = n.call(this, r) || this;
            u.frames = a.Utils.newFloatArray(r << 1);
            return u;
          }
          h(q, n);
          q.prototype.getPropertyId = function () {
            return (b.rotate << 24) + this.boneIndex;
          };
          q.prototype.setFrame = function (r, u, v) {
            r <<= 1;
            this.frames[r] = u;
            this.frames[r + q.ROTATION] = v;
          };
          q.prototype.apply = function (r, u, v, x, y, z, A) {
            u = this.frames;
            r = r.bones[this.boneIndex];
            if (r.active)
              if (v < u[0])
                switch (z) {
                  case k.setup:
                    r.rotation = r.data.rotation;
                    break;
                  case k.first:
                    (z = r.data.rotation - r.rotation),
                      (r.rotation +=
                        (z -
                          360 *
                            (16384 - ((16384.499999999996 - z / 360) | 0))) *
                        y);
                }
              else if (v >= u[u.length - q.ENTRIES])
                switch (((v = u[u.length + q.PREV_ROTATION]), z)) {
                  case k.setup:
                    r.rotation = r.data.rotation + v * y;
                    break;
                  case k.first:
                  case k.replace:
                    (v += r.data.rotation - r.rotation),
                      (v -=
                        360 * (16384 - ((16384.499999999996 - v / 360) | 0)));
                  case k.add:
                    r.rotation += v * y;
                }
              else {
                A = d.binarySearch(u, v, q.ENTRIES);
                x = u[A + q.PREV_ROTATION];
                var B = u[A];
                v = this.getCurvePercent(
                  (A >> 1) - 1,
                  1 - (v - B) / (u[A + q.PREV_TIME] - B)
                );
                u = u[A + q.ROTATION] - x;
                u =
                  x +
                  (u - 360 * (16384 - ((16384.499999999996 - u / 360) | 0))) *
                    v;
                switch (z) {
                  case k.setup:
                    r.rotation =
                      r.data.rotation +
                      (u -
                        360 * (16384 - ((16384.499999999996 - u / 360) | 0))) *
                        y;
                    break;
                  case k.first:
                  case k.replace:
                    u += r.data.rotation - r.rotation;
                  case k.add:
                    r.rotation +=
                      (u -
                        360 * (16384 - ((16384.499999999996 - u / 360) | 0))) *
                      y;
                }
              }
          };
          q.ENTRIES = 2;
          q.PREV_TIME = -2;
          q.PREV_ROTATION = -1;
          q.ROTATION = 1;
          return q;
        })(c);
        a.RotateTimeline = f;
        f = (function (n) {
          function q(r) {
            var u = n.call(this, r) || this;
            u.frames = a.Utils.newFloatArray(r * q.ENTRIES);
            return u;
          }
          h(q, n);
          q.prototype.getPropertyId = function () {
            return (b.translate << 24) + this.boneIndex;
          };
          q.prototype.setFrame = function (r, u, v, x) {
            r *= q.ENTRIES;
            this.frames[r] = u;
            this.frames[r + q.X] = v;
            this.frames[r + q.Y] = x;
          };
          q.prototype.apply = function (r, u, v, x, y, z, A) {
            u = this.frames;
            r = r.bones[this.boneIndex];
            if (r.active)
              if (v < u[0])
                switch (z) {
                  case k.setup:
                    r.x = r.data.x;
                    r.y = r.data.y;
                    break;
                  case k.first:
                    (r.x += (r.data.x - r.x) * y),
                      (r.y += (r.data.y - r.y) * y);
                }
              else {
                if (v >= u[u.length - q.ENTRIES])
                  (x = u[u.length + q.PREV_X]), (A = u[u.length + q.PREV_Y]);
                else {
                  var B = d.binarySearch(u, v, q.ENTRIES);
                  x = u[B + q.PREV_X];
                  A = u[B + q.PREV_Y];
                  var D = u[B];
                  v = this.getCurvePercent(
                    B / q.ENTRIES - 1,
                    1 - (v - D) / (u[B + q.PREV_TIME] - D)
                  );
                  x += (u[B + q.X] - x) * v;
                  A += (u[B + q.Y] - A) * v;
                }
                switch (z) {
                  case k.setup:
                    r.x = r.data.x + x * y;
                    r.y = r.data.y + A * y;
                    break;
                  case k.first:
                  case k.replace:
                    r.x += (r.data.x + x - r.x) * y;
                    r.y += (r.data.y + A - r.y) * y;
                    break;
                  case k.add:
                    (r.x += x * y), (r.y += A * y);
                }
              }
          };
          q.ENTRIES = 3;
          q.PREV_TIME = -3;
          q.PREV_X = -2;
          q.PREV_Y = -1;
          q.X = 1;
          q.Y = 2;
          return q;
        })(c);
        a.TranslateTimeline = f;
        var g = (function (n) {
          function q(r) {
            return n.call(this, r) || this;
          }
          h(q, n);
          q.prototype.getPropertyId = function () {
            return (b.scale << 24) + this.boneIndex;
          };
          q.prototype.apply = function (r, u, v, x, y, z, A) {
            var B = this.frames;
            r = r.bones[this.boneIndex];
            if (r.active)
              if (v < B[0])
                switch (z) {
                  case k.setup:
                    r.scaleX = r.data.scaleX;
                    r.scaleY = r.data.scaleY;
                    break;
                  case k.first:
                    (r.scaleX += (r.data.scaleX - r.scaleX) * y),
                      (r.scaleY += (r.data.scaleY - r.scaleY) * y);
                }
              else {
                if (v >= B[B.length - q.ENTRIES])
                  (u = B[B.length + q.PREV_X] * r.data.scaleX),
                    (x = B[B.length + q.PREV_Y] * r.data.scaleY);
                else {
                  var D = d.binarySearch(B, v, q.ENTRIES);
                  u = B[D + q.PREV_X];
                  x = B[D + q.PREV_Y];
                  var E = B[D];
                  v = this.getCurvePercent(
                    D / q.ENTRIES - 1,
                    1 - (v - E) / (B[D + q.PREV_TIME] - E)
                  );
                  u = (u + (B[D + q.X] - u) * v) * r.data.scaleX;
                  x = (x + (B[D + q.Y] - x) * v) * r.data.scaleY;
                }
                if (1 == y)
                  z == k.add
                    ? ((r.scaleX += u - r.data.scaleX),
                      (r.scaleY += x - r.data.scaleY))
                    : ((r.scaleX = u), (r.scaleY = x));
                else if (A == e.mixOut)
                  switch (z) {
                    case k.setup:
                      z = r.data.scaleX;
                      A = r.data.scaleY;
                      r.scaleX =
                        z + (Math.abs(u) * a.MathUtils.signum(z) - z) * y;
                      r.scaleY =
                        A + (Math.abs(x) * a.MathUtils.signum(A) - A) * y;
                      break;
                    case k.first:
                    case k.replace:
                      z = r.scaleX;
                      A = r.scaleY;
                      r.scaleX =
                        z + (Math.abs(u) * a.MathUtils.signum(z) - z) * y;
                      r.scaleY =
                        A + (Math.abs(x) * a.MathUtils.signum(A) - A) * y;
                      break;
                    case k.add:
                      (z = r.scaleX),
                        (A = r.scaleY),
                        (r.scaleX =
                          z +
                          (Math.abs(u) * a.MathUtils.signum(z) -
                            r.data.scaleX) *
                            y),
                        (r.scaleY =
                          A +
                          (Math.abs(x) * a.MathUtils.signum(A) -
                            r.data.scaleY) *
                            y);
                  }
                else
                  switch (z) {
                    case k.setup:
                      z = Math.abs(r.data.scaleX) * a.MathUtils.signum(u);
                      A = Math.abs(r.data.scaleY) * a.MathUtils.signum(x);
                      r.scaleX = z + (u - z) * y;
                      r.scaleY = A + (x - A) * y;
                      break;
                    case k.first:
                    case k.replace:
                      z = Math.abs(r.scaleX) * a.MathUtils.signum(u);
                      A = Math.abs(r.scaleY) * a.MathUtils.signum(x);
                      r.scaleX = z + (u - z) * y;
                      r.scaleY = A + (x - A) * y;
                      break;
                    case k.add:
                      (z = a.MathUtils.signum(u)),
                        (A = a.MathUtils.signum(x)),
                        (r.scaleX =
                          Math.abs(r.scaleX) * z +
                          (u - Math.abs(r.data.scaleX) * z) * y),
                        (r.scaleY =
                          Math.abs(r.scaleY) * A +
                          (x - Math.abs(r.data.scaleY) * A) * y);
                  }
              }
          };
          return q;
        })(f);
        a.ScaleTimeline = g;
        f = (function (n) {
          function q(r) {
            return n.call(this, r) || this;
          }
          h(q, n);
          q.prototype.getPropertyId = function () {
            return (b.shear << 24) + this.boneIndex;
          };
          q.prototype.apply = function (r, u, v, x, y, z, A) {
            u = this.frames;
            r = r.bones[this.boneIndex];
            if (r.active)
              if (v < u[0])
                switch (z) {
                  case k.setup:
                    r.shearX = r.data.shearX;
                    r.shearY = r.data.shearY;
                    break;
                  case k.first:
                    (r.shearX += (r.data.shearX - r.shearX) * y),
                      (r.shearY += (r.data.shearY - r.shearY) * y);
                }
              else {
                if (v >= u[u.length - q.ENTRIES])
                  (x = u[u.length + q.PREV_X]), (A = u[u.length + q.PREV_Y]);
                else {
                  var B = d.binarySearch(u, v, q.ENTRIES);
                  x = u[B + q.PREV_X];
                  A = u[B + q.PREV_Y];
                  var D = u[B];
                  v = this.getCurvePercent(
                    B / q.ENTRIES - 1,
                    1 - (v - D) / (u[B + q.PREV_TIME] - D)
                  );
                  x += (u[B + q.X] - x) * v;
                  A += (u[B + q.Y] - A) * v;
                }
                switch (z) {
                  case k.setup:
                    r.shearX = r.data.shearX + x * y;
                    r.shearY = r.data.shearY + A * y;
                    break;
                  case k.first:
                  case k.replace:
                    r.shearX += (r.data.shearX + x - r.shearX) * y;
                    r.shearY += (r.data.shearY + A - r.shearY) * y;
                    break;
                  case k.add:
                    (r.shearX += x * y), (r.shearY += A * y);
                }
              }
          };
          return q;
        })(f);
        a.ShearTimeline = f;
        f = (function (n) {
          function q(r) {
            var u = n.call(this, r) || this;
            u.frames = a.Utils.newFloatArray(r * q.ENTRIES);
            return u;
          }
          h(q, n);
          q.prototype.getPropertyId = function () {
            return (b.color << 24) + this.slotIndex;
          };
          q.prototype.setFrame = function (r, u, v, x, y, z) {
            r *= q.ENTRIES;
            this.frames[r] = u;
            this.frames[r + q.R] = v;
            this.frames[r + q.G] = x;
            this.frames[r + q.B] = y;
            this.frames[r + q.A] = z;
          };
          q.prototype.apply = function (r, u, v, x, y, z, A) {
            r = r.slots[this.slotIndex];
            if (r.bone.active) {
              var B = this.frames;
              if (v < B[0])
                switch (z) {
                  case k.setup:
                    r.color.setFromColor(r.data.color);
                    break;
                  case k.first:
                    (v = r.color),
                      (z = r.data.color),
                      v.add(
                        (z.r - v.r) * y,
                        (z.g - v.g) * y,
                        (z.b - v.b) * y,
                        (z.a - v.a) * y
                      );
                }
              else {
                if (v >= B[B.length - q.ENTRIES]) {
                  v = B.length;
                  u = B[v + q.PREV_R];
                  x = B[v + q.PREV_G];
                  A = B[v + q.PREV_B];
                  var D = B[v + q.PREV_A];
                } else {
                  var E = d.binarySearch(B, v, q.ENTRIES);
                  u = B[E + q.PREV_R];
                  x = B[E + q.PREV_G];
                  A = B[E + q.PREV_B];
                  D = B[E + q.PREV_A];
                  var C = B[E];
                  v = this.getCurvePercent(
                    E / q.ENTRIES - 1,
                    1 - (v - C) / (B[E + q.PREV_TIME] - C)
                  );
                  u += (B[E + q.R] - u) * v;
                  x += (B[E + q.G] - x) * v;
                  A += (B[E + q.B] - A) * v;
                  D += (B[E + q.A] - D) * v;
                }
                1 == y
                  ? r.color.set(u, x, A, D)
                  : ((v = r.color),
                    z == k.setup && v.setFromColor(r.data.color),
                    v.add(
                      (u - v.r) * y,
                      (x - v.g) * y,
                      (A - v.b) * y,
                      (D - v.a) * y
                    ));
              }
            }
          };
          q.ENTRIES = 5;
          q.PREV_TIME = -5;
          q.PREV_R = -4;
          q.PREV_G = -3;
          q.PREV_B = -2;
          q.PREV_A = -1;
          q.R = 1;
          q.G = 2;
          q.B = 3;
          q.A = 4;
          return q;
        })(c);
        a.ColorTimeline = f;
        f = (function (n) {
          function q(r) {
            var u = n.call(this, r) || this;
            u.frames = a.Utils.newFloatArray(r * q.ENTRIES);
            return u;
          }
          h(q, n);
          q.prototype.getPropertyId = function () {
            return (b.twoColor << 24) + this.slotIndex;
          };
          q.prototype.setFrame = function (r, u, v, x, y, z, A, B, D) {
            r *= q.ENTRIES;
            this.frames[r] = u;
            this.frames[r + q.R] = v;
            this.frames[r + q.G] = x;
            this.frames[r + q.B] = y;
            this.frames[r + q.A] = z;
            this.frames[r + q.R2] = A;
            this.frames[r + q.G2] = B;
            this.frames[r + q.B2] = D;
          };
          q.prototype.apply = function (r, u, v, x, y, z, A) {
            r = r.slots[this.slotIndex];
            if (r.bone.active) {
              var B = this.frames;
              if (v < B[0])
                switch (z) {
                  case k.setup:
                    r.color.setFromColor(r.data.color);
                    r.darkColor.setFromColor(r.data.darkColor);
                    break;
                  case k.first:
                    (v = r.color),
                      (B = r.darkColor),
                      (z = r.data.color),
                      (r = r.data.darkColor),
                      v.add(
                        (z.r - v.r) * y,
                        (z.g - v.g) * y,
                        (z.b - v.b) * y,
                        (z.a - v.a) * y
                      ),
                      B.add(
                        (r.r - B.r) * y,
                        (r.g - B.g) * y,
                        (r.b - B.b) * y,
                        0
                      );
                }
              else {
                if (v >= B[B.length - q.ENTRIES]) {
                  v = B.length;
                  u = B[v + q.PREV_R];
                  x = B[v + q.PREV_G];
                  A = B[v + q.PREV_B];
                  var D = B[v + q.PREV_A];
                  var E = B[v + q.PREV_R2];
                  var C = B[v + q.PREV_G2];
                  var F = B[v + q.PREV_B2];
                } else {
                  var G = d.binarySearch(B, v, q.ENTRIES);
                  u = B[G + q.PREV_R];
                  x = B[G + q.PREV_G];
                  A = B[G + q.PREV_B];
                  D = B[G + q.PREV_A];
                  E = B[G + q.PREV_R2];
                  C = B[G + q.PREV_G2];
                  F = B[G + q.PREV_B2];
                  var H = B[G];
                  v = this.getCurvePercent(
                    G / q.ENTRIES - 1,
                    1 - (v - H) / (B[G + q.PREV_TIME] - H)
                  );
                  u += (B[G + q.R] - u) * v;
                  x += (B[G + q.G] - x) * v;
                  A += (B[G + q.B] - A) * v;
                  D += (B[G + q.A] - D) * v;
                  E += (B[G + q.R2] - E) * v;
                  C += (B[G + q.G2] - C) * v;
                  F += (B[G + q.B2] - F) * v;
                }
                1 == y
                  ? (r.color.set(u, x, A, D), r.darkColor.set(E, C, F, 1))
                  : ((v = r.color),
                    (B = r.darkColor),
                    z == k.setup &&
                      (v.setFromColor(r.data.color),
                      B.setFromColor(r.data.darkColor)),
                    v.add(
                      (u - v.r) * y,
                      (x - v.g) * y,
                      (A - v.b) * y,
                      (D - v.a) * y
                    ),
                    B.add((E - B.r) * y, (C - B.g) * y, (F - B.b) * y, 0));
              }
            }
          };
          q.ENTRIES = 8;
          q.PREV_TIME = -8;
          q.PREV_R = -7;
          q.PREV_G = -6;
          q.PREV_B = -5;
          q.PREV_A = -4;
          q.PREV_R2 = -3;
          q.PREV_G2 = -2;
          q.PREV_B2 = -1;
          q.R = 1;
          q.G = 2;
          q.B = 3;
          q.A = 4;
          q.R2 = 5;
          q.G2 = 6;
          q.B2 = 7;
          return q;
        })(c);
        a.TwoColorTimeline = f;
        f = (function () {
          function n(q) {
            this.frames = a.Utils.newFloatArray(q);
            this.attachmentNames = Array(q);
          }
          n.prototype.getPropertyId = function () {
            return (b.attachment << 24) + this.slotIndex;
          };
          n.prototype.getFrameCount = function () {
            return this.frames.length;
          };
          n.prototype.setFrame = function (q, r, u) {
            this.frames[q] = r;
            this.attachmentNames[q] = u;
          };
          n.prototype.apply = function (q, r, u, v, x, y, z) {
            r = q.slots[this.slotIndex];
            r.bone.active &&
              (z == e.mixOut
                ? y == k.setup &&
                  this.setAttachment(q, r, r.data.attachmentName)
                : ((z = this.frames),
                  u < z[0]
                    ? (y != k.setup && y != k.first) ||
                      this.setAttachment(q, r, r.data.attachmentName)
                    : ((u =
                        u >= z[z.length - 1]
                          ? z.length - 1
                          : d.binarySearch(z, u, 1) - 1),
                      (u = this.attachmentNames[u]),
                      q.slots[this.slotIndex].setAttachment(
                        null == u ? null : q.getAttachment(this.slotIndex, u)
                      ))));
          };
          n.prototype.setAttachment = function (q, r, u) {
            r.attachment =
              null == u ? null : q.getAttachment(this.slotIndex, u);
          };
          return n;
        })();
        a.AttachmentTimeline = f;
        var m = null;
        f = (function (n) {
          function q(r) {
            var u = n.call(this, r) || this;
            u.frames = a.Utils.newFloatArray(r);
            u.frameVertices = Array(r);
            null == m && (m = a.Utils.newFloatArray(64));
            return u;
          }
          h(q, n);
          q.prototype.getPropertyId = function () {
            return (b.deform << 27) + +this.attachment.id + this.slotIndex;
          };
          q.prototype.setFrame = function (r, u, v) {
            this.frames[r] = u;
            this.frameVertices[r] = v;
          };
          q.prototype.apply = function (r, u, v, x, y, z, A) {
            r = r.slots[this.slotIndex];
            if (r.bone.active) {
              var B = r.getAttachment();
              if (
                B instanceof a.VertexAttachment &&
                B.deformAttachment == this.attachment
              ) {
                u = r.deform;
                0 == u.length && (z = k.setup);
                A = this.frameVertices;
                r = A[0].length;
                var D = this.frames;
                if (v < D[0])
                  switch (z) {
                    case k.setup:
                      u.length = 0;
                      break;
                    case k.first:
                      if (1 == y) u.length = 0;
                      else if (
                        ((u = a.Utils.setArraySize(u, r)), null == B.bones)
                      )
                        for (z = B.vertices, x = 0; x < r; x++)
                          u[x] += (z[x] - u[x]) * y;
                      else for (y = 1 - y, x = 0; x < r; x++) u[x] *= y;
                  }
                else if (
                  ((u = a.Utils.setArraySize(u, r)), v >= D[D.length - 1])
                )
                  if (((x = A[D.length - 1]), 1 == y))
                    if (z == k.add)
                      if (null == B.bones)
                        for (z = B.vertices, y = 0; y < r; y++)
                          u[y] += x[y] - z[y];
                      else for (y = 0; y < r; y++) u[y] += x[y];
                    else a.Utils.arrayCopy(x, 0, u, 0, r);
                  else
                    switch (z) {
                      case k.setup:
                        if (null == B.bones)
                          for (z = B.vertices, A = 0; A < r; A++)
                            (D = z[A]), (u[A] = D + (x[A] - D) * y);
                        else for (A = 0; A < r; A++) u[A] = x[A] * y;
                        break;
                      case k.first:
                      case k.replace:
                        for (A = 0; A < r; A++) u[A] += (x[A] - u[A]) * y;
                        break;
                      case k.add:
                        if (null == B.bones)
                          for (z = B.vertices, A = 0; A < r; A++)
                            u[A] += (x[A] - z[A]) * y;
                        else for (A = 0; A < r; A++) u[A] += x[A] * y;
                    }
                else {
                  var E = d.binarySearch(D, v);
                  x = A[E - 1];
                  A = A[E];
                  var C = D[E];
                  v = this.getCurvePercent(E - 1, 1 - (v - C) / (D[E - 1] - C));
                  if (1 == y)
                    if (z == k.add)
                      if (null == B.bones)
                        for (z = B.vertices, y = 0; y < r; y++)
                          (B = x[y]), (u[y] += B + (A[y] - B) * v - z[y]);
                      else
                        for (y = 0; y < r; y++)
                          (B = x[y]), (u[y] += B + (A[y] - B) * v);
                    else
                      for (y = 0; y < r; y++)
                        (B = x[y]), (u[y] = B + (A[y] - B) * v);
                  else
                    switch (z) {
                      case k.setup:
                        if (null == B.bones)
                          for (z = B.vertices, E = 0; E < r; E++)
                            (B = x[E]),
                              (D = z[E]),
                              (u[E] = D + (B + (A[E] - B) * v - D) * y);
                        else
                          for (z = 0; z < r; z++)
                            (B = x[z]), (u[z] = (B + (A[z] - B) * v) * y);
                        break;
                      case k.first:
                      case k.replace:
                        for (z = 0; z < r; z++)
                          (B = x[z]), (u[z] += (B + (A[z] - B) * v - u[z]) * y);
                        break;
                      case k.add:
                        if (null == B.bones)
                          for (z = B.vertices, D = 0; D < r; D++)
                            (B = x[D]),
                              (u[D] += (B + (A[D] - B) * v - z[D]) * y);
                        else
                          for (z = 0; z < r; z++)
                            (B = x[z]), (u[z] += (B + (A[z] - B) * v) * y);
                    }
                }
              }
            }
          };
          return q;
        })(c);
        a.DeformTimeline = f;
        f = (function () {
          function n(q) {
            this.frames = a.Utils.newFloatArray(q);
            this.events = Array(q);
          }
          n.prototype.getPropertyId = function () {
            return b.event << 24;
          };
          n.prototype.getFrameCount = function () {
            return this.frames.length;
          };
          n.prototype.setFrame = function (q, r) {
            this.frames[q] = r.time;
            this.events[q] = r;
          };
          n.prototype.apply = function (q, r, u, v, x, y, z) {
            if (null != v) {
              var A = this.frames,
                B = this.frames.length;
              if (r > u)
                this.apply(q, r, Number.MAX_VALUE, v, x, y, z), (r = -1);
              else if (r >= A[B - 1]) return;
              if (!(u < A[0])) {
                if (r < A[0]) q = 0;
                else
                  for (
                    q = d.binarySearch(A, r), r = A[q];
                    0 < q && A[q - 1] == r;

                  )
                    q--;
                for (; q < B && u >= A[q]; q++) v.push(this.events[q]);
              }
            }
          };
          return n;
        })();
        a.EventTimeline = f;
        f = (function () {
          function n(q) {
            this.frames = a.Utils.newFloatArray(q);
            this.drawOrders = Array(q);
          }
          n.prototype.getPropertyId = function () {
            return b.drawOrder << 24;
          };
          n.prototype.getFrameCount = function () {
            return this.frames.length;
          };
          n.prototype.setFrame = function (q, r, u) {
            this.frames[q] = r;
            this.drawOrders[q] = u;
          };
          n.prototype.apply = function (q, r, u, v, x, y, z) {
            r = q.drawOrder;
            v = q.slots;
            if (z == e.mixOut)
              y == k.setup &&
                a.Utils.arrayCopy(q.slots, 0, q.drawOrder, 0, q.slots.length);
            else if (((z = this.frames), u < z[0]))
              (y != k.setup && y != k.first) ||
                a.Utils.arrayCopy(q.slots, 0, q.drawOrder, 0, q.slots.length);
            else if (
              ((q =
                u >= z[z.length - 1] ? z.length - 1 : d.binarySearch(z, u) - 1),
              (q = this.drawOrders[q]),
              null == q)
            )
              a.Utils.arrayCopy(v, 0, r, 0, v.length);
            else for (u = 0, y = q.length; u < y; u++) r[u] = v[q[u]];
          };
          return n;
        })();
        a.DrawOrderTimeline = f;
        f = (function (n) {
          function q(r) {
            var u = n.call(this, r) || this;
            u.frames = a.Utils.newFloatArray(r * q.ENTRIES);
            return u;
          }
          h(q, n);
          q.prototype.getPropertyId = function () {
            return (b.ikConstraint << 24) + this.ikConstraintIndex;
          };
          q.prototype.setFrame = function (r, u, v, x, y, z, A) {
            r *= q.ENTRIES;
            this.frames[r] = u;
            this.frames[r + q.MIX] = v;
            this.frames[r + q.SOFTNESS] = x;
            this.frames[r + q.BEND_DIRECTION] = y;
            this.frames[r + q.COMPRESS] = z ? 1 : 0;
            this.frames[r + q.STRETCH] = A ? 1 : 0;
          };
          q.prototype.apply = function (r, u, v, x, y, z, A) {
            u = this.frames;
            r = r.ikConstraints[this.ikConstraintIndex];
            if (r.active)
              if (v < u[0])
                switch (z) {
                  case k.setup:
                    r.mix = r.data.mix;
                    r.softness = r.data.softness;
                    r.bendDirection = r.data.bendDirection;
                    r.compress = r.data.compress;
                    r.stretch = r.data.stretch;
                    break;
                  case k.first:
                    (r.mix += (r.data.mix - r.mix) * y),
                      (r.softness += (r.data.softness - r.softness) * y),
                      (r.bendDirection = r.data.bendDirection),
                      (r.compress = r.data.compress),
                      (r.stretch = r.data.stretch);
                }
              else if (v >= u[u.length - q.ENTRIES])
                z == k.setup
                  ? ((r.mix =
                      r.data.mix + (u[u.length + q.PREV_MIX] - r.data.mix) * y),
                    (r.softness =
                      r.data.softness +
                      (u[u.length + q.PREV_SOFTNESS] - r.data.softness) * y),
                    A == e.mixOut
                      ? ((r.bendDirection = r.data.bendDirection),
                        (r.compress = r.data.compress),
                        (r.stretch = r.data.stretch))
                      : ((r.bendDirection =
                          u[u.length + q.PREV_BEND_DIRECTION]),
                        (r.compress = 0 != u[u.length + q.PREV_COMPRESS]),
                        (r.stretch = 0 != u[u.length + q.PREV_STRETCH])))
                  : ((r.mix += (u[u.length + q.PREV_MIX] - r.mix) * y),
                    (r.softness +=
                      (u[u.length + q.PREV_SOFTNESS] - r.softness) * y),
                    A == e.mixIn &&
                      ((r.bendDirection = u[u.length + q.PREV_BEND_DIRECTION]),
                      (r.compress = 0 != u[u.length + q.PREV_COMPRESS]),
                      (r.stretch = 0 != u[u.length + q.PREV_STRETCH])));
              else {
                x = d.binarySearch(u, v, q.ENTRIES);
                var B = u[x + q.PREV_MIX],
                  D = u[x + q.PREV_SOFTNESS],
                  E = u[x];
                v = this.getCurvePercent(
                  x / q.ENTRIES - 1,
                  1 - (v - E) / (u[x + q.PREV_TIME] - E)
                );
                z == k.setup
                  ? ((r.mix =
                      r.data.mix +
                      (B + (u[x + q.MIX] - B) * v - r.data.mix) * y),
                    (r.softness =
                      r.data.softness +
                      (D + (u[x + q.SOFTNESS] - D) * v - r.data.softness) * y),
                    A == e.mixOut
                      ? ((r.bendDirection = r.data.bendDirection),
                        (r.compress = r.data.compress),
                        (r.stretch = r.data.stretch))
                      : ((r.bendDirection = u[x + q.PREV_BEND_DIRECTION]),
                        (r.compress = 0 != u[x + q.PREV_COMPRESS]),
                        (r.stretch = 0 != u[x + q.PREV_STRETCH])))
                  : ((r.mix += (B + (u[x + q.MIX] - B) * v - r.mix) * y),
                    (r.softness +=
                      (D + (u[x + q.SOFTNESS] - D) * v - r.softness) * y),
                    A == e.mixIn &&
                      ((r.bendDirection = u[x + q.PREV_BEND_DIRECTION]),
                      (r.compress = 0 != u[x + q.PREV_COMPRESS]),
                      (r.stretch = 0 != u[x + q.PREV_STRETCH])));
              }
          };
          q.ENTRIES = 6;
          q.PREV_TIME = -6;
          q.PREV_MIX = -5;
          q.PREV_SOFTNESS = -4;
          q.PREV_BEND_DIRECTION = -3;
          q.PREV_COMPRESS = -2;
          q.PREV_STRETCH = -1;
          q.MIX = 1;
          q.SOFTNESS = 2;
          q.BEND_DIRECTION = 3;
          q.COMPRESS = 4;
          q.STRETCH = 5;
          return q;
        })(c);
        a.IkConstraintTimeline = f;
        f = (function (n) {
          function q(r) {
            var u = n.call(this, r) || this;
            u.frames = a.Utils.newFloatArray(r * q.ENTRIES);
            return u;
          }
          h(q, n);
          q.prototype.getPropertyId = function () {
            return (
              (b.transformConstraint << 24) + this.transformConstraintIndex
            );
          };
          q.prototype.setFrame = function (r, u, v, x, y, z) {
            r *= q.ENTRIES;
            this.frames[r] = u;
            this.frames[r + q.ROTATE] = v;
            this.frames[r + q.TRANSLATE] = x;
            this.frames[r + q.SCALE] = y;
            this.frames[r + q.SHEAR] = z;
          };
          q.prototype.apply = function (r, u, v, x, y, z, A) {
            u = this.frames;
            r = r.transformConstraints[this.transformConstraintIndex];
            if (r.active)
              if (v < u[0])
                switch (((v = r.data), z)) {
                  case k.setup:
                    r.rotateMix = v.rotateMix;
                    r.translateMix = v.translateMix;
                    r.scaleMix = v.scaleMix;
                    r.shearMix = v.shearMix;
                    break;
                  case k.first:
                    (r.rotateMix += (v.rotateMix - r.rotateMix) * y),
                      (r.translateMix += (v.translateMix - r.translateMix) * y),
                      (r.scaleMix += (v.scaleMix - r.scaleMix) * y),
                      (r.shearMix += (v.shearMix - r.shearMix) * y);
                }
              else {
                if (v >= u[u.length - q.ENTRIES]) {
                  v = u.length;
                  x = u[v + q.PREV_ROTATE];
                  A = u[v + q.PREV_TRANSLATE];
                  var B = u[v + q.PREV_SCALE];
                  var D = u[v + q.PREV_SHEAR];
                } else {
                  var E = d.binarySearch(u, v, q.ENTRIES);
                  x = u[E + q.PREV_ROTATE];
                  A = u[E + q.PREV_TRANSLATE];
                  B = u[E + q.PREV_SCALE];
                  D = u[E + q.PREV_SHEAR];
                  var C = u[E];
                  v = this.getCurvePercent(
                    E / q.ENTRIES - 1,
                    1 - (v - C) / (u[E + q.PREV_TIME] - C)
                  );
                  x += (u[E + q.ROTATE] - x) * v;
                  A += (u[E + q.TRANSLATE] - A) * v;
                  B += (u[E + q.SCALE] - B) * v;
                  D += (u[E + q.SHEAR] - D) * v;
                }
                z == k.setup
                  ? ((v = r.data),
                    (r.rotateMix = v.rotateMix + (x - v.rotateMix) * y),
                    (r.translateMix =
                      v.translateMix + (A - v.translateMix) * y),
                    (r.scaleMix = v.scaleMix + (B - v.scaleMix) * y),
                    (r.shearMix = v.shearMix + (D - v.shearMix) * y))
                  : ((r.rotateMix += (x - r.rotateMix) * y),
                    (r.translateMix += (A - r.translateMix) * y),
                    (r.scaleMix += (B - r.scaleMix) * y),
                    (r.shearMix += (D - r.shearMix) * y));
              }
          };
          q.ENTRIES = 5;
          q.PREV_TIME = -5;
          q.PREV_ROTATE = -4;
          q.PREV_TRANSLATE = -3;
          q.PREV_SCALE = -2;
          q.PREV_SHEAR = -1;
          q.ROTATE = 1;
          q.TRANSLATE = 2;
          q.SCALE = 3;
          q.SHEAR = 4;
          return q;
        })(c);
        a.TransformConstraintTimeline = f;
        f = (function (n) {
          function q(r) {
            var u = n.call(this, r) || this;
            u.frames = a.Utils.newFloatArray(r * q.ENTRIES);
            return u;
          }
          h(q, n);
          q.prototype.getPropertyId = function () {
            return (b.pathConstraintPosition << 24) + this.pathConstraintIndex;
          };
          q.prototype.setFrame = function (r, u, v) {
            r *= q.ENTRIES;
            this.frames[r] = u;
            this.frames[r + q.VALUE] = v;
          };
          q.prototype.apply = function (r, u, v, x, y, z, A) {
            u = this.frames;
            r = r.pathConstraints[this.pathConstraintIndex];
            if (r.active)
              if (v < u[0])
                switch (z) {
                  case k.setup:
                    r.position = r.data.position;
                    break;
                  case k.first:
                    r.position += (r.data.position - r.position) * y;
                }
              else {
                if (v >= u[u.length - q.ENTRIES])
                  x = u[u.length + q.PREV_VALUE];
                else {
                  A = d.binarySearch(u, v, q.ENTRIES);
                  x = u[A + q.PREV_VALUE];
                  var B = u[A];
                  v = this.getCurvePercent(
                    A / q.ENTRIES - 1,
                    1 - (v - B) / (u[A + q.PREV_TIME] - B)
                  );
                  x += (u[A + q.VALUE] - x) * v;
                }
                r.position =
                  z == k.setup
                    ? r.data.position + (x - r.data.position) * y
                    : r.position + (x - r.position) * y;
              }
          };
          q.ENTRIES = 2;
          q.PREV_TIME = -2;
          q.PREV_VALUE = -1;
          q.VALUE = 1;
          return q;
        })(c);
        a.PathConstraintPositionTimeline = f;
        f = (function (n) {
          function q(r) {
            return n.call(this, r) || this;
          }
          h(q, n);
          q.prototype.getPropertyId = function () {
            return (b.pathConstraintSpacing << 24) + this.pathConstraintIndex;
          };
          q.prototype.apply = function (r, u, v, x, y, z, A) {
            u = this.frames;
            r = r.pathConstraints[this.pathConstraintIndex];
            if (r.active)
              if (v < u[0])
                switch (z) {
                  case k.setup:
                    r.spacing = r.data.spacing;
                    break;
                  case k.first:
                    r.spacing += (r.data.spacing - r.spacing) * y;
                }
              else {
                if (v >= u[u.length - q.ENTRIES])
                  x = u[u.length + q.PREV_VALUE];
                else {
                  A = d.binarySearch(u, v, q.ENTRIES);
                  x = u[A + q.PREV_VALUE];
                  var B = u[A];
                  v = this.getCurvePercent(
                    A / q.ENTRIES - 1,
                    1 - (v - B) / (u[A + q.PREV_TIME] - B)
                  );
                  x += (u[A + q.VALUE] - x) * v;
                }
                r.spacing =
                  z == k.setup
                    ? r.data.spacing + (x - r.data.spacing) * y
                    : r.spacing + (x - r.spacing) * y;
              }
          };
          return q;
        })(f);
        a.PathConstraintSpacingTimeline = f;
        c = (function (n) {
          function q(r) {
            var u = n.call(this, r) || this;
            u.frames = a.Utils.newFloatArray(r * q.ENTRIES);
            return u;
          }
          h(q, n);
          q.prototype.getPropertyId = function () {
            return (b.pathConstraintMix << 24) + this.pathConstraintIndex;
          };
          q.prototype.setFrame = function (r, u, v, x) {
            r *= q.ENTRIES;
            this.frames[r] = u;
            this.frames[r + q.ROTATE] = v;
            this.frames[r + q.TRANSLATE] = x;
          };
          q.prototype.apply = function (r, u, v, x, y, z, A) {
            u = this.frames;
            r = r.pathConstraints[this.pathConstraintIndex];
            if (r.active)
              if (v < u[0])
                switch (z) {
                  case k.setup:
                    r.rotateMix = r.data.rotateMix;
                    r.translateMix = r.data.translateMix;
                    break;
                  case k.first:
                    (r.rotateMix += (r.data.rotateMix - r.rotateMix) * y),
                      (r.translateMix +=
                        (r.data.translateMix - r.translateMix) * y);
                }
              else {
                if (v >= u[u.length - q.ENTRIES])
                  (x = u[u.length + q.PREV_ROTATE]),
                    (A = u[u.length + q.PREV_TRANSLATE]);
                else {
                  var B = d.binarySearch(u, v, q.ENTRIES);
                  x = u[B + q.PREV_ROTATE];
                  A = u[B + q.PREV_TRANSLATE];
                  var D = u[B];
                  v = this.getCurvePercent(
                    B / q.ENTRIES - 1,
                    1 - (v - D) / (u[B + q.PREV_TIME] - D)
                  );
                  x += (u[B + q.ROTATE] - x) * v;
                  A += (u[B + q.TRANSLATE] - A) * v;
                }
                z == k.setup
                  ? ((r.rotateMix =
                      r.data.rotateMix + (x - r.data.rotateMix) * y),
                    (r.translateMix =
                      r.data.translateMix + (A - r.data.translateMix) * y))
                  : ((r.rotateMix += (x - r.rotateMix) * y),
                    (r.translateMix += (A - r.translateMix) * y));
              }
          };
          q.ENTRIES = 3;
          q.PREV_TIME = -3;
          q.PREV_ROTATE = -2;
          q.PREV_TRANSLATE = -1;
          q.ROTATE = 1;
          q.TRANSLATE = 2;
          return q;
        })(c);
        a.PathConstraintMixTimeline = c;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function c(f) {
            this.tracks = [];
            this.timeScale = 1;
            this.unkeyedState = 0;
            this.events = [];
            this.listeners = [];
            this.queue = new e(this);
            this.propertyIDs = new a.IntSet();
            this.animationsChanged = !1;
            this.trackEntryPool = new a.Pool(function () {
              return new k();
            });
            this.data = f;
          }
          c.prototype.update = function (f) {
            f *= this.timeScale;
            for (var g = this.tracks, m = 0, n = g.length; m < n; m++) {
              var q = g[m];
              if (null != q) {
                q.animationLast = q.nextAnimationLast;
                q.trackLast = q.nextTrackLast;
                var r = f * q.timeScale;
                if (0 < q.delay) {
                  q.delay -= r;
                  if (0 < q.delay) continue;
                  r = -q.delay;
                  q.delay = 0;
                }
                var u = q.next;
                if (null != u) {
                  var v = q.trackLast - u.delay;
                  if (0 <= v) {
                    u.delay = 0;
                    u.trackTime +=
                      0 == q.timeScale
                        ? 0
                        : (v / q.timeScale + f) * u.timeScale;
                    q.trackTime += r;
                    for (this.setCurrent(m, u, !0); null != u.mixingFrom; )
                      (u.mixTime += f), (u = u.mixingFrom);
                    continue;
                  }
                } else if (q.trackLast >= q.trackEnd && null == q.mixingFrom) {
                  g[m] = null;
                  this.queue.end(q);
                  this.disposeNext(q);
                  continue;
                }
                if (null != q.mixingFrom && this.updateMixingFrom(q, f))
                  for (
                    u = q.mixingFrom,
                      q.mixingFrom = null,
                      null != u && (u.mixingTo = null);
                    null != u;

                  )
                    this.queue.end(u), (u = u.mixingFrom);
                q.trackTime += r;
              }
            }
            this.queue.drain();
          };
          c.prototype.updateMixingFrom = function (f, g) {
            var m = f.mixingFrom;
            if (null == m) return !0;
            var n = this.updateMixingFrom(m, g);
            m.animationLast = m.nextAnimationLast;
            m.trackLast = m.nextTrackLast;
            if (0 < f.mixTime && f.mixTime >= f.mixDuration) {
              if (0 == m.totalAlpha || 0 == f.mixDuration)
                (f.mixingFrom = m.mixingFrom),
                  null != m.mixingFrom && (m.mixingFrom.mixingTo = f),
                  (f.interruptAlpha = m.interruptAlpha),
                  this.queue.end(m);
              return n;
            }
            m.trackTime += g * m.timeScale;
            f.mixTime += g;
            return !1;
          };
          c.prototype.apply = function (f) {
            if (null == f) throw Error("skeleton cannot be null.");
            this.animationsChanged && this._animationsChanged();
            for (
              var g = this.events, m = this.tracks, n = !1, q = 0, r = m.length;
              q < r;
              q++
            ) {
              var u = m[q];
              if (!(null == u || 0 < u.delay)) {
                n = !0;
                var v = 0 == q ? a.MixBlend.first : u.mixBlend,
                  x = u.alpha;
                null != u.mixingFrom
                  ? (x *= this.applyMixingFrom(u, f, v))
                  : u.trackTime >= u.trackEnd && null == u.next && (x = 0);
                var y = u.animationLast,
                  z = u.getAnimationTime(),
                  A = u.animation.timelines.length,
                  B = u.animation.timelines;
                if ((0 == q && 1 == x) || v == a.MixBlend.add)
                  for (var D = 0; D < A; D++) {
                    a.Utils.webkit602BugfixHelper(x, v);
                    var E = B[D];
                    E instanceof a.AttachmentTimeline
                      ? this.applyAttachmentTimeline(E, f, z, v, !0)
                      : E.apply(f, y, z, g, x, v, a.MixDirection.mixIn);
                  }
                else {
                  E = u.timelineMode;
                  var C = 0 == u.timelinesRotation.length;
                  C && a.Utils.setArraySize(u.timelinesRotation, A << 1, null);
                  var F = u.timelinesRotation;
                  for (D = 0; D < A; D++) {
                    var G = B[D],
                      H = E[D] == c.SUBSEQUENT ? v : a.MixBlend.setup;
                    G instanceof a.RotateTimeline
                      ? this.applyRotateTimeline(G, f, z, x, H, F, D << 1, C)
                      : G instanceof a.AttachmentTimeline
                      ? this.applyAttachmentTimeline(G, f, z, v, !0)
                      : (a.Utils.webkit602BugfixHelper(x, v),
                        G.apply(f, y, z, g, x, H, a.MixDirection.mixIn));
                  }
                }
                this.queueEvents(u, z);
                g.length = 0;
                u.nextAnimationLast = z;
                u.nextTrackLast = u.trackTime;
              }
            }
            g = this.unkeyedState + c.SETUP;
            m = f.slots;
            q = 0;
            for (r = f.slots.length; q < r; q++)
              (u = m[q]),
                u.attachmentState == g &&
                  ((v = u.data.attachmentName),
                  (u.attachment =
                    null == v ? null : f.getAttachment(u.data.index, v)));
            this.unkeyedState += 2;
            this.queue.drain();
            return n;
          };
          c.prototype.applyMixingFrom = function (f, g, m) {
            var n = f.mixingFrom;
            null != n.mixingFrom && this.applyMixingFrom(n, g, m);
            if (0 == f.mixDuration) {
              var q = 1;
              m == a.MixBlend.first && (m = a.MixBlend.setup);
            } else
              (q = f.mixTime / f.mixDuration),
                1 < q && (q = 1),
                m != a.MixBlend.first && (m = n.mixBlend);
            var r = q < n.eventThreshold ? this.events : null,
              u = q < n.attachmentThreshold,
              v = q < n.drawOrderThreshold,
              x = n.animationLast,
              y = n.getAnimationTime(),
              z = n.animation.timelines.length,
              A = n.animation.timelines,
              B = n.alpha * f.interruptAlpha,
              D = B * (1 - q);
            if (m == a.MixBlend.add)
              for (var E = 0; E < z; E++)
                A[E].apply(g, x, y, r, D, m, a.MixDirection.mixOut);
            else {
              var C = n.timelineMode,
                F = n.timelineHoldMix,
                G = 0 == n.timelinesRotation.length;
              G && a.Utils.setArraySize(n.timelinesRotation, z << 1, null);
              var H = n.timelinesRotation;
              for (E = n.totalAlpha = 0; E < z; E++) {
                var K = A[E],
                  I = a.MixDirection.mixOut;
                switch (C[E]) {
                  case c.SUBSEQUENT:
                    if (!v && K instanceof a.DrawOrderTimeline) continue;
                    var M = m;
                    var N = D;
                    break;
                  case c.FIRST:
                    M = a.MixBlend.setup;
                    N = D;
                    break;
                  case c.HOLD_SUBSEQUENT:
                    M = m;
                    N = B;
                    break;
                  case c.HOLD_FIRST:
                    M = a.MixBlend.setup;
                    N = B;
                    break;
                  default:
                    (M = a.MixBlend.setup),
                      (N = F[E]),
                      (N = B * Math.max(0, 1 - N.mixTime / N.mixDuration));
                }
                n.totalAlpha += N;
                K instanceof a.RotateTimeline
                  ? this.applyRotateTimeline(K, g, y, N, M, H, E << 1, G)
                  : K instanceof a.AttachmentTimeline
                  ? this.applyAttachmentTimeline(K, g, y, M, u)
                  : (a.Utils.webkit602BugfixHelper(N, m),
                    v &&
                      K instanceof a.DrawOrderTimeline &&
                      M == a.MixBlend.setup &&
                      (I = a.MixDirection.mixIn),
                    K.apply(g, x, y, r, N, M, I));
              }
            }
            0 < f.mixDuration && this.queueEvents(n, y);
            this.events.length = 0;
            n.nextAnimationLast = y;
            n.nextTrackLast = n.trackTime;
            return q;
          };
          c.prototype.applyAttachmentTimeline = function (f, g, m, n, q) {
            var r = g.slots[f.slotIndex];
            if (r.bone.active) {
              var u = f.frames;
              m < u[0]
                ? (n != a.MixBlend.setup && n != a.MixBlend.first) ||
                  this.setAttachment(g, r, r.data.attachmentName, q)
                : ((m =
                    m >= u[u.length - 1]
                      ? u.length - 1
                      : a.Animation.binarySearch(u, m) - 1),
                  this.setAttachment(g, r, f.attachmentNames[m], q));
              r.attachmentState <= this.unkeyedState &&
                (r.attachmentState = this.unkeyedState + c.SETUP);
            }
          };
          c.prototype.setAttachment = function (f, g, m, n) {
            g.attachment = null == m ? null : f.getAttachment(g.data.index, m);
            n && (g.attachmentState = this.unkeyedState + c.CURRENT);
          };
          c.prototype.applyRotateTimeline = function (f, g, m, n, q, r, u, v) {
            v && (r[u] = 0);
            if (1 == n) f.apply(g, 0, m, null, 1, q, a.MixDirection.mixIn);
            else {
              var x = f.frames;
              g = g.bones[f.boneIndex];
              if (g.active) {
                if (m < x[0])
                  switch (q) {
                    case a.MixBlend.setup:
                      g.rotation = g.data.rotation;
                    default:
                      return;
                    case a.MixBlend.first:
                      (q = g.rotation), (x = g.data.rotation);
                  }
                else if (
                  ((q = q == a.MixBlend.setup ? g.data.rotation : g.rotation),
                  m >= x[x.length - a.RotateTimeline.ENTRIES])
                )
                  x =
                    g.data.rotation +
                    x[x.length + a.RotateTimeline.PREV_ROTATION];
                else {
                  var y = a.Animation.binarySearch(
                      x,
                      m,
                      a.RotateTimeline.ENTRIES
                    ),
                    z = x[y + a.RotateTimeline.PREV_ROTATION],
                    A = x[y];
                  f = f.getCurvePercent(
                    (y >> 1) - 1,
                    1 - (m - A) / (x[y + a.RotateTimeline.PREV_TIME] - A)
                  );
                  x = x[y + a.RotateTimeline.ROTATION] - z;
                  x =
                    z +
                    (x - 360 * (16384 - ((16384.499999999996 - x / 360) | 0))) *
                      f +
                    g.data.rotation;
                  x -= 360 * (16384 - ((16384.499999999996 - x / 360) | 0));
                }
                x -= q;
                x -= 360 * (16384 - ((16384.499999999996 - x / 360) | 0));
                0 == x
                  ? (z = r[u])
                  : (v ? ((v = 0), (z = x)) : ((v = r[u]), (z = r[u + 1])),
                    (f = 0 < x),
                    (m = 0 <= v),
                    a.MathUtils.signum(z) != a.MathUtils.signum(x) &&
                      90 >= Math.abs(z) &&
                      (180 < Math.abs(v) && (v += 360 * a.MathUtils.signum(v)),
                      (m = f)),
                    (z = x + v - (v % 360)),
                    m != f && (z += 360 * a.MathUtils.signum(v)),
                    (r[u] = z));
                r[u + 1] = x;
                q += z * n;
                g.rotation =
                  q - 360 * (16384 - ((16384.499999999996 - q / 360) | 0));
              }
            }
          };
          c.prototype.queueEvents = function (f, g) {
            for (
              var m = f.animationStart,
                n = f.animationEnd,
                q = n - m,
                r = f.trackLast % q,
                u = this.events,
                v = 0,
                x = u.length;
              v < x;
              v++
            ) {
              var y = u[v];
              if (y.time < r) break;
              y.time > n || this.queue.event(f, y);
            }
            for (
              (f.loop
                ? 0 == q || r > f.trackTime % q
                : g >= n && f.animationLast < n) && this.queue.complete(f);
              v < x;
              v++
            )
              u[v].time < m || this.queue.event(f, u[v]);
          };
          c.prototype.clearTracks = function () {
            var f = this.queue.drainDisabled;
            this.queue.drainDisabled = !0;
            for (var g = 0, m = this.tracks.length; g < m; g++)
              this.clearTrack(g);
            this.tracks.length = 0;
            this.queue.drainDisabled = f;
            this.queue.drain();
          };
          c.prototype.clearTrack = function (f) {
            if (
              !(f >= this.tracks.length) &&
              ((f = this.tracks[f]), null != f)
            ) {
              this.queue.end(f);
              this.disposeNext(f);
              for (var g = f; ; ) {
                var m = g.mixingFrom;
                if (null == m) break;
                this.queue.end(m);
                g.mixingFrom = null;
                g.mixingTo = null;
                g = m;
              }
              this.tracks[f.trackIndex] = null;
              this.queue.drain();
            }
          };
          c.prototype.setCurrent = function (f, g, m) {
            var n = this.expandToIndex(f);
            this.tracks[f] = g;
            null != n &&
              (m && this.queue.interrupt(n),
              (g.mixingFrom = n),
              (n.mixingTo = g),
              (g.mixTime = 0),
              null != n.mixingFrom &&
                0 < n.mixDuration &&
                (g.interruptAlpha *= Math.min(1, n.mixTime / n.mixDuration)),
              (n.timelinesRotation.length = 0));
            this.queue.start(g);
          };
          c.prototype.setAnimation = function (f, g, m) {
            var n = this.data.skeletonData.findAnimation(g);
            if (null == n) throw Error("Animation not found: " + g);
            return this.setAnimationWith(f, n, m);
          };
          c.prototype.setAnimationWith = function (f, g, m) {
            if (null == g) throw Error("animation cannot be null.");
            var n = !0,
              q = this.expandToIndex(f);
            null != q &&
              (-1 == q.nextTrackLast
                ? ((this.tracks[f] = q.mixingFrom),
                  this.queue.interrupt(q),
                  this.queue.end(q),
                  this.disposeNext(q),
                  (q = q.mixingFrom),
                  (n = !1))
                : this.disposeNext(q));
            g = this.trackEntry(f, g, m, q);
            this.setCurrent(f, g, n);
            this.queue.drain();
            return g;
          };
          c.prototype.addAnimation = function (f, g, m, n) {
            var q = this.data.skeletonData.findAnimation(g);
            if (null == q) throw Error("Animation not found: " + g);
            return this.addAnimationWith(f, q, m, n);
          };
          c.prototype.addAnimationWith = function (f, g, m, n) {
            if (null == g) throw Error("animation cannot be null.");
            var q = this.expandToIndex(f);
            if (null != q) for (; null != q.next; ) q = q.next;
            m = this.trackEntry(f, g, m, q);
            null == q
              ? (this.setCurrent(f, m, !0), this.queue.drain())
              : ((q.next = m),
                0 >= n &&
                  ((f = q.animationEnd - q.animationStart),
                  0 != f
                    ? ((n = q.loop
                        ? n + f * (1 + ((q.trackTime / f) | 0))
                        : n + Math.max(f, q.trackTime)),
                      (n -= this.data.getMix(q.animation, g)))
                    : (n = q.trackTime)));
            m.delay = n;
            return m;
          };
          c.prototype.setEmptyAnimation = function (f, g) {
            f = this.setAnimationWith(f, c.emptyAnimation, !1);
            f.mixDuration = g;
            f.trackEnd = g;
            return f;
          };
          c.prototype.addEmptyAnimation = function (f, g, m) {
            0 >= m && (m -= g);
            f = this.addAnimationWith(f, c.emptyAnimation, !1, m);
            f.mixDuration = g;
            f.trackEnd = g;
            return f;
          };
          c.prototype.setEmptyAnimations = function (f) {
            var g = this.queue.drainDisabled;
            this.queue.drainDisabled = !0;
            for (var m = 0, n = this.tracks.length; m < n; m++) {
              var q = this.tracks[m];
              null != q && this.setEmptyAnimation(q.trackIndex, f);
            }
            this.queue.drainDisabled = g;
            this.queue.drain();
          };
          c.prototype.expandToIndex = function (f) {
            if (f < this.tracks.length) return this.tracks[f];
            a.Utils.ensureArrayCapacity(this.tracks, f + 1, null);
            this.tracks.length = f + 1;
            return null;
          };
          c.prototype.trackEntry = function (f, g, m, n) {
            var q = this.trackEntryPool.obtain();
            q.trackIndex = f;
            q.animation = g;
            q.loop = m;
            q.holdPrevious = !1;
            q.eventThreshold = 0;
            q.attachmentThreshold = 0;
            q.drawOrderThreshold = 0;
            q.animationStart = 0;
            q.animationEnd = g.duration;
            q.animationLast = -1;
            q.nextAnimationLast = -1;
            q.delay = 0;
            q.trackTime = 0;
            q.trackLast = -1;
            q.nextTrackLast = -1;
            q.trackEnd = Number.MAX_VALUE;
            q.timeScale = 1;
            q.alpha = 1;
            q.interruptAlpha = 1;
            q.mixTime = 0;
            q.mixDuration = null == n ? 0 : this.data.getMix(n.animation, g);
            q.mixBlend = a.MixBlend.replace;
            return q;
          };
          c.prototype.disposeNext = function (f) {
            for (var g = f.next; null != g; )
              this.queue.dispose(g), (g = g.next);
            f.next = null;
          };
          c.prototype._animationsChanged = function () {
            this.animationsChanged = !1;
            this.propertyIDs.clear();
            for (var f = 0, g = this.tracks.length; f < g; f++) {
              var m = this.tracks[f];
              if (null != m) {
                for (; null != m.mixingFrom; ) m = m.mixingFrom;
                do
                  (null != m.mixingFrom && m.mixBlend == a.MixBlend.add) ||
                    this.computeHold(m),
                    (m = m.mixingTo);
                while (null != m);
              }
            }
          };
          c.prototype.computeHold = function (f) {
            var g = f.mixingTo,
              m = f.animation.timelines,
              n = f.animation.timelines.length,
              q = a.Utils.setArraySize(f.timelineMode, n);
            f.timelineHoldMix.length = 0;
            var r = a.Utils.setArraySize(f.timelineHoldMix, n),
              u = this.propertyIDs;
            if (null != g && g.holdPrevious)
              for (var v = 0; v < n; v++)
                q[v] = u.add(m[v].getPropertyId())
                  ? c.HOLD_FIRST
                  : c.HOLD_SUBSEQUENT;
            else
              a: for (v = 0; v < n; v++) {
                var x = m[v],
                  y = x.getPropertyId();
                if (u.add(y))
                  if (
                    null == g ||
                    x instanceof a.AttachmentTimeline ||
                    x instanceof a.DrawOrderTimeline ||
                    x instanceof a.EventTimeline ||
                    !g.animation.hasTimeline(y)
                  )
                    q[v] = c.FIRST;
                  else {
                    for (x = g.mixingTo; null != x; x = x.mixingTo)
                      if (!x.animation.hasTimeline(y)) {
                        if (0 < f.mixDuration) {
                          q[v] = c.HOLD_MIX;
                          r[v] = x;
                          continue a;
                        }
                        break;
                      }
                    q[v] = c.HOLD_FIRST;
                  }
                else q[v] = c.SUBSEQUENT;
              }
          };
          c.prototype.getCurrent = function (f) {
            return f >= this.tracks.length ? null : this.tracks[f];
          };
          c.prototype.addListener = function (f) {
            if (null == f) throw Error("listener cannot be null.");
            this.listeners.push(f);
          };
          c.prototype.removeListener = function (f) {
            f = this.listeners.indexOf(f);
            0 <= f && this.listeners.splice(f, 1);
          };
          c.prototype.clearListeners = function () {
            this.listeners.length = 0;
          };
          c.prototype.clearListenerNotifications = function () {
            this.queue.clear();
          };
          c.emptyAnimation = new a.Animation("<empty>", [], 0);
          c.SUBSEQUENT = 0;
          c.FIRST = 1;
          c.HOLD_SUBSEQUENT = 2;
          c.HOLD_FIRST = 3;
          c.HOLD_MIX = 4;
          c.SETUP = 1;
          c.CURRENT = 2;
          return c;
        })();
        a.AnimationState = d;
        var k = (function () {
          function c() {
            this.mixBlend = a.MixBlend.replace;
            this.timelineMode = [];
            this.timelineHoldMix = [];
            this.timelinesRotation = [];
          }
          c.prototype.reset = function () {
            this.listener =
              this.animation =
              this.mixingTo =
              this.mixingFrom =
              this.next =
                null;
            this.timelineMode.length = 0;
            this.timelineHoldMix.length = 0;
            this.timelinesRotation.length = 0;
          };
          c.prototype.getAnimationTime = function () {
            if (this.loop) {
              var f = this.animationEnd - this.animationStart;
              return 0 == f
                ? this.animationStart
                : (this.trackTime % f) + this.animationStart;
            }
            return Math.min(
              this.trackTime + this.animationStart,
              this.animationEnd
            );
          };
          c.prototype.setAnimationLast = function (f) {
            this.nextAnimationLast = this.animationLast = f;
          };
          c.prototype.isComplete = function () {
            return this.trackTime >= this.animationEnd - this.animationStart;
          };
          c.prototype.resetRotationDirections = function () {
            this.timelinesRotation.length = 0;
          };
          return c;
        })();
        a.TrackEntry = k;
        var e = (function () {
          function c(f) {
            this.objects = [];
            this.drainDisabled = !1;
            this.animState = f;
          }
          c.prototype.start = function (f) {
            this.objects.push(b.start);
            this.objects.push(f);
            this.animState.animationsChanged = !0;
          };
          c.prototype.interrupt = function (f) {
            this.objects.push(b.interrupt);
            this.objects.push(f);
          };
          c.prototype.end = function (f) {
            this.objects.push(b.end);
            this.objects.push(f);
            this.animState.animationsChanged = !0;
          };
          c.prototype.dispose = function (f) {
            this.objects.push(b.dispose);
            this.objects.push(f);
          };
          c.prototype.complete = function (f) {
            this.objects.push(b.complete);
            this.objects.push(f);
          };
          c.prototype.event = function (f, g) {
            this.objects.push(b.event);
            this.objects.push(f);
            this.objects.push(g);
          };
          c.prototype.drain = function () {
            if (!this.drainDisabled) {
              this.drainDisabled = !0;
              for (
                var f = this.objects, g = this.animState.listeners, m = 0;
                m < f.length;
                m += 2
              ) {
                var n = f[m + 1];
                switch (f[m]) {
                  case b.start:
                    null != n.listener &&
                      n.listener.start &&
                      n.listener.start(n);
                    for (var q = 0; q < g.length; q++)
                      g[q].start && g[q].start(n);
                    break;
                  case b.interrupt:
                    null != n.listener &&
                      n.listener.interrupt &&
                      n.listener.interrupt(n);
                    for (q = 0; q < g.length; q++)
                      g[q].interrupt && g[q].interrupt(n);
                    break;
                  case b.end:
                    for (
                      null != n.listener && n.listener.end && n.listener.end(n),
                        q = 0;
                      q < g.length;
                      q++
                    )
                      g[q].end && g[q].end(n);
                  case b.dispose:
                    null != n.listener &&
                      n.listener.dispose &&
                      n.listener.dispose(n);
                    for (q = 0; q < g.length; q++)
                      g[q].dispose && g[q].dispose(n);
                    this.animState.trackEntryPool.free(n);
                    break;
                  case b.complete:
                    null != n.listener &&
                      n.listener.complete &&
                      n.listener.complete(n);
                    for (q = 0; q < g.length; q++)
                      g[q].complete && g[q].complete(n);
                    break;
                  case b.event:
                    var r = f[m++ + 2];
                    null != n.listener &&
                      n.listener.event &&
                      n.listener.event(n, r);
                    for (q = 0; q < g.length; q++)
                      g[q].event && g[q].event(n, r);
                }
              }
              this.clear();
              this.drainDisabled = !1;
            }
          };
          c.prototype.clear = function () {
            this.objects.length = 0;
          };
          return c;
        })();
        a.EventQueue = e;
        var b;
        (function (c) {
          c[(c.start = 0)] = "start";
          c[(c.interrupt = 1)] = "interrupt";
          c[(c.end = 2)] = "end";
          c[(c.dispose = 3)] = "dispose";
          c[(c.complete = 4)] = "complete";
          c[(c.event = 5)] = "event";
        })((b = a.EventType || (a.EventType = {})));
        d = (function () {
          function c() {}
          c.prototype.start = function (f) {};
          c.prototype.interrupt = function (f) {};
          c.prototype.end = function (f) {};
          c.prototype.dispose = function (f) {};
          c.prototype.complete = function (f) {};
          c.prototype.event = function (f, g) {};
          return c;
        })();
        a.AnimationStateAdapter = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k(e) {
            this.animationToMixTime = {};
            this.defaultMix = 0;
            if (null == e) throw Error("skeletonData cannot be null.");
            this.skeletonData = e;
          }
          k.prototype.setMix = function (e, b, c) {
            var f = this.skeletonData.findAnimation(e);
            if (null == f) throw Error("Animation not found: " + e);
            e = this.skeletonData.findAnimation(b);
            if (null == e) throw Error("Animation not found: " + b);
            this.setMixWith(f, e, c);
          };
          k.prototype.setMixWith = function (e, b, c) {
            if (null == e) throw Error("from cannot be null.");
            if (null == b) throw Error("to cannot be null.");
            this.animationToMixTime[e.name + "." + b.name] = c;
          };
          k.prototype.getMix = function (e, b) {
            e = this.animationToMixTime[e.name + "." + b.name];
            return void 0 === e ? this.defaultMix : e;
          };
          return k;
        })();
        a.AnimationStateData = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k(e, b) {
            void 0 === b && (b = "");
            this.assets = {};
            this.errors = {};
            this.loaded = this.toLoad = 0;
            this.rawDataUris = {};
            this.textureLoader = e;
            this.pathPrefix = b;
          }
          k.prototype.downloadText = function (e, b, c) {
            var f = new XMLHttpRequest();
            f.overrideMimeType("text/html");
            this.rawDataUris[e] && (e = this.rawDataUris[e]);
            f.open("GET", e, !0);
            f.onload = function () {
              200 == f.status ? b(f.responseText) : c(f.status, f.responseText);
            };
            f.onerror = function () {
              c(f.status, f.responseText);
            };
            f.send();
          };
          k.prototype.downloadBinary = function (e, b, c) {
            var f = new XMLHttpRequest();
            this.rawDataUris[e] && (e = this.rawDataUris[e]);
            f.open("GET", e, !0);
            f.responseType = "arraybuffer";
            f.onload = function () {
              200 == f.status
                ? b(new Uint8Array(f.response))
                : c(f.status, f.responseText);
            };
            f.onerror = function () {
              c(f.status, f.responseText);
            };
            f.send();
          };
          k.prototype.setRawDataURI = function (e, b) {
            this.rawDataUris[this.pathPrefix + e] = b;
          };
          k.prototype.loadBinary = function (e, b, c) {
            var f = this;
            void 0 === b && (b = null);
            void 0 === c && (c = null);
            e = this.pathPrefix + e;
            this.toLoad++;
            this.downloadBinary(
              e,
              function (g) {
                f.assets[e] = g;
                b && b(e, g);
                f.toLoad--;
                f.loaded++;
              },
              function (g, m) {
                f.errors[e] =
                  "Couldn't load binary " + e + ": status " + status + ", " + m;
                c &&
                  c(
                    e,
                    "Couldn't load binary " +
                      e +
                      ": status " +
                      status +
                      ", " +
                      m
                  );
                f.toLoad--;
                f.loaded++;
              }
            );
          };
          k.prototype.loadText = function (e, b, c) {
            var f = this;
            void 0 === b && (b = null);
            void 0 === c && (c = null);
            e = this.pathPrefix + e;
            this.toLoad++;
            this.downloadText(
              e,
              function (g) {
                f.assets[e] = g;
                b && b(e, g);
                f.toLoad--;
                f.loaded++;
              },
              function (g, m) {
                f.errors[e] =
                  "Couldn't load text " + e + ": status " + status + ", " + m;
                c &&
                  c(
                    e,
                    "Couldn't load text " + e + ": status " + status + ", " + m
                  );
                f.toLoad--;
                f.loaded++;
              }
            );
          };
          k.prototype.loadTexture = function (e, b, c) {
            var f = this;
            void 0 === b && (b = null);
            void 0 === c && (c = null);
            var g = (e = this.pathPrefix + e);
            this.toLoad++;
            var m = new Image();
            m.crossOrigin = "anonymous";
            m.onload = function (n) {
              n = f.textureLoader(m);
              f.assets[g] = n;
              f.toLoad--;
              f.loaded++;
              b && b(e, m);
            };
            m.onerror = function (n) {
              f.errors[e] = "Couldn't load image " + e;
              f.toLoad--;
              f.loaded++;
              c && c(e, "Couldn't load image " + e);
            };
            this.rawDataUris[e] && (e = this.rawDataUris[e]);
            m.src = e;
          };
          k.prototype.loadTextureAtlas = function (e, b, c) {
            var f = this;
            void 0 === b && (b = null);
            void 0 === c && (c = null);
            var g =
              0 <= e.lastIndexOf("/") ? e.substring(0, e.lastIndexOf("/")) : "";
            e = this.pathPrefix + e;
            this.toLoad++;
            this.downloadText(
              e,
              function (m) {
                var n = 0,
                  q = [];
                try {
                  new a.TextureAtlas(m, function (v) {
                    q.push("" == g ? v : g + "/" + v);
                    v = document.createElement("img");
                    v.width = 16;
                    v.height = 16;
                    return new a.FakeTexture(v);
                  });
                } catch (v) {
                  var r = v;
                  f.errors[e] =
                    "Couldn't load texture atlas " + e + ": " + r.message;
                  c &&
                    c(e, "Couldn't load texture atlas " + e + ": " + r.message);
                  f.toLoad--;
                  f.loaded++;
                  return;
                }
                r = function (v) {
                  var x = !1;
                  f.loadTexture(
                    v,
                    function (y, z) {
                      n++;
                      if (n == q.length)
                        if (x)
                          (f.errors[e] =
                            "Couldn't load texture atlas page " +
                            y +
                            "} of atlas " +
                            e),
                            c &&
                              c(
                                e,
                                "Couldn't load texture atlas page " +
                                  y +
                                  " of atlas " +
                                  e
                              ),
                            f.toLoad--,
                            f.loaded++;
                        else
                          try {
                            var A = new a.TextureAtlas(m, function (B) {
                              return f.get("" == g ? B : g + "/" + B);
                            });
                            f.assets[e] = A;
                            b && b(e, A);
                            f.toLoad--;
                            f.loaded++;
                          } catch (B) {
                            (y = B),
                              (f.errors[e] =
                                "Couldn't load texture atlas " +
                                e +
                                ": " +
                                y.message),
                              c &&
                                c(
                                  e,
                                  "Couldn't load texture atlas " +
                                    e +
                                    ": " +
                                    y.message
                                ),
                              f.toLoad--,
                              f.loaded++;
                          }
                    },
                    function (y, z) {
                      x = !0;
                      n++;
                      n == q.length &&
                        ((f.errors[e] =
                          "Couldn't load texture atlas page " +
                          y +
                          "} of atlas " +
                          e),
                        c &&
                          c(
                            e,
                            "Couldn't load texture atlas page " +
                              y +
                              " of atlas " +
                              e
                          ),
                        f.toLoad--,
                        f.loaded++);
                    }
                  );
                };
                for (var u = 0; u < q.length; u++) r(q[u]);
              },
              function (m, n) {
                f.errors[e] =
                  "Couldn't load texture atlas " +
                  e +
                  ": status " +
                  status +
                  ", " +
                  n;
                c &&
                  c(
                    e,
                    "Couldn't load texture atlas " +
                      e +
                      ": status " +
                      status +
                      ", " +
                      n
                  );
                f.toLoad--;
                f.loaded++;
              }
            );
          };
          k.prototype.get = function (e) {
            e = this.pathPrefix + e;
            return this.assets[e];
          };
          k.prototype.remove = function (e) {
            e = this.pathPrefix + e;
            var b = this.assets[e];
            b.dispose && b.dispose();
            this.assets[e] = null;
          };
          k.prototype.removeAll = function () {
            for (var e in this.assets) {
              var b = this.assets[e];
              b.dispose && b.dispose();
            }
            this.assets = {};
          };
          k.prototype.isLoadingComplete = function () {
            return 0 == this.toLoad;
          };
          k.prototype.getToLoad = function () {
            return this.toLoad;
          };
          k.prototype.getLoaded = function () {
            return this.loaded;
          };
          k.prototype.dispose = function () {
            this.removeAll();
          };
          k.prototype.hasErrors = function () {
            return 0 < Object.keys(this.errors).length;
          };
          k.prototype.getErrors = function () {
            return this.errors;
          };
          return k;
        })();
        a.AssetManager = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k(e) {
            this.atlas = e;
          }
          k.prototype.newRegionAttachment = function (e, b, c) {
            e = this.atlas.findRegion(c);
            if (null == e)
              throw Error(
                "Region not found in atlas: " +
                  c +
                  " (region attachment: " +
                  b +
                  ")"
              );
            e.renderObject = e;
            b = new a.RegionAttachment(b);
            b.setRegion(e);
            return b;
          };
          k.prototype.newMeshAttachment = function (e, b, c) {
            e = this.atlas.findRegion(c);
            if (null == e)
              throw Error(
                "Region not found in atlas: " +
                  c +
                  " (mesh attachment: " +
                  b +
                  ")"
              );
            e.renderObject = e;
            b = new a.MeshAttachment(b);
            b.region = e;
            return b;
          };
          k.prototype.newBoundingBoxAttachment = function (e, b) {
            return new a.BoundingBoxAttachment(b);
          };
          k.prototype.newPathAttachment = function (e, b) {
            return new a.PathAttachment(b);
          };
          k.prototype.newPointAttachment = function (e, b) {
            return new a.PointAttachment(b);
          };
          k.prototype.newClippingAttachment = function (e, b) {
            return new a.ClippingAttachment(b);
          };
          return k;
        })();
        a.AtlasAttachmentLoader = d;
      })(t || (t = {}));
      (function (a) {
        a = a.BlendMode || (a.BlendMode = {});
        a[(a.Normal = 0)] = "Normal";
        a[(a.Additive = 1)] = "Additive";
        a[(a.Multiply = 2)] = "Multiply";
        a[(a.Screen = 3)] = "Screen";
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k(e, b, c) {
            this.children = [];
            this.ashearY =
              this.ashearX =
              this.ascaleY =
              this.ascaleX =
              this.arotation =
              this.ay =
              this.ax =
              this.shearY =
              this.shearX =
              this.scaleY =
              this.scaleX =
              this.rotation =
              this.y =
              this.x =
                0;
            this.appliedValid = !1;
            this.worldX = this.worldY = this.d = this.c = this.b = this.a = 0;
            this.active = this.sorted = !1;
            if (null == e) throw Error("data cannot be null.");
            if (null == b) throw Error("skeleton cannot be null.");
            this.data = e;
            this.skeleton = b;
            this.parent = c;
            this.setToSetupPose();
          }
          k.prototype.isActive = function () {
            return this.active;
          };
          k.prototype.update = function () {
            this.updateWorldTransformWith(
              this.x,
              this.y,
              this.rotation,
              this.scaleX,
              this.scaleY,
              this.shearX,
              this.shearY
            );
          };
          k.prototype.updateWorldTransform = function () {
            this.updateWorldTransformWith(
              this.x,
              this.y,
              this.rotation,
              this.scaleX,
              this.scaleY,
              this.shearX,
              this.shearY
            );
          };
          k.prototype.updateWorldTransformWith = function (
            e,
            b,
            c,
            f,
            g,
            m,
            n
          ) {
            this.ax = e;
            this.ay = b;
            this.arotation = c;
            this.ascaleX = f;
            this.ascaleY = g;
            this.ashearX = m;
            this.ashearY = n;
            this.appliedValid = !0;
            var q = this.parent;
            if (null == q) {
              var r = this.skeleton;
              n = c + 90 + n;
              var u = r.scaleX,
                v = r.scaleY;
              this.a = a.MathUtils.cosDeg(c + m) * f * u;
              this.b = a.MathUtils.cosDeg(n) * g * u;
              this.c = a.MathUtils.sinDeg(c + m) * f * v;
              this.d = a.MathUtils.sinDeg(n) * g * v;
              this.worldX = e * u + r.x;
              this.worldY = b * v + r.y;
            } else {
              r = q.a;
              u = q.b;
              v = q.c;
              var x = q.d;
              this.worldX = r * e + u * b + q.worldX;
              this.worldY = v * e + x * b + q.worldY;
              switch (this.data.transformMode) {
                case a.TransformMode.Normal:
                  n = c + 90 + n;
                  e = a.MathUtils.cosDeg(c + m) * f;
                  b = a.MathUtils.cosDeg(n) * g;
                  f *= a.MathUtils.sinDeg(c + m);
                  g *= a.MathUtils.sinDeg(n);
                  this.a = r * e + u * f;
                  this.b = r * b + u * g;
                  this.c = v * e + x * f;
                  this.d = v * b + x * g;
                  return;
                case a.TransformMode.OnlyTranslation:
                  n = c + 90 + n;
                  this.a = a.MathUtils.cosDeg(c + m) * f;
                  this.b = a.MathUtils.cosDeg(n) * g;
                  this.c = a.MathUtils.sinDeg(c + m) * f;
                  this.d = a.MathUtils.sinDeg(n) * g;
                  break;
                case a.TransformMode.NoRotationOrReflection:
                  e = r * r + v * v;
                  1e-4 < e
                    ? ((e = Math.abs(r * x - u * v) / e),
                      (r /= this.skeleton.scaleX),
                      (v /= this.skeleton.scaleY),
                      (u = v * e),
                      (x = r * e),
                      (e = Math.atan2(v, r) * a.MathUtils.radDeg))
                    : ((v = r = 0),
                      (e = 90 - Math.atan2(x, u) * a.MathUtils.radDeg));
                  m = c + m - e;
                  n = c + n - e + 90;
                  e = a.MathUtils.cosDeg(m) * f;
                  b = a.MathUtils.cosDeg(n) * g;
                  f *= a.MathUtils.sinDeg(m);
                  g *= a.MathUtils.sinDeg(n);
                  this.a = r * e - u * f;
                  this.b = r * b - u * g;
                  this.c = v * e + x * f;
                  this.d = v * b + x * g;
                  break;
                case a.TransformMode.NoScale:
                case a.TransformMode.NoScaleOrReflection:
                  (e = a.MathUtils.cosDeg(c)),
                    (b = a.MathUtils.sinDeg(c)),
                    (c = (r * e + u * b) / this.skeleton.scaleX),
                    (q = (v * e + x * b) / this.skeleton.scaleY),
                    (e = Math.sqrt(c * c + q * q)),
                    1e-5 < e && (e = 1 / e),
                    (c *= e),
                    (q *= e),
                    (e = Math.sqrt(c * c + q * q)),
                    this.data.transformMode == a.TransformMode.NoScale &&
                      0 > r * x - u * v !=
                        (0 > this.skeleton.scaleX !=
                          0 > this.skeleton.scaleY) &&
                      (e = -e),
                    (u = Math.PI / 2 + Math.atan2(q, c)),
                    (r = Math.cos(u) * e),
                    (u = Math.sin(u) * e),
                    (e = a.MathUtils.cosDeg(m) * f),
                    (b = a.MathUtils.cosDeg(90 + n) * g),
                    (f *= a.MathUtils.sinDeg(m)),
                    (g *= a.MathUtils.sinDeg(90 + n)),
                    (this.a = c * e + r * f),
                    (this.b = c * b + r * g),
                    (this.c = q * e + u * f),
                    (this.d = q * b + u * g);
              }
              this.a *= this.skeleton.scaleX;
              this.b *= this.skeleton.scaleX;
              this.c *= this.skeleton.scaleY;
              this.d *= this.skeleton.scaleY;
            }
          };
          k.prototype.setToSetupPose = function () {
            var e = this.data;
            this.x = e.x;
            this.y = e.y;
            this.rotation = e.rotation;
            this.scaleX = e.scaleX;
            this.scaleY = e.scaleY;
            this.shearX = e.shearX;
            this.shearY = e.shearY;
          };
          k.prototype.getWorldRotationX = function () {
            return Math.atan2(this.c, this.a) * a.MathUtils.radDeg;
          };
          k.prototype.getWorldRotationY = function () {
            return Math.atan2(this.d, this.b) * a.MathUtils.radDeg;
          };
          k.prototype.getWorldScaleX = function () {
            return Math.sqrt(this.a * this.a + this.c * this.c);
          };
          k.prototype.getWorldScaleY = function () {
            return Math.sqrt(this.b * this.b + this.d * this.d);
          };
          k.prototype.updateAppliedTransform = function () {
            this.appliedValid = !0;
            var e = this.parent;
            if (null == e)
              (this.ax = this.worldX),
                (this.ay = this.worldY),
                (this.arotation =
                  Math.atan2(this.c, this.a) * a.MathUtils.radDeg),
                (this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c)),
                (this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d)),
                (this.ashearX = 0),
                (this.ashearY =
                  Math.atan2(
                    this.a * this.b + this.c * this.d,
                    this.a * this.d - this.b * this.c
                  ) * a.MathUtils.radDeg);
            else {
              var b = e.a,
                c = e.b,
                f = e.c,
                g = e.d,
                m = 1 / (b * g - c * f),
                n = this.worldX - e.worldX;
              e = this.worldY - e.worldY;
              this.ax = n * g * m - e * c * m;
              this.ay = e * b * m - n * f * m;
              g *= m;
              b *= m;
              c *= m;
              m *= f;
              f = g * this.a - c * this.c;
              c = g * this.b - c * this.d;
              g = b * this.c - m * this.a;
              m = b * this.d - m * this.b;
              this.ashearX = 0;
              this.ascaleX = Math.sqrt(f * f + g * g);
              1e-4 < this.ascaleX
                ? ((b = f * m - c * g),
                  (this.ascaleY = b / this.ascaleX),
                  (this.ashearY =
                    Math.atan2(f * c + g * m, b) * a.MathUtils.radDeg),
                  (this.arotation = Math.atan2(g, f) * a.MathUtils.radDeg))
                : ((this.ascaleX = 0),
                  (this.ascaleY = Math.sqrt(c * c + m * m)),
                  (this.ashearY = 0),
                  (this.arotation =
                    90 - Math.atan2(m, c) * a.MathUtils.radDeg));
            }
          };
          k.prototype.worldToLocal = function (e) {
            var b = this.a,
              c = this.b,
              f = this.c,
              g = this.d,
              m = 1 / (b * g - c * f),
              n = e.x - this.worldX,
              q = e.y - this.worldY;
            e.x = n * g * m - q * c * m;
            e.y = q * b * m - n * f * m;
            return e;
          };
          k.prototype.localToWorld = function (e) {
            var b = e.x,
              c = e.y;
            e.x = b * this.a + c * this.b + this.worldX;
            e.y = b * this.c + c * this.d + this.worldY;
            return e;
          };
          k.prototype.worldToLocalRotation = function (e) {
            var b = a.MathUtils.sinDeg(e);
            e = a.MathUtils.cosDeg(e);
            return (
              Math.atan2(this.a * b - this.c * e, this.d * e - this.b * b) *
                a.MathUtils.radDeg +
              this.rotation -
              this.shearX
            );
          };
          k.prototype.localToWorldRotation = function (e) {
            e -= this.rotation - this.shearX;
            var b = a.MathUtils.sinDeg(e);
            e = a.MathUtils.cosDeg(e);
            return (
              Math.atan2(e * this.c + b * this.d, e * this.a + b * this.b) *
              a.MathUtils.radDeg
            );
          };
          k.prototype.rotateWorld = function (e) {
            var b = this.a,
              c = this.b,
              f = this.c,
              g = this.d,
              m = a.MathUtils.cosDeg(e);
            e = a.MathUtils.sinDeg(e);
            this.a = m * b - e * f;
            this.b = m * c - e * g;
            this.c = e * b + m * f;
            this.d = e * c + m * g;
            this.appliedValid = !1;
          };
          return k;
        })();
        a.Bone = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          return function (e, b, c) {
            this.rotation = this.y = this.x = 0;
            this.scaleY = this.scaleX = 1;
            this.shearY = this.shearX = 0;
            this.transformMode = k.Normal;
            this.skinRequired = !1;
            this.color = new a.Color();
            if (0 > e) throw Error("index must be >= 0.");
            if (null == b) throw Error("name cannot be null.");
            this.index = e;
            this.name = b;
            this.parent = c;
          };
        })();
        a.BoneData = d;
        var k;
        (function (e) {
          e[(e.Normal = 0)] = "Normal";
          e[(e.OnlyTranslation = 1)] = "OnlyTranslation";
          e[(e.NoRotationOrReflection = 2)] = "NoRotationOrReflection";
          e[(e.NoScale = 3)] = "NoScale";
          e[(e.NoScaleOrReflection = 4)] = "NoScaleOrReflection";
        })((k = a.TransformMode || (a.TransformMode = {})));
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          return function (k, e, b) {
            this.name = k;
            this.order = e;
            this.skinRequired = b;
          };
        })();
        a.ConstraintData = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          return function (k, e) {
            if (null == e) throw Error("data cannot be null.");
            this.time = k;
            this.data = e;
          };
        })();
        a.Event = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          return function (k) {
            this.name = k;
          };
        })();
        a.EventData = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k(e, b) {
            this.bendDirection = 0;
            this.stretch = this.compress = !1;
            this.mix = 1;
            this.softness = 0;
            this.active = !1;
            if (null == e) throw Error("data cannot be null.");
            if (null == b) throw Error("skeleton cannot be null.");
            this.data = e;
            this.mix = e.mix;
            this.softness = e.softness;
            this.bendDirection = e.bendDirection;
            this.compress = e.compress;
            this.stretch = e.stretch;
            this.bones = [];
            for (var c = 0; c < e.bones.length; c++)
              this.bones.push(b.findBone(e.bones[c].name));
            this.target = b.findBone(e.target.name);
          }
          k.prototype.isActive = function () {
            return this.active;
          };
          k.prototype.apply = function () {
            this.update();
          };
          k.prototype.update = function () {
            var e = this.target,
              b = this.bones;
            switch (b.length) {
              case 1:
                this.apply1(
                  b[0],
                  e.worldX,
                  e.worldY,
                  this.compress,
                  this.stretch,
                  this.data.uniform,
                  this.mix
                );
                break;
              case 2:
                this.apply2(
                  b[0],
                  b[1],
                  e.worldX,
                  e.worldY,
                  this.bendDirection,
                  this.stretch,
                  this.softness,
                  this.mix
                );
            }
          };
          k.prototype.apply1 = function (e, b, c, f, g, m, n) {
            e.appliedValid || e.updateAppliedTransform();
            var q = e.parent,
              r = q.a,
              u = q.b,
              v = q.c,
              x = q.d,
              y = -e.ashearX - e.arotation;
            switch (e.data.transformMode) {
              case a.TransformMode.OnlyTranslation:
                u = b - e.worldX;
                x = c - e.worldY;
                break;
              case a.TransformMode.NoRotationOrReflection:
                x = Math.abs(r * x - u * v) / (r * r + v * v);
                var z = r / e.skeleton.scaleX,
                  A = v / e.skeleton.scaleY;
                u = -A * x * e.skeleton.scaleX;
                x = z * x * e.skeleton.scaleY;
                y += Math.atan2(A, z) * a.MathUtils.radDeg;
              default:
                (z = b - q.worldX),
                  (q = c - q.worldY),
                  (A = r * x - u * v),
                  (u = (z * x - q * u) / A - e.ax),
                  (x = (q * r - z * v) / A - e.ay);
            }
            y += Math.atan2(x, u) * a.MathUtils.radDeg;
            0 > e.ascaleX && (y += 180);
            180 < y ? (y -= 360) : -180 > y && (y += 360);
            r = e.ascaleX;
            v = e.ascaleY;
            if (f || g) {
              switch (e.data.transformMode) {
                case a.TransformMode.NoScale:
                case a.TransformMode.NoScaleOrReflection:
                  (u = b - e.worldX), (x = c - e.worldY);
              }
              b = e.data.length * r;
              c = Math.sqrt(u * u + x * x);
              if ((f && c < b) || (g && c > b && 1e-4 < b))
                (x = (c / b - 1) * n + 1), (r *= x), m && (v *= x);
            }
            e.updateWorldTransformWith(
              e.ax,
              e.ay,
              e.arotation + y * n,
              r,
              v,
              e.ashearX,
              e.ashearY
            );
          };
          k.prototype.apply2 = function (e, b, c, f, g, m, n, q) {
            if (0 == q) b.updateWorldTransform();
            else {
              e.appliedValid || e.updateAppliedTransform();
              b.appliedValid || b.updateAppliedTransform();
              var r = e.ax,
                u = e.ay,
                v = e.ascaleX,
                x = v,
                y = e.ascaleY,
                z = b.ascaleX;
              if (0 > v) {
                v = -v;
                var A = 180;
                var B = -1;
              } else (A = 0), (B = 1);
              0 > y && ((y = -y), (B = -B));
              if (0 > z) {
                z = -z;
                var D = 180;
              } else D = 0;
              var E = b.ax,
                C = e.a,
                F = e.b,
                G = e.c,
                H = e.d,
                K = 1e-4 >= Math.abs(v - y);
              if (K) {
                var I = b.ay;
                var M = C * E + F * I + e.worldX;
                var N = G * E + H * I + e.worldY;
              } else (I = 0), (M = C * E + e.worldX), (N = G * E + e.worldY);
              var P = e.parent;
              C = P.a;
              F = P.b;
              G = P.c;
              H = P.d;
              var J = 1 / (C * H - F * G),
                L = M - P.worldX;
              M = N - P.worldY;
              N = (L * H - M * F) * J - r;
              M = (M * C - L * G) * J - u;
              N = Math.sqrt(N * N + M * M);
              var O = b.data.length * z;
              if (1e-4 > N)
                this.apply1(e, c, f, !1, m, !1, q),
                  b.updateWorldTransformWith(
                    E,
                    I,
                    0,
                    b.ascaleX,
                    b.ascaleY,
                    b.ashearX,
                    b.ashearY
                  );
              else {
                L = c - P.worldX;
                M = f - P.worldY;
                H = (L * H - M * F) * J - r;
                G = (M * C - L * G) * J - u;
                J = H * H + G * G;
                0 != n &&
                  ((n *= (v * (z + 1)) / 2),
                  (C = Math.sqrt(J)),
                  (F = C - N - O * v + n),
                  0 < F &&
                    ((J = Math.min(1, F / (2 * n)) - 1),
                    (J = (F - n * (1 - J * J)) / C),
                    (H -= J * H),
                    (G -= J * G),
                    (J = H * H + G * G)));
                a: if (K)
                  (O *= v),
                    (C = (J - N * N - O * O) / (2 * N * O)),
                    -1 > C
                      ? (C = -1)
                      : 1 < C &&
                        ((C = 1),
                        m && (x *= (Math.sqrt(J) / (N + O) - 1) * q + 1)),
                    (g *= Math.acos(C)),
                    (C = N + O * C),
                    (F = O * Math.sin(g)),
                    (C = Math.atan2(G * C - H * F, H * C + G * F));
                else {
                  C = v * O;
                  F = y * O;
                  M = C * C;
                  L = F * F;
                  m = Math.atan2(G, H);
                  G = L * N * N + M * J - M * L;
                  n = -2 * L * N;
                  K = L - M;
                  H = n * n - 4 * K * G;
                  if (
                    0 <= H &&
                    ((H = Math.sqrt(H)),
                    0 > n && (H = -H),
                    (H = -(n + H) / 2),
                    (n = H / K),
                    (G /= H),
                    (G = Math.abs(n) < Math.abs(G) ? n : G),
                    G * G <= J)
                  ) {
                    M = Math.sqrt(J - G * G) * g;
                    C = m - Math.atan2(M, G);
                    g = Math.atan2(M / y, (G - N) / v);
                    break a;
                  }
                  v = a.MathUtils.PI;
                  n = N - C;
                  K = n * n;
                  y = O = 0;
                  z = N + C;
                  c = z * z;
                  f = 0;
                  G = (-C * N) / (M - L);
                  -1 <= G &&
                    1 >= G &&
                    ((G = Math.acos(G)),
                    (L = C * Math.cos(G) + N),
                    (M = F * Math.sin(G)),
                    (H = L * L + M * M),
                    H < K && ((v = G), (K = H), (n = L), (O = M)),
                    H > c && ((y = G), (c = H), (z = L), (f = M)));
                  J <= (K + c) / 2
                    ? ((C = m - Math.atan2(O * g, n)), (g *= v))
                    : ((C = m - Math.atan2(f * g, z)), (g *= y));
                }
                N = Math.atan2(I, E) * B;
                F = e.arotation;
                C = (C - N) * a.MathUtils.radDeg + A - F;
                180 < C ? (C -= 360) : -180 > C && (C += 360);
                e.updateWorldTransformWith(r, u, F + C * q, x, e.ascaleY, 0, 0);
                F = b.arotation;
                g = ((g + N) * a.MathUtils.radDeg - b.ashearX) * B + D - F;
                180 < g ? (g -= 360) : -180 > g && (g += 360);
                b.updateWorldTransformWith(
                  E,
                  I,
                  F + g * q,
                  b.ascaleX,
                  b.ascaleY,
                  b.ashearX,
                  b.ashearY
                );
              }
            }
          };
          return k;
        })();
        a.IkConstraint = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function (k) {
          function e(b) {
            b = k.call(this, b, 0, !1) || this;
            b.bones = [];
            b.bendDirection = 1;
            b.compress = !1;
            b.stretch = !1;
            b.uniform = !1;
            b.mix = 1;
            b.softness = 0;
            return b;
          }
          h(e, k);
          return e;
        })(a.ConstraintData);
        a.IkConstraintData = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k(e, b) {
            this.translateMix =
              this.rotateMix =
              this.spacing =
              this.position =
                0;
            this.spaces = [];
            this.positions = [];
            this.world = [];
            this.curves = [];
            this.lengths = [];
            this.segments = [];
            this.active = !1;
            if (null == e) throw Error("data cannot be null.");
            if (null == b) throw Error("skeleton cannot be null.");
            this.data = e;
            this.bones = [];
            for (var c = 0, f = e.bones.length; c < f; c++)
              this.bones.push(b.findBone(e.bones[c].name));
            this.target = b.findSlot(e.target.name);
            this.position = e.position;
            this.spacing = e.spacing;
            this.rotateMix = e.rotateMix;
            this.translateMix = e.translateMix;
          }
          k.prototype.isActive = function () {
            return this.active;
          };
          k.prototype.apply = function () {
            this.update();
          };
          k.prototype.update = function () {
            var e = this.target.getAttachment();
            if (e instanceof a.PathAttachment) {
              var b = this.rotateMix,
                c = this.translateMix,
                f = 0 < b;
              if (0 < c || f) {
                var g = this.data,
                  m = g.spacingMode == a.SpacingMode.Percent,
                  n = g.rotateMode,
                  q = n == a.RotateMode.Tangent,
                  r = n == a.RotateMode.ChainScale,
                  u = this.bones.length,
                  v = q ? u : u + 1,
                  x = this.bones,
                  y = a.Utils.setArraySize(this.spaces, v),
                  z = null,
                  A = this.spacing;
                if (r || !m) {
                  r && (z = a.Utils.setArraySize(this.lengths, u));
                  for (
                    var B = g.spacingMode == a.SpacingMode.Length,
                      D = 0,
                      E = v - 1;
                    D < E;

                  ) {
                    var C = x[D],
                      F = C.data.length;
                    if (F < k.epsilon) r && (z[D] = 0), (y[++D] = 0);
                    else if (m) {
                      if (r) {
                        var G = F * C.a,
                          H = F * C.c;
                        z[D] = Math.sqrt(G * G + H * H);
                      }
                      y[++D] = A;
                    } else
                      (G = F * C.a),
                        (H = F * C.c),
                        (C = Math.sqrt(G * G + H * H)),
                        r && (z[D] = C),
                        (y[++D] = ((B ? F + A : A) * C) / F);
                  }
                } else for (D = 1; D < v; D++) y[D] = A;
                e = this.computeWorldPositions(
                  e,
                  v,
                  q,
                  g.positionMode == a.PositionMode.Percent,
                  m
                );
                m = e[0];
                v = e[1];
                g = g.offsetRotation;
                0 == g
                  ? (n = n == a.RotateMode.Chain)
                  : ((n = !1),
                    (A = this.target.bone),
                    (g *=
                      0 < A.a * A.d - A.b * A.c
                        ? a.MathUtils.degRad
                        : -a.MathUtils.degRad));
                D = 0;
                for (A = 3; D < u; D++, A += 3) {
                  C = x[D];
                  C.worldX += (m - C.worldX) * c;
                  C.worldY += (v - C.worldY) * c;
                  G = e[A];
                  H = e[A + 1];
                  B = G - m;
                  E = H - v;
                  r &&
                    ((m = z[D]),
                    0 != m &&
                      ((m = (Math.sqrt(B * B + E * E) / m - 1) * b + 1),
                      (C.a *= m),
                      (C.c *= m)));
                  m = G;
                  v = H;
                  if (f) {
                    G = C.a;
                    H = C.b;
                    F = C.c;
                    var K = C.d;
                    var I = q
                      ? e[A - 1]
                      : 0 == y[D + 1]
                      ? e[A + 2]
                      : Math.atan2(E, B);
                    I -= Math.atan2(F, G);
                    if (n) {
                      var M = Math.cos(I);
                      var N = Math.sin(I);
                      var P = C.data.length;
                      m += (P * (M * G - N * F) - B) * b;
                      v += (P * (N * G + M * F) - E) * b;
                    } else I += g;
                    I > a.MathUtils.PI
                      ? (I -= a.MathUtils.PI2)
                      : I < -a.MathUtils.PI && (I += a.MathUtils.PI2);
                    I *= b;
                    M = Math.cos(I);
                    N = Math.sin(I);
                    C.a = M * G - N * F;
                    C.b = M * H - N * K;
                    C.c = N * G + M * F;
                    C.d = N * H + M * K;
                  }
                  C.appliedValid = !1;
                }
              }
            }
          };
          k.prototype.computeWorldPositions = function (e, b, c, f, g) {
            var m = this.target,
              n = this.position,
              q = this.spaces,
              r = a.Utils.setArraySize(this.positions, 3 * b + 2),
              u = e.closed,
              v = e.worldVerticesLength,
              x = v / 6,
              y = k.NONE;
            if (!e.constantSpeed) {
              var z = e.lengths;
              x -= u ? 1 : 2;
              var A = z[x];
              f && (n *= A);
              if (g) for (var B = 1; B < b; B++) q[B] *= A;
              var D = a.Utils.setArraySize(this.world, 8);
              for (g = f = B = 0; B < b; B++, f += 3) {
                var E = q[B],
                  C = (n += E);
                if (u) (C %= A), 0 > C && (C += A), (g = 0);
                else if (0 > C) {
                  y != k.BEFORE &&
                    ((y = k.BEFORE), e.computeWorldVertices(m, 2, 4, D, 0, 2));
                  this.addBeforePosition(C, D, 0, r, f);
                  continue;
                } else if (C > A) {
                  y != k.AFTER &&
                    ((y = k.AFTER),
                    e.computeWorldVertices(m, v - 6, 4, D, 0, 2));
                  this.addAfterPosition(C - A, D, 0, r, f);
                  continue;
                }
                for (; ; g++) {
                  var F = z[g];
                  if (!(C > F)) {
                    if (0 == g) C /= F;
                    else {
                      var G = z[g - 1];
                      C = (C - G) / (F - G);
                    }
                    break;
                  }
                }
                g != y &&
                  ((y = g),
                  u && g == x
                    ? (e.computeWorldVertices(m, v - 4, 4, D, 0, 2),
                      e.computeWorldVertices(m, 0, 4, D, 4, 2))
                    : e.computeWorldVertices(m, 6 * g + 2, 8, D, 0, 2));
                this.addCurvePosition(
                  C,
                  D[0],
                  D[1],
                  D[2],
                  D[3],
                  D[4],
                  D[5],
                  D[6],
                  D[7],
                  r,
                  f,
                  c || (0 < B && 0 == E)
                );
              }
              return r;
            }
            u
              ? ((v += 2),
                (D = a.Utils.setArraySize(this.world, v)),
                e.computeWorldVertices(m, 2, v - 4, D, 0, 2),
                e.computeWorldVertices(m, 0, 2, D, v - 4, 2),
                (D[v - 2] = D[0]),
                (D[v - 1] = D[1]))
              : (x--,
                (v -= 4),
                (D = a.Utils.setArraySize(this.world, v)),
                e.computeWorldVertices(m, 2, v, D, 0, 2));
            m = a.Utils.setArraySize(this.curves, x);
            z = 0;
            A = D[0];
            F = D[1];
            var H = 0,
              K = 0,
              I = 0,
              M = 0,
              N = 0,
              P = 0;
            B = 0;
            for (E = 2; B < x; B++, E += 6) {
              H = D[E];
              K = D[E + 1];
              I = D[E + 2];
              M = D[E + 3];
              N = D[E + 4];
              P = D[E + 5];
              var J = 0.1875 * (A - 2 * H + I);
              var L = 0.1875 * (F - 2 * K + M);
              G = 0.09375 * (3 * (H - I) - A + N);
              var O = 0.09375 * (3 * (K - M) - F + P);
              var Q = 2 * J + G;
              var S = 2 * L + O;
              J = 0.75 * (H - A) + J + 0.16666667 * G;
              L = 0.75 * (K - F) + L + 0.16666667 * O;
              z += Math.sqrt(J * J + L * L);
              J += Q;
              L += S;
              Q += G;
              S += O;
              z += Math.sqrt(J * J + L * L);
              J += Q;
              L += S;
              z += Math.sqrt(J * J + L * L);
              J += Q + G;
              L += S + O;
              z += Math.sqrt(J * J + L * L);
              m[B] = z;
              A = N;
              F = P;
            }
            n = f ? n * z : (z / e.lengths[x - 1]) * n;
            if (g) for (B = 1; B < b; B++) q[B] *= z;
            e = this.segments;
            for (O = g = f = B = x = 0; B < b; B++, f += 3) {
              E = q[B];
              C = n += E;
              if (u) (C %= z), 0 > C && (C += z), (g = 0);
              else if (0 > C) {
                this.addBeforePosition(C, D, 0, r, f);
                continue;
              } else if (C > z) {
                this.addAfterPosition(C - z, D, v - 4, r, f);
                continue;
              }
              for (; ; g++)
                if (((Q = m[g]), !(C > Q))) {
                  0 == g ? (C /= Q) : ((G = m[g - 1]), (C = (C - G) / (Q - G)));
                  break;
                }
              if (g != y) {
                y = g;
                var R = 6 * g;
                A = D[R];
                F = D[R + 1];
                H = D[R + 2];
                K = D[R + 3];
                I = D[R + 4];
                M = D[R + 5];
                N = D[R + 6];
                P = D[R + 7];
                J = 0.03 * (A - 2 * H + I);
                L = 0.03 * (F - 2 * K + M);
                G = 0.006 * (3 * (H - I) - A + N);
                O = 0.006 * (3 * (K - M) - F + P);
                Q = 2 * J + G;
                S = 2 * L + O;
                J = 0.3 * (H - A) + J + 0.16666667 * G;
                L = 0.3 * (K - F) + L + 0.16666667 * O;
                x = Math.sqrt(J * J + L * L);
                e[0] = x;
                for (R = 1; 8 > R; R++)
                  (J += Q),
                    (L += S),
                    (Q += G),
                    (S += O),
                    (x += Math.sqrt(J * J + L * L)),
                    (e[R] = x);
                J += Q;
                L += S;
                x += Math.sqrt(J * J + L * L);
                e[8] = x;
                J += Q + G;
                L += S + O;
                x += Math.sqrt(J * J + L * L);
                e[9] = x;
                O = 0;
              }
              for (C *= x; ; O++)
                if (((Q = e[O]), !(C > Q))) {
                  0 == O
                    ? (C /= Q)
                    : ((G = e[O - 1]), (C = O + (C - G) / (Q - G)));
                  break;
                }
              this.addCurvePosition(
                0.1 * C,
                A,
                F,
                H,
                K,
                I,
                M,
                N,
                P,
                r,
                f,
                c || (0 < B && 0 == E)
              );
            }
            return r;
          };
          k.prototype.addBeforePosition = function (e, b, c, f, g) {
            var m = b[c],
              n = b[c + 1];
            b = Math.atan2(b[c + 3] - n, b[c + 2] - m);
            f[g] = m + e * Math.cos(b);
            f[g + 1] = n + e * Math.sin(b);
            f[g + 2] = b;
          };
          k.prototype.addAfterPosition = function (e, b, c, f, g) {
            var m = b[c + 2],
              n = b[c + 3];
            b = Math.atan2(n - b[c + 1], m - b[c]);
            f[g] = m + e * Math.cos(b);
            f[g + 1] = n + e * Math.sin(b);
            f[g + 2] = b;
          };
          k.prototype.addCurvePosition = function (
            e,
            b,
            c,
            f,
            g,
            m,
            n,
            q,
            r,
            u,
            v,
            x
          ) {
            if (0 == e || isNaN(e))
              (u[v] = b), (u[v + 1] = c), (u[v + 2] = Math.atan2(g - c, f - b));
            else {
              var y = e * e,
                z = y * e,
                A = 1 - e,
                B = A * A,
                D = B * A,
                E = A * e,
                C = 3 * E;
              A *= C;
              C *= e;
              q = b * D + f * A + m * C + q * z;
              r = c * D + g * A + n * C + r * z;
              u[v] = q;
              u[v + 1] = r;
              x &&
                (u[v + 2] =
                  0.001 > e
                    ? Math.atan2(g - c, f - b)
                    : Math.atan2(
                        r - (c * B + g * E * 2 + n * y),
                        q - (b * B + f * E * 2 + m * y)
                      ));
            }
          };
          k.NONE = -1;
          k.BEFORE = -2;
          k.AFTER = -3;
          k.epsilon = 1e-5;
          return k;
        })();
        a.PathConstraint = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function (k) {
          function e(b) {
            b = k.call(this, b, 0, !1) || this;
            b.bones = [];
            return b;
          }
          h(e, k);
          return e;
        })(a.ConstraintData);
        a.PathConstraintData = d;
        (function (k) {
          k[(k.Fixed = 0)] = "Fixed";
          k[(k.Percent = 1)] = "Percent";
        })(a.PositionMode || (a.PositionMode = {}));
        (function (k) {
          k[(k.Length = 0)] = "Length";
          k[(k.Fixed = 1)] = "Fixed";
          k[(k.Percent = 2)] = "Percent";
        })(a.SpacingMode || (a.SpacingMode = {}));
        (function (k) {
          k[(k.Tangent = 0)] = "Tangent";
          k[(k.Chain = 1)] = "Chain";
          k[(k.ChainScale = 2)] = "ChainScale";
        })(a.RotateMode || (a.RotateMode = {}));
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
            function e(b) {
              this.toLoad = [];
              this.assets = {};
              this.clientId = b;
            }
            e.prototype.loaded = function () {
              var b = 0,
                c;
              for (c in this.assets) b++;
              return b;
            };
            return e;
          })(),
          k = (function () {
            function e(b) {
              void 0 === b && (b = "");
              this.clientAssets = {};
              this.queuedAssets = {};
              this.rawAssets = {};
              this.errors = {};
              this.pathPrefix = b;
            }
            e.prototype.queueAsset = function (b, c, f) {
              var g = this.clientAssets[b];
              if (null === g || void 0 === g)
                (g = new d(b)), (this.clientAssets[b] = g);
              null !== c && (g.textureLoader = c);
              g.toLoad.push(f);
              if (this.queuedAssets[f] === f) return !1;
              this.queuedAssets[f] = f;
              return !0;
            };
            e.prototype.loadText = function (b, c) {
              var f = this;
              c = this.pathPrefix + c;
              if (this.queueAsset(b, null, c)) {
                var g = new XMLHttpRequest();
                g.overrideMimeType("text/html");
                g.onreadystatechange = function () {
                  g.readyState == XMLHttpRequest.DONE &&
                    (200 <= g.status && 300 > g.status
                      ? (f.rawAssets[c] = g.responseText)
                      : (f.errors[c] =
                          "Couldn't load text " +
                          c +
                          ": status " +
                          g.status +
                          ", " +
                          g.responseText));
                };
                g.open("GET", c, !0);
                g.send();
              }
            };
            e.prototype.loadJson = function (b, c) {
              var f = this;
              c = this.pathPrefix + c;
              if (this.queueAsset(b, null, c)) {
                var g = new XMLHttpRequest();
                g.overrideMimeType("text/html");
                g.onreadystatechange = function () {
                  g.readyState == XMLHttpRequest.DONE &&
                    (200 <= g.status && 300 > g.status
                      ? (f.rawAssets[c] = JSON.parse(g.responseText))
                      : (f.errors[c] =
                          "Couldn't load text " +
                          c +
                          ": status " +
                          g.status +
                          ", " +
                          g.responseText));
                };
                g.open("GET", c, !0);
                g.send();
              }
            };
            e.prototype.loadTexture = function (b, c, f) {
              var g = this;
              f = this.pathPrefix + f;
              if (this.queueAsset(b, c, f))
                if (
                  ("undefined" !== typeof window &&
                    "undefined" !== typeof navigator &&
                    window.document) ||
                  "undefined" === typeof importScripts
                ) {
                  var m = new Image();
                  m.crossOrigin = "anonymous";
                  m.onload = function (n) {
                    g.rawAssets[f] = m;
                  };
                  m.onerror = function (n) {
                    g.errors[f] = "Couldn't load image " + f;
                  };
                  m.src = f;
                } else
                  fetch(f, {
                    mode: "cors",
                  })
                    .then(function (n) {
                      n.ok || (g.errors[f] = "Couldn't load image " + f);
                      return n.blob();
                    })
                    .then(function (n) {
                      return createImageBitmap(n, {
                        premultiplyAlpha: "none",
                        colorSpaceConversion: "none",
                      });
                    })
                    .then(function (n) {
                      g.rawAssets[f] = n;
                    });
            };
            e.prototype.get = function (b, c) {
              c = this.pathPrefix + c;
              b = this.clientAssets[b];
              return null === b || void 0 === b ? !0 : b.assets[c];
            };
            e.prototype.updateClientAssets = function (b) {
              for (
                var c =
                    !(
                      "undefined" !== typeof window &&
                      "undefined" !== typeof navigator &&
                      window.document
                    ) && "undefined" !== typeof importScripts,
                  f = 0;
                f < b.toLoad.length;
                f++
              ) {
                var g = b.toLoad[f],
                  m = b.assets[g];
                if (null === m || void 0 === m)
                  (m = this.rawAssets[g]),
                    null !== m &&
                      void 0 !== m &&
                      (b.assets[g] = c
                        ? m instanceof ImageBitmap
                          ? b.textureLoader(m)
                          : m
                        : m instanceof HTMLImageElement
                        ? b.textureLoader(m)
                        : m);
              }
            };
            e.prototype.isLoadingComplete = function (b) {
              b = this.clientAssets[b];
              if (null === b || void 0 === b) return !0;
              this.updateClientAssets(b);
              return b.toLoad.length == b.loaded();
            };
            e.prototype.dispose = function () {};
            e.prototype.hasErrors = function () {
              return 0 < Object.keys(this.errors).length;
            };
            e.prototype.getErrors = function () {
              return this.errors;
            };
            return e;
          })();
        a.SharedAssetManager = k;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k(e) {
            this._updateCache = [];
            this.updateCacheReset = [];
            this.time = 0;
            this.scaleY = this.scaleX = 1;
            this.y = this.x = 0;
            if (null == e) throw Error("data cannot be null.");
            this.data = e;
            this.bones = [];
            for (var b = 0; b < e.bones.length; b++) {
              var c = e.bones[b];
              if (null == c.parent) c = new a.Bone(c, this, null);
              else {
                var f = this.bones[c.parent.index];
                c = new a.Bone(c, this, f);
                f.children.push(c);
              }
              this.bones.push(c);
            }
            this.slots = [];
            this.drawOrder = [];
            for (b = 0; b < e.slots.length; b++)
              (f = e.slots[b]),
                (c = this.bones[f.boneData.index]),
                (c = new a.Slot(f, c)),
                this.slots.push(c),
                this.drawOrder.push(c);
            this.ikConstraints = [];
            for (b = 0; b < e.ikConstraints.length; b++)
              this.ikConstraints.push(
                new a.IkConstraint(e.ikConstraints[b], this)
              );
            this.transformConstraints = [];
            for (b = 0; b < e.transformConstraints.length; b++)
              this.transformConstraints.push(
                new a.TransformConstraint(e.transformConstraints[b], this)
              );
            this.pathConstraints = [];
            for (b = 0; b < e.pathConstraints.length; b++)
              this.pathConstraints.push(
                new a.PathConstraint(e.pathConstraints[b], this)
              );
            this.color = new a.Color(1, 1, 1, 1);
            this.updateCache();
          }
          k.prototype.updateCache = function () {
            this._updateCache.length = 0;
            this.updateCacheReset.length = 0;
            for (var e = this.bones, b = 0, c = e.length; b < c; b++) {
              var f = e[b];
              f.sorted = f.data.skinRequired;
              f.active = !f.sorted;
            }
            if (null != this.skin) {
              var g = this.skin.bones;
              b = 0;
              for (c = this.skin.bones.length; b < c; b++) {
                f = this.bones[g[b].index];
                do (f.sorted = !1), (f.active = !0), (f = f.parent);
                while (null != f);
              }
            }
            c = this.ikConstraints;
            f = this.transformConstraints;
            g = this.pathConstraints;
            var m = c.length,
              n = f.length,
              q = g.length,
              r = m + n + q;
            b = 0;
            a: for (; b < r; b++) {
              for (var u = 0; u < m; u++) {
                var v = c[u];
                if (v.data.order == b) {
                  this.sortIkConstraint(v);
                  continue a;
                }
              }
              for (u = 0; u < n; u++)
                if (((v = f[u]), v.data.order == b)) {
                  this.sortTransformConstraint(v);
                  continue a;
                }
              for (u = 0; u < q; u++)
                if (((v = g[u]), v.data.order == b)) {
                  this.sortPathConstraint(v);
                  continue a;
                }
            }
            b = 0;
            for (c = e.length; b < c; b++) this.sortBone(e[b]);
          };
          k.prototype.sortIkConstraint = function (e) {
            e.active =
              e.target.isActive() &&
              (!e.data.skinRequired ||
                (null != this.skin &&
                  a.Utils.contains(this.skin.constraints, e.data, !0)));
            if (e.active) {
              this.sortBone(e.target);
              var b = e.bones,
                c = b[0];
              this.sortBone(c);
              if (1 < b.length) {
                var f = b[b.length - 1];
                -1 < this._updateCache.indexOf(f) ||
                  this.updateCacheReset.push(f);
              }
              this._updateCache.push(e);
              this.sortReset(c.children);
              b[b.length - 1].sorted = !0;
            }
          };
          k.prototype.sortPathConstraint = function (e) {
            e.active =
              e.target.bone.isActive() &&
              (!e.data.skinRequired ||
                (null != this.skin &&
                  a.Utils.contains(this.skin.constraints, e.data, !0)));
            if (e.active) {
              var b = e.target,
                c = b.data.index,
                f = b.bone;
              null != this.skin &&
                this.sortPathConstraintAttachment(this.skin, c, f);
              null != this.data.defaultSkin &&
                this.data.defaultSkin != this.skin &&
                this.sortPathConstraintAttachment(this.data.defaultSkin, c, f);
              for (var g = 0, m = this.data.skins.length; g < m; g++)
                this.sortPathConstraintAttachment(this.data.skins[g], c, f);
              g = b.getAttachment();
              g instanceof a.PathAttachment &&
                this.sortPathConstraintAttachmentWith(g, f);
              f = e.bones;
              b = f.length;
              for (g = 0; g < b; g++) this.sortBone(f[g]);
              this._updateCache.push(e);
              for (g = 0; g < b; g++) this.sortReset(f[g].children);
              for (g = 0; g < b; g++) f[g].sorted = !0;
            }
          };
          k.prototype.sortTransformConstraint = function (e) {
            e.active =
              e.target.isActive() &&
              (!e.data.skinRequired ||
                (null != this.skin &&
                  a.Utils.contains(this.skin.constraints, e.data, !0)));
            if (e.active) {
              this.sortBone(e.target);
              var b = e.bones,
                c = b.length;
              if (e.data.local)
                for (var f = 0; f < c; f++) {
                  var g = b[f];
                  this.sortBone(g.parent);
                  -1 < this._updateCache.indexOf(g) ||
                    this.updateCacheReset.push(g);
                }
              else for (f = 0; f < c; f++) this.sortBone(b[f]);
              this._updateCache.push(e);
              for (e = 0; e < c; e++) this.sortReset(b[e].children);
              for (e = 0; e < c; e++) b[e].sorted = !0;
            }
          };
          k.prototype.sortPathConstraintAttachment = function (e, b, c) {
            if ((e = e.attachments[b]))
              for (var f in e) this.sortPathConstraintAttachmentWith(e[f], c);
          };
          k.prototype.sortPathConstraintAttachmentWith = function (e, b) {
            if (e instanceof a.PathAttachment)
              if (((e = e.bones), null == e)) this.sortBone(b);
              else {
                b = this.bones;
                for (var c = 0; c < e.length; ) {
                  var f = e[c++];
                  for (f = c + f; c < f; c++) this.sortBone(b[e[c]]);
                }
              }
          };
          k.prototype.sortBone = function (e) {
            if (!e.sorted) {
              var b = e.parent;
              null != b && this.sortBone(b);
              e.sorted = !0;
              this._updateCache.push(e);
            }
          };
          k.prototype.sortReset = function (e) {
            for (var b = 0, c = e.length; b < c; b++) {
              var f = e[b];
              f.active &&
                (f.sorted && this.sortReset(f.children), (f.sorted = !1));
            }
          };
          k.prototype.updateWorldTransform = function () {
            for (
              var e = this.updateCacheReset, b = 0, c = e.length;
              b < c;
              b++
            ) {
              var f = e[b];
              f.ax = f.x;
              f.ay = f.y;
              f.arotation = f.rotation;
              f.ascaleX = f.scaleX;
              f.ascaleY = f.scaleY;
              f.ashearX = f.shearX;
              f.ashearY = f.shearY;
              f.appliedValid = !0;
            }
            e = this._updateCache;
            b = 0;
            for (c = e.length; b < c; b++) e[b].update();
          };
          k.prototype.setToSetupPose = function () {
            this.setBonesToSetupPose();
            this.setSlotsToSetupPose();
          };
          k.prototype.setBonesToSetupPose = function () {
            for (var e = this.bones, b = 0, c = e.length; b < c; b++)
              e[b].setToSetupPose();
            var f = this.ikConstraints;
            b = 0;
            for (c = f.length; b < c; b++)
              (e = f[b]),
                (e.mix = e.data.mix),
                (e.softness = e.data.softness),
                (e.bendDirection = e.data.bendDirection),
                (e.compress = e.data.compress),
                (e.stretch = e.data.stretch);
            var g = this.transformConstraints;
            b = 0;
            for (c = g.length; b < c; b++)
              (e = g[b]),
                (f = e.data),
                (e.rotateMix = f.rotateMix),
                (e.translateMix = f.translateMix),
                (e.scaleMix = f.scaleMix),
                (e.shearMix = f.shearMix);
            g = this.pathConstraints;
            b = 0;
            for (c = g.length; b < c; b++)
              (e = g[b]),
                (f = e.data),
                (e.position = f.position),
                (e.spacing = f.spacing),
                (e.rotateMix = f.rotateMix),
                (e.translateMix = f.translateMix);
          };
          k.prototype.setSlotsToSetupPose = function () {
            var e = this.slots;
            a.Utils.arrayCopy(e, 0, this.drawOrder, 0, e.length);
            for (var b = 0, c = e.length; b < c; b++) e[b].setToSetupPose();
          };
          k.prototype.getRootBone = function () {
            return 0 == this.bones.length ? null : this.bones[0];
          };
          k.prototype.findBone = function (e) {
            if (null == e) throw Error("boneName cannot be null.");
            for (var b = this.bones, c = 0, f = b.length; c < f; c++) {
              var g = b[c];
              if (g.data.name == e) return g;
            }
            return null;
          };
          k.prototype.findBoneIndex = function (e) {
            if (null == e) throw Error("boneName cannot be null.");
            for (var b = this.bones, c = 0, f = b.length; c < f; c++)
              if (b[c].data.name == e) return c;
            return -1;
          };
          k.prototype.findSlot = function (e) {
            if (null == e) throw Error("slotName cannot be null.");
            for (var b = this.slots, c = 0, f = b.length; c < f; c++) {
              var g = b[c];
              if (g.data.name == e) return g;
            }
            return null;
          };
          k.prototype.findSlotIndex = function (e) {
            if (null == e) throw Error("slotName cannot be null.");
            for (var b = this.slots, c = 0, f = b.length; c < f; c++)
              if (b[c].data.name == e) return c;
            return -1;
          };
          k.prototype.setSkinByName = function (e) {
            var b = this.data.findSkin(e);
            if (null == b) throw Error("Skin not found: " + e);
            this.setSkin(b);
          };
          k.prototype.setSkin = function (e) {
            if (e != this.skin) {
              if (null != e)
                if (null != this.skin) e.attachAll(this, this.skin);
                else
                  for (var b = this.slots, c = 0, f = b.length; c < f; c++) {
                    var g = b[c],
                      m = g.data.attachmentName;
                    null != m &&
                      ((m = e.getAttachment(c, m)),
                      null != m && g.setAttachment(m));
                  }
              this.skin = e;
              this.updateCache();
            }
          };
          k.prototype.getAttachmentByName = function (e, b) {
            return this.getAttachment(this.data.findSlotIndex(e), b);
          };
          k.prototype.getAttachment = function (e, b) {
            if (null == b) throw Error("attachmentName cannot be null.");
            if (null != this.skin) {
              var c = this.skin.getAttachment(e, b);
              if (null != c) return c;
            }
            return null != this.data.defaultSkin
              ? this.data.defaultSkin.getAttachment(e, b)
              : null;
          };
          k.prototype.setAttachment = function (e, b) {
            if (null == e) throw Error("slotName cannot be null.");
            for (var c = this.slots, f = 0, g = c.length; f < g; f++) {
              var m = c[f];
              if (m.data.name == e) {
                c = null;
                if (null != b && ((c = this.getAttachment(f, b)), null == c))
                  throw Error(
                    "Attachment not found: " + b + ", for slot: " + e
                  );
                m.setAttachment(c);
                return;
              }
            }
            throw Error("Slot not found: " + e);
          };
          k.prototype.findIkConstraint = function (e) {
            if (null == e) throw Error("constraintName cannot be null.");
            for (var b = this.ikConstraints, c = 0, f = b.length; c < f; c++) {
              var g = b[c];
              if (g.data.name == e) return g;
            }
            return null;
          };
          k.prototype.findTransformConstraint = function (e) {
            if (null == e) throw Error("constraintName cannot be null.");
            for (
              var b = this.transformConstraints, c = 0, f = b.length;
              c < f;
              c++
            ) {
              var g = b[c];
              if (g.data.name == e) return g;
            }
            return null;
          };
          k.prototype.findPathConstraint = function (e) {
            if (null == e) throw Error("constraintName cannot be null.");
            for (
              var b = this.pathConstraints, c = 0, f = b.length;
              c < f;
              c++
            ) {
              var g = b[c];
              if (g.data.name == e) return g;
            }
            return null;
          };
          k.prototype.getBounds = function (e, b, c) {
            void 0 === c && (c = Array(2));
            if (null == e) throw Error("offset cannot be null.");
            if (null == b) throw Error("size cannot be null.");
            for (
              var f = this.drawOrder,
                g = Number.POSITIVE_INFINITY,
                m = Number.POSITIVE_INFINITY,
                n = Number.NEGATIVE_INFINITY,
                q = Number.NEGATIVE_INFINITY,
                r = 0,
                u = f.length;
              r < u;
              r++
            ) {
              var v = f[r];
              if (v.bone.active) {
                var x = null,
                  y = v.getAttachment();
                if (y instanceof a.RegionAttachment) {
                  var z = 8;
                  x = a.Utils.setArraySize(c, z, 0);
                  y.computeWorldVertices(v.bone, x, 0, 2);
                } else
                  y instanceof a.MeshAttachment &&
                    ((z = y.worldVerticesLength),
                    (x = a.Utils.setArraySize(c, z, 0)),
                    y.computeWorldVertices(v, 0, z, x, 0, 2));
                if (null != x)
                  for (v = 0, z = x.length; v < z; v += 2) {
                    y = x[v];
                    var A = x[v + 1];
                    g = Math.min(g, y);
                    m = Math.min(m, A);
                    n = Math.max(n, y);
                    q = Math.max(q, A);
                  }
              }
            }
            e.set(g, m);
            b.set(n - g, q - m);
          };
          k.prototype.update = function (e) {
            this.time += e;
          };
          return k;
        })();
        a.Skeleton = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function c(f) {
            this.scale = 1;
            this.linkedMeshes = [];
            this.attachmentLoader = f;
          }
          c.prototype.readSkeletonData = function (f) {
            var g = this.scale,
              m = new a.SkeletonData();
            m.name = "";
            f = new k(f);
            m.hash = f.readString();
            m.version = f.readString();
            if ("3.8.75" == m.version)
              throw Error(
                "Unsupported skeleton data, please export with a newer version of Spine."
              );
            m.x = f.readFloat();
            m.y = f.readFloat();
            m.width = f.readFloat();
            m.height = f.readFloat();
            var n = f.readBoolean();
            n &&
              ((m.fps = f.readFloat()),
              (m.imagesPath = f.readString()),
              (m.audioPath = f.readString()));
            var q = f.readInt(!0);
            for (var r = 0; r < q; r++) f.strings.push(f.readString());
            q = f.readInt(!0);
            for (r = 0; r < q; r++) {
              var u = f.readString(),
                v = 0 == r ? null : m.bones[f.readInt(!0)];
              u = new a.BoneData(r, u, v);
              u.rotation = f.readFloat();
              u.x = f.readFloat() * g;
              u.y = f.readFloat() * g;
              u.scaleX = f.readFloat();
              u.scaleY = f.readFloat();
              u.shearX = f.readFloat();
              u.shearY = f.readFloat();
              u.length = f.readFloat() * g;
              u.transformMode = c.TransformModeValues[f.readInt(!0)];
              u.skinRequired = f.readBoolean();
              n && a.Color.rgba8888ToColor(u.color, f.readInt32());
              m.bones.push(u);
            }
            q = f.readInt(!0);
            for (r = 0; r < q; r++)
              (u = f.readString()),
                (v = m.bones[f.readInt(!0)]),
                (u = new a.SlotData(r, u, v)),
                a.Color.rgba8888ToColor(u.color, f.readInt32()),
                (v = f.readInt32()),
                -1 != v &&
                  a.Color.rgb888ToColor((u.darkColor = new a.Color()), v),
                (u.attachmentName = f.readStringRef()),
                (u.blendMode = c.BlendModeValues[f.readInt(!0)]),
                m.slots.push(u);
            q = f.readInt(!0);
            for (r = 0; r < q; r++) {
              u = new a.IkConstraintData(f.readString());
              u.order = f.readInt(!0);
              u.skinRequired = f.readBoolean();
              v = f.readInt(!0);
              for (var x = 0; x < v; x++) u.bones.push(m.bones[f.readInt(!0)]);
              u.target = m.bones[f.readInt(!0)];
              u.mix = f.readFloat();
              u.softness = f.readFloat() * g;
              u.bendDirection = f.readByte();
              u.compress = f.readBoolean();
              u.stretch = f.readBoolean();
              u.uniform = f.readBoolean();
              m.ikConstraints.push(u);
            }
            q = f.readInt(!0);
            for (r = 0; r < q; r++) {
              u = new a.TransformConstraintData(f.readString());
              u.order = f.readInt(!0);
              u.skinRequired = f.readBoolean();
              v = f.readInt(!0);
              for (x = 0; x < v; x++) u.bones.push(m.bones[f.readInt(!0)]);
              u.target = m.bones[f.readInt(!0)];
              u.local = f.readBoolean();
              u.relative = f.readBoolean();
              u.offsetRotation = f.readFloat();
              u.offsetX = f.readFloat() * g;
              u.offsetY = f.readFloat() * g;
              u.offsetScaleX = f.readFloat();
              u.offsetScaleY = f.readFloat();
              u.offsetShearY = f.readFloat();
              u.rotateMix = f.readFloat();
              u.translateMix = f.readFloat();
              u.scaleMix = f.readFloat();
              u.shearMix = f.readFloat();
              m.transformConstraints.push(u);
            }
            q = f.readInt(!0);
            for (r = 0; r < q; r++) {
              u = new a.PathConstraintData(f.readString());
              u.order = f.readInt(!0);
              u.skinRequired = f.readBoolean();
              v = f.readInt(!0);
              for (x = 0; x < v; x++) u.bones.push(m.bones[f.readInt(!0)]);
              u.target = m.slots[f.readInt(!0)];
              u.positionMode = c.PositionModeValues[f.readInt(!0)];
              u.spacingMode = c.SpacingModeValues[f.readInt(!0)];
              u.rotateMode = c.RotateModeValues[f.readInt(!0)];
              u.offsetRotation = f.readFloat();
              u.position = f.readFloat();
              u.positionMode == a.PositionMode.Fixed && (u.position *= g);
              u.spacing = f.readFloat();
              if (
                u.spacingMode == a.SpacingMode.Length ||
                u.spacingMode == a.SpacingMode.Fixed
              )
                u.spacing *= g;
              u.rotateMix = f.readFloat();
              u.translateMix = f.readFloat();
              m.pathConstraints.push(u);
            }
            q = this.readSkin(f, m, !0, n);
            null != q && ((m.defaultSkin = q), m.skins.push(q));
            r = m.skins.length;
            for (
              a.Utils.setArraySize(m.skins, (q = r + f.readInt(!0)));
              r < q;
              r++
            )
              m.skins[r] = this.readSkin(f, m, !1, n);
            q = this.linkedMeshes.length;
            for (r = 0; r < q; r++) {
              g = this.linkedMeshes[r];
              n = null == g.skin ? m.defaultSkin : m.findSkin(g.skin);
              if (null == n) throw Error("Skin not found: " + g.skin);
              n = n.getAttachment(g.slotIndex, g.parent);
              if (null == n) throw Error("Parent mesh not found: " + g.parent);
              g.mesh.deformAttachment = g.inheritDeform ? n : g.mesh;
              g.mesh.setParentMesh(n);
              g.mesh.updateUVs();
            }
            this.linkedMeshes.length = 0;
            q = f.readInt(!0);
            for (r = 0; r < q; r++)
              (u = new a.EventData(f.readStringRef())),
                (u.intValue = f.readInt(!1)),
                (u.floatValue = f.readFloat()),
                (u.stringValue = f.readString()),
                (u.audioPath = f.readString()),
                null != u.audioPath &&
                  ((u.volume = f.readFloat()), (u.balance = f.readFloat())),
                m.events.push(u);
            q = f.readInt(!0);
            for (r = 0; r < q; r++)
              m.animations.push(this.readAnimation(f, f.readString(), m));
            return m;
          };
          c.prototype.readSkin = function (f, g, m, n) {
            if (m) {
              var q = f.readInt(!0);
              if (0 == q) return null;
              m = new a.Skin("default");
            } else {
              m = new a.Skin(f.readStringRef());
              m.bones.length = f.readInt(!0);
              var r = 0;
              for (q = m.bones.length; r < q; r++)
                m.bones[r] = g.bones[f.readInt(!0)];
              r = 0;
              for (q = f.readInt(!0); r < q; r++)
                m.constraints.push(g.ikConstraints[f.readInt(!0)]);
              r = 0;
              for (q = f.readInt(!0); r < q; r++)
                m.constraints.push(g.transformConstraints[f.readInt(!0)]);
              r = 0;
              for (q = f.readInt(!0); r < q; r++)
                m.constraints.push(g.pathConstraints[f.readInt(!0)]);
              q = f.readInt(!0);
            }
            for (r = 0; r < q; r++)
              for (
                var u = f.readInt(!0), v = 0, x = f.readInt(!0);
                v < x;
                v++
              ) {
                var y = f.readStringRef(),
                  z = this.readAttachment(f, g, m, u, y, n);
                null != z && m.setAttachment(u, y, z);
              }
            return m;
          };
          c.prototype.readAttachment = function (f, g, m, n, q, r) {
            var u = this.scale,
              v = f.readStringRef();
            null == v && (v = q);
            q = f.readByte();
            switch (c.AttachmentTypeValues[q]) {
              case a.AttachmentType.Region:
                g = f.readStringRef();
                n = f.readFloat();
                var x = f.readFloat(),
                  y = f.readFloat();
                r = f.readFloat();
                var z = f.readFloat(),
                  A = f.readFloat(),
                  B = f.readFloat();
                q = f.readInt32();
                null == g && (g = v);
                f = this.attachmentLoader.newRegionAttachment(m, v, g);
                if (null == f) break;
                f.path = g;
                f.x = x * u;
                f.y = y * u;
                f.scaleX = r;
                f.scaleY = z;
                f.rotation = n;
                f.width = A * u;
                f.height = B * u;
                a.Color.rgba8888ToColor(f.color, q);
                f.updateOffset();
                return f;
              case a.AttachmentType.BoundingBox:
                n = f.readInt(!0);
                x = this.readVertices(f, n);
                q = r ? f.readInt32() : 0;
                u = this.attachmentLoader.newBoundingBoxAttachment(m, v);
                if (null == u) break;
                u.worldVerticesLength = n << 1;
                u.vertices = x.vertices;
                u.bones = x.bones;
                r && a.Color.rgba8888ToColor(u.color, q);
                return u;
              case a.AttachmentType.Mesh:
                g = f.readStringRef();
                q = f.readInt32();
                n = f.readInt(!0);
                y = this.readFloatArray(f, n << 1, 1);
                z = this.readShortArray(f);
                x = this.readVertices(f, n);
                var D = f.readInt(!0),
                  E = null;
                B = A = 0;
                r &&
                  ((E = this.readShortArray(f)),
                  (A = f.readFloat()),
                  (B = f.readFloat()));
                null == g && (g = v);
                f = this.attachmentLoader.newMeshAttachment(m, v, g);
                if (null == f) break;
                f.path = g;
                a.Color.rgba8888ToColor(f.color, q);
                f.bones = x.bones;
                f.vertices = x.vertices;
                f.worldVerticesLength = n << 1;
                f.triangles = z;
                f.regionUVs = y;
                f.updateUVs();
                f.hullLength = D << 1;
                r && ((f.edges = E), (f.width = A * u), (f.height = B * u));
                return f;
              case a.AttachmentType.LinkedMesh:
                g = f.readStringRef();
                q = f.readInt32();
                x = f.readStringRef();
                y = f.readStringRef();
                z = f.readBoolean();
                B = A = 0;
                r && ((A = f.readFloat()), (B = f.readFloat()));
                null == g && (g = v);
                f = this.attachmentLoader.newMeshAttachment(m, v, g);
                if (null == f) break;
                f.path = g;
                a.Color.rgba8888ToColor(f.color, q);
                r && ((f.width = A * u), (f.height = B * u));
                this.linkedMeshes.push(new e(f, x, n, y, z));
                return f;
              case a.AttachmentType.Path:
                A = f.readBoolean();
                B = f.readBoolean();
                n = f.readInt(!0);
                x = this.readVertices(f, n);
                y = a.Utils.newArray(n / 3, 0);
                q = 0;
                for (g = y.length; q < g; q++) y[q] = f.readFloat() * u;
                q = r ? f.readInt32() : 0;
                g = this.attachmentLoader.newPathAttachment(m, v);
                if (null == g) break;
                g.closed = A;
                g.constantSpeed = B;
                g.worldVerticesLength = n << 1;
                g.vertices = x.vertices;
                g.bones = x.bones;
                g.lengths = y;
                r && a.Color.rgba8888ToColor(g.color, q);
                return g;
              case a.AttachmentType.Point:
                n = f.readFloat();
                x = f.readFloat();
                y = f.readFloat();
                q = r ? f.readInt32() : 0;
                f = this.attachmentLoader.newPointAttachment(m, v);
                if (null == f) break;
                f.x = x * u;
                f.y = y * u;
                f.rotation = n;
                r && a.Color.rgba8888ToColor(f.color, q);
                return f;
              case a.AttachmentType.Clipping:
                if (
                  ((u = f.readInt(!0)),
                  (n = f.readInt(!0)),
                  (x = this.readVertices(f, n)),
                  (q = r ? f.readInt32() : 0),
                  (f = this.attachmentLoader.newClippingAttachment(m, v)),
                  null != f)
                )
                  return (
                    (f.endSlot = g.slots[u]),
                    (f.worldVerticesLength = n << 1),
                    (f.vertices = x.vertices),
                    (f.bones = x.bones),
                    r && a.Color.rgba8888ToColor(f.color, q),
                    f
                  );
            }
            return null;
          };
          c.prototype.readVertices = function (f, g) {
            var m = g << 1,
              n = new b(),
              q = this.scale;
            if (!f.readBoolean())
              return (n.vertices = this.readFloatArray(f, m, q)), n;
            m = [];
            for (var r = [], u = 0; u < g; u++) {
              var v = f.readInt(!0);
              r.push(v);
              for (var x = 0; x < v; x++)
                r.push(f.readInt(!0)),
                  m.push(f.readFloat() * q),
                  m.push(f.readFloat() * q),
                  m.push(f.readFloat());
            }
            n.vertices = a.Utils.toFloatArray(m);
            n.bones = r;
            return n;
          };
          c.prototype.readFloatArray = function (f, g, m) {
            var n = Array(g);
            if (1 == m) for (var q = 0; q < g; q++) n[q] = f.readFloat();
            else for (q = 0; q < g; q++) n[q] = f.readFloat() * m;
            return n;
          };
          c.prototype.readShortArray = function (f) {
            for (var g = f.readInt(!0), m = Array(g), n = 0; n < g; n++)
              m[n] = f.readShort();
            return m;
          };
          c.prototype.readAnimation = function (f, g, m) {
            for (
              var n = [],
                q = this.scale,
                r = 0,
                u = new a.Color(),
                v = new a.Color(),
                x = 0,
                y = f.readInt(!0);
              x < y;
              x++
            )
              for (
                var z = f.readInt(!0), A = 0, B = f.readInt(!0);
                A < B;
                A++
              ) {
                var D = f.readByte(),
                  E = f.readInt(!0);
                switch (D) {
                  case c.SLOT_ATTACHMENT:
                    D = new a.AttachmentTimeline(E);
                    D.slotIndex = z;
                    for (var C = 0; C < E; C++)
                      D.setFrame(C, f.readFloat(), f.readStringRef());
                    n.push(D);
                    r = Math.max(r, D.frames[E - 1]);
                    break;
                  case c.SLOT_COLOR:
                    D = new a.ColorTimeline(E);
                    D.slotIndex = z;
                    for (C = 0; C < E; C++) {
                      var F = f.readFloat();
                      a.Color.rgba8888ToColor(u, f.readInt32());
                      D.setFrame(C, F, u.r, u.g, u.b, u.a);
                      C < E - 1 && this.readCurve(f, C, D);
                    }
                    n.push(D);
                    r = Math.max(
                      r,
                      D.frames[(E - 1) * a.ColorTimeline.ENTRIES]
                    );
                    break;
                  case c.SLOT_TWO_COLOR:
                    D = new a.TwoColorTimeline(E);
                    D.slotIndex = z;
                    for (C = 0; C < E; C++)
                      (F = f.readFloat()),
                        a.Color.rgba8888ToColor(u, f.readInt32()),
                        a.Color.rgb888ToColor(v, f.readInt32()),
                        D.setFrame(C, F, u.r, u.g, u.b, u.a, v.r, v.g, v.b),
                        C < E - 1 && this.readCurve(f, C, D);
                    n.push(D);
                    r = Math.max(
                      r,
                      D.frames[(E - 1) * a.TwoColorTimeline.ENTRIES]
                    );
                }
              }
            x = 0;
            for (y = f.readInt(!0); x < y; x++)
              for (F = f.readInt(!0), A = 0, B = f.readInt(!0); A < B; A++)
                switch (((D = f.readByte()), (E = f.readInt(!0)), D)) {
                  case c.BONE_ROTATE:
                    D = new a.RotateTimeline(E);
                    D.boneIndex = F;
                    for (C = 0; C < E; C++)
                      D.setFrame(C, f.readFloat(), f.readFloat()),
                        C < E - 1 && this.readCurve(f, C, D);
                    n.push(D);
                    r = Math.max(
                      r,
                      D.frames[(E - 1) * a.RotateTimeline.ENTRIES]
                    );
                    break;
                  case c.BONE_TRANSLATE:
                  case c.BONE_SCALE:
                  case c.BONE_SHEAR:
                    z = 1;
                    D == c.BONE_SCALE
                      ? (D = new a.ScaleTimeline(E))
                      : D == c.BONE_SHEAR
                      ? (D = new a.ShearTimeline(E))
                      : ((D = new a.TranslateTimeline(E)), (z = q));
                    D.boneIndex = F;
                    for (C = 0; C < E; C++)
                      D.setFrame(
                        C,
                        f.readFloat(),
                        f.readFloat() * z,
                        f.readFloat() * z
                      ),
                        C < E - 1 && this.readCurve(f, C, D);
                    n.push(D);
                    r = Math.max(
                      r,
                      D.frames[(E - 1) * a.TranslateTimeline.ENTRIES]
                    );
                }
            x = 0;
            for (y = f.readInt(!0); x < y; x++) {
              F = f.readInt(!0);
              E = f.readInt(!0);
              D = new a.IkConstraintTimeline(E);
              D.ikConstraintIndex = F;
              for (C = 0; C < E; C++)
                D.setFrame(
                  C,
                  f.readFloat(),
                  f.readFloat(),
                  f.readFloat() * q,
                  f.readByte(),
                  f.readBoolean(),
                  f.readBoolean()
                ),
                  C < E - 1 && this.readCurve(f, C, D);
              n.push(D);
              r = Math.max(
                r,
                D.frames[(E - 1) * a.IkConstraintTimeline.ENTRIES]
              );
            }
            x = 0;
            for (y = f.readInt(!0); x < y; x++) {
              F = f.readInt(!0);
              E = f.readInt(!0);
              D = new a.TransformConstraintTimeline(E);
              D.transformConstraintIndex = F;
              for (C = 0; C < E; C++)
                D.setFrame(
                  C,
                  f.readFloat(),
                  f.readFloat(),
                  f.readFloat(),
                  f.readFloat(),
                  f.readFloat()
                ),
                  C < E - 1 && this.readCurve(f, C, D);
              n.push(D);
              r = Math.max(
                r,
                D.frames[(E - 1) * a.TransformConstraintTimeline.ENTRIES]
              );
            }
            x = 0;
            for (y = f.readInt(!0); x < y; x++)
              for (
                F = f.readInt(!0),
                  u = m.pathConstraints[F],
                  A = 0,
                  B = f.readInt(!0);
                A < B;
                A++
              )
                switch (((D = f.readByte()), (E = f.readInt(!0)), D)) {
                  case c.PATH_POSITION:
                  case c.PATH_SPACING:
                    z = 1;
                    if (D == c.PATH_SPACING) {
                      if (
                        ((D = new a.PathConstraintSpacingTimeline(E)),
                        u.spacingMode == a.SpacingMode.Length ||
                          u.spacingMode == a.SpacingMode.Fixed)
                      )
                        z = q;
                    } else
                      (D = new a.PathConstraintPositionTimeline(E)),
                        u.positionMode == a.PositionMode.Fixed && (z = q);
                    D.pathConstraintIndex = F;
                    for (C = 0; C < E; C++)
                      D.setFrame(C, f.readFloat(), f.readFloat() * z),
                        C < E - 1 && this.readCurve(f, C, D);
                    n.push(D);
                    r = Math.max(
                      r,
                      D.frames[
                        (E - 1) * a.PathConstraintPositionTimeline.ENTRIES
                      ]
                    );
                    break;
                  case c.PATH_MIX:
                    D = new a.PathConstraintMixTimeline(E);
                    D.pathConstraintIndex = F;
                    for (C = 0; C < E; C++)
                      D.setFrame(
                        C,
                        f.readFloat(),
                        f.readFloat(),
                        f.readFloat()
                      ),
                        C < E - 1 && this.readCurve(f, C, D);
                    n.push(D);
                    r = Math.max(
                      r,
                      D.frames[(E - 1) * a.PathConstraintMixTimeline.ENTRIES]
                    );
                }
            x = 0;
            for (y = f.readInt(!0); x < y; x++)
              for (
                u = m.skins[f.readInt(!0)], A = 0, B = f.readInt(!0);
                A < B;
                A++
              ) {
                z = f.readInt(!0);
                v = 0;
                for (var G = f.readInt(!0); v < G; v++) {
                  F = u.getAttachment(z, f.readStringRef());
                  var H = null != F.bones,
                    K = F.vertices,
                    I = H ? (K.length / 3) * 2 : K.length;
                  E = f.readInt(!0);
                  D = new a.DeformTimeline(E);
                  D.slotIndex = z;
                  D.attachment = F;
                  for (C = 0; C < E; C++) {
                    F = f.readFloat();
                    var M = f.readInt(!0);
                    if (0 == M) var N = H ? a.Utils.newFloatArray(I) : K;
                    else {
                      N = a.Utils.newFloatArray(I);
                      var P = f.readInt(!0);
                      M += P;
                      if (1 == q) for (; P < M; P++) N[P] = f.readFloat();
                      else for (; P < M; P++) N[P] = f.readFloat() * q;
                      if (!H)
                        for (P = 0, M = N.length; P < M; P++) N[P] += K[P];
                    }
                    D.setFrame(C, F, N);
                    C < E - 1 && this.readCurve(f, C, D);
                  }
                  n.push(D);
                  r = Math.max(r, D.frames[E - 1]);
                }
              }
            q = f.readInt(!0);
            if (0 < q) {
              D = new a.DrawOrderTimeline(q);
              y = m.slots.length;
              for (x = 0; x < q; x++) {
                F = f.readFloat();
                B = f.readInt(!0);
                E = a.Utils.newArray(y, 0);
                for (A = y - 1; 0 <= A; A--) E[A] = -1;
                C = a.Utils.newArray(y - B, 0);
                for (A = v = u = 0; A < B; A++) {
                  for (z = f.readInt(!0); u != z; ) C[v++] = u++;
                  E[u + f.readInt(!0)] = u++;
                }
                for (; u < y; ) C[v++] = u++;
                for (A = y - 1; 0 <= A; A--) -1 == E[A] && (E[A] = C[--v]);
                D.setFrame(x, F, E);
              }
              n.push(D);
              r = Math.max(r, D.frames[q - 1]);
            }
            A = f.readInt(!0);
            if (0 < A) {
              D = new a.EventTimeline(A);
              for (x = 0; x < A; x++)
                (F = f.readFloat()),
                  (z = m.events[f.readInt(!0)]),
                  (F = new a.Event(F, z)),
                  (F.intValue = f.readInt(!1)),
                  (F.floatValue = f.readFloat()),
                  (F.stringValue = f.readBoolean()
                    ? f.readString()
                    : z.stringValue),
                  null != F.data.audioPath &&
                    ((F.volume = f.readFloat()), (F.balance = f.readFloat())),
                  D.setFrame(x, F);
              n.push(D);
              r = Math.max(r, D.frames[A - 1]);
            }
            return new a.Animation(g, n, r);
          };
          c.prototype.readCurve = function (f, g, m) {
            switch (f.readByte()) {
              case c.CURVE_STEPPED:
                m.setStepped(g);
                break;
              case c.CURVE_BEZIER:
                this.setCurve(
                  m,
                  g,
                  f.readFloat(),
                  f.readFloat(),
                  f.readFloat(),
                  f.readFloat()
                );
            }
          };
          c.prototype.setCurve = function (f, g, m, n, q, r) {
            f.setCurve(g, m, n, q, r);
          };
          c.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6];
          c.TransformModeValues = [
            a.TransformMode.Normal,
            a.TransformMode.OnlyTranslation,
            a.TransformMode.NoRotationOrReflection,
            a.TransformMode.NoScale,
            a.TransformMode.NoScaleOrReflection,
          ];
          c.PositionModeValues = [a.PositionMode.Fixed, a.PositionMode.Percent];
          c.SpacingModeValues = [
            a.SpacingMode.Length,
            a.SpacingMode.Fixed,
            a.SpacingMode.Percent,
          ];
          c.RotateModeValues = [
            a.RotateMode.Tangent,
            a.RotateMode.Chain,
            a.RotateMode.ChainScale,
          ];
          c.BlendModeValues = [
            a.BlendMode.Normal,
            a.BlendMode.Additive,
            a.BlendMode.Multiply,
            a.BlendMode.Screen,
          ];
          c.BONE_ROTATE = 0;
          c.BONE_TRANSLATE = 1;
          c.BONE_SCALE = 2;
          c.BONE_SHEAR = 3;
          c.SLOT_ATTACHMENT = 0;
          c.SLOT_COLOR = 1;
          c.SLOT_TWO_COLOR = 2;
          c.PATH_POSITION = 0;
          c.PATH_SPACING = 1;
          c.PATH_MIX = 2;
          c.CURVE_LINEAR = 0;
          c.CURVE_STEPPED = 1;
          c.CURVE_BEZIER = 2;
          return c;
        })();
        a.SkeletonBinary = d;
        var k = (function () {
            function c(f, g, m, n) {
              void 0 === g && (g = []);
              void 0 === m && (m = 0);
              void 0 === n && (n = new DataView(f.buffer));
              this.strings = g;
              this.index = m;
              this.buffer = n;
            }
            c.prototype.readByte = function () {
              return this.buffer.getInt8(this.index++);
            };
            c.prototype.readShort = function () {
              var f = this.buffer.getInt16(this.index);
              this.index += 2;
              return f;
            };
            c.prototype.readInt32 = function () {
              var f = this.buffer.getInt32(this.index);
              this.index += 4;
              return f;
            };
            c.prototype.readInt = function (f) {
              var g = this.readByte(),
                m = g & 127;
              0 != (g & 128) &&
                ((g = this.readByte()),
                (m |= (g & 127) << 7),
                0 != (g & 128) &&
                  ((g = this.readByte()),
                  (m |= (g & 127) << 14),
                  0 != (g & 128) &&
                    ((g = this.readByte()),
                    (m |= (g & 127) << 21),
                    0 != (g & 128) &&
                      ((g = this.readByte()), (m |= (g & 127) << 28)))));
              return f ? m : (m >>> 1) ^ -(m & 1);
            };
            c.prototype.readStringRef = function () {
              var f = this.readInt(!0);
              return 0 == f ? null : this.strings[f - 1];
            };
            c.prototype.readString = function () {
              var f = this.readInt(!0);
              switch (f) {
                case 0:
                  return null;
                case 1:
                  return "";
              }
              f--;
              for (var g = "", m = 0; m < f; ) {
                var n = this.readByte();
                switch (n >> 4) {
                  case 12:
                  case 13:
                    g += String.fromCharCode(
                      ((n & 31) << 6) | (this.readByte() & 63)
                    );
                    m += 2;
                    break;
                  case 14:
                    g += String.fromCharCode(
                      ((n & 15) << 12) |
                        ((this.readByte() & 63) << 6) |
                        (this.readByte() & 63)
                    );
                    m += 3;
                    break;
                  default:
                    (g += String.fromCharCode(n)), m++;
                }
              }
              return g;
            };
            c.prototype.readFloat = function () {
              var f = this.buffer.getFloat32(this.index);
              this.index += 4;
              return f;
            };
            c.prototype.readBoolean = function () {
              return 0 != this.readByte();
            };
            return c;
          })(),
          e = (function () {
            return function (c, f, g, m, n) {
              this.mesh = c;
              this.skin = f;
              this.slotIndex = g;
              this.parent = m;
              this.inheritDeform = n;
            };
          })(),
          b = (function () {
            return function (c, f) {
              void 0 === c && (c = null);
              void 0 === f && (f = null);
              this.bones = c;
              this.vertices = f;
            };
          })();
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k() {
            this.maxY = this.maxX = this.minY = this.minX = 0;
            this.boundingBoxes = [];
            this.polygons = [];
            this.polygonPool = new a.Pool(function () {
              return a.Utils.newFloatArray(16);
            });
          }
          k.prototype.update = function (e, b) {
            if (null == e) throw Error("skeleton cannot be null.");
            var c = this.boundingBoxes,
              f = this.polygons,
              g = this.polygonPool;
            e = e.slots;
            var m = e.length;
            c.length = 0;
            g.freeAll(f);
            for (var n = (f.length = 0); n < m; n++) {
              var q = e[n];
              if (q.bone.active) {
                var r = q.getAttachment();
                if (r instanceof a.BoundingBoxAttachment) {
                  c.push(r);
                  var u = g.obtain();
                  u.length != r.worldVerticesLength &&
                    (u = a.Utils.newFloatArray(r.worldVerticesLength));
                  f.push(u);
                  r.computeWorldVertices(q, 0, r.worldVerticesLength, u, 0, 2);
                }
              }
            }
            b
              ? this.aabbCompute()
              : ((this.minY = this.minX = Number.POSITIVE_INFINITY),
                (this.maxY = this.maxX = Number.NEGATIVE_INFINITY));
          };
          k.prototype.aabbCompute = function () {
            for (
              var e = Number.POSITIVE_INFINITY,
                b = Number.POSITIVE_INFINITY,
                c = Number.NEGATIVE_INFINITY,
                f = Number.NEGATIVE_INFINITY,
                g = this.polygons,
                m = 0,
                n = g.length;
              m < n;
              m++
            ) {
              var q = g[m],
                r = q,
                u = 0;
              for (q = q.length; u < q; u += 2) {
                var v = r[u],
                  x = r[u + 1];
                e = Math.min(e, v);
                b = Math.min(b, x);
                c = Math.max(c, v);
                f = Math.max(f, x);
              }
            }
            this.minX = e;
            this.minY = b;
            this.maxX = c;
            this.maxY = f;
          };
          k.prototype.aabbContainsPoint = function (e, b) {
            return (
              e >= this.minX &&
              e <= this.maxX &&
              b >= this.minY &&
              b <= this.maxY
            );
          };
          k.prototype.aabbIntersectsSegment = function (e, b, c, f) {
            var g = this.minX,
              m = this.minY,
              n = this.maxX,
              q = this.maxY;
            if (
              (e <= g && c <= g) ||
              (b <= m && f <= m) ||
              (e >= n && c >= n) ||
              (b >= q && f >= q)
            )
              return !1;
            c = (f - b) / (c - e);
            f = c * (g - e) + b;
            if (f > m && f < q) return !0;
            f = c * (n - e) + b;
            if (f > m && f < q) return !0;
            m = (m - b) / c + e;
            if (m > g && m < n) return !0;
            m = (q - b) / c + e;
            return m > g && m < n ? !0 : !1;
          };
          k.prototype.aabbIntersectsSkeleton = function (e) {
            return (
              this.minX < e.maxX &&
              this.maxX > e.minX &&
              this.minY < e.maxY &&
              this.maxY > e.minY
            );
          };
          k.prototype.containsPoint = function (e, b) {
            for (var c = this.polygons, f = 0, g = c.length; f < g; f++)
              if (this.containsPointPolygon(c[f], e, b))
                return this.boundingBoxes[f];
            return null;
          };
          k.prototype.containsPointPolygon = function (e, b, c) {
            for (var f = e.length, g = f - 2, m = !1, n = 0; n < f; n += 2) {
              var q = e[n + 1],
                r = e[g + 1];
              if ((q < c && r >= c) || (r < c && q >= c)) {
                var u = e[n];
                u + ((c - q) / (r - q)) * (e[g] - u) < b && (m = !m);
              }
              g = n;
            }
            return m;
          };
          k.prototype.intersectsSegment = function (e, b, c, f) {
            for (var g = this.polygons, m = 0, n = g.length; m < n; m++)
              if (this.intersectsSegmentPolygon(g[m], e, b, c, f))
                return this.boundingBoxes[m];
            return null;
          };
          k.prototype.intersectsSegmentPolygon = function (e, b, c, f, g) {
            for (
              var m = e.length,
                n = b - f,
                q = c - g,
                r = b * g - c * f,
                u = e[m - 2],
                v = e[m - 1],
                x = 0;
              x < m;
              x += 2
            ) {
              var y = e[x],
                z = e[x + 1],
                A = u * z - v * y,
                B = u - y,
                D = v - z,
                E = n * D - q * B;
              B = (r * B - n * A) / E;
              if (
                ((B >= u && B <= y) || (B >= y && B <= u)) &&
                ((B >= b && B <= f) || (B >= f && B <= b)) &&
                ((u = (r * D - q * A) / E),
                ((u >= v && u <= z) || (u >= z && u <= v)) &&
                  ((u >= c && u <= g) || (u >= g && u <= c)))
              )
                return !0;
              u = y;
              v = z;
            }
            return !1;
          };
          k.prototype.getPolygon = function (e) {
            if (null == e) throw Error("boundingBox cannot be null.");
            e = this.boundingBoxes.indexOf(e);
            return -1 == e ? null : this.polygons[e];
          };
          k.prototype.getWidth = function () {
            return this.maxX - this.minX;
          };
          k.prototype.getHeight = function () {
            return this.maxY - this.minY;
          };
          return k;
        })();
        a.SkeletonBounds = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k() {
            this.triangulator = new a.Triangulator();
            this.clippingPolygon = [];
            this.clipOutput = [];
            this.clippedVertices = [];
            this.clippedTriangles = [];
            this.scratch = [];
          }
          k.prototype.clipStart = function (e, b) {
            if (null != this.clipAttachment) return 0;
            this.clipAttachment = b;
            var c = b.worldVerticesLength,
              f = a.Utils.setArraySize(this.clippingPolygon, c);
            b.computeWorldVertices(e, 0, c, f, 0, 2);
            e = this.clippingPolygon;
            k.makeClockwise(e);
            e = this.clippingPolygons = this.triangulator.decompose(
              e,
              this.triangulator.triangulate(e)
            );
            b = 0;
            for (c = e.length; b < c; b++)
              (f = e[b]), k.makeClockwise(f), f.push(f[0]), f.push(f[1]);
            return e.length;
          };
          k.prototype.clipEndWithSlot = function (e) {
            null != this.clipAttachment &&
              this.clipAttachment.endSlot == e.data &&
              this.clipEnd();
          };
          k.prototype.clipEnd = function () {
            null != this.clipAttachment &&
              ((this.clippingPolygons = this.clipAttachment = null),
              (this.clippedVertices.length = 0),
              (this.clippedTriangles.length = 0),
              (this.clippingPolygon.length = 0));
          };
          k.prototype.isClipping = function () {
            return null != this.clipAttachment;
          };
          k.prototype.clipTriangles = function (e, b, c, f, g, m, n, q) {
            b = this.clipOutput;
            var r = this.clippedVertices,
              u = this.clippedTriangles,
              v = this.clippingPolygons,
              x = this.clippingPolygons.length,
              y = q ? 12 : 8,
              z = 0;
            r.length = 0;
            var A = (u.length = 0);
            a: for (; A < f; A += 3) {
              var B = c[A] << 1,
                D = e[B],
                E = e[B + 1],
                C = g[B],
                F = g[B + 1];
              B = c[A + 1] << 1;
              var G = e[B],
                H = e[B + 1],
                K = g[B],
                I = g[B + 1];
              B = c[A + 2] << 1;
              var M = e[B],
                N = e[B + 1],
                P = g[B];
              B = g[B + 1];
              for (var J = 0; J < x; J++) {
                var L = r.length;
                if (this.clip(D, E, G, H, M, N, v[J], b)) {
                  var O = b.length;
                  if (0 != O) {
                    for (
                      var Q = H - N,
                        S = M - G,
                        R = D - M,
                        T = N - E,
                        U = 1 / (Q * R + S * (E - N)),
                        V = O >> 1,
                        X = this.clipOutput,
                        W = a.Utils.setArraySize(r, L + V * y),
                        Z = 0;
                      Z < O;
                      Z += 2
                    ) {
                      var aa = X[Z],
                        Y = X[Z + 1];
                      W[L] = aa;
                      W[L + 1] = Y;
                      W[L + 2] = m.r;
                      W[L + 3] = m.g;
                      W[L + 4] = m.b;
                      W[L + 5] = m.a;
                      aa -= M;
                      var ba = Y - N;
                      Y = (Q * aa + S * ba) * U;
                      aa = (T * aa + R * ba) * U;
                      ba = 1 - Y - aa;
                      W[L + 6] = C * Y + K * aa + P * ba;
                      W[L + 7] = F * Y + I * aa + B * ba;
                      q &&
                        ((W[L + 8] = n.r),
                        (W[L + 9] = n.g),
                        (W[L + 10] = n.b),
                        (W[L + 11] = n.a));
                      L += y;
                    }
                    L = u.length;
                    O = a.Utils.setArraySize(u, L + 3 * (V - 2));
                    V--;
                    for (Z = 1; Z < V; Z++)
                      (O[L] = z),
                        (O[L + 1] = z + Z),
                        (O[L + 2] = z + Z + 1),
                        (L += 3);
                    z += V + 1;
                  }
                } else {
                  W = a.Utils.setArraySize(r, L + 3 * y);
                  W[L] = D;
                  W[L + 1] = E;
                  W[L + 2] = m.r;
                  W[L + 3] = m.g;
                  W[L + 4] = m.b;
                  W[L + 5] = m.a;
                  q
                    ? ((W[L + 6] = C),
                      (W[L + 7] = F),
                      (W[L + 8] = n.r),
                      (W[L + 9] = n.g),
                      (W[L + 10] = n.b),
                      (W[L + 11] = n.a),
                      (W[L + 12] = G),
                      (W[L + 13] = H),
                      (W[L + 14] = m.r),
                      (W[L + 15] = m.g),
                      (W[L + 16] = m.b),
                      (W[L + 17] = m.a),
                      (W[L + 18] = K),
                      (W[L + 19] = I),
                      (W[L + 20] = n.r),
                      (W[L + 21] = n.g),
                      (W[L + 22] = n.b),
                      (W[L + 23] = n.a),
                      (W[L + 24] = M),
                      (W[L + 25] = N),
                      (W[L + 26] = m.r),
                      (W[L + 27] = m.g),
                      (W[L + 28] = m.b),
                      (W[L + 29] = m.a),
                      (W[L + 30] = P),
                      (W[L + 31] = B),
                      (W[L + 32] = n.r),
                      (W[L + 33] = n.g),
                      (W[L + 34] = n.b),
                      (W[L + 35] = n.a))
                    : ((W[L + 6] = C),
                      (W[L + 7] = F),
                      (W[L + 8] = G),
                      (W[L + 9] = H),
                      (W[L + 10] = m.r),
                      (W[L + 11] = m.g),
                      (W[L + 12] = m.b),
                      (W[L + 13] = m.a),
                      (W[L + 14] = K),
                      (W[L + 15] = I),
                      (W[L + 16] = M),
                      (W[L + 17] = N),
                      (W[L + 18] = m.r),
                      (W[L + 19] = m.g),
                      (W[L + 20] = m.b),
                      (W[L + 21] = m.a),
                      (W[L + 22] = P),
                      (W[L + 23] = B));
                  L = u.length;
                  O = a.Utils.setArraySize(u, L + 3);
                  O[L] = z;
                  O[L + 1] = z + 1;
                  O[L + 2] = z + 2;
                  z += 3;
                  continue a;
                }
              }
            }
          };
          k.prototype.clip = function (e, b, c, f, g, m, n, q) {
            var r = q,
              u = !1;
            if (2 <= n.length % 4) {
              var v = q;
              q = this.scratch;
            } else v = this.scratch;
            v.length = 0;
            v.push(e);
            v.push(b);
            v.push(c);
            v.push(f);
            v.push(g);
            v.push(m);
            v.push(e);
            v.push(b);
            q.length = 0;
            b = n.length - 4;
            for (e = 0; ; e += 2) {
              c = n[e];
              f = n[e + 1];
              g = n[e + 2];
              m = n[e + 3];
              for (
                var x = c - g,
                  y = f - m,
                  z = v,
                  A = v.length - 2,
                  B = q.length,
                  D = 0;
                D < A;
                D += 2
              ) {
                var E = z[D],
                  C = z[D + 1],
                  F = z[D + 2],
                  G = z[D + 3],
                  H = 0 < x * (G - m) - y * (F - g);
                if (0 < x * (C - m) - y * (E - g)) {
                  if (H) {
                    q.push(F);
                    q.push(G);
                    continue;
                  }
                  u = G - C;
                  H = F - E;
                  var K = u * (g - c) - H * (m - f);
                  1e-6 < Math.abs(K)
                    ? ((u = (H * (f - C) - u * (c - E)) / K),
                      q.push(c + (g - c) * u),
                      q.push(f + (m - f) * u))
                    : (q.push(c), q.push(f));
                } else
                  H &&
                    ((u = G - C),
                    (H = F - E),
                    (K = u * (g - c) - H * (m - f)),
                    1e-6 < Math.abs(K)
                      ? ((u = (H * (f - C) - u * (c - E)) / K),
                        q.push(c + (g - c) * u),
                        q.push(f + (m - f) * u))
                      : (q.push(c), q.push(f)),
                    q.push(F),
                    q.push(G));
                u = !0;
              }
              if (B == q.length) return (r.length = 0), !0;
              q.push(q[0]);
              q.push(q[1]);
              if (e == b) break;
              c = q;
              q = v;
              q.length = 0;
              v = c;
            }
            if (r != q)
              for (e = r.length = 0, n = q.length - 2; e < n; e++) r[e] = q[e];
            else r.length -= 2;
            return u;
          };
          k.makeClockwise = function (e) {
            for (
              var b = e.length,
                c = e[b - 2] * e[1] - e[0] * e[b - 1],
                f,
                g,
                m,
                n,
                q = 0,
                r = b - 3;
              q < r;
              q += 2
            )
              (f = e[q]),
                (g = e[q + 1]),
                (m = e[q + 2]),
                (n = e[q + 3]),
                (c += f * n - m * g);
            if (!(0 > c))
              for (q = 0, c = b - 2, r = b >> 1; q < r; q += 2)
                (b = e[q]),
                  (f = e[q + 1]),
                  (g = c - q),
                  (e[q] = e[g]),
                  (e[q + 1] = e[g + 1]),
                  (e[g] = b),
                  (e[g + 1] = f);
          };
          return k;
        })();
        a.SkeletonClipping = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k() {
            this.bones = [];
            this.slots = [];
            this.skins = [];
            this.events = [];
            this.animations = [];
            this.ikConstraints = [];
            this.transformConstraints = [];
            this.pathConstraints = [];
            this.fps = 0;
          }
          k.prototype.findBone = function (e) {
            if (null == e) throw Error("boneName cannot be null.");
            for (var b = this.bones, c = 0, f = b.length; c < f; c++) {
              var g = b[c];
              if (g.name == e) return g;
            }
            return null;
          };
          k.prototype.findBoneIndex = function (e) {
            if (null == e) throw Error("boneName cannot be null.");
            for (var b = this.bones, c = 0, f = b.length; c < f; c++)
              if (b[c].name == e) return c;
            return -1;
          };
          k.prototype.findSlot = function (e) {
            if (null == e) throw Error("slotName cannot be null.");
            for (var b = this.slots, c = 0, f = b.length; c < f; c++) {
              var g = b[c];
              if (g.name == e) return g;
            }
            return null;
          };
          k.prototype.findSlotIndex = function (e) {
            if (null == e) throw Error("slotName cannot be null.");
            for (var b = this.slots, c = 0, f = b.length; c < f; c++)
              if (b[c].name == e) return c;
            return -1;
          };
          k.prototype.findSkin = function (e) {
            if (null == e) throw Error("skinName cannot be null.");
            for (var b = this.skins, c = 0, f = b.length; c < f; c++) {
              var g = b[c];
              if (g.name == e) return g;
            }
            return null;
          };
          k.prototype.findEvent = function (e) {
            if (null == e) throw Error("eventDataName cannot be null.");
            for (var b = this.events, c = 0, f = b.length; c < f; c++) {
              var g = b[c];
              if (g.name == e) return g;
            }
            return null;
          };
          k.prototype.findAnimation = function (e) {
            if (null == e) throw Error("animationName cannot be null.");
            for (var b = this.animations, c = 0, f = b.length; c < f; c++) {
              var g = b[c];
              if (g.name == e) return g;
            }
            return null;
          };
          k.prototype.findIkConstraint = function (e) {
            if (null == e) throw Error("constraintName cannot be null.");
            for (var b = this.ikConstraints, c = 0, f = b.length; c < f; c++) {
              var g = b[c];
              if (g.name == e) return g;
            }
            return null;
          };
          k.prototype.findTransformConstraint = function (e) {
            if (null == e) throw Error("constraintName cannot be null.");
            for (
              var b = this.transformConstraints, c = 0, f = b.length;
              c < f;
              c++
            ) {
              var g = b[c];
              if (g.name == e) return g;
            }
            return null;
          };
          k.prototype.findPathConstraint = function (e) {
            if (null == e) throw Error("constraintName cannot be null.");
            for (
              var b = this.pathConstraints, c = 0, f = b.length;
              c < f;
              c++
            ) {
              var g = b[c];
              if (g.name == e) return g;
            }
            return null;
          };
          k.prototype.findPathConstraintIndex = function (e) {
            if (null == e) throw Error("pathConstraintName cannot be null.");
            for (var b = this.pathConstraints, c = 0, f = b.length; c < f; c++)
              if (b[c].name == e) return c;
            return -1;
          };
          return k;
        })();
        a.SkeletonData = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function e(b) {
            this.scale = 1;
            this.linkedMeshes = [];
            this.attachmentLoader = b;
          }
          e.prototype.readSkeletonData = function (b) {
            var c = this.scale,
              f = new a.SkeletonData();
            b = "string" === typeof b ? JSON.parse(b) : b;
            var g = b.skeleton;
            if (null != g) {
              f.hash = g.hash;
              f.version = g.spine;
              if ("3.8.75" == f.version)
                throw Error(
                  "Unsupported skeleton data, please export with a newer version of Spine."
                );
              f.x = g.x;
              f.y = g.y;
              f.width = g.width;
              f.height = g.height;
              f.fps = g.fps;
              f.imagesPath = g.images;
            }
            if (b.bones)
              for (g = 0; g < b.bones.length; g++) {
                var m = b.bones[g],
                  n = null,
                  q = this.getValue(m, "parent", null);
                if (null != q && ((n = f.findBone(q)), null == n))
                  throw Error("Parent bone not found: " + q);
                n = new a.BoneData(f.bones.length, m.name, n);
                n.length = this.getValue(m, "length", 0) * c;
                n.x = this.getValue(m, "x", 0) * c;
                n.y = this.getValue(m, "y", 0) * c;
                n.rotation = this.getValue(m, "rotation", 0);
                n.scaleX = this.getValue(m, "scaleX", 1);
                n.scaleY = this.getValue(m, "scaleY", 1);
                n.shearX = this.getValue(m, "shearX", 0);
                n.shearY = this.getValue(m, "shearY", 0);
                n.transformMode = e.transformModeFromString(
                  this.getValue(m, "transform", "normal")
                );
                n.skinRequired = this.getValue(m, "skin", !1);
                f.bones.push(n);
              }
            if (b.slots)
              for (g = 0; g < b.slots.length; g++) {
                m = b.slots[g];
                var r = m.name;
                q = m.bone;
                n = f.findBone(q);
                if (null == n) throw Error("Slot bone not found: " + q);
                n = new a.SlotData(f.slots.length, r, n);
                q = this.getValue(m, "color", null);
                null != q && n.color.setFromString(q);
                q = this.getValue(m, "dark", null);
                null != q &&
                  ((n.darkColor = new a.Color(1, 1, 1, 1)),
                  n.darkColor.setFromString(q));
                n.attachmentName = this.getValue(m, "attachment", null);
                n.blendMode = e.blendModeFromString(
                  this.getValue(m, "blend", "normal")
                );
                f.slots.push(n);
              }
            if (b.ik)
              for (g = 0; g < b.ik.length; g++) {
                var u = b.ik[g];
                n = new a.IkConstraintData(u.name);
                n.order = this.getValue(u, "order", 0);
                n.skinRequired = this.getValue(u, "skin", !1);
                for (var v = 0; v < u.bones.length; v++) {
                  q = u.bones[v];
                  m = f.findBone(q);
                  if (null == m) throw Error("IK bone not found: " + q);
                  n.bones.push(m);
                }
                m = u.target;
                n.target = f.findBone(m);
                if (null == n.target)
                  throw Error("IK target bone not found: " + m);
                n.mix = this.getValue(u, "mix", 1);
                n.softness = this.getValue(u, "softness", 0) * c;
                n.bendDirection = this.getValue(u, "bendPositive", !0) ? 1 : -1;
                n.compress = this.getValue(u, "compress", !1);
                n.stretch = this.getValue(u, "stretch", !1);
                n.uniform = this.getValue(u, "uniform", !1);
                f.ikConstraints.push(n);
              }
            if (b.transform)
              for (g = 0; g < b.transform.length; g++) {
                u = b.transform[g];
                n = new a.TransformConstraintData(u.name);
                n.order = this.getValue(u, "order", 0);
                n.skinRequired = this.getValue(u, "skin", !1);
                for (v = 0; v < u.bones.length; v++) {
                  q = u.bones[v];
                  m = f.findBone(q);
                  if (null == m)
                    throw Error("Transform constraint bone not found: " + q);
                  n.bones.push(m);
                }
                m = u.target;
                n.target = f.findBone(m);
                if (null == n.target)
                  throw Error(
                    "Transform constraint target bone not found: " + m
                  );
                n.local = this.getValue(u, "local", !1);
                n.relative = this.getValue(u, "relative", !1);
                n.offsetRotation = this.getValue(u, "rotation", 0);
                n.offsetX = this.getValue(u, "x", 0) * c;
                n.offsetY = this.getValue(u, "y", 0) * c;
                n.offsetScaleX = this.getValue(u, "scaleX", 0);
                n.offsetScaleY = this.getValue(u, "scaleY", 0);
                n.offsetShearY = this.getValue(u, "shearY", 0);
                n.rotateMix = this.getValue(u, "rotateMix", 1);
                n.translateMix = this.getValue(u, "translateMix", 1);
                n.scaleMix = this.getValue(u, "scaleMix", 1);
                n.shearMix = this.getValue(u, "shearMix", 1);
                f.transformConstraints.push(n);
              }
            if (b.path)
              for (g = 0; g < b.path.length; g++) {
                u = b.path[g];
                n = new a.PathConstraintData(u.name);
                n.order = this.getValue(u, "order", 0);
                n.skinRequired = this.getValue(u, "skin", !1);
                for (v = 0; v < u.bones.length; v++) {
                  q = u.bones[v];
                  m = f.findBone(q);
                  if (null == m)
                    throw Error("Transform constraint bone not found: " + q);
                  n.bones.push(m);
                }
                m = u.target;
                n.target = f.findSlot(m);
                if (null == n.target)
                  throw Error("Path target slot not found: " + m);
                n.positionMode = e.positionModeFromString(
                  this.getValue(u, "positionMode", "percent")
                );
                n.spacingMode = e.spacingModeFromString(
                  this.getValue(u, "spacingMode", "length")
                );
                n.rotateMode = e.rotateModeFromString(
                  this.getValue(u, "rotateMode", "tangent")
                );
                n.offsetRotation = this.getValue(u, "rotation", 0);
                n.position = this.getValue(u, "position", 0);
                n.positionMode == a.PositionMode.Fixed && (n.position *= c);
                n.spacing = this.getValue(u, "spacing", 0);
                if (
                  n.spacingMode == a.SpacingMode.Length ||
                  n.spacingMode == a.SpacingMode.Fixed
                )
                  n.spacing *= c;
                n.rotateMix = this.getValue(u, "rotateMix", 1);
                n.translateMix = this.getValue(u, "translateMix", 1);
                f.pathConstraints.push(n);
              }
            if (b.skins)
              for (g = 0; g < b.skins.length; g++) {
                n = b.skins[g];
                c = new a.Skin(n.name);
                if (n.bones)
                  for (q = 0; q < n.bones.length; q++) {
                    m = f.findBone(n.bones[q]);
                    if (null == m)
                      throw Error("Skin bone not found: " + n.bones[g]);
                    c.bones.push(m);
                  }
                if (n.ik)
                  for (q = 0; q < n.ik.length; q++) {
                    m = f.findIkConstraint(n.ik[q]);
                    if (null == m)
                      throw Error("Skin IK constraint not found: " + n.ik[g]);
                    c.constraints.push(m);
                  }
                if (n.transform)
                  for (q = 0; q < n.transform.length; q++) {
                    m = f.findTransformConstraint(n.transform[q]);
                    if (null == m)
                      throw Error(
                        "Skin transform constraint not found: " + n.transform[g]
                      );
                    c.constraints.push(m);
                  }
                if (n.path)
                  for (q = 0; q < n.path.length; q++) {
                    m = f.findPathConstraint(n.path[q]);
                    if (null == m)
                      throw Error(
                        "Skin path constraint not found: " + n.path[g]
                      );
                    c.constraints.push(m);
                  }
                for (r in n.attachments) {
                  q = f.findSlot(r);
                  if (null == q) throw Error("Slot not found: " + r);
                  m = n.attachments[r];
                  for (var x in m)
                    (u = this.readAttachment(m[x], c, q.index, x, f)),
                      null != u && c.setAttachment(q.index, x, u);
                }
                f.skins.push(c);
                "default" == c.name && (f.defaultSkin = c);
              }
            g = 0;
            for (r = this.linkedMeshes.length; g < r; g++) {
              x = this.linkedMeshes[g];
              c = null == x.skin ? f.defaultSkin : f.findSkin(x.skin);
              if (null == c) throw Error("Skin not found: " + x.skin);
              c = c.getAttachment(x.slotIndex, x.parent);
              if (null == c) throw Error("Parent mesh not found: " + x.parent);
              x.mesh.deformAttachment = x.inheritDeform ? c : x.mesh;
              x.mesh.setParentMesh(c);
              x.mesh.updateUVs();
            }
            this.linkedMeshes.length = 0;
            if (b.events)
              for (var y in b.events)
                (g = b.events[y]),
                  (n = new a.EventData(y)),
                  (n.intValue = this.getValue(g, "int", 0)),
                  (n.floatValue = this.getValue(g, "float", 0)),
                  (n.stringValue = this.getValue(g, "string", "")),
                  (n.audioPath = this.getValue(g, "audio", null)),
                  null != n.audioPath &&
                    ((n.volume = this.getValue(g, "volume", 1)),
                    (n.balance = this.getValue(g, "balance", 0))),
                  f.events.push(n);
            if (b.animations)
              for (var z in b.animations)
                this.readAnimation(b.animations[z], z, f);
            return f;
          };
          e.prototype.readAttachment = function (b, c, f, g, m) {
            var n = this.scale;
            g = this.getValue(b, "name", g);
            switch (this.getValue(b, "type", "region")) {
              case "region":
                m = this.getValue(b, "path", g);
                f = this.attachmentLoader.newRegionAttachment(c, g, m);
                if (null == f) break;
                f.path = m;
                f.x = this.getValue(b, "x", 0) * n;
                f.y = this.getValue(b, "y", 0) * n;
                f.scaleX = this.getValue(b, "scaleX", 1);
                f.scaleY = this.getValue(b, "scaleY", 1);
                f.rotation = this.getValue(b, "rotation", 0);
                f.width = b.width * n;
                f.height = b.height * n;
                c = this.getValue(b, "color", null);
                null != c && f.color.setFromString(c);
                f.updateOffset();
                return f;
              case "boundingbox":
                n = this.attachmentLoader.newBoundingBoxAttachment(c, g);
                if (null == n) break;
                this.readVertices(b, n, b.vertexCount << 1);
                c = this.getValue(b, "color", null);
                null != c && n.color.setFromString(c);
                return n;
              case "mesh":
              case "linkedmesh":
                m = this.getValue(b, "path", g);
                g = this.attachmentLoader.newMeshAttachment(c, g, m);
                if (null == g) break;
                g.path = m;
                c = this.getValue(b, "color", null);
                null != c && g.color.setFromString(c);
                g.width = this.getValue(b, "width", 0) * n;
                g.height = this.getValue(b, "height", 0) * n;
                n = this.getValue(b, "parent", null);
                if (null != n)
                  return (
                    this.linkedMeshes.push(
                      new k(
                        g,
                        this.getValue(b, "skin", null),
                        f,
                        n,
                        this.getValue(b, "deform", !0)
                      )
                    ),
                    g
                  );
                n = b.uvs;
                this.readVertices(b, g, n.length);
                g.triangles = b.triangles;
                g.regionUVs = n;
                g.updateUVs();
                g.edges = this.getValue(b, "edges", null);
                g.hullLength = 2 * this.getValue(b, "hull", 0);
                return g;
              case "path":
                m = this.attachmentLoader.newPathAttachment(c, g);
                if (null == m) break;
                m.closed = this.getValue(b, "closed", !1);
                m.constantSpeed = this.getValue(b, "constantSpeed", !0);
                f = b.vertexCount;
                this.readVertices(b, m, f << 1);
                f = a.Utils.newArray(f / 3, 0);
                for (c = 0; c < b.lengths.length; c++) f[c] = b.lengths[c] * n;
                m.lengths = f;
                c = this.getValue(b, "color", null);
                null != c && m.color.setFromString(c);
                return m;
              case "point":
                m = this.attachmentLoader.newPointAttachment(c, g);
                if (null == m) break;
                m.x = this.getValue(b, "x", 0) * n;
                m.y = this.getValue(b, "y", 0) * n;
                m.rotation = this.getValue(b, "rotation", 0);
                c = this.getValue(b, "color", null);
                null != c && m.color.setFromString(c);
                return m;
              case "clipping":
                if (
                  ((n = this.attachmentLoader.newClippingAttachment(c, g)),
                  null != n)
                ) {
                  f = this.getValue(b, "end", null);
                  if (null != f) {
                    m = m.findSlot(f);
                    if (null == m)
                      throw Error("Clipping end slot not found: " + f);
                    n.endSlot = m;
                  }
                  f = b.vertexCount;
                  this.readVertices(b, n, f << 1);
                  c = this.getValue(b, "color", null);
                  null != c && n.color.setFromString(c);
                  return n;
                }
            }
            return null;
          };
          e.prototype.readVertices = function (b, c, f) {
            var g = this.scale;
            c.worldVerticesLength = f;
            b = b.vertices;
            if (f == b.length) {
              var m = a.Utils.toFloatArray(b);
              if (1 != g) {
                f = 0;
                for (var n = b.length; f < n; f++) m[f] *= g;
              }
              c.vertices = m;
            } else {
              m = [];
              var q = [];
              f = 0;
              for (n = b.length; f < n; ) {
                var r = b[f++];
                q.push(r);
                for (r = f + 4 * r; f < r; f += 4)
                  q.push(b[f]),
                    m.push(b[f + 1] * g),
                    m.push(b[f + 2] * g),
                    m.push(b[f + 3]);
              }
              c.bones = q;
              c.vertices = a.Utils.toFloatArray(m);
            }
          };
          e.prototype.readAnimation = function (b, c, f) {
            var g = this.scale,
              m = [],
              n = 0;
            if (b.slots)
              for (var q in b.slots) {
                var r = b.slots[q],
                  u = f.findSlotIndex(q);
                if (-1 == u) throw Error("Slot not found: " + q);
                for (var v in r) {
                  var x = r[v];
                  if ("attachment" == v) {
                    var y = new a.AttachmentTimeline(x.length);
                    y.slotIndex = u;
                    for (var z = 0, A = 0; A < x.length; A++) {
                      var B = x[A];
                      y.setFrame(z++, this.getValue(B, "time", 0), B.name);
                    }
                    m.push(y);
                    n = Math.max(n, y.frames[y.getFrameCount() - 1]);
                  } else if ("color" == v) {
                    y = new a.ColorTimeline(x.length);
                    y.slotIndex = u;
                    for (A = z = 0; A < x.length; A++) {
                      B = x[A];
                      var D = new a.Color();
                      D.setFromString(B.color);
                      y.setFrame(
                        z,
                        this.getValue(B, "time", 0),
                        D.r,
                        D.g,
                        D.b,
                        D.a
                      );
                      this.readCurve(B, y, z);
                      z++;
                    }
                    m.push(y);
                    n = Math.max(
                      n,
                      y.frames[
                        (y.getFrameCount() - 1) * a.ColorTimeline.ENTRIES
                      ]
                    );
                  } else if ("twoColor" == v) {
                    y = new a.TwoColorTimeline(x.length);
                    y.slotIndex = u;
                    for (A = z = 0; A < x.length; A++) {
                      B = x[A];
                      D = new a.Color();
                      var E = new a.Color();
                      D.setFromString(B.light);
                      E.setFromString(B.dark);
                      y.setFrame(
                        z,
                        this.getValue(B, "time", 0),
                        D.r,
                        D.g,
                        D.b,
                        D.a,
                        E.r,
                        E.g,
                        E.b
                      );
                      this.readCurve(B, y, z);
                      z++;
                    }
                    m.push(y);
                    n = Math.max(
                      n,
                      y.frames[
                        (y.getFrameCount() - 1) * a.TwoColorTimeline.ENTRIES
                      ]
                    );
                  } else
                    throw Error(
                      "Invalid timeline type for a slot: " + v + " (" + q + ")"
                    );
                }
              }
            if (b.bones)
              for (var C in b.bones) {
                r = b.bones[C];
                D = f.findBoneIndex(C);
                if (-1 == D) throw Error("Bone not found: " + C);
                for (v in r)
                  if (((x = r[v]), "rotate" === v)) {
                    y = new a.RotateTimeline(x.length);
                    y.boneIndex = D;
                    for (A = z = 0; A < x.length; A++)
                      (B = x[A]),
                        y.setFrame(
                          z,
                          this.getValue(B, "time", 0),
                          this.getValue(B, "angle", 0)
                        ),
                        this.readCurve(B, y, z),
                        z++;
                    m.push(y);
                    n = Math.max(
                      n,
                      y.frames[
                        (y.getFrameCount() - 1) * a.RotateTimeline.ENTRIES
                      ]
                    );
                  } else if (
                    "translate" === v ||
                    "scale" === v ||
                    "shear" === v
                  ) {
                    u = 1;
                    E = 0;
                    "scale" === v
                      ? ((y = new a.ScaleTimeline(x.length)), (E = 1))
                      : "shear" === v
                      ? (y = new a.ShearTimeline(x.length))
                      : ((y = new a.TranslateTimeline(x.length)), (u = g));
                    y.boneIndex = D;
                    for (A = z = 0; A < x.length; A++) {
                      B = x[A];
                      var F = this.getValue(B, "x", E),
                        G = this.getValue(B, "y", E);
                      y.setFrame(z, this.getValue(B, "time", 0), F * u, G * u);
                      this.readCurve(B, y, z);
                      z++;
                    }
                    m.push(y);
                    n = Math.max(
                      n,
                      y.frames[
                        (y.getFrameCount() - 1) * a.TranslateTimeline.ENTRIES
                      ]
                    );
                  } else
                    throw Error(
                      "Invalid timeline type for a bone: " + v + " (" + C + ")"
                    );
              }
            if (b.ik)
              for (var H in b.ik) {
                r = b.ik[H];
                z = f.findIkConstraint(H);
                y = new a.IkConstraintTimeline(r.length);
                y.ikConstraintIndex = f.ikConstraints.indexOf(z);
                for (A = z = 0; A < r.length; A++)
                  (B = r[A]),
                    y.setFrame(
                      z,
                      this.getValue(B, "time", 0),
                      this.getValue(B, "mix", 1),
                      this.getValue(B, "softness", 0) * g,
                      this.getValue(B, "bendPositive", !0) ? 1 : -1,
                      this.getValue(B, "compress", !1),
                      this.getValue(B, "stretch", !1)
                    ),
                    this.readCurve(B, y, z),
                    z++;
                m.push(y);
                n = Math.max(
                  n,
                  y.frames[
                    (y.getFrameCount() - 1) * a.IkConstraintTimeline.ENTRIES
                  ]
                );
              }
            if (b.transform)
              for (H in b.transform) {
                r = b.transform[H];
                z = f.findTransformConstraint(H);
                y = new a.TransformConstraintTimeline(r.length);
                y.transformConstraintIndex = f.transformConstraints.indexOf(z);
                for (A = z = 0; A < r.length; A++)
                  (B = r[A]),
                    y.setFrame(
                      z,
                      this.getValue(B, "time", 0),
                      this.getValue(B, "rotateMix", 1),
                      this.getValue(B, "translateMix", 1),
                      this.getValue(B, "scaleMix", 1),
                      this.getValue(B, "shearMix", 1)
                    ),
                    this.readCurve(B, y, z),
                    z++;
                m.push(y);
                n = Math.max(
                  n,
                  y.frames[
                    (y.getFrameCount() - 1) *
                      a.TransformConstraintTimeline.ENTRIES
                  ]
                );
              }
            if (b.path)
              for (H in b.path) {
                r = b.path[H];
                C = f.findPathConstraintIndex(H);
                if (-1 == C) throw Error("Path constraint not found: " + H);
                D = f.pathConstraints[C];
                for (v in r)
                  if (((x = r[v]), "position" === v || "spacing" === v)) {
                    u = 1;
                    if ("spacing" === v) {
                      if (
                        ((y = new a.PathConstraintSpacingTimeline(x.length)),
                        D.spacingMode == a.SpacingMode.Length ||
                          D.spacingMode == a.SpacingMode.Fixed)
                      )
                        u = g;
                    } else
                      (y = new a.PathConstraintPositionTimeline(x.length)),
                        D.positionMode == a.PositionMode.Fixed && (u = g);
                    y.pathConstraintIndex = C;
                    for (A = z = 0; A < x.length; A++)
                      (B = x[A]),
                        y.setFrame(
                          z,
                          this.getValue(B, "time", 0),
                          this.getValue(B, v, 0) * u
                        ),
                        this.readCurve(B, y, z),
                        z++;
                    m.push(y);
                    n = Math.max(
                      n,
                      y.frames[
                        (y.getFrameCount() - 1) *
                          a.PathConstraintPositionTimeline.ENTRIES
                      ]
                    );
                  } else if ("mix" === v) {
                    y = new a.PathConstraintMixTimeline(x.length);
                    y.pathConstraintIndex = C;
                    for (A = z = 0; A < x.length; A++)
                      (B = x[A]),
                        y.setFrame(
                          z,
                          this.getValue(B, "time", 0),
                          this.getValue(B, "rotateMix", 1),
                          this.getValue(B, "translateMix", 1)
                        ),
                        this.readCurve(B, y, z),
                        z++;
                    m.push(y);
                    n = Math.max(
                      n,
                      y.frames[
                        (y.getFrameCount() - 1) *
                          a.PathConstraintMixTimeline.ENTRIES
                      ]
                    );
                  }
              }
            if (b.deform)
              for (var K in b.deform) {
                C = b.deform[K];
                D = f.findSkin(K);
                if (null == D) throw Error("Skin not found: " + K);
                for (q in C) {
                  r = C[q];
                  u = f.findSlotIndex(q);
                  if (-1 == u) throw Error("Slot not found: " + r.name);
                  for (v in r) {
                    x = r[v];
                    z = D.getAttachment(u, v);
                    if (null == z)
                      throw Error("Deform attachment not found: " + x.name);
                    E = null != z.bones;
                    F = z.vertices;
                    G = E ? (F.length / 3) * 2 : F.length;
                    y = new a.DeformTimeline(x.length);
                    y.slotIndex = u;
                    y.attachment = z;
                    for (H = z = 0; H < x.length; H++) {
                      B = x[H];
                      var I = this.getValue(B, "vertices", null);
                      if (null == I) var M = E ? a.Utils.newFloatArray(G) : F;
                      else {
                        M = a.Utils.newFloatArray(G);
                        A = this.getValue(B, "offset", 0);
                        a.Utils.arrayCopy(I, 0, M, A, I.length);
                        if (1 != g)
                          for (I = A + I.length; A < I; A++) M[A] *= g;
                        if (!E) for (A = 0; A < G; A++) M[A] += F[A];
                      }
                      y.setFrame(z, this.getValue(B, "time", 0), M);
                      this.readCurve(B, y, z);
                      z++;
                    }
                    m.push(y);
                    n = Math.max(n, y.frames[y.getFrameCount() - 1]);
                  }
                }
              }
            g = b.drawOrder;
            null == g && (g = b.draworder);
            if (null != g) {
              y = new a.DrawOrderTimeline(g.length);
              q = f.slots.length;
              for (H = z = 0; H < g.length; H++) {
                v = g[H];
                K = null;
                x = this.getValue(v, "offsets", null);
                if (null != x) {
                  K = a.Utils.newArray(q, -1);
                  B = a.Utils.newArray(q - x.length, 0);
                  for (A = C = r = 0; A < x.length; A++) {
                    D = x[A];
                    u = f.findSlotIndex(D.slot);
                    if (-1 == u) throw Error("Slot not found: " + D.slot);
                    for (; r != u; ) B[C++] = r++;
                    K[r + D.offset] = r++;
                  }
                  for (; r < q; ) B[C++] = r++;
                  for (A = q - 1; 0 <= A; A--) -1 == K[A] && (K[A] = B[--C]);
                }
                y.setFrame(z++, this.getValue(v, "time", 0), K);
              }
              m.push(y);
              n = Math.max(n, y.frames[y.getFrameCount() - 1]);
            }
            if (b.events) {
              y = new a.EventTimeline(b.events.length);
              for (A = z = 0; A < b.events.length; A++) {
                g = b.events[A];
                q = f.findEvent(g.name);
                if (null == q) throw Error("Event not found: " + g.name);
                v = new a.Event(
                  a.Utils.toSinglePrecision(this.getValue(g, "time", 0)),
                  q
                );
                v.intValue = this.getValue(g, "int", q.intValue);
                v.floatValue = this.getValue(g, "float", q.floatValue);
                v.stringValue = this.getValue(g, "string", q.stringValue);
                null != v.data.audioPath &&
                  ((v.volume = this.getValue(g, "volume", 1)),
                  (v.balance = this.getValue(g, "balance", 0)));
                y.setFrame(z++, v);
              }
              m.push(y);
              n = Math.max(n, y.frames[y.getFrameCount() - 1]);
            }
            if (isNaN(n))
              throw Error("Error while parsing animation, duration is NaN");
            f.animations.push(new a.Animation(c, m, n));
          };
          e.prototype.readCurve = function (b, c, f) {
            b.hasOwnProperty("curve") &&
              ("stepped" == b.curve
                ? c.setStepped(f)
                : c.setCurve(
                    f,
                    b.curve,
                    this.getValue(b, "c2", 0),
                    this.getValue(b, "c3", 1),
                    this.getValue(b, "c4", 1)
                  ));
          };
          e.prototype.getValue = function (b, c, f) {
            return void 0 !== b[c] ? b[c] : f;
          };
          e.blendModeFromString = function (b) {
            b = b.toLowerCase();
            if ("normal" == b) return a.BlendMode.Normal;
            if ("additive" == b) return a.BlendMode.Additive;
            if ("multiply" == b) return a.BlendMode.Multiply;
            if ("screen" == b) return a.BlendMode.Screen;
            throw Error("Unknown blend mode: " + b);
          };
          e.positionModeFromString = function (b) {
            b = b.toLowerCase();
            if ("fixed" == b) return a.PositionMode.Fixed;
            if ("percent" == b) return a.PositionMode.Percent;
            throw Error("Unknown position mode: " + b);
          };
          e.spacingModeFromString = function (b) {
            b = b.toLowerCase();
            if ("length" == b) return a.SpacingMode.Length;
            if ("fixed" == b) return a.SpacingMode.Fixed;
            if ("percent" == b) return a.SpacingMode.Percent;
            throw Error("Unknown position mode: " + b);
          };
          e.rotateModeFromString = function (b) {
            b = b.toLowerCase();
            if ("tangent" == b) return a.RotateMode.Tangent;
            if ("chain" == b) return a.RotateMode.Chain;
            if ("chainscale" == b) return a.RotateMode.ChainScale;
            throw Error("Unknown rotate mode: " + b);
          };
          e.transformModeFromString = function (b) {
            b = b.toLowerCase();
            if ("normal" == b) return a.TransformMode.Normal;
            if ("onlytranslation" == b) return a.TransformMode.OnlyTranslation;
            if ("norotationorreflection" == b)
              return a.TransformMode.NoRotationOrReflection;
            if ("noscale" == b) return a.TransformMode.NoScale;
            if ("noscaleorreflection" == b)
              return a.TransformMode.NoScaleOrReflection;
            throw Error("Unknown transform mode: " + b);
          };
          return e;
        })();
        a.SkeletonJson = d;
        var k = (function () {
          return function (e, b, c, f, g) {
            this.mesh = e;
            this.skin = b;
            this.slotIndex = c;
            this.parent = f;
            this.inheritDeform = g;
          };
        })();
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          return function (e, b, c) {
            this.slotIndex = e;
            this.name = b;
            this.attachment = c;
          };
        })();
        a.SkinEntry = d;
        var k = (function () {
          function e(b) {
            this.attachments = [];
            this.bones = [];
            this.constraints = [];
            if (null == b) throw Error("name cannot be null.");
            this.name = b;
          }
          e.prototype.setAttachment = function (b, c, f) {
            if (null == f) throw Error("attachment cannot be null.");
            var g = this.attachments;
            b >= g.length && (g.length = b + 1);
            g[b] || (g[b] = {});
            g[b][c] = f;
          };
          e.prototype.addSkin = function (b) {
            for (var c = 0; c < b.bones.length; c++) {
              for (
                var f = b.bones[c], g = !1, m = 0;
                m < this.bones.length;
                m++
              )
                if (this.bones[m] == f) {
                  g = !0;
                  break;
                }
              g || this.bones.push(f);
            }
            for (c = 0; c < b.constraints.length; c++) {
              f = b.constraints[c];
              g = !1;
              for (m = 0; m < this.constraints.length; m++)
                if (this.constraints[m] == f) {
                  g = !0;
                  break;
                }
              g || this.constraints.push(f);
            }
            b = b.getAttachments();
            for (c = 0; c < b.length; c++)
              (g = b[c]), this.setAttachment(g.slotIndex, g.name, g.attachment);
          };
          e.prototype.copySkin = function (b) {
            for (var c = 0; c < b.bones.length; c++) {
              for (
                var f = b.bones[c], g = !1, m = 0;
                m < this.bones.length;
                m++
              )
                if (this.bones[m] == f) {
                  g = !0;
                  break;
                }
              g || this.bones.push(f);
            }
            for (c = 0; c < b.constraints.length; c++) {
              f = b.constraints[c];
              g = !1;
              for (m = 0; m < this.constraints.length; m++)
                if (this.constraints[m] == f) {
                  g = !0;
                  break;
                }
              g || this.constraints.push(f);
            }
            b = b.getAttachments();
            for (c = 0; c < b.length; c++)
              (g = b[c]),
                null != g.attachment &&
                  ((g.attachment =
                    g.attachment instanceof a.MeshAttachment
                      ? g.attachment.newLinkedMesh()
                      : g.attachment.copy()),
                  this.setAttachment(g.slotIndex, g.name, g.attachment));
          };
          e.prototype.getAttachment = function (b, c) {
            return (b = this.attachments[b]) ? b[c] : null;
          };
          e.prototype.removeAttachment = function (b, c) {
            (b = this.attachments[b]) && (b[c] = null);
          };
          e.prototype.getAttachments = function () {
            for (var b = [], c = 0; c < this.attachments.length; c++) {
              var f = this.attachments[c];
              if (f)
                for (var g in f) {
                  var m = f[g];
                  m && b.push(new d(c, g, m));
                }
            }
            return b;
          };
          e.prototype.getAttachmentsForSlot = function (b, c) {
            var f = this.attachments[b];
            if (f)
              for (var g in f) {
                var m = f[g];
                m && c.push(new d(b, g, m));
              }
          };
          e.prototype.clear = function () {
            this.attachments.length = 0;
            this.bones.length = 0;
            this.constraints.length = 0;
          };
          e.prototype.attachAll = function (b, c) {
            for (var f = 0, g = 0; g < b.slots.length; g++) {
              var m = b.slots[g],
                n = m.getAttachment();
              if (n && f < c.attachments.length) {
                var q = c.attachments[f],
                  r;
                for (r in q)
                  if (n == q[r]) {
                    n = this.getAttachment(f, r);
                    null != n && m.setAttachment(n);
                    break;
                  }
              }
              f++;
            }
          };
          return e;
        })();
        a.Skin = k;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k(e, b) {
            this.deform = [];
            if (null == e) throw Error("data cannot be null.");
            if (null == b) throw Error("bone cannot be null.");
            this.data = e;
            this.bone = b;
            this.color = new a.Color();
            this.darkColor = null == e.darkColor ? null : new a.Color();
            this.setToSetupPose();
          }
          k.prototype.getSkeleton = function () {
            return this.bone.skeleton;
          };
          k.prototype.getAttachment = function () {
            return this.attachment;
          };
          k.prototype.setAttachment = function (e) {
            this.attachment != e &&
              ((this.attachment = e),
              (this.attachmentTime = this.bone.skeleton.time),
              (this.deform.length = 0));
          };
          k.prototype.setAttachmentTime = function (e) {
            this.attachmentTime = this.bone.skeleton.time - e;
          };
          k.prototype.getAttachmentTime = function () {
            return this.bone.skeleton.time - this.attachmentTime;
          };
          k.prototype.setToSetupPose = function () {
            this.color.setFromColor(this.data.color);
            null != this.darkColor &&
              this.darkColor.setFromColor(this.data.darkColor);
            null == this.data.attachmentName
              ? (this.attachment = null)
              : ((this.attachment = null),
                this.setAttachment(
                  this.bone.skeleton.getAttachment(
                    this.data.index,
                    this.data.attachmentName
                  )
                ));
          };
          return k;
        })();
        a.Slot = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          return function (k, e, b) {
            this.color = new a.Color(1, 1, 1, 1);
            if (0 > k) throw Error("index must be >= 0.");
            if (null == e) throw Error("name cannot be null.");
            if (null == b) throw Error("boneData cannot be null.");
            this.index = k;
            this.name = e;
            this.boneData = b;
          };
        })();
        a.SlotData = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function c(f) {
            this._image = f;
          }
          c.prototype.getImage = function () {
            return this._image;
          };
          c.filterFromString = function (f) {
            switch (f.toLowerCase()) {
              case "nearest":
                return k.Nearest;
              case "linear":
                return k.Linear;
              case "mipmap":
                return k.MipMap;
              case "mipmapnearestnearest":
                return k.MipMapNearestNearest;
              case "mipmaplinearnearest":
                return k.MipMapLinearNearest;
              case "mipmapnearestlinear":
                return k.MipMapNearestLinear;
              case "mipmaplinearlinear":
                return k.MipMapLinearLinear;
              default:
                throw Error("Unknown texture filter " + f);
            }
          };
          c.wrapFromString = function (f) {
            switch (f.toLowerCase()) {
              case "mirroredtepeat":
                return e.MirroredRepeat;
              case "clamptoedge":
                return e.ClampToEdge;
              case "repeat":
                return e.Repeat;
              default:
                throw Error("Unknown texture wrap " + f);
            }
          };
          return c;
        })();
        a.Texture = d;
        var k;
        (function (c) {
          c[(c.Nearest = 9728)] = "Nearest";
          c[(c.Linear = 9729)] = "Linear";
          c[(c.MipMap = 9987)] = "MipMap";
          c[(c.MipMapNearestNearest = 9984)] = "MipMapNearestNearest";
          c[(c.MipMapLinearNearest = 9985)] = "MipMapLinearNearest";
          c[(c.MipMapNearestLinear = 9986)] = "MipMapNearestLinear";
          c[(c.MipMapLinearLinear = 9987)] = "MipMapLinearLinear";
        })((k = a.TextureFilter || (a.TextureFilter = {})));
        var e;
        (function (c) {
          c[(c.MirroredRepeat = 33648)] = "MirroredRepeat";
          c[(c.ClampToEdge = 33071)] = "ClampToEdge";
          c[(c.Repeat = 10497)] = "Repeat";
        })((e = a.TextureWrap || (a.TextureWrap = {})));
        var b = (function () {
          return function () {
            this.height = this.width = this.v2 = this.u2 = this.v = this.u = 0;
            this.rotate = !1;
            this.originalHeight =
              this.originalWidth =
              this.offsetY =
              this.offsetX =
                0;
          };
        })();
        a.TextureRegion = b;
        d = (function (c) {
          function f() {
            return (null !== c && c.apply(this, arguments)) || this;
          }
          h(f, c);
          f.prototype.setFilters = function (g, m) {};
          f.prototype.setWraps = function (g, m) {};
          f.prototype.dispose = function () {};
          return f;
        })(d);
        a.FakeTexture = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function c(f, g) {
            this.pages = [];
            this.regions = [];
            this.load(f, g);
          }
          c.prototype.load = function (f, g) {
            if (null == g) throw Error("textureLoader cannot be null.");
            f = new k(f);
            for (var m = Array(4), n = null; ; ) {
              var q = f.readLine();
              if (null == q) break;
              q = q.trim();
              if (0 == q.length) n = null;
              else if (n) {
                var r = new b();
                r.name = q;
                r.page = n;
                q = f.readValue();
                "true" == q.toLocaleLowerCase()
                  ? (r.degrees = 90)
                  : "false" == q.toLocaleLowerCase()
                  ? (r.degrees = 0)
                  : (r.degrees = parseFloat(q));
                r.rotate = 90 == r.degrees;
                f.readTuple(m);
                q = parseInt(m[0]);
                var u = parseInt(m[1]);
                f.readTuple(m);
                var v = parseInt(m[0]),
                  x = parseInt(m[1]);
                r.u = q / n.width;
                r.v = u / n.height;
                r.rotate
                  ? ((r.u2 = (q + x) / n.width), (r.v2 = (u + v) / n.height))
                  : ((r.u2 = (q + v) / n.width), (r.v2 = (u + x) / n.height));
                r.x = q;
                r.y = u;
                r.width = Math.abs(v);
                r.height = Math.abs(x);
                4 == f.readTuple(m) && 4 == f.readTuple(m) && f.readTuple(m);
                r.originalWidth = parseInt(m[0]);
                r.originalHeight = parseInt(m[1]);
                f.readTuple(m);
                r.offsetX = parseInt(m[0]);
                r.offsetY = parseInt(m[1]);
                r.index = parseInt(f.readValue());
                r.texture = n.texture;
                this.regions.push(r);
              } else
                (n = new e()),
                  (n.name = q),
                  2 == f.readTuple(m) &&
                    ((n.width = parseInt(m[0])),
                    (n.height = parseInt(m[1])),
                    f.readTuple(m)),
                  f.readTuple(m),
                  (n.minFilter = a.Texture.filterFromString(m[0])),
                  (n.magFilter = a.Texture.filterFromString(m[1])),
                  (r = f.readValue()),
                  (n.uWrap = a.TextureWrap.ClampToEdge),
                  (n.vWrap = a.TextureWrap.ClampToEdge),
                  "x" == r
                    ? (n.uWrap = a.TextureWrap.Repeat)
                    : "y" == r
                    ? (n.vWrap = a.TextureWrap.Repeat)
                    : "xy" == r && (n.uWrap = n.vWrap = a.TextureWrap.Repeat),
                  (n.texture = g(q)),
                  n.texture.setFilters(n.minFilter, n.magFilter),
                  n.texture.setWraps(n.uWrap, n.vWrap),
                  (n.width = n.texture.getImage().width),
                  (n.height = n.texture.getImage().height),
                  this.pages.push(n);
            }
          };
          c.prototype.findRegion = function (f) {
            for (var g = 0; g < this.regions.length; g++)
              if (this.regions[g].name == f) return this.regions[g];
            return null;
          };
          c.prototype.dispose = function () {
            for (var f = 0; f < this.pages.length; f++)
              this.pages[f].texture.dispose();
          };
          return c;
        })();
        a.TextureAtlas = d;
        var k = (function () {
            function c(f) {
              this.index = 0;
              this.lines = f.split(/\r\n|\r|\n/);
            }
            c.prototype.readLine = function () {
              return this.index >= this.lines.length
                ? null
                : this.lines[this.index++];
            };
            c.prototype.readValue = function () {
              var f = this.readLine(),
                g = f.indexOf(":");
              if (-1 == g) throw Error("Invalid line: " + f);
              return f.substring(g + 1).trim();
            };
            c.prototype.readTuple = function (f) {
              var g = this.readLine(),
                m = g.indexOf(":");
              if (-1 == m) throw Error("Invalid line: " + g);
              var n = 0;
              for (m += 1; 3 > n; n++) {
                var q = g.indexOf(",", m);
                if (-1 == q) break;
                f[n] = g.substr(m, q - m).trim();
                m = q + 1;
              }
              f[n] = g.substring(m).trim();
              return n + 1;
            };
            return c;
          })(),
          e = (function () {
            return function () {};
          })();
        a.TextureAtlasPage = e;
        var b = (function (c) {
          function f() {
            return (null !== c && c.apply(this, arguments)) || this;
          }
          h(f, c);
          return f;
        })(a.TextureRegion);
        a.TextureAtlasRegion = b;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k(e, b) {
            this.shearMix =
              this.scaleMix =
              this.translateMix =
              this.rotateMix =
                0;
            this.temp = new a.Vector2();
            this.active = !1;
            if (null == e) throw Error("data cannot be null.");
            if (null == b) throw Error("skeleton cannot be null.");
            this.data = e;
            this.rotateMix = e.rotateMix;
            this.translateMix = e.translateMix;
            this.scaleMix = e.scaleMix;
            this.shearMix = e.shearMix;
            this.bones = [];
            for (var c = 0; c < e.bones.length; c++)
              this.bones.push(b.findBone(e.bones[c].name));
            this.target = b.findBone(e.target.name);
          }
          k.prototype.isActive = function () {
            return this.active;
          };
          k.prototype.apply = function () {
            this.update();
          };
          k.prototype.update = function () {
            this.data.local
              ? this.data.relative
                ? this.applyRelativeLocal()
                : this.applyAbsoluteLocal()
              : this.data.relative
              ? this.applyRelativeWorld()
              : this.applyAbsoluteWorld();
          };
          k.prototype.applyAbsoluteWorld = function () {
            var e = this.rotateMix,
              b = this.translateMix,
              c = this.scaleMix,
              f = this.shearMix,
              g = this.target,
              m = g.a,
              n = g.b,
              q = g.c,
              r = g.d,
              u = 0 < m * r - n * q ? a.MathUtils.degRad : -a.MathUtils.degRad,
              v = this.data.offsetRotation * u;
            u *= this.data.offsetShearY;
            for (var x = this.bones, y = 0, z = x.length; y < z; y++) {
              var A = x[y],
                B = !1;
              if (0 != e) {
                var D = A.a;
                B = A.b;
                var E = A.c,
                  C = A.d,
                  F = Math.atan2(q, m) - Math.atan2(E, D) + v;
                F > a.MathUtils.PI
                  ? (F -= a.MathUtils.PI2)
                  : F < -a.MathUtils.PI && (F += a.MathUtils.PI2);
                F *= e;
                var G = Math.cos(F);
                F = Math.sin(F);
                A.a = G * D - F * E;
                A.b = G * B - F * C;
                A.c = F * D + G * E;
                A.d = F * B + G * C;
                B = !0;
              }
              0 != b &&
                ((B = this.temp),
                g.localToWorld(B.set(this.data.offsetX, this.data.offsetY)),
                (A.worldX += (B.x - A.worldX) * b),
                (A.worldY += (B.y - A.worldY) * b),
                (B = !0));
              0 < c &&
                ((B = Math.sqrt(A.a * A.a + A.c * A.c)),
                (C = Math.sqrt(m * m + q * q)),
                1e-5 < B &&
                  (B = (B + (C - B + this.data.offsetScaleX) * c) / B),
                (A.a *= B),
                (A.c *= B),
                (B = Math.sqrt(A.b * A.b + A.d * A.d)),
                (C = Math.sqrt(n * n + r * r)),
                1e-5 < B &&
                  (B = (B + (C - B + this.data.offsetScaleY) * c) / B),
                (A.b *= B),
                (A.d *= B),
                (B = !0));
              0 < f &&
                ((B = A.b),
                (C = A.d),
                (D = Math.atan2(C, B)),
                (F =
                  Math.atan2(r, n) -
                  Math.atan2(q, m) -
                  (D - Math.atan2(A.c, A.a))),
                F > a.MathUtils.PI
                  ? (F -= a.MathUtils.PI2)
                  : F < -a.MathUtils.PI && (F += a.MathUtils.PI2),
                (F = D + (F + u) * f),
                (B = Math.sqrt(B * B + C * C)),
                (A.b = Math.cos(F) * B),
                (A.d = Math.sin(F) * B),
                (B = !0));
              B && (A.appliedValid = !1);
            }
          };
          k.prototype.applyRelativeWorld = function () {
            var e = this.rotateMix,
              b = this.translateMix,
              c = this.scaleMix,
              f = this.shearMix,
              g = this.target,
              m = g.a,
              n = g.b,
              q = g.c,
              r = g.d,
              u = 0 < m * r - n * q ? a.MathUtils.degRad : -a.MathUtils.degRad,
              v = this.data.offsetRotation * u;
            u *= this.data.offsetShearY;
            for (var x = this.bones, y = 0, z = x.length; y < z; y++) {
              var A = x[y],
                B = !1;
              if (0 != e) {
                B = A.a;
                var D = A.b,
                  E = A.c,
                  C = A.d,
                  F = Math.atan2(q, m) + v;
                F > a.MathUtils.PI
                  ? (F -= a.MathUtils.PI2)
                  : F < -a.MathUtils.PI && (F += a.MathUtils.PI2);
                F *= e;
                var G = Math.cos(F);
                F = Math.sin(F);
                A.a = G * B - F * E;
                A.b = G * D - F * C;
                A.c = F * B + G * E;
                A.d = F * D + G * C;
                B = !0;
              }
              0 != b &&
                ((B = this.temp),
                g.localToWorld(B.set(this.data.offsetX, this.data.offsetY)),
                (A.worldX += B.x * b),
                (A.worldY += B.y * b),
                (B = !0));
              0 < c &&
                ((B =
                  (Math.sqrt(m * m + q * q) - 1 + this.data.offsetScaleX) * c +
                  1),
                (A.a *= B),
                (A.c *= B),
                (B =
                  (Math.sqrt(n * n + r * r) - 1 + this.data.offsetScaleY) * c +
                  1),
                (A.b *= B),
                (A.d *= B),
                (B = !0));
              0 < f &&
                ((F = Math.atan2(r, n) - Math.atan2(q, m)),
                F > a.MathUtils.PI
                  ? (F -= a.MathUtils.PI2)
                  : F < -a.MathUtils.PI && (F += a.MathUtils.PI2),
                (D = A.b),
                (C = A.d),
                (F = Math.atan2(C, D) + (F - a.MathUtils.PI / 2 + u) * f),
                (B = Math.sqrt(D * D + C * C)),
                (A.b = Math.cos(F) * B),
                (A.d = Math.sin(F) * B),
                (B = !0));
              B && (A.appliedValid = !1);
            }
          };
          k.prototype.applyAbsoluteLocal = function () {
            var e = this.rotateMix,
              b = this.translateMix,
              c = this.scaleMix,
              f = this.shearMix,
              g = this.target;
            g.appliedValid || g.updateAppliedTransform();
            for (var m = this.bones, n = 0, q = m.length; n < q; n++) {
              var r = m[n];
              r.appliedValid || r.updateAppliedTransform();
              var u = r.arotation;
              if (0 != e) {
                var v = g.arotation - u + this.data.offsetRotation;
                v -= 360 * (16384 - ((16384.499999999996 - v / 360) | 0));
                u += v * e;
              }
              var x = r.ax,
                y = r.ay;
              0 != b &&
                ((x += (g.ax - x + this.data.offsetX) * b),
                (y += (g.ay - y + this.data.offsetY) * b));
              var z = r.ascaleX,
                A = r.ascaleY;
              0 != c &&
                (1e-5 < z &&
                  (z = (z + (g.ascaleX - z + this.data.offsetScaleX) * c) / z),
                1e-5 < A &&
                  (A = (A + (g.ascaleY - A + this.data.offsetScaleY) * c) / A));
              var B = r.ashearY;
              0 != f &&
                ((v = g.ashearY - B + this.data.offsetShearY),
                (v -= 360 * (16384 - ((16384.499999999996 - v / 360) | 0))),
                (r.shearY += v * f));
              r.updateWorldTransformWith(x, y, u, z, A, r.ashearX, B);
            }
          };
          k.prototype.applyRelativeLocal = function () {
            var e = this.rotateMix,
              b = this.translateMix,
              c = this.scaleMix,
              f = this.shearMix,
              g = this.target;
            g.appliedValid || g.updateAppliedTransform();
            for (var m = this.bones, n = 0, q = m.length; n < q; n++) {
              var r = m[n];
              r.appliedValid || r.updateAppliedTransform();
              var u = r.arotation;
              0 != e && (u += (g.arotation + this.data.offsetRotation) * e);
              var v = r.ax,
                x = r.ay;
              0 != b &&
                ((v += (g.ax + this.data.offsetX) * b),
                (x += (g.ay + this.data.offsetY) * b));
              var y = r.ascaleX,
                z = r.ascaleY;
              0 != c &&
                (1e-5 < y &&
                  (y *= (g.ascaleX - 1 + this.data.offsetScaleX) * c + 1),
                1e-5 < z &&
                  (z *= (g.ascaleY - 1 + this.data.offsetScaleY) * c + 1));
              var A = r.ashearY;
              0 != f && (A += (g.ashearY + this.data.offsetShearY) * f);
              r.updateWorldTransformWith(v, x, u, y, z, r.ashearX, A);
            }
          };
          return k;
        })();
        a.TransformConstraint = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function (k) {
          function e(b) {
            b = k.call(this, b, 0, !1) || this;
            b.bones = [];
            b.rotateMix = 0;
            b.translateMix = 0;
            b.scaleMix = 0;
            b.shearMix = 0;
            b.offsetRotation = 0;
            b.offsetX = 0;
            b.offsetY = 0;
            b.offsetScaleX = 0;
            b.offsetScaleY = 0;
            b.offsetShearY = 0;
            b.relative = !1;
            b.local = !1;
            return b;
          }
          h(e, k);
          return e;
        })(a.ConstraintData);
        a.TransformConstraintData = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k() {
            this.convexPolygons = [];
            this.convexPolygonsIndices = [];
            this.indicesArray = [];
            this.isConcaveArray = [];
            this.triangles = [];
            this.polygonPool = new a.Pool(function () {
              return [];
            });
            this.polygonIndicesPool = new a.Pool(function () {
              return [];
            });
          }
          k.prototype.triangulate = function (e) {
            for (
              var b = e.length >> 1, c = this.indicesArray, f = (c.length = 0);
              f < b;
              f++
            )
              c[f] = f;
            var g = this.isConcaveArray;
            f = g.length = 0;
            for (var m = b; f < m; ++f) g[f] = k.isConcave(f, b, e, c);
            m = this.triangles;
            for (m.length = 0; 3 < b; ) {
              var n = b - 1;
              f = 0;
              for (var q = 1; ; ) {
                a: if (!g[f]) {
                  var r = c[n] << 1,
                    u = c[f] << 1,
                    v = c[q] << 1,
                    x = e[r];
                  r = e[r + 1];
                  var y = e[u];
                  u = e[u + 1];
                  var z = e[v];
                  v = e[v + 1];
                  for (var A = (q + 1) % b; A != n; A = (A + 1) % b)
                    if (g[A]) {
                      var B = c[A] << 1,
                        D = e[B];
                      B = e[B + 1];
                      if (
                        k.positiveArea(z, v, x, r, D, B) &&
                        k.positiveArea(x, r, y, u, D, B) &&
                        k.positiveArea(y, u, z, v, D, B)
                      )
                        break a;
                    }
                  break;
                }
                if (0 == q) {
                  do {
                    if (!g[f]) break;
                    f--;
                  } while (0 < f);
                  break;
                }
                n = f;
                f = q;
                q = (q + 1) % b;
              }
              m.push(c[(b + f - 1) % b]);
              m.push(c[f]);
              m.push(c[(f + 1) % b]);
              c.splice(f, 1);
              g.splice(f, 1);
              b--;
              n = (b + f - 1) % b;
              f = f == b ? 0 : f;
              g[n] = k.isConcave(n, b, e, c);
              g[f] = k.isConcave(f, b, e, c);
            }
            3 == b && (m.push(c[2]), m.push(c[0]), m.push(c[1]));
            return m;
          };
          k.prototype.decompose = function (e, b) {
            var c = this.convexPolygons;
            this.polygonPool.freeAll(c);
            c.length = 0;
            var f = this.convexPolygonsIndices;
            this.polygonIndicesPool.freeAll(f);
            f.length = 0;
            var g = this.polygonIndicesPool.obtain();
            g.length = 0;
            var m = this.polygonPool.obtain();
            m.length = 0;
            for (var n = -1, q = 0, r = 0, u = b.length; r < u; r += 3) {
              var v = b[r] << 1,
                x = b[r + 1] << 1,
                y = b[r + 2] << 1,
                z = e[v],
                A = e[v + 1],
                B = e[x],
                D = e[x + 1],
                E = e[y],
                C = e[y + 1],
                F = !1;
              if (n == v) {
                var G = m.length - 4;
                G = k.winding(m[G], m[G + 1], m[G + 2], m[G + 3], E, C);
                var H = k.winding(E, C, m[0], m[1], m[2], m[3]);
                G == q && H == q && (m.push(E), m.push(C), g.push(y), (F = !0));
              }
              F ||
                (0 < m.length
                  ? (c.push(m), f.push(g))
                  : (this.polygonPool.free(m), this.polygonIndicesPool.free(g)),
                (m = this.polygonPool.obtain()),
                (m.length = 0),
                m.push(z),
                m.push(A),
                m.push(B),
                m.push(D),
                m.push(E),
                m.push(C),
                (g = this.polygonIndicesPool.obtain()),
                (g.length = 0),
                g.push(v),
                g.push(x),
                g.push(y),
                (q = k.winding(z, A, B, D, E, C)),
                (n = v));
            }
            0 < m.length && (c.push(m), f.push(g));
            r = 0;
            for (u = c.length; r < u; r++)
              if (((g = f[r]), 0 != g.length))
                for (
                  e = g[0],
                    b = g[g.length - 1],
                    m = c[r],
                    G = m.length - 4,
                    n = m[G],
                    q = m[G + 1],
                    v = m[G + 2],
                    x = m[G + 3],
                    y = m[0],
                    z = m[1],
                    A = m[2],
                    B = m[3],
                    D = k.winding(n, q, v, x, y, z),
                    F = 0;
                  F < u;
                  F++
                )
                  if (F != r) {
                    var K = f[F];
                    if (3 == K.length) {
                      G = K[0];
                      H = K[1];
                      var I = K[2],
                        M = c[F];
                      E = M[M.length - 2];
                      C = M[M.length - 1];
                      G == e &&
                        H == b &&
                        ((G = k.winding(n, q, v, x, E, C)),
                        (H = k.winding(E, C, y, z, A, B)),
                        G == D &&
                          H == D &&
                          ((M.length = 0),
                          (K.length = 0),
                          m.push(E),
                          m.push(C),
                          g.push(I),
                          (n = v),
                          (q = x),
                          (v = E),
                          (x = C),
                          (F = 0)));
                    }
                  }
            for (r = c.length - 1; 0 <= r; r--)
              (m = c[r]),
                0 == m.length &&
                  (c.splice(r, 1),
                  this.polygonPool.free(m),
                  (g = f[r]),
                  f.splice(r, 1),
                  this.polygonIndicesPool.free(g));
            return c;
          };
          k.isConcave = function (e, b, c, f) {
            var g = f[(b + e - 1) % b] << 1,
              m = f[e] << 1;
            e = f[(e + 1) % b] << 1;
            return !this.positiveArea(
              c[g],
              c[g + 1],
              c[m],
              c[m + 1],
              c[e],
              c[e + 1]
            );
          };
          k.positiveArea = function (e, b, c, f, g, m) {
            return 0 <= e * (m - f) + c * (b - m) + g * (f - b);
          };
          k.winding = function (e, b, c, f, g, m) {
            c -= e;
            f -= b;
            return 0 <= g * f - m * c + c * b - e * f ? 1 : -1;
          };
          return k;
        })();
        a.Triangulator = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k() {
            this.array = [];
          }
          k.prototype.add = function (e) {
            var b = this.contains(e);
            this.array[e | 0] = e | 0;
            return !b;
          };
          k.prototype.contains = function (e) {
            return void 0 != this.array[e | 0];
          };
          k.prototype.remove = function (e) {
            this.array[e | 0] = void 0;
          };
          k.prototype.clear = function () {
            this.array.length = 0;
          };
          return k;
        })();
        a.IntSet = d;
        d = (function () {
          function k(e, b, c, f) {
            void 0 === e && (e = 0);
            void 0 === b && (b = 0);
            void 0 === c && (c = 0);
            void 0 === f && (f = 0);
            this.r = e;
            this.g = b;
            this.b = c;
            this.a = f;
          }
          k.prototype.set = function (e, b, c, f) {
            this.r = e;
            this.g = b;
            this.b = c;
            this.a = f;
            this.clamp();
            return this;
          };
          k.prototype.setFromColor = function (e) {
            this.r = e.r;
            this.g = e.g;
            this.b = e.b;
            this.a = e.a;
            return this;
          };
          k.prototype.setFromString = function (e) {
            e = "#" == e.charAt(0) ? e.substr(1) : e;
            this.r = parseInt(e.substr(0, 2), 16) / 255;
            this.g = parseInt(e.substr(2, 2), 16) / 255;
            this.b = parseInt(e.substr(4, 2), 16) / 255;
            this.a = (8 != e.length ? 255 : parseInt(e.substr(6, 2), 16)) / 255;
            return this;
          };
          k.prototype.add = function (e, b, c, f) {
            this.r += e;
            this.g += b;
            this.b += c;
            this.a += f;
            this.clamp();
            return this;
          };
          k.prototype.clamp = function () {
            0 > this.r ? (this.r = 0) : 1 < this.r && (this.r = 1);
            0 > this.g ? (this.g = 0) : 1 < this.g && (this.g = 1);
            0 > this.b ? (this.b = 0) : 1 < this.b && (this.b = 1);
            0 > this.a ? (this.a = 0) : 1 < this.a && (this.a = 1);
            return this;
          };
          k.rgba8888ToColor = function (e, b) {
            e.r = ((b & 4278190080) >>> 24) / 255;
            e.g = ((b & 16711680) >>> 16) / 255;
            e.b = ((b & 65280) >>> 8) / 255;
            e.a = (b & 255) / 255;
          };
          k.rgb888ToColor = function (e, b) {
            e.r = ((b & 16711680) >>> 16) / 255;
            e.g = ((b & 65280) >>> 8) / 255;
            e.b = (b & 255) / 255;
          };
          k.WHITE = new k(1, 1, 1, 1);
          k.RED = new k(1, 0, 0, 1);
          k.GREEN = new k(0, 1, 0, 1);
          k.BLUE = new k(0, 0, 1, 1);
          k.MAGENTA = new k(1, 0, 1, 1);
          return k;
        })();
        a.Color = d;
        d = (function () {
          function k() {}
          k.clamp = function (e, b, c) {
            return e < b ? b : e > c ? c : e;
          };
          k.cosDeg = function (e) {
            return Math.cos(e * k.degRad);
          };
          k.sinDeg = function (e) {
            return Math.sin(e * k.degRad);
          };
          k.signum = function (e) {
            return 0 < e ? 1 : 0 > e ? -1 : 0;
          };
          k.toInt = function (e) {
            return 0 < e ? Math.floor(e) : Math.ceil(e);
          };
          k.cbrt = function (e) {
            var b = Math.pow(Math.abs(e), 1 / 3);
            return 0 > e ? -b : b;
          };
          k.randomTriangular = function (e, b) {
            return k.randomTriangularWith(e, b, 0.5 * (e + b));
          };
          k.randomTriangularWith = function (e, b, c) {
            var f = Math.random(),
              g = b - e;
            return f <= (c - e) / g
              ? e + Math.sqrt(f * g * (c - e))
              : b - Math.sqrt((1 - f) * g * (b - c));
          };
          k.PI = 3.1415927;
          k.PI2 = 2 * k.PI;
          k.radiansToDegrees = 180 / k.PI;
          k.radDeg = k.radiansToDegrees;
          k.degreesToRadians = k.PI / 180;
          k.degRad = k.degreesToRadians;
          return k;
        })();
        a.MathUtils = d;
        d = (function () {
          function k() {}
          k.prototype.apply = function (e, b, c) {
            return e + (b - e) * this.applyInternal(c);
          };
          return k;
        })();
        a.Interpolation = d;
        d = (function (k) {
          function e(b) {
            var c = k.call(this) || this;
            c.power = b;
            return c;
          }
          h(e, k);
          e.prototype.applyInternal = function (b) {
            return 0.5 >= b
              ? Math.pow(2 * b, this.power) / 2
              : Math.pow(2 * (b - 1), this.power) /
                  (0 == this.power % 2 ? -2 : 2) +
                  1;
          };
          return e;
        })(d);
        a.Pow = d;
        d = (function (k) {
          function e(b) {
            return k.call(this, b) || this;
          }
          h(e, k);
          e.prototype.applyInternal = function (b) {
            return (
              Math.pow(b - 1, this.power) * (0 == this.power % 2 ? -1 : 1) + 1
            );
          };
          return e;
        })(d);
        a.PowOut = d;
        d = (function () {
          function k() {}
          k.arrayCopy = function (e, b, c, f, g) {
            for (var m = b; m < b + g; m++, f++) c[f] = e[m];
          };
          k.setArraySize = function (e, b, c) {
            void 0 === c && (c = 0);
            var f = e.length;
            if (f == b) return e;
            e.length = b;
            if (f < b) for (; f < b; f++) e[f] = c;
            return e;
          };
          k.ensureArrayCapacity = function (e, b, c) {
            void 0 === c && (c = 0);
            return e.length >= b ? e : k.setArraySize(e, b, c);
          };
          k.newArray = function (e, b) {
            for (var c = Array(e), f = 0; f < e; f++) c[f] = b;
            return c;
          };
          k.newFloatArray = function (e) {
            if (k.SUPPORTS_TYPED_ARRAYS) return new Float32Array(e);
            e = Array(e);
            for (var b = 0; b < e.length; b++) e[b] = 0;
            return e;
          };
          k.newShortArray = function (e) {
            if (k.SUPPORTS_TYPED_ARRAYS) return new Int16Array(e);
            e = Array(e);
            for (var b = 0; b < e.length; b++) e[b] = 0;
            return e;
          };
          k.toFloatArray = function (e) {
            return k.SUPPORTS_TYPED_ARRAYS ? new Float32Array(e) : e;
          };
          k.toSinglePrecision = function (e) {
            return k.SUPPORTS_TYPED_ARRAYS ? Math.fround(e) : e;
          };
          k.webkit602BugfixHelper = function (e, b) {};
          k.contains = function (e, b, c) {
            for (c = 0; c < e.length; c++) if (e[c] == b) return !0;
            return !1;
          };
          k.SUPPORTS_TYPED_ARRAYS = "undefined" !== typeof Float32Array;
          return k;
        })();
        a.Utils = d;
        d = (function () {
          function k() {}
          k.logBones = function (e) {
            for (var b = 0; b < e.bones.length; b++);
          };
          return k;
        })();
        a.DebugUtils = d;
        d = (function () {
          function k(e) {
            this.items = [];
            this.instantiator = e;
          }
          k.prototype.obtain = function () {
            return 0 < this.items.length
              ? this.items.pop()
              : this.instantiator();
          };
          k.prototype.free = function (e) {
            e.reset && e.reset();
            this.items.push(e);
          };
          k.prototype.freeAll = function (e) {
            for (var b = 0; b < e.length; b++) this.free(e[b]);
          };
          k.prototype.clear = function () {
            this.items.length = 0;
          };
          return k;
        })();
        a.Pool = d;
        d = (function () {
          function k(e, b) {
            void 0 === e && (e = 0);
            void 0 === b && (b = 0);
            this.x = e;
            this.y = b;
          }
          k.prototype.set = function (e, b) {
            this.x = e;
            this.y = b;
            return this;
          };
          k.prototype.length = function () {
            var e = this.x,
              b = this.y;
            return Math.sqrt(e * e + b * b);
          };
          k.prototype.normalize = function () {
            var e = this.length();
            0 != e && ((this.x /= e), (this.y /= e));
            return this;
          };
          return k;
        })();
        a.Vector2 = d;
        d = (function () {
          function k() {
            this.maxDelta = 0.064;
            this.totalTime = this.delta = this.framesPerSecond = 0;
            this.lastTime = Date.now() / 1e3;
            this.frameTime = this.frameCount = 0;
          }
          k.prototype.update = function () {
            var e = Date.now() / 1e3;
            this.delta = e - this.lastTime;
            this.frameTime += this.delta;
            this.totalTime += this.delta;
            this.delta > this.maxDelta && (this.delta = this.maxDelta);
            this.lastTime = e;
            this.frameCount++;
            1 < this.frameTime &&
              ((this.framesPerSecond = this.frameCount / this.frameTime),
              (this.frameCount = this.frameTime = 0));
          };
          return k;
        })();
        a.TimeKeeper = d;
        d = (function () {
          function k(e) {
            void 0 === e && (e = 32);
            this.mean = this.lastValue = this.addedValues = 0;
            this.dirty = !0;
            this.values = Array(e);
          }
          k.prototype.hasEnoughData = function () {
            return this.addedValues >= this.values.length;
          };
          k.prototype.addValue = function (e) {
            this.addedValues < this.values.length && this.addedValues++;
            this.values[this.lastValue++] = e;
            this.lastValue > this.values.length - 1 && (this.lastValue = 0);
            this.dirty = !0;
          };
          k.prototype.getMean = function () {
            if (this.hasEnoughData()) {
              if (this.dirty) {
                for (var e = 0, b = 0; b < this.values.length; b++)
                  e += this.values[b];
                this.mean = e / this.values.length;
                this.dirty = !1;
              }
              return this.mean;
            }
            return 0;
          };
          return k;
        })();
        a.WindowedMean = d;
      })(t || (t = {}));
      (function () {
        Math.fround ||
          (Math.fround = (function (a) {
            return function (d) {
              return (a[0] = d), a[0];
            };
          })(new Float32Array(1)));
      })();
      (function (a) {
        var d = (function () {
          return function (k) {
            if (null == k) throw Error("name cannot be null.");
            this.name = k;
          };
        })();
        a.Attachment = d;
        d = (function (k) {
          function e(b) {
            b = k.call(this, b) || this;
            b.id = (e.nextID++ & 65535) << 11;
            b.worldVerticesLength = 0;
            return (b.deformAttachment = b);
          }
          h(e, k);
          e.prototype.computeWorldVertices = function (b, c, f, g, m, n) {
            f = m + (f >> 1) * n;
            var q = b.bone.skeleton,
              r = b.deform,
              u = this.vertices,
              v = this.bones;
            if (null == v) {
              0 < r.length && (u = r);
              b = b.bone;
              r = b.worldX;
              v = b.worldY;
              var x = b.a;
              q = b.b;
              var y = b.c;
              b = b.d;
              for (var z = c; m < f; z += 2, m += n) {
                c = u[z];
                var A = u[z + 1];
                g[m] = c * x + A * q + r;
                g[m + 1] = c * y + A * b + v;
              }
            } else {
              for (A = b = x = 0; A < c; A += 2)
                (y = v[x]), (x += y + 1), (b += y);
              z = q.bones;
              if (0 == r.length)
                for (q = 3 * b; m < f; m += n) {
                  var B = 0,
                    D = 0;
                  y = v[x++];
                  for (y += x; x < y; x++, q += 3) {
                    b = z[v[x]];
                    c = u[q];
                    A = u[q + 1];
                    var E = u[q + 2];
                    B += (c * b.a + A * b.b + b.worldX) * E;
                    D += (c * b.c + A * b.d + b.worldY) * E;
                  }
                  g[m] = B;
                  g[m + 1] = D;
                }
              else {
                q = 3 * b;
                for (var C = b << 1; m < f; m += n) {
                  D = B = 0;
                  y = v[x++];
                  for (y += x; x < y; x++, q += 3, C += 2)
                    (b = z[v[x]]),
                      (c = u[q] + r[C]),
                      (A = u[q + 1] + r[C + 1]),
                      (E = u[q + 2]),
                      (B += (c * b.a + A * b.b + b.worldX) * E),
                      (D += (c * b.c + A * b.d + b.worldY) * E);
                  g[m] = B;
                  g[m + 1] = D;
                }
              }
            }
          };
          e.prototype.copyTo = function (b) {
            null != this.bones
              ? ((b.bones = Array(this.bones.length)),
                a.Utils.arrayCopy(this.bones, 0, b.bones, 0, this.bones.length))
              : (b.bones = null);
            null != this.vertices
              ? ((b.vertices = a.Utils.newFloatArray(this.vertices.length)),
                a.Utils.arrayCopy(
                  this.vertices,
                  0,
                  b.vertices,
                  0,
                  this.vertices.length
                ))
              : (b.vertices = null);
            b.worldVerticesLength = this.worldVerticesLength;
            b.deformAttachment = this.deformAttachment;
          };
          e.nextID = 0;
          return e;
        })(d);
        a.VertexAttachment = d;
      })(t || (t = {}));
      (function (a) {
        a = a.AttachmentType || (a.AttachmentType = {});
        a[(a.Region = 0)] = "Region";
        a[(a.BoundingBox = 1)] = "BoundingBox";
        a[(a.Mesh = 2)] = "Mesh";
        a[(a.LinkedMesh = 3)] = "LinkedMesh";
        a[(a.Path = 4)] = "Path";
        a[(a.Point = 5)] = "Point";
        a[(a.Clipping = 6)] = "Clipping";
      })(t || (t = {}));
      (function (a) {
        var d = (function (k) {
          function e(b) {
            b = k.call(this, b) || this;
            b.color = new a.Color(1, 1, 1, 1);
            return b;
          }
          h(e, k);
          e.prototype.copy = function () {
            var b = new e(this.name);
            this.copyTo(b);
            b.color.setFromColor(this.color);
            return b;
          };
          return e;
        })(a.VertexAttachment);
        a.BoundingBoxAttachment = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function (k) {
          function e(b) {
            b = k.call(this, b) || this;
            b.color = new a.Color(0.2275, 0.2275, 0.8078, 1);
            return b;
          }
          h(e, k);
          e.prototype.copy = function () {
            var b = new e(this.name);
            this.copyTo(b);
            b.endSlot = this.endSlot;
            b.color.setFromColor(this.color);
            return b;
          };
          return e;
        })(a.VertexAttachment);
        a.ClippingAttachment = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function (k) {
          function e(b) {
            b = k.call(this, b) || this;
            b.color = new a.Color(1, 1, 1, 1);
            b.tempColor = new a.Color(0, 0, 0, 0);
            return b;
          }
          h(e, k);
          e.prototype.updateUVs = function () {
            var b = this.regionUVs;
            if (null == this.uvs || this.uvs.length != b.length)
              this.uvs = a.Utils.newFloatArray(b.length);
            var c = this.uvs,
              f = this.uvs.length,
              g = this.region.u,
              m = this.region.v;
            if (this.region instanceof a.TextureAtlasRegion) {
              var n = this.region;
              var q = n.texture.getImage().width;
              var r = n.texture.getImage().height;
              switch (n.degrees) {
                case 90:
                  g -= (n.originalHeight - n.offsetY - n.height) / q;
                  m -= (n.originalWidth - n.offsetX - n.width) / r;
                  q = n.originalHeight / q;
                  n = n.originalWidth / r;
                  for (r = 0; r < f; r += 2)
                    (c[r] = g + b[r + 1] * q), (c[r + 1] = m + (1 - b[r]) * n);
                  return;
                case 180:
                  g -= (n.originalWidth - n.offsetX - n.width) / q;
                  m -= n.offsetY / r;
                  q = n.originalWidth / q;
                  n = n.originalHeight / r;
                  for (r = 0; r < f; r += 2)
                    (c[r] = g + (1 - b[r]) * q),
                      (c[r + 1] = m + (1 - b[r + 1]) * n);
                  return;
                case 270:
                  g -= n.offsetY / q;
                  m -= n.offsetX / r;
                  q = n.originalHeight / q;
                  n = n.originalWidth / r;
                  for (r = 0; r < f; r += 2)
                    (c[r] = g + (1 - b[r + 1]) * q), (c[r + 1] = m + b[r] * n);
                  return;
              }
              g -= n.offsetX / q;
              m -= (n.originalHeight - n.offsetY - n.height) / r;
              q = n.originalWidth / q;
              n = n.originalHeight / r;
            } else
              null == this.region
                ? ((g = m = 0), (q = n = 1))
                : ((q = this.region.u2 - g), (n = this.region.v2 - m));
            for (r = 0; r < f; r += 2)
              (c[r] = g + b[r] * q), (c[r + 1] = m + b[r + 1] * n);
          };
          e.prototype.getParentMesh = function () {
            return this.parentMesh;
          };
          e.prototype.setParentMesh = function (b) {
            this.parentMesh = b;
            null != b &&
              ((this.bones = b.bones),
              (this.vertices = b.vertices),
              (this.worldVerticesLength = b.worldVerticesLength),
              (this.regionUVs = b.regionUVs),
              (this.triangles = b.triangles),
              (this.hullLength = b.hullLength),
              (this.worldVerticesLength = b.worldVerticesLength));
          };
          e.prototype.copy = function () {
            if (null != this.parentMesh) return this.newLinkedMesh();
            var b = new e(this.name);
            b.region = this.region;
            b.path = this.path;
            b.color.setFromColor(this.color);
            this.copyTo(b);
            b.regionUVs = Array(this.regionUVs.length);
            a.Utils.arrayCopy(
              this.regionUVs,
              0,
              b.regionUVs,
              0,
              this.regionUVs.length
            );
            b.uvs = Array(this.uvs.length);
            a.Utils.arrayCopy(this.uvs, 0, b.uvs, 0, this.uvs.length);
            b.triangles = Array(this.triangles.length);
            a.Utils.arrayCopy(
              this.triangles,
              0,
              b.triangles,
              0,
              this.triangles.length
            );
            b.hullLength = this.hullLength;
            null != this.edges &&
              ((b.edges = Array(this.edges.length)),
              a.Utils.arrayCopy(this.edges, 0, b.edges, 0, this.edges.length));
            b.width = this.width;
            b.height = this.height;
            return b;
          };
          e.prototype.newLinkedMesh = function () {
            var b = new e(this.name);
            b.region = this.region;
            b.path = this.path;
            b.color.setFromColor(this.color);
            b.deformAttachment = this.deformAttachment;
            b.setParentMesh(null != this.parentMesh ? this.parentMesh : this);
            b.updateUVs();
            return b;
          };
          return e;
        })(a.VertexAttachment);
        a.MeshAttachment = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function (k) {
          function e(b) {
            b = k.call(this, b) || this;
            b.closed = !1;
            b.constantSpeed = !1;
            b.color = new a.Color(1, 1, 1, 1);
            return b;
          }
          h(e, k);
          e.prototype.copy = function () {
            var b = new e(this.name);
            this.copyTo(b);
            b.lengths = Array(this.lengths.length);
            a.Utils.arrayCopy(
              this.lengths,
              0,
              b.lengths,
              0,
              this.lengths.length
            );
            b.closed = closed;
            b.constantSpeed = this.constantSpeed;
            b.color.setFromColor(this.color);
            return b;
          };
          return e;
        })(a.VertexAttachment);
        a.PathAttachment = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function (k) {
          function e(b) {
            b = k.call(this, b) || this;
            b.color = new a.Color(0.38, 0.94, 0, 1);
            return b;
          }
          h(e, k);
          e.prototype.computeWorldPosition = function (b, c) {
            c.x = this.x * b.a + this.y * b.b + b.worldX;
            c.y = this.x * b.c + this.y * b.d + b.worldY;
            return c;
          };
          e.prototype.computeWorldRotation = function (b) {
            var c = a.MathUtils.cosDeg(this.rotation),
              f = a.MathUtils.sinDeg(this.rotation);
            return (
              Math.atan2(c * b.c + f * b.d, c * b.a + f * b.b) *
              a.MathUtils.radDeg
            );
          };
          e.prototype.copy = function () {
            var b = new e(this.name);
            b.x = this.x;
            b.y = this.y;
            b.rotation = this.rotation;
            b.color.setFromColor(this.color);
            return b;
          };
          return e;
        })(a.VertexAttachment);
        a.PointAttachment = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function (k) {
          function e(b) {
            b = k.call(this, b) || this;
            b.x = 0;
            b.y = 0;
            b.scaleX = 1;
            b.scaleY = 1;
            b.rotation = 0;
            b.width = 0;
            b.height = 0;
            b.color = new a.Color(1, 1, 1, 1);
            b.offset = a.Utils.newFloatArray(8);
            b.uvs = a.Utils.newFloatArray(8);
            b.tempColor = new a.Color(1, 1, 1, 1);
            return b;
          }
          h(e, k);
          e.prototype.updateOffset = function () {
            var b = (this.width / this.region.originalWidth) * this.scaleX,
              c = (this.height / this.region.originalHeight) * this.scaleY,
              f = (-this.width / 2) * this.scaleX + this.region.offsetX * b,
              g = (-this.height / 2) * this.scaleY + this.region.offsetY * c,
              m = f + this.region.width * b;
            b = g + this.region.height * c;
            c = (this.rotation * Math.PI) / 180;
            var n = Math.cos(c),
              q = Math.sin(c);
            c = f * n + this.x;
            f *= q;
            var r = g * n + this.y;
            g *= q;
            var u = m * n + this.x;
            m *= q;
            n = b * n + this.y;
            b *= q;
            q = this.offset;
            q[e.OX1] = c - g;
            q[e.OY1] = r + f;
            q[e.OX2] = c - b;
            q[e.OY2] = n + f;
            q[e.OX3] = u - b;
            q[e.OY3] = n + m;
            q[e.OX4] = u - g;
            q[e.OY4] = r + m;
          };
          e.prototype.setRegion = function (b) {
            this.region = b;
            var c = this.uvs;
            b.rotate
              ? ((c[2] = b.u),
                (c[3] = b.v2),
                (c[4] = b.u),
                (c[5] = b.v),
                (c[6] = b.u2),
                (c[7] = b.v),
                (c[0] = b.u2),
                (c[1] = b.v2))
              : ((c[0] = b.u),
                (c[1] = b.v2),
                (c[2] = b.u),
                (c[3] = b.v),
                (c[4] = b.u2),
                (c[5] = b.v),
                (c[6] = b.u2),
                (c[7] = b.v2));
          };
          e.prototype.computeWorldVertices = function (b, c, f, g) {
            var m = this.offset,
              n = b.worldX,
              q = b.worldY,
              r = b.a,
              u = b.b,
              v = b.c;
            b = b.d;
            var x = m[e.OX1];
            var y = m[e.OY1];
            c[f] = x * r + y * u + n;
            c[f + 1] = x * v + y * b + q;
            f += g;
            x = m[e.OX2];
            y = m[e.OY2];
            c[f] = x * r + y * u + n;
            c[f + 1] = x * v + y * b + q;
            f += g;
            x = m[e.OX3];
            y = m[e.OY3];
            c[f] = x * r + y * u + n;
            c[f + 1] = x * v + y * b + q;
            f += g;
            x = m[e.OX4];
            y = m[e.OY4];
            c[f] = x * r + y * u + n;
            c[f + 1] = x * v + y * b + q;
          };
          e.prototype.copy = function () {
            var b = new e(this.name);
            b.region = this.region;
            b.rendererObject = this.rendererObject;
            b.path = this.path;
            b.x = this.x;
            b.y = this.y;
            b.scaleX = this.scaleX;
            b.scaleY = this.scaleY;
            b.rotation = this.rotation;
            b.width = this.width;
            b.height = this.height;
            a.Utils.arrayCopy(this.uvs, 0, b.uvs, 0, 8);
            a.Utils.arrayCopy(this.offset, 0, b.offset, 0, 8);
            b.color.setFromColor(this.color);
            return b;
          };
          e.OX1 = 0;
          e.OY1 = 1;
          e.OX2 = 2;
          e.OY2 = 3;
          e.OX3 = 4;
          e.OY3 = 5;
          e.OX4 = 6;
          e.OY4 = 7;
          e.X1 = 0;
          e.Y1 = 1;
          e.C1R = 2;
          e.C1G = 3;
          e.C1B = 4;
          e.C1A = 5;
          e.U1 = 6;
          e.V1 = 7;
          e.X2 = 8;
          e.Y2 = 9;
          e.C2R = 10;
          e.C2G = 11;
          e.C2B = 12;
          e.C2A = 13;
          e.U2 = 14;
          e.V2 = 15;
          e.X3 = 16;
          e.Y3 = 17;
          e.C3R = 18;
          e.C3G = 19;
          e.C3B = 20;
          e.C3A = 21;
          e.U3 = 22;
          e.V3 = 23;
          e.X4 = 24;
          e.Y4 = 25;
          e.C4R = 26;
          e.C4G = 27;
          e.C4B = 28;
          e.C4A = 29;
          e.U4 = 30;
          e.V4 = 31;
          return e;
        })(a.Attachment);
        a.RegionAttachment = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k(e, b) {
            this.jitterY = this.jitterX = 0;
            this.jitterX = e;
            this.jitterY = b;
          }
          k.prototype.begin = function (e) {};
          k.prototype.transform = function (e, b, c, f) {
            e.x += a.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
            e.y += a.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
          };
          k.prototype.end = function () {};
          return k;
        })();
        a.JitterEffect = d;
      })(t || (t = {}));
      (function (a) {
        var d = (function () {
          function k(e) {
            this.worldY =
              this.worldX =
              this.angle =
              this.radius =
              this.centerY =
              this.centerX =
                0;
            this.radius = e;
          }
          k.prototype.begin = function (e) {
            this.worldX = e.x + this.centerX;
            this.worldY = e.y + this.centerY;
          };
          k.prototype.transform = function (e, b, c, f) {
            f = this.angle * a.MathUtils.degreesToRadians;
            b = e.x - this.worldX;
            c = e.y - this.worldY;
            var g = Math.sqrt(b * b + c * c);
            g < this.radius &&
              ((g = k.interpolation.apply(
                0,
                f,
                (this.radius - g) / this.radius
              )),
              (f = Math.cos(g)),
              (g = Math.sin(g)),
              (e.x = f * b - g * c + this.worldX),
              (e.y = g * b + f * c + this.worldY));
          };
          k.prototype.end = function () {};
          k.interpolation = new a.PowOut(2);
          return k;
        })();
        a.SwirlEffect = d;
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function (e) {
            function b(c) {
              void 0 === c && (c = "");
              return (
                e.call(
                  this,
                  function (f) {
                    return new a.canvas.CanvasTexture(f);
                  },
                  c
                ) || this
              );
            }
            h(b, e);
            return b;
          })(a.AssetManager);
          d.AssetManager = k;
        })(a.canvas || (a.canvas = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function (e) {
            function b(c) {
              return e.call(this, c) || this;
            }
            h(b, e);
            b.prototype.setFilters = function (c, f) {};
            b.prototype.setWraps = function (c, f) {};
            b.prototype.dispose = function () {};
            return b;
          })(a.Texture);
          d.CanvasTexture = k;
        })(a.canvas || (a.canvas = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function () {
            function e(b) {
              this.debugRendering = this.triangleRendering = !1;
              this.vertices = a.Utils.newFloatArray(8192);
              this.tempColor = new a.Color();
              this.ctx = b;
            }
            e.prototype.draw = function (b) {
              this.triangleRendering
                ? this.drawTriangles(b)
                : this.drawImages(b);
            };
            e.prototype.drawImages = function (b) {
              var c = this.ctx;
              b = b.drawOrder;
              this.debugRendering && (c.strokeStyle = "green");
              c.save();
              for (var f = 0, g = b.length; f < g; f++) {
                var m = b[f];
                if (m.bone.active) {
                  var n = m.getAttachment();
                  if (n instanceof a.RegionAttachment) {
                    var q = n;
                    var r = q.region;
                    var u = r.texture.getImage();
                    var v = m.bone.skeleton.color,
                      x = m.color,
                      y = q.color;
                    q = this.tempColor;
                    q.set(
                      v.r * x.r * y.r,
                      v.g * x.g * y.g,
                      v.b * x.b * y.b,
                      v.a * x.a * y.a
                    );
                    x = n;
                    y = m.bone;
                    m = r.width;
                    v = r.height;
                    c.save();
                    c.transform(y.a, y.c, y.b, y.d, y.worldX, y.worldY);
                    c.translate(n.offset[0], n.offset[1]);
                    c.rotate((n.rotation * Math.PI) / 180);
                    x = x.width / m;
                    c.scale(x * n.scaleX, x * n.scaleY);
                    c.translate(m / 2, v / 2);
                    n.region.rotate &&
                      ((n = m), (m = v), (v = n), c.rotate(-Math.PI / 2));
                    c.scale(1, -1);
                    c.translate(-m / 2, -v / 2);
                    if (1 != q.r || 1 != q.g || 1 != q.b || 1 != q.a)
                      c.globalAlpha = q.a;
                    c.drawImage(u, r.x, r.y, m, v, 0, 0, m, v);
                    this.debugRendering && c.strokeRect(0, 0, m, v);
                    c.restore();
                  }
                }
              }
              c.restore();
            };
            e.prototype.drawTriangles = function (b) {
              for (var c, f = b.drawOrder, g = 0, m = f.length; g < m; g++) {
                var n = f[g],
                  q = n.getAttachment();
                if (q instanceof a.RegionAttachment) {
                  var r = q;
                  b = this.computeRegionVertices(n, r, !1);
                  c = e.QUAD_TRIANGLES;
                  r = r.region;
                  r = r.texture.getImage();
                } else if (q instanceof a.MeshAttachment)
                  (r = q),
                    (b = this.computeMeshVertices(n, r, !1)),
                    (c = r.triangles),
                    (r = r.region.renderObject.texture.getImage());
                else continue;
                if (null != r) {
                  n.data.blendMode;
                  var u = n.bone.skeleton.color;
                  n = n.color;
                  q = q.color;
                  var v = this.tempColor;
                  v.set(
                    u.r * n.r * q.r,
                    u.g * n.g * q.g,
                    u.b * n.b * q.b,
                    u.a * n.a * q.a
                  );
                  q = this.ctx;
                  if (1 != v.r || 1 != v.g || 1 != v.b || 1 != v.a)
                    q.globalAlpha = v.a;
                  for (n = 0; n < c.length; n += 3) {
                    u = 8 * c[n];
                    v = 8 * c[n + 1];
                    var x = 8 * c[n + 2],
                      y = b[u],
                      z = b[u + 1],
                      A = b[v],
                      B = b[v + 1],
                      D = b[x],
                      E = b[x + 1];
                    this.drawTriangle(
                      r,
                      y,
                      z,
                      b[u + 6],
                      b[u + 7],
                      A,
                      B,
                      b[v + 6],
                      b[v + 7],
                      D,
                      E,
                      b[x + 6],
                      b[x + 7]
                    );
                    this.debugRendering &&
                      ((q.strokeStyle = "green"),
                      q.beginPath(),
                      q.moveTo(y, z),
                      q.lineTo(A, B),
                      q.lineTo(D, E),
                      q.lineTo(y, z),
                      q.stroke());
                  }
                }
              }
              this.ctx.globalAlpha = 1;
            };
            e.prototype.drawTriangle = function (
              b,
              c,
              f,
              g,
              m,
              n,
              q,
              r,
              u,
              v,
              x,
              y,
              z
            ) {
              var A = this.ctx;
              g *= b.width;
              m *= b.height;
              r *= b.width;
              u *= b.height;
              y *= b.width;
              z *= b.height;
              A.beginPath();
              A.moveTo(c, f);
              A.lineTo(n, q);
              A.lineTo(v, x);
              A.closePath();
              n -= c;
              q -= f;
              v -= c;
              x -= f;
              r -= g;
              u -= m;
              y -= g;
              z -= m;
              var B = 1 / (r * z - y * u),
                D = (z * n - u * v) * B;
              u = (z * q - u * x) * B;
              n = (r * v - y * n) * B;
              q = (r * x - y * q) * B;
              c = c - D * g - n * m;
              f = f - u * g - q * m;
              A.save();
              A.transform(D, u, n, q, c, f);
              A.clip();
              A.drawImage(b, 0, 0);
              A.restore();
            };
            e.prototype.computeRegionVertices = function (b, c, f) {
              var g = b.bone.skeleton.color,
                m = b.color,
                n = c.color,
                q = g.a * m.a * n.a,
                r = f ? q : 1;
              f = this.tempColor;
              f.set(
                g.r * m.r * n.r * r,
                g.g * m.g * n.g * r,
                g.b * m.b * n.b * r,
                q
              );
              c.computeWorldVertices(b.bone, this.vertices, 0, e.VERTEX_SIZE);
              b = this.vertices;
              c = c.uvs;
              b[a.RegionAttachment.C1R] = f.r;
              b[a.RegionAttachment.C1G] = f.g;
              b[a.RegionAttachment.C1B] = f.b;
              b[a.RegionAttachment.C1A] = f.a;
              b[a.RegionAttachment.U1] = c[0];
              b[a.RegionAttachment.V1] = c[1];
              b[a.RegionAttachment.C2R] = f.r;
              b[a.RegionAttachment.C2G] = f.g;
              b[a.RegionAttachment.C2B] = f.b;
              b[a.RegionAttachment.C2A] = f.a;
              b[a.RegionAttachment.U2] = c[2];
              b[a.RegionAttachment.V2] = c[3];
              b[a.RegionAttachment.C3R] = f.r;
              b[a.RegionAttachment.C3G] = f.g;
              b[a.RegionAttachment.C3B] = f.b;
              b[a.RegionAttachment.C3A] = f.a;
              b[a.RegionAttachment.U3] = c[4];
              b[a.RegionAttachment.V3] = c[5];
              b[a.RegionAttachment.C4R] = f.r;
              b[a.RegionAttachment.C4G] = f.g;
              b[a.RegionAttachment.C4B] = f.b;
              b[a.RegionAttachment.C4A] = f.a;
              b[a.RegionAttachment.U4] = c[6];
              b[a.RegionAttachment.V4] = c[7];
              return b;
            };
            e.prototype.computeMeshVertices = function (b, c, f) {
              var g = b.bone.skeleton.color,
                m = b.color,
                n = c.color,
                q = g.a * m.a * n.a,
                r = f ? q : 1;
              f = this.tempColor;
              f.set(
                g.r * m.r * n.r * r,
                g.g * m.g * n.g * r,
                g.b * m.b * n.b * r,
                q
              );
              g = c.worldVerticesLength / 2;
              this.vertices.length < c.worldVerticesLength &&
                (this.vertices = a.Utils.newFloatArray(c.worldVerticesLength));
              m = this.vertices;
              c.computeWorldVertices(
                b,
                0,
                c.worldVerticesLength,
                m,
                0,
                e.VERTEX_SIZE
              );
              b = c.uvs;
              n = c = 0;
              for (q = 2; c < g; c++)
                (m[q++] = f.r),
                  (m[q++] = f.g),
                  (m[q++] = f.b),
                  (m[q++] = f.a),
                  (m[q++] = b[n++]),
                  (m[q++] = b[n++]),
                  (q += 2);
              return m;
            };
            e.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
            e.VERTEX_SIZE = 8;
            return e;
          })();
          d.SkeletonRenderer = k;
        })(a.canvas || (a.canvas = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function (e) {
            function b(c, f) {
              void 0 === f && (f = "");
              return (
                e.call(
                  this,
                  function (g) {
                    return new a.webgl.GLTexture(c, g);
                  },
                  f
                ) || this
              );
            }
            h(b, e);
            return b;
          })(a.AssetManager);
          d.AssetManager = k;
        })(a.webgl || (a.webgl = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function () {
            function e(b, c) {
              this.position = new d.Vector3(0, 0, 0);
              this.direction = new d.Vector3(0, 0, -1);
              this.up = new d.Vector3(0, 1, 0);
              this.near = 0;
              this.far = 100;
              this.zoom = 1;
              this.viewportHeight = this.viewportWidth = 0;
              this.projectionView = new d.Matrix4();
              this.inverseProjectionView = new d.Matrix4();
              this.projection = new d.Matrix4();
              this.view = new d.Matrix4();
              this.tmp = new d.Vector3();
              this.viewportWidth = b;
              this.viewportHeight = c;
              this.update();
            }
            e.prototype.update = function () {
              var b = this.projection,
                c = this.view,
                f = this.projectionView,
                g = this.inverseProjectionView,
                m = this.zoom,
                n = this.viewportWidth,
                q = this.viewportHeight;
              b.ortho(
                (-n / 2) * m,
                (n / 2) * m,
                (-q / 2) * m,
                (q / 2) * m,
                this.near,
                this.far
              );
              c.lookAt(this.position, this.direction, this.up);
              f.set(b.values);
              f.multiply(c);
              g.set(f.values).invert();
            };
            e.prototype.screenToWorld = function (b, c, f) {
              var g = f - b.y - 1,
                m = this.tmp;
              m.x = (2 * b.x) / c - 1;
              m.y = (2 * g) / f - 1;
              m.z = 2 * b.z - 1;
              m.project(this.inverseProjectionView);
              b.set(m.x, m.y, m.z);
              return b;
            };
            e.prototype.setViewport = function (b, c) {
              this.viewportWidth = b;
              this.viewportHeight = c;
            };
            return e;
          })();
          d.OrthoCamera = k;
        })(a.webgl || (a.webgl = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function (e) {
            function b(c, f, g) {
              void 0 === g && (g = !1);
              f = e.call(this, f) || this;
              f.texture = null;
              f.boundUnit = 0;
              f.useMipMaps = !1;
              f.context =
                c instanceof d.ManagedWebGLRenderingContext
                  ? c
                  : new d.ManagedWebGLRenderingContext(c);
              f.useMipMaps = g;
              f.restore();
              f.context.addRestorable(f);
              return f;
            }
            h(b, e);
            b.prototype.setFilters = function (c, f) {
              var g = this.context.gl;
              this.bind();
              g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, c);
              g.texParameteri(
                g.TEXTURE_2D,
                g.TEXTURE_MAG_FILTER,
                b.validateMagFilter(f)
              );
            };
            b.validateMagFilter = function (c) {
              switch (c) {
                case a.TextureFilter.MipMap:
                case a.TextureFilter.MipMapLinearLinear:
                case a.TextureFilter.MipMapLinearNearest:
                case a.TextureFilter.MipMapNearestLinear:
                case a.TextureFilter.MipMapNearestNearest:
                  return a.TextureFilter.Linear;
                default:
                  return c;
              }
            };
            b.prototype.setWraps = function (c, f) {
              var g = this.context.gl;
              this.bind();
              g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, c);
              g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, f);
            };
            b.prototype.update = function (c) {
              var f = this.context.gl;
              this.texture || (this.texture = this.context.gl.createTexture());
              this.bind();
              b.DISABLE_UNPACK_PREMULTIPLIED_ALPHA_WEBGL &&
                f.pixelStorei(f.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1);
              f.texImage2D(
                f.TEXTURE_2D,
                0,
                f.RGBA,
                f.RGBA,
                f.UNSIGNED_BYTE,
                this._image
              );
              f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.LINEAR);
              f.texParameteri(
                f.TEXTURE_2D,
                f.TEXTURE_MIN_FILTER,
                c ? f.LINEAR_MIPMAP_LINEAR : f.LINEAR
              );
              f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE);
              f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE);
              c && f.generateMipmap(f.TEXTURE_2D);
            };
            b.prototype.restore = function () {
              this.texture = null;
              this.update(this.useMipMaps);
            };
            b.prototype.bind = function (c) {
              void 0 === c && (c = 0);
              var f = this.context.gl;
              this.boundUnit = c;
              f.activeTexture(f.TEXTURE0 + c);
              f.bindTexture(f.TEXTURE_2D, this.texture);
            };
            b.prototype.unbind = function () {
              var c = this.context.gl;
              c.activeTexture(c.TEXTURE0 + this.boundUnit);
              c.bindTexture(c.TEXTURE_2D, null);
            };
            b.prototype.dispose = function () {
              this.context.removeRestorable(this);
              this.context.gl.deleteTexture(this.texture);
            };
            b.DISABLE_UNPACK_PREMULTIPLIED_ALPHA_WEBGL = !1;
            return b;
          })(a.Texture);
          d.GLTexture = k;
        })(a.webgl || (a.webgl = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          d.M00 = 0;
          d.M01 = 4;
          d.M02 = 8;
          d.M03 = 12;
          d.M10 = 1;
          d.M11 = 5;
          d.M12 = 9;
          d.M13 = 13;
          d.M20 = 2;
          d.M21 = 6;
          d.M22 = 10;
          d.M23 = 14;
          d.M30 = 3;
          d.M31 = 7;
          d.M32 = 11;
          d.M33 = 15;
          var k = (function () {
            function e() {
              this.temp = new Float32Array(16);
              var b = (this.values = new Float32Array(16));
              b[d.M00] = 1;
              b[d.M11] = 1;
              b[d.M22] = 1;
              b[d.M33] = 1;
            }
            e.prototype.set = function (b) {
              this.values.set(b);
              return this;
            };
            e.prototype.transpose = function () {
              var b = this.temp,
                c = this.values;
              b[d.M00] = c[d.M00];
              b[d.M01] = c[d.M10];
              b[d.M02] = c[d.M20];
              b[d.M03] = c[d.M30];
              b[d.M10] = c[d.M01];
              b[d.M11] = c[d.M11];
              b[d.M12] = c[d.M21];
              b[d.M13] = c[d.M31];
              b[d.M20] = c[d.M02];
              b[d.M21] = c[d.M12];
              b[d.M22] = c[d.M22];
              b[d.M23] = c[d.M32];
              b[d.M30] = c[d.M03];
              b[d.M31] = c[d.M13];
              b[d.M32] = c[d.M23];
              b[d.M33] = c[d.M33];
              return this.set(b);
            };
            e.prototype.identity = function () {
              var b = this.values;
              b[d.M00] = 1;
              b[d.M01] = 0;
              b[d.M02] = 0;
              b[d.M03] = 0;
              b[d.M10] = 0;
              b[d.M11] = 1;
              b[d.M12] = 0;
              b[d.M13] = 0;
              b[d.M20] = 0;
              b[d.M21] = 0;
              b[d.M22] = 1;
              b[d.M23] = 0;
              b[d.M30] = 0;
              b[d.M31] = 0;
              b[d.M32] = 0;
              b[d.M33] = 1;
              return this;
            };
            e.prototype.invert = function () {
              var b = this.values,
                c = this.temp,
                f =
                  b[d.M30] * b[d.M21] * b[d.M12] * b[d.M03] -
                  b[d.M20] * b[d.M31] * b[d.M12] * b[d.M03] -
                  b[d.M30] * b[d.M11] * b[d.M22] * b[d.M03] +
                  b[d.M10] * b[d.M31] * b[d.M22] * b[d.M03] +
                  b[d.M20] * b[d.M11] * b[d.M32] * b[d.M03] -
                  b[d.M10] * b[d.M21] * b[d.M32] * b[d.M03] -
                  b[d.M30] * b[d.M21] * b[d.M02] * b[d.M13] +
                  b[d.M20] * b[d.M31] * b[d.M02] * b[d.M13] +
                  b[d.M30] * b[d.M01] * b[d.M22] * b[d.M13] -
                  b[d.M00] * b[d.M31] * b[d.M22] * b[d.M13] -
                  b[d.M20] * b[d.M01] * b[d.M32] * b[d.M13] +
                  b[d.M00] * b[d.M21] * b[d.M32] * b[d.M13] +
                  b[d.M30] * b[d.M11] * b[d.M02] * b[d.M23] -
                  b[d.M10] * b[d.M31] * b[d.M02] * b[d.M23] -
                  b[d.M30] * b[d.M01] * b[d.M12] * b[d.M23] +
                  b[d.M00] * b[d.M31] * b[d.M12] * b[d.M23] +
                  b[d.M10] * b[d.M01] * b[d.M32] * b[d.M23] -
                  b[d.M00] * b[d.M11] * b[d.M32] * b[d.M23] -
                  b[d.M20] * b[d.M11] * b[d.M02] * b[d.M33] +
                  b[d.M10] * b[d.M21] * b[d.M02] * b[d.M33] +
                  b[d.M20] * b[d.M01] * b[d.M12] * b[d.M33] -
                  b[d.M00] * b[d.M21] * b[d.M12] * b[d.M33] -
                  b[d.M10] * b[d.M01] * b[d.M22] * b[d.M33] +
                  b[d.M00] * b[d.M11] * b[d.M22] * b[d.M33];
              if (0 == f) throw Error("non-invertible matrix");
              f = 1 / f;
              c[d.M00] =
                b[d.M12] * b[d.M23] * b[d.M31] -
                b[d.M13] * b[d.M22] * b[d.M31] +
                b[d.M13] * b[d.M21] * b[d.M32] -
                b[d.M11] * b[d.M23] * b[d.M32] -
                b[d.M12] * b[d.M21] * b[d.M33] +
                b[d.M11] * b[d.M22] * b[d.M33];
              c[d.M01] =
                b[d.M03] * b[d.M22] * b[d.M31] -
                b[d.M02] * b[d.M23] * b[d.M31] -
                b[d.M03] * b[d.M21] * b[d.M32] +
                b[d.M01] * b[d.M23] * b[d.M32] +
                b[d.M02] * b[d.M21] * b[d.M33] -
                b[d.M01] * b[d.M22] * b[d.M33];
              c[d.M02] =
                b[d.M02] * b[d.M13] * b[d.M31] -
                b[d.M03] * b[d.M12] * b[d.M31] +
                b[d.M03] * b[d.M11] * b[d.M32] -
                b[d.M01] * b[d.M13] * b[d.M32] -
                b[d.M02] * b[d.M11] * b[d.M33] +
                b[d.M01] * b[d.M12] * b[d.M33];
              c[d.M03] =
                b[d.M03] * b[d.M12] * b[d.M21] -
                b[d.M02] * b[d.M13] * b[d.M21] -
                b[d.M03] * b[d.M11] * b[d.M22] +
                b[d.M01] * b[d.M13] * b[d.M22] +
                b[d.M02] * b[d.M11] * b[d.M23] -
                b[d.M01] * b[d.M12] * b[d.M23];
              c[d.M10] =
                b[d.M13] * b[d.M22] * b[d.M30] -
                b[d.M12] * b[d.M23] * b[d.M30] -
                b[d.M13] * b[d.M20] * b[d.M32] +
                b[d.M10] * b[d.M23] * b[d.M32] +
                b[d.M12] * b[d.M20] * b[d.M33] -
                b[d.M10] * b[d.M22] * b[d.M33];
              c[d.M11] =
                b[d.M02] * b[d.M23] * b[d.M30] -
                b[d.M03] * b[d.M22] * b[d.M30] +
                b[d.M03] * b[d.M20] * b[d.M32] -
                b[d.M00] * b[d.M23] * b[d.M32] -
                b[d.M02] * b[d.M20] * b[d.M33] +
                b[d.M00] * b[d.M22] * b[d.M33];
              c[d.M12] =
                b[d.M03] * b[d.M12] * b[d.M30] -
                b[d.M02] * b[d.M13] * b[d.M30] -
                b[d.M03] * b[d.M10] * b[d.M32] +
                b[d.M00] * b[d.M13] * b[d.M32] +
                b[d.M02] * b[d.M10] * b[d.M33] -
                b[d.M00] * b[d.M12] * b[d.M33];
              c[d.M13] =
                b[d.M02] * b[d.M13] * b[d.M20] -
                b[d.M03] * b[d.M12] * b[d.M20] +
                b[d.M03] * b[d.M10] * b[d.M22] -
                b[d.M00] * b[d.M13] * b[d.M22] -
                b[d.M02] * b[d.M10] * b[d.M23] +
                b[d.M00] * b[d.M12] * b[d.M23];
              c[d.M20] =
                b[d.M11] * b[d.M23] * b[d.M30] -
                b[d.M13] * b[d.M21] * b[d.M30] +
                b[d.M13] * b[d.M20] * b[d.M31] -
                b[d.M10] * b[d.M23] * b[d.M31] -
                b[d.M11] * b[d.M20] * b[d.M33] +
                b[d.M10] * b[d.M21] * b[d.M33];
              c[d.M21] =
                b[d.M03] * b[d.M21] * b[d.M30] -
                b[d.M01] * b[d.M23] * b[d.M30] -
                b[d.M03] * b[d.M20] * b[d.M31] +
                b[d.M00] * b[d.M23] * b[d.M31] +
                b[d.M01] * b[d.M20] * b[d.M33] -
                b[d.M00] * b[d.M21] * b[d.M33];
              c[d.M22] =
                b[d.M01] * b[d.M13] * b[d.M30] -
                b[d.M03] * b[d.M11] * b[d.M30] +
                b[d.M03] * b[d.M10] * b[d.M31] -
                b[d.M00] * b[d.M13] * b[d.M31] -
                b[d.M01] * b[d.M10] * b[d.M33] +
                b[d.M00] * b[d.M11] * b[d.M33];
              c[d.M23] =
                b[d.M03] * b[d.M11] * b[d.M20] -
                b[d.M01] * b[d.M13] * b[d.M20] -
                b[d.M03] * b[d.M10] * b[d.M21] +
                b[d.M00] * b[d.M13] * b[d.M21] +
                b[d.M01] * b[d.M10] * b[d.M23] -
                b[d.M00] * b[d.M11] * b[d.M23];
              c[d.M30] =
                b[d.M12] * b[d.M21] * b[d.M30] -
                b[d.M11] * b[d.M22] * b[d.M30] -
                b[d.M12] * b[d.M20] * b[d.M31] +
                b[d.M10] * b[d.M22] * b[d.M31] +
                b[d.M11] * b[d.M20] * b[d.M32] -
                b[d.M10] * b[d.M21] * b[d.M32];
              c[d.M31] =
                b[d.M01] * b[d.M22] * b[d.M30] -
                b[d.M02] * b[d.M21] * b[d.M30] +
                b[d.M02] * b[d.M20] * b[d.M31] -
                b[d.M00] * b[d.M22] * b[d.M31] -
                b[d.M01] * b[d.M20] * b[d.M32] +
                b[d.M00] * b[d.M21] * b[d.M32];
              c[d.M32] =
                b[d.M02] * b[d.M11] * b[d.M30] -
                b[d.M01] * b[d.M12] * b[d.M30] -
                b[d.M02] * b[d.M10] * b[d.M31] +
                b[d.M00] * b[d.M12] * b[d.M31] +
                b[d.M01] * b[d.M10] * b[d.M32] -
                b[d.M00] * b[d.M11] * b[d.M32];
              c[d.M33] =
                b[d.M01] * b[d.M12] * b[d.M20] -
                b[d.M02] * b[d.M11] * b[d.M20] +
                b[d.M02] * b[d.M10] * b[d.M21] -
                b[d.M00] * b[d.M12] * b[d.M21] -
                b[d.M01] * b[d.M10] * b[d.M22] +
                b[d.M00] * b[d.M11] * b[d.M22];
              b[d.M00] = c[d.M00] * f;
              b[d.M01] = c[d.M01] * f;
              b[d.M02] = c[d.M02] * f;
              b[d.M03] = c[d.M03] * f;
              b[d.M10] = c[d.M10] * f;
              b[d.M11] = c[d.M11] * f;
              b[d.M12] = c[d.M12] * f;
              b[d.M13] = c[d.M13] * f;
              b[d.M20] = c[d.M20] * f;
              b[d.M21] = c[d.M21] * f;
              b[d.M22] = c[d.M22] * f;
              b[d.M23] = c[d.M23] * f;
              b[d.M30] = c[d.M30] * f;
              b[d.M31] = c[d.M31] * f;
              b[d.M32] = c[d.M32] * f;
              b[d.M33] = c[d.M33] * f;
              return this;
            };
            e.prototype.determinant = function () {
              var b = this.values;
              return (
                b[d.M30] * b[d.M21] * b[d.M12] * b[d.M03] -
                b[d.M20] * b[d.M31] * b[d.M12] * b[d.M03] -
                b[d.M30] * b[d.M11] * b[d.M22] * b[d.M03] +
                b[d.M10] * b[d.M31] * b[d.M22] * b[d.M03] +
                b[d.M20] * b[d.M11] * b[d.M32] * b[d.M03] -
                b[d.M10] * b[d.M21] * b[d.M32] * b[d.M03] -
                b[d.M30] * b[d.M21] * b[d.M02] * b[d.M13] +
                b[d.M20] * b[d.M31] * b[d.M02] * b[d.M13] +
                b[d.M30] * b[d.M01] * b[d.M22] * b[d.M13] -
                b[d.M00] * b[d.M31] * b[d.M22] * b[d.M13] -
                b[d.M20] * b[d.M01] * b[d.M32] * b[d.M13] +
                b[d.M00] * b[d.M21] * b[d.M32] * b[d.M13] +
                b[d.M30] * b[d.M11] * b[d.M02] * b[d.M23] -
                b[d.M10] * b[d.M31] * b[d.M02] * b[d.M23] -
                b[d.M30] * b[d.M01] * b[d.M12] * b[d.M23] +
                b[d.M00] * b[d.M31] * b[d.M12] * b[d.M23] +
                b[d.M10] * b[d.M01] * b[d.M32] * b[d.M23] -
                b[d.M00] * b[d.M11] * b[d.M32] * b[d.M23] -
                b[d.M20] * b[d.M11] * b[d.M02] * b[d.M33] +
                b[d.M10] * b[d.M21] * b[d.M02] * b[d.M33] +
                b[d.M20] * b[d.M01] * b[d.M12] * b[d.M33] -
                b[d.M00] * b[d.M21] * b[d.M12] * b[d.M33] -
                b[d.M10] * b[d.M01] * b[d.M22] * b[d.M33] +
                b[d.M00] * b[d.M11] * b[d.M22] * b[d.M33]
              );
            };
            e.prototype.translate = function (b, c, f) {
              var g = this.values;
              g[d.M03] += b;
              g[d.M13] += c;
              g[d.M23] += f;
              return this;
            };
            e.prototype.copy = function () {
              return new e().set(this.values);
            };
            e.prototype.projection = function (b, c, f, g) {
              this.identity();
              f = 1 / Math.tan(((Math.PI / 180) * f) / 2);
              var m = this.values;
              m[d.M00] = f / g;
              m[d.M10] = 0;
              m[d.M20] = 0;
              m[d.M30] = 0;
              m[d.M01] = 0;
              m[d.M11] = f;
              m[d.M21] = 0;
              m[d.M31] = 0;
              m[d.M02] = 0;
              m[d.M12] = 0;
              m[d.M22] = (c + b) / (b - c);
              m[d.M32] = -1;
              m[d.M03] = 0;
              m[d.M13] = 0;
              m[d.M23] = (2 * c * b) / (b - c);
              m[d.M33] = 0;
              return this;
            };
            e.prototype.ortho2d = function (b, c, f, g) {
              return this.ortho(b, b + f, c, c + g, 0, 1);
            };
            e.prototype.ortho = function (b, c, f, g, m, n) {
              this.identity();
              var q = this.values;
              q[d.M00] = 2 / (c - b);
              q[d.M10] = 0;
              q[d.M20] = 0;
              q[d.M30] = 0;
              q[d.M01] = 0;
              q[d.M11] = 2 / (g - f);
              q[d.M21] = 0;
              q[d.M31] = 0;
              q[d.M02] = 0;
              q[d.M12] = 0;
              q[d.M22] = -2 / (n - m);
              q[d.M32] = 0;
              q[d.M03] = -(c + b) / (c - b);
              q[d.M13] = -(g + f) / (g - f);
              q[d.M23] = -(n + m) / (n - m);
              q[d.M33] = 1;
              return this;
            };
            e.prototype.multiply = function (b) {
              var c = this.temp,
                f = this.values;
              b = b.values;
              c[d.M00] =
                f[d.M00] * b[d.M00] +
                f[d.M01] * b[d.M10] +
                f[d.M02] * b[d.M20] +
                f[d.M03] * b[d.M30];
              c[d.M01] =
                f[d.M00] * b[d.M01] +
                f[d.M01] * b[d.M11] +
                f[d.M02] * b[d.M21] +
                f[d.M03] * b[d.M31];
              c[d.M02] =
                f[d.M00] * b[d.M02] +
                f[d.M01] * b[d.M12] +
                f[d.M02] * b[d.M22] +
                f[d.M03] * b[d.M32];
              c[d.M03] =
                f[d.M00] * b[d.M03] +
                f[d.M01] * b[d.M13] +
                f[d.M02] * b[d.M23] +
                f[d.M03] * b[d.M33];
              c[d.M10] =
                f[d.M10] * b[d.M00] +
                f[d.M11] * b[d.M10] +
                f[d.M12] * b[d.M20] +
                f[d.M13] * b[d.M30];
              c[d.M11] =
                f[d.M10] * b[d.M01] +
                f[d.M11] * b[d.M11] +
                f[d.M12] * b[d.M21] +
                f[d.M13] * b[d.M31];
              c[d.M12] =
                f[d.M10] * b[d.M02] +
                f[d.M11] * b[d.M12] +
                f[d.M12] * b[d.M22] +
                f[d.M13] * b[d.M32];
              c[d.M13] =
                f[d.M10] * b[d.M03] +
                f[d.M11] * b[d.M13] +
                f[d.M12] * b[d.M23] +
                f[d.M13] * b[d.M33];
              c[d.M20] =
                f[d.M20] * b[d.M00] +
                f[d.M21] * b[d.M10] +
                f[d.M22] * b[d.M20] +
                f[d.M23] * b[d.M30];
              c[d.M21] =
                f[d.M20] * b[d.M01] +
                f[d.M21] * b[d.M11] +
                f[d.M22] * b[d.M21] +
                f[d.M23] * b[d.M31];
              c[d.M22] =
                f[d.M20] * b[d.M02] +
                f[d.M21] * b[d.M12] +
                f[d.M22] * b[d.M22] +
                f[d.M23] * b[d.M32];
              c[d.M23] =
                f[d.M20] * b[d.M03] +
                f[d.M21] * b[d.M13] +
                f[d.M22] * b[d.M23] +
                f[d.M23] * b[d.M33];
              c[d.M30] =
                f[d.M30] * b[d.M00] +
                f[d.M31] * b[d.M10] +
                f[d.M32] * b[d.M20] +
                f[d.M33] * b[d.M30];
              c[d.M31] =
                f[d.M30] * b[d.M01] +
                f[d.M31] * b[d.M11] +
                f[d.M32] * b[d.M21] +
                f[d.M33] * b[d.M31];
              c[d.M32] =
                f[d.M30] * b[d.M02] +
                f[d.M31] * b[d.M12] +
                f[d.M32] * b[d.M22] +
                f[d.M33] * b[d.M32];
              c[d.M33] =
                f[d.M30] * b[d.M03] +
                f[d.M31] * b[d.M13] +
                f[d.M32] * b[d.M23] +
                f[d.M33] * b[d.M33];
              return this.set(this.temp);
            };
            e.prototype.multiplyLeft = function (b) {
              var c = this.temp,
                f = this.values;
              b = b.values;
              c[d.M00] =
                b[d.M00] * f[d.M00] +
                b[d.M01] * f[d.M10] +
                b[d.M02] * f[d.M20] +
                b[d.M03] * f[d.M30];
              c[d.M01] =
                b[d.M00] * f[d.M01] +
                b[d.M01] * f[d.M11] +
                b[d.M02] * f[d.M21] +
                b[d.M03] * f[d.M31];
              c[d.M02] =
                b[d.M00] * f[d.M02] +
                b[d.M01] * f[d.M12] +
                b[d.M02] * f[d.M22] +
                b[d.M03] * f[d.M32];
              c[d.M03] =
                b[d.M00] * f[d.M03] +
                b[d.M01] * f[d.M13] +
                b[d.M02] * f[d.M23] +
                b[d.M03] * f[d.M33];
              c[d.M10] =
                b[d.M10] * f[d.M00] +
                b[d.M11] * f[d.M10] +
                b[d.M12] * f[d.M20] +
                b[d.M13] * f[d.M30];
              c[d.M11] =
                b[d.M10] * f[d.M01] +
                b[d.M11] * f[d.M11] +
                b[d.M12] * f[d.M21] +
                b[d.M13] * f[d.M31];
              c[d.M12] =
                b[d.M10] * f[d.M02] +
                b[d.M11] * f[d.M12] +
                b[d.M12] * f[d.M22] +
                b[d.M13] * f[d.M32];
              c[d.M13] =
                b[d.M10] * f[d.M03] +
                b[d.M11] * f[d.M13] +
                b[d.M12] * f[d.M23] +
                b[d.M13] * f[d.M33];
              c[d.M20] =
                b[d.M20] * f[d.M00] +
                b[d.M21] * f[d.M10] +
                b[d.M22] * f[d.M20] +
                b[d.M23] * f[d.M30];
              c[d.M21] =
                b[d.M20] * f[d.M01] +
                b[d.M21] * f[d.M11] +
                b[d.M22] * f[d.M21] +
                b[d.M23] * f[d.M31];
              c[d.M22] =
                b[d.M20] * f[d.M02] +
                b[d.M21] * f[d.M12] +
                b[d.M22] * f[d.M22] +
                b[d.M23] * f[d.M32];
              c[d.M23] =
                b[d.M20] * f[d.M03] +
                b[d.M21] * f[d.M13] +
                b[d.M22] * f[d.M23] +
                b[d.M23] * f[d.M33];
              c[d.M30] =
                b[d.M30] * f[d.M00] +
                b[d.M31] * f[d.M10] +
                b[d.M32] * f[d.M20] +
                b[d.M33] * f[d.M30];
              c[d.M31] =
                b[d.M30] * f[d.M01] +
                b[d.M31] * f[d.M11] +
                b[d.M32] * f[d.M21] +
                b[d.M33] * f[d.M31];
              c[d.M32] =
                b[d.M30] * f[d.M02] +
                b[d.M31] * f[d.M12] +
                b[d.M32] * f[d.M22] +
                b[d.M33] * f[d.M32];
              c[d.M33] =
                b[d.M30] * f[d.M03] +
                b[d.M31] * f[d.M13] +
                b[d.M32] * f[d.M23] +
                b[d.M33] * f[d.M33];
              return this.set(this.temp);
            };
            e.prototype.lookAt = function (b, c, f) {
              e.initTemps();
              var g = e.xAxis,
                m = e.yAxis,
                n = e.zAxis;
              n.setFrom(c).normalize();
              g.setFrom(c).normalize();
              g.cross(f).normalize();
              m.setFrom(g).cross(n).normalize();
              this.identity();
              c = this.values;
              c[d.M00] = g.x;
              c[d.M01] = g.y;
              c[d.M02] = g.z;
              c[d.M10] = m.x;
              c[d.M11] = m.y;
              c[d.M12] = m.z;
              c[d.M20] = -n.x;
              c[d.M21] = -n.y;
              c[d.M22] = -n.z;
              e.tmpMatrix.identity();
              e.tmpMatrix.values[d.M03] = -b.x;
              e.tmpMatrix.values[d.M13] = -b.y;
              e.tmpMatrix.values[d.M23] = -b.z;
              this.multiply(e.tmpMatrix);
              return this;
            };
            e.initTemps = function () {
              null === e.xAxis && (e.xAxis = new d.Vector3());
              null === e.yAxis && (e.yAxis = new d.Vector3());
              null === e.zAxis && (e.zAxis = new d.Vector3());
            };
            e.xAxis = null;
            e.yAxis = null;
            e.zAxis = null;
            e.tmpMatrix = new e();
            return e;
          })();
          d.Matrix4 = k;
        })(a.webgl || (a.webgl = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function () {
            function c(f, g, m, n) {
              this.attributes = g;
              this.verticesLength = 0;
              this.dirtyVertices = !1;
              this.indicesLength = 0;
              this.dirtyIndices = !1;
              this.elementsPerVertex = 0;
              this.context =
                f instanceof d.ManagedWebGLRenderingContext
                  ? f
                  : new d.ManagedWebGLRenderingContext(f);
              for (f = this.elementsPerVertex = 0; f < g.length; f++)
                this.elementsPerVertex += g[f].numElements;
              this.vertices = new Float32Array(m * this.elementsPerVertex);
              this.indices = new Uint16Array(n);
              this.context.addRestorable(this);
            }
            c.prototype.getAttributes = function () {
              return this.attributes;
            };
            c.prototype.maxVertices = function () {
              return this.vertices.length / this.elementsPerVertex;
            };
            c.prototype.numVertices = function () {
              return this.verticesLength / this.elementsPerVertex;
            };
            c.prototype.setVerticesLength = function (f) {
              this.dirtyVertices = !0;
              this.verticesLength = f;
            };
            c.prototype.getVertices = function () {
              return this.vertices;
            };
            c.prototype.maxIndices = function () {
              return this.indices.length;
            };
            c.prototype.numIndices = function () {
              return this.indicesLength;
            };
            c.prototype.setIndicesLength = function (f) {
              this.dirtyIndices = !0;
              this.indicesLength = f;
            };
            c.prototype.getIndices = function () {
              return this.indices;
            };
            c.prototype.getVertexSizeInFloats = function () {
              for (var f = 0, g = 0; g < this.attributes.length; g++)
                f += this.attributes[g].numElements;
              return f;
            };
            c.prototype.setVertices = function (f) {
              this.dirtyVertices = !0;
              if (f.length > this.vertices.length)
                throw Error(
                  "Mesh can't store more than " +
                    this.maxVertices() +
                    " vertices"
                );
              this.vertices.set(f, 0);
              this.verticesLength = f.length;
            };
            c.prototype.setIndices = function (f) {
              this.dirtyIndices = !0;
              if (f.length > this.indices.length)
                throw Error(
                  "Mesh can't store more than " + this.maxIndices() + " indices"
                );
              this.indices.set(f, 0);
              this.indicesLength = f.length;
            };
            c.prototype.draw = function (f, g) {
              this.drawWithOffset(
                f,
                g,
                0,
                0 < this.indicesLength
                  ? this.indicesLength
                  : this.verticesLength / this.elementsPerVertex
              );
            };
            c.prototype.drawWithOffset = function (f, g, m, n) {
              var q = this.context.gl;
              (this.dirtyVertices || this.dirtyIndices) && this.update();
              this.bind(f);
              0 < this.indicesLength
                ? q.drawElements(g, n, q.UNSIGNED_SHORT, 2 * m)
                : q.drawArrays(g, m, n);
              this.unbind(f);
            };
            c.prototype.bind = function (f) {
              var g = this.context.gl;
              g.bindBuffer(g.ARRAY_BUFFER, this.verticesBuffer);
              for (var m = 0, n = 0; n < this.attributes.length; n++) {
                var q = this.attributes[n],
                  r = f.getAttributeLocation(q.name);
                g.enableVertexAttribArray(r);
                g.vertexAttribPointer(
                  r,
                  q.numElements,
                  g.FLOAT,
                  !1,
                  4 * this.elementsPerVertex,
                  4 * m
                );
                m += q.numElements;
              }
              0 < this.indicesLength &&
                g.bindBuffer(g.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
            };
            c.prototype.unbind = function (f) {
              for (
                var g = this.context.gl, m = 0;
                m < this.attributes.length;
                m++
              ) {
                var n = f.getAttributeLocation(this.attributes[m].name);
                g.disableVertexAttribArray(n);
              }
              g.bindBuffer(g.ARRAY_BUFFER, null);
              0 < this.indicesLength &&
                g.bindBuffer(g.ELEMENT_ARRAY_BUFFER, null);
            };
            c.prototype.update = function () {
              var f = this.context.gl;
              this.dirtyVertices &&
                (this.verticesBuffer ||
                  (this.verticesBuffer = f.createBuffer()),
                f.bindBuffer(f.ARRAY_BUFFER, this.verticesBuffer),
                f.bufferData(
                  f.ARRAY_BUFFER,
                  this.vertices.subarray(0, this.verticesLength),
                  f.DYNAMIC_DRAW
                ),
                (this.dirtyVertices = !1));
              this.dirtyIndices &&
                (this.indicesBuffer || (this.indicesBuffer = f.createBuffer()),
                f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this.indicesBuffer),
                f.bufferData(
                  f.ELEMENT_ARRAY_BUFFER,
                  this.indices.subarray(0, this.indicesLength),
                  f.DYNAMIC_DRAW
                ),
                (this.dirtyIndices = !1));
            };
            c.prototype.restore = function () {
              this.indicesBuffer = this.verticesBuffer = null;
              this.update();
            };
            c.prototype.dispose = function () {
              this.context.removeRestorable(this);
              var f = this.context.gl;
              f.deleteBuffer(this.verticesBuffer);
              f.deleteBuffer(this.indicesBuffer);
            };
            return c;
          })();
          d.Mesh = k;
          k = (function () {
            return function (c, f, g) {
              this.name = c;
              this.type = f;
              this.numElements = g;
            };
          })();
          d.VertexAttribute = k;
          var e = (function (c) {
            function f() {
              return c.call(this, d.Shader.POSITION, b.Float, 2) || this;
            }
            h(f, c);
            return f;
          })(k);
          d.Position2Attribute = e;
          e = (function (c) {
            function f() {
              return c.call(this, d.Shader.POSITION, b.Float, 3) || this;
            }
            h(f, c);
            return f;
          })(k);
          d.Position3Attribute = e;
          e = (function (c) {
            function f(g) {
              void 0 === g && (g = 0);
              return (
                c.call(
                  this,
                  d.Shader.TEXCOORDS + (0 == g ? "" : g),
                  b.Float,
                  2
                ) || this
              );
            }
            h(f, c);
            return f;
          })(k);
          d.TexCoordAttribute = e;
          e = (function (c) {
            function f() {
              return c.call(this, d.Shader.COLOR, b.Float, 4) || this;
            }
            h(f, c);
            return f;
          })(k);
          d.ColorAttribute = e;
          k = (function (c) {
            function f() {
              return c.call(this, d.Shader.COLOR2, b.Float, 4) || this;
            }
            h(f, c);
            return f;
          })(k);
          d.Color2Attribute = k;
          var b;
          (function (c) {
            c[(c.Float = 0)] = "Float";
          })((b = d.VertexAttributeType || (d.VertexAttributeType = {})));
        })(a.webgl || (a.webgl = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function () {
            function e(b, c, f) {
              void 0 === c && (c = !0);
              void 0 === f && (f = 10920);
              this.isDrawing = !1;
              this.lastTexture = this.shader = null;
              this.indicesLength = this.verticesLength = 0;
              if (10920 < f)
                throw Error(
                  "Can't have more than 10920 triangles per batch: " + f
                );
              this.context =
                b instanceof d.ManagedWebGLRenderingContext
                  ? b
                  : new d.ManagedWebGLRenderingContext(b);
              c = c
                ? [
                    new d.Position2Attribute(),
                    new d.ColorAttribute(),
                    new d.TexCoordAttribute(),
                    new d.Color2Attribute(),
                  ]
                : [
                    new d.Position2Attribute(),
                    new d.ColorAttribute(),
                    new d.TexCoordAttribute(),
                  ];
              this.mesh = new d.Mesh(b, c, f, 3 * f);
              this.srcBlend = this.context.gl.SRC_ALPHA;
              this.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA;
            }
            e.prototype.begin = function (b) {
              var c = this.context.gl;
              if (this.isDrawing)
                throw Error(
                  "PolygonBatch is already drawing. Call PolygonBatch.end() before calling PolygonBatch.begin()"
                );
              this.drawCalls = 0;
              this.shader = b;
              this.lastTexture = null;
              this.isDrawing = !0;
              c.enable(c.BLEND);
              c.blendFunc(this.srcBlend, this.dstBlend);
            };
            e.prototype.setBlendMode = function (b, c) {
              var f = this.context.gl;
              this.srcBlend = b;
              this.dstBlend = c;
              this.isDrawing &&
                (this.flush(), f.blendFunc(this.srcBlend, this.dstBlend));
            };
            e.prototype.draw = function (b, c, f) {
              b != this.lastTexture
                ? (this.flush(), (this.lastTexture = b))
                : (this.verticesLength + c.length >
                    this.mesh.getVertices().length ||
                    this.indicesLength + f.length >
                      this.mesh.getIndices().length) &&
                  this.flush();
              b = this.mesh.numVertices();
              this.mesh.getVertices().set(c, this.verticesLength);
              this.verticesLength += c.length;
              this.mesh.setVerticesLength(this.verticesLength);
              c = this.mesh.getIndices();
              for (var g = this.indicesLength, m = 0; m < f.length; g++, m++)
                c[g] = f[m] + b;
              this.indicesLength += f.length;
              this.mesh.setIndicesLength(this.indicesLength);
            };
            e.prototype.flush = function () {
              var b = this.context.gl;
              0 != this.verticesLength &&
                (this.lastTexture.bind(),
                this.mesh.draw(this.shader, b.TRIANGLES),
                (this.indicesLength = this.verticesLength = 0),
                this.mesh.setVerticesLength(0),
                this.mesh.setIndicesLength(0),
                this.drawCalls++);
            };
            e.prototype.end = function () {
              var b = this.context.gl;
              if (!this.isDrawing)
                throw Error(
                  "PolygonBatch is not drawing. Call PolygonBatch.begin() before calling PolygonBatch.end()"
                );
              (0 < this.verticesLength || 0 < this.indicesLength) &&
                this.flush();
              this.lastTexture = this.shader = null;
              this.isDrawing = !1;
              b.disable(b.BLEND);
            };
            e.prototype.getDrawCalls = function () {
              return this.drawCalls;
            };
            e.prototype.dispose = function () {
              this.mesh.dispose();
            };
            return e;
          })();
          d.PolygonBatcher = k;
        })(a.webgl || (a.webgl = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function () {
            function b(c, f, g) {
              void 0 === g && (g = !0);
              this.twoColorTint = !1;
              this.activeRenderer = null;
              this.QUAD = [
                0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1,
                1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0,
              ];
              this.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
              this.WHITE = new a.Color(1, 1, 1, 1);
              this.canvas = c;
              this.context =
                f instanceof d.ManagedWebGLRenderingContext
                  ? f
                  : new d.ManagedWebGLRenderingContext(f);
              this.twoColorTint = g;
              this.camera = new d.OrthoCamera(c.width, c.height);
              this.batcherShader = g
                ? d.Shader.newTwoColoredTextured(this.context)
                : d.Shader.newColoredTextured(this.context);
              this.batcher = new d.PolygonBatcher(this.context, g);
              this.shapesShader = d.Shader.newColored(this.context);
              this.shapes = new d.ShapeRenderer(this.context);
              this.skeletonRenderer = new d.SkeletonRenderer(this.context, g);
              this.skeletonDebugRenderer = new d.SkeletonDebugRenderer(
                this.context
              );
            }
            b.prototype.begin = function () {
              this.camera.update();
              this.enableRenderer(this.batcher);
            };
            b.prototype.drawSkeleton = function (c, f, g, m) {
              void 0 === f && (f = !1);
              void 0 === g && (g = -1);
              void 0 === m && (m = -1);
              this.enableRenderer(this.batcher);
              this.skeletonRenderer.premultipliedAlpha = f;
              this.skeletonRenderer.draw(this.batcher, c, g, m);
            };
            b.prototype.drawSkeletonDebug = function (c, f, g) {
              void 0 === f && (f = !1);
              void 0 === g && (g = null);
              this.enableRenderer(this.shapes);
              this.skeletonDebugRenderer.premultipliedAlpha = f;
              this.skeletonDebugRenderer.draw(this.shapes, c, g);
            };
            b.prototype.drawTexture = function (c, f, g, m, n, q) {
              void 0 === q && (q = null);
              this.enableRenderer(this.batcher);
              null === q && (q = this.WHITE);
              var r = this.QUAD,
                u = 0;
              r[u++] = f;
              r[u++] = g;
              r[u++] = q.r;
              r[u++] = q.g;
              r[u++] = q.b;
              r[u++] = q.a;
              r[u++] = 0;
              r[u++] = 1;
              this.twoColorTint &&
                ((r[u++] = 0), (r[u++] = 0), (r[u++] = 0), (r[u++] = 0));
              r[u++] = f + m;
              r[u++] = g;
              r[u++] = q.r;
              r[u++] = q.g;
              r[u++] = q.b;
              r[u++] = q.a;
              r[u++] = 1;
              r[u++] = 1;
              this.twoColorTint &&
                ((r[u++] = 0), (r[u++] = 0), (r[u++] = 0), (r[u++] = 0));
              r[u++] = f + m;
              r[u++] = g + n;
              r[u++] = q.r;
              r[u++] = q.g;
              r[u++] = q.b;
              r[u++] = q.a;
              r[u++] = 1;
              r[u++] = 0;
              this.twoColorTint &&
                ((r[u++] = 0), (r[u++] = 0), (r[u++] = 0), (r[u++] = 0));
              r[u++] = f;
              r[u++] = g + n;
              r[u++] = q.r;
              r[u++] = q.g;
              r[u++] = q.b;
              r[u++] = q.a;
              r[u++] = 0;
              r[u++] = 0;
              this.twoColorTint &&
                ((r[u++] = 0), (r[u++] = 0), (r[u++] = 0), (r[u++] = 0));
              this.batcher.draw(c, r, this.QUAD_TRIANGLES);
            };
            b.prototype.drawTextureUV = function (
              c,
              f,
              g,
              m,
              n,
              q,
              r,
              u,
              v,
              x
            ) {
              void 0 === x && (x = null);
              this.enableRenderer(this.batcher);
              null === x && (x = this.WHITE);
              var y = this.QUAD,
                z = 0;
              y[z++] = f;
              y[z++] = g;
              y[z++] = x.r;
              y[z++] = x.g;
              y[z++] = x.b;
              y[z++] = x.a;
              y[z++] = q;
              y[z++] = r;
              this.twoColorTint &&
                ((y[z++] = 0), (y[z++] = 0), (y[z++] = 0), (y[z++] = 0));
              y[z++] = f + m;
              y[z++] = g;
              y[z++] = x.r;
              y[z++] = x.g;
              y[z++] = x.b;
              y[z++] = x.a;
              y[z++] = u;
              y[z++] = r;
              this.twoColorTint &&
                ((y[z++] = 0), (y[z++] = 0), (y[z++] = 0), (y[z++] = 0));
              y[z++] = f + m;
              y[z++] = g + n;
              y[z++] = x.r;
              y[z++] = x.g;
              y[z++] = x.b;
              y[z++] = x.a;
              y[z++] = u;
              y[z++] = v;
              this.twoColorTint &&
                ((y[z++] = 0), (y[z++] = 0), (y[z++] = 0), (y[z++] = 0));
              y[z++] = f;
              y[z++] = g + n;
              y[z++] = x.r;
              y[z++] = x.g;
              y[z++] = x.b;
              y[z++] = x.a;
              y[z++] = q;
              y[z++] = v;
              this.twoColorTint &&
                ((y[z++] = 0), (y[z++] = 0), (y[z++] = 0), (y[z++] = 0));
              this.batcher.draw(c, y, this.QUAD_TRIANGLES);
            };
            b.prototype.drawTextureRotated = function (
              c,
              f,
              g,
              m,
              n,
              q,
              r,
              u,
              v,
              x
            ) {
              void 0 === v && (v = null);
              this.enableRenderer(this.batcher);
              null === v && (v = this.WHITE);
              x = this.QUAD;
              f += q;
              g += r;
              var y = -q,
                z = -r;
              m -= q;
              var A = n - r;
              if (0 != u) {
                var B = a.MathUtils.cosDeg(u),
                  D = a.MathUtils.sinDeg(u);
                u = B * y - D * z;
                n = D * y + B * z;
                r = B * y - D * A;
                q = D * y + B * A;
                y = B * m - D * A;
                A = D * m + B * A;
                m = y + (u - r);
                z = A + (n - q);
              } else (u = y), (n = z), (r = y), (q = A), (y = m);
              B = 0;
              x[B++] = u + f;
              x[B++] = n + g;
              x[B++] = v.r;
              x[B++] = v.g;
              x[B++] = v.b;
              x[B++] = v.a;
              x[B++] = 0;
              x[B++] = 1;
              this.twoColorTint &&
                ((x[B++] = 0), (x[B++] = 0), (x[B++] = 0), (x[B++] = 0));
              x[B++] = m + f;
              x[B++] = z + g;
              x[B++] = v.r;
              x[B++] = v.g;
              x[B++] = v.b;
              x[B++] = v.a;
              x[B++] = 1;
              x[B++] = 1;
              this.twoColorTint &&
                ((x[B++] = 0), (x[B++] = 0), (x[B++] = 0), (x[B++] = 0));
              x[B++] = y + f;
              x[B++] = A + g;
              x[B++] = v.r;
              x[B++] = v.g;
              x[B++] = v.b;
              x[B++] = v.a;
              x[B++] = 1;
              x[B++] = 0;
              this.twoColorTint &&
                ((x[B++] = 0), (x[B++] = 0), (x[B++] = 0), (x[B++] = 0));
              x[B++] = r + f;
              x[B++] = q + g;
              x[B++] = v.r;
              x[B++] = v.g;
              x[B++] = v.b;
              x[B++] = v.a;
              x[B++] = 0;
              x[B++] = 0;
              this.twoColorTint &&
                ((x[B++] = 0), (x[B++] = 0), (x[B++] = 0), (x[B++] = 0));
              this.batcher.draw(c, x, this.QUAD_TRIANGLES);
            };
            b.prototype.drawRegion = function (c, f, g, m, n, q, r) {
              void 0 === q && (q = null);
              this.enableRenderer(this.batcher);
              null === q && (q = this.WHITE);
              r = this.QUAD;
              var u = 0;
              r[u++] = f;
              r[u++] = g;
              r[u++] = q.r;
              r[u++] = q.g;
              r[u++] = q.b;
              r[u++] = q.a;
              r[u++] = c.u;
              r[u++] = c.v2;
              this.twoColorTint &&
                ((r[u++] = 0), (r[u++] = 0), (r[u++] = 0), (r[u++] = 0));
              r[u++] = f + m;
              r[u++] = g;
              r[u++] = q.r;
              r[u++] = q.g;
              r[u++] = q.b;
              r[u++] = q.a;
              r[u++] = c.u2;
              r[u++] = c.v2;
              this.twoColorTint &&
                ((r[u++] = 0), (r[u++] = 0), (r[u++] = 0), (r[u++] = 0));
              r[u++] = f + m;
              r[u++] = g + n;
              r[u++] = q.r;
              r[u++] = q.g;
              r[u++] = q.b;
              r[u++] = q.a;
              r[u++] = c.u2;
              r[u++] = c.v;
              this.twoColorTint &&
                ((r[u++] = 0), (r[u++] = 0), (r[u++] = 0), (r[u++] = 0));
              r[u++] = f;
              r[u++] = g + n;
              r[u++] = q.r;
              r[u++] = q.g;
              r[u++] = q.b;
              r[u++] = q.a;
              r[u++] = c.u;
              r[u++] = c.v;
              this.twoColorTint &&
                ((r[u++] = 0), (r[u++] = 0), (r[u++] = 0), (r[u++] = 0));
              this.batcher.draw(c.texture, r, this.QUAD_TRIANGLES);
            };
            b.prototype.line = function (c, f, g, m, n, q) {
              void 0 === n && (n = null);
              this.enableRenderer(this.shapes);
              this.shapes.line(c, f, g, m, n);
            };
            b.prototype.triangle = function (c, f, g, m, n, q, r, u, v, x) {
              void 0 === u && (u = null);
              void 0 === v && (v = null);
              void 0 === x && (x = null);
              this.enableRenderer(this.shapes);
              this.shapes.triangle(c, f, g, m, n, q, r, u, v, x);
            };
            b.prototype.quad = function (
              c,
              f,
              g,
              m,
              n,
              q,
              r,
              u,
              v,
              x,
              y,
              z,
              A
            ) {
              void 0 === x && (x = null);
              void 0 === y && (y = null);
              void 0 === z && (z = null);
              void 0 === A && (A = null);
              this.enableRenderer(this.shapes);
              this.shapes.quad(c, f, g, m, n, q, r, u, v, x, y, z, A);
            };
            b.prototype.rect = function (c, f, g, m, n, q) {
              void 0 === q && (q = null);
              this.enableRenderer(this.shapes);
              this.shapes.rect(c, f, g, m, n, q);
            };
            b.prototype.rectLine = function (c, f, g, m, n, q, r) {
              void 0 === r && (r = null);
              this.enableRenderer(this.shapes);
              this.shapes.rectLine(c, f, g, m, n, q, r);
            };
            b.prototype.polygon = function (c, f, g, m) {
              void 0 === m && (m = null);
              this.enableRenderer(this.shapes);
              this.shapes.polygon(c, f, g, m);
            };
            b.prototype.circle = function (c, f, g, m, n, q) {
              void 0 === n && (n = null);
              void 0 === q && (q = 0);
              this.enableRenderer(this.shapes);
              this.shapes.circle(c, f, g, m, n, q);
            };
            b.prototype.curve = function (c, f, g, m, n, q, r, u, v, x) {
              void 0 === x && (x = null);
              this.enableRenderer(this.shapes);
              this.shapes.curve(c, f, g, m, n, q, r, u, v, x);
            };
            b.prototype.end = function () {
              this.activeRenderer === this.batcher
                ? this.batcher.end()
                : this.activeRenderer === this.shapes && this.shapes.end();
              this.activeRenderer = null;
            };
            b.prototype.resize = function (c) {
              var f = this.canvas,
                g = f.clientWidth,
                m = f.clientHeight;
              if (f.width != g || f.height != m) (f.width = g), (f.height = m);
              this.context.gl.viewport(0, 0, f.width, f.height);
              c !== e.Stretch &&
                (c === e.Expand
                  ? this.camera.setViewport(g, m)
                  : c === e.Fit &&
                    ((c = f.width),
                    (f = f.height),
                    (g = this.camera.viewportWidth),
                    (m = this.camera.viewportHeight),
                    (g = m / g < f / c ? g / c : m / f),
                    (this.camera.viewportWidth = c * g),
                    (this.camera.viewportHeight = f * g)));
              this.camera.update();
            };
            b.prototype.enableRenderer = function (c) {
              this.activeRenderer !== c &&
                (this.end(),
                c instanceof d.PolygonBatcher
                  ? (this.batcherShader.bind(),
                    this.batcherShader.setUniform4x4f(
                      d.Shader.MVP_MATRIX,
                      this.camera.projectionView.values
                    ),
                    this.batcherShader.setUniformi("u_texture", 0),
                    this.batcher.begin(this.batcherShader),
                    (this.activeRenderer = this.batcher))
                  : c instanceof d.ShapeRenderer
                  ? (this.shapesShader.bind(),
                    this.shapesShader.setUniform4x4f(
                      d.Shader.MVP_MATRIX,
                      this.camera.projectionView.values
                    ),
                    this.shapes.begin(this.shapesShader),
                    (this.activeRenderer = this.shapes))
                  : (this.activeRenderer = this.skeletonDebugRenderer));
            };
            b.prototype.dispose = function () {
              this.batcher.dispose();
              this.batcherShader.dispose();
              this.shapes.dispose();
              this.shapesShader.dispose();
              this.skeletonDebugRenderer.dispose();
            };
            return b;
          })();
          d.SceneRenderer = k;
          var e;
          (function (b) {
            b[(b.Stretch = 0)] = "Stretch";
            b[(b.Expand = 1)] = "Expand";
            b[(b.Fit = 2)] = "Fit";
          })((e = d.ResizeMode || (d.ResizeMode = {})));
        })(a.webgl || (a.webgl = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function () {
            function e(b, c, f) {
              this.vertexShader = c;
              this.fragmentShader = f;
              this.program = this.fs = this.vs = null;
              this.tmp2x2 = new Float32Array(4);
              this.tmp3x3 = new Float32Array(9);
              this.tmp4x4 = new Float32Array(16);
              this.vsSource = c;
              this.fsSource = f;
              this.context =
                b instanceof d.ManagedWebGLRenderingContext
                  ? b
                  : new d.ManagedWebGLRenderingContext(b);
              this.context.addRestorable(this);
              this.compile();
            }
            e.prototype.getProgram = function () {
              return this.program;
            };
            e.prototype.getVertexShader = function () {
              return this.vertexShader;
            };
            e.prototype.getFragmentShader = function () {
              return this.fragmentShader;
            };
            e.prototype.getVertexShaderSource = function () {
              return this.vsSource;
            };
            e.prototype.getFragmentSource = function () {
              return this.fsSource;
            };
            e.prototype.compile = function () {
              var b = this.context.gl;
              try {
                (this.vs = this.compileShader(
                  b.VERTEX_SHADER,
                  this.vertexShader
                )),
                  (this.fs = this.compileShader(
                    b.FRAGMENT_SHADER,
                    this.fragmentShader
                  )),
                  (this.program = this.compileProgram(this.vs, this.fs));
              } catch (c) {
                throw (this.dispose(), c);
              }
            };
            e.prototype.compileShader = function (b, c) {
              var f = this.context.gl;
              b = f.createShader(b);
              f.shaderSource(b, c);
              f.compileShader(b);
              if (
                !f.getShaderParameter(b, f.COMPILE_STATUS) &&
                ((c = "Couldn't compile shader: " + f.getShaderInfoLog(b)),
                f.deleteShader(b),
                !f.isContextLost())
              )
                throw Error(c);
              return b;
            };
            e.prototype.compileProgram = function (b, c) {
              var f = this.context.gl,
                g = f.createProgram();
              f.attachShader(g, b);
              f.attachShader(g, c);
              f.linkProgram(g);
              if (
                !f.getProgramParameter(g, f.LINK_STATUS) &&
                ((b =
                  "Couldn't compile shader program: " + f.getProgramInfoLog(g)),
                f.deleteProgram(g),
                !f.isContextLost())
              )
                throw Error(b);
              return g;
            };
            e.prototype.restore = function () {
              this.compile();
            };
            e.prototype.bind = function () {
              this.context.gl.useProgram(this.program);
            };
            e.prototype.unbind = function () {
              this.context.gl.useProgram(null);
            };
            e.prototype.setUniformi = function (b, c) {
              this.context.gl.uniform1i(this.getUniformLocation(b), c);
            };
            e.prototype.setUniformf = function (b, c) {
              this.context.gl.uniform1f(this.getUniformLocation(b), c);
            };
            e.prototype.setUniform2f = function (b, c, f) {
              this.context.gl.uniform2f(this.getUniformLocation(b), c, f);
            };
            e.prototype.setUniform3f = function (b, c, f, g) {
              this.context.gl.uniform3f(this.getUniformLocation(b), c, f, g);
            };
            e.prototype.setUniform4f = function (b, c, f, g, m) {
              this.context.gl.uniform4f(this.getUniformLocation(b), c, f, g, m);
            };
            e.prototype.setUniform2x2f = function (b, c) {
              var f = this.context.gl;
              this.tmp2x2.set(c);
              f.uniformMatrix2fv(this.getUniformLocation(b), !1, this.tmp2x2);
            };
            e.prototype.setUniform3x3f = function (b, c) {
              var f = this.context.gl;
              this.tmp3x3.set(c);
              f.uniformMatrix3fv(this.getUniformLocation(b), !1, this.tmp3x3);
            };
            e.prototype.setUniform4x4f = function (b, c) {
              var f = this.context.gl;
              this.tmp4x4.set(c);
              f.uniformMatrix4fv(this.getUniformLocation(b), !1, this.tmp4x4);
            };
            e.prototype.getUniformLocation = function (b) {
              var c = this.context.gl,
                f = c.getUniformLocation(this.program, b);
              if (!f && !c.isContextLost())
                throw Error("Couldn't find location for uniform " + b);
              return f;
            };
            e.prototype.getAttributeLocation = function (b) {
              var c = this.context.gl,
                f = c.getAttribLocation(this.program, b);
              if (-1 == f && !c.isContextLost())
                throw Error("Couldn't find location for attribute " + b);
              return f;
            };
            e.prototype.dispose = function () {
              this.context.removeRestorable(this);
              var b = this.context.gl;
              this.vs && (b.deleteShader(this.vs), (this.vs = null));
              this.fs && (b.deleteShader(this.fs), (this.fs = null));
              this.program &&
                (b.deleteProgram(this.program), (this.program = null));
            };
            e.newColoredTextured = function (b) {
              return new e(
                b,
                "\n\t\t\t\tattribute vec4 " +
                  e.POSITION +
                  ";\n\t\t\t\tattribute vec4 " +
                  e.COLOR +
                  ";\n\t\t\t\tattribute vec2 " +
                  e.TEXCOORDS +
                  ";\n\t\t\t\tuniform mat4 " +
                  e.MVP_MATRIX +
                  ";\n\t\t\t\tvarying vec4 v_color;\n\t\t\t\tvarying vec2 v_texCoords;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tv_color = " +
                  e.COLOR +
                  ";\n\t\t\t\t\tv_texCoords = " +
                  e.TEXCOORDS +
                  ";\n\t\t\t\t\tgl_Position = " +
                  e.MVP_MATRIX +
                  " * " +
                  e.POSITION +
                  ";\n\t\t\t\t}\n\t\t\t",
                "\n\t\t\t\t#ifdef GL_ES\n\t\t\t\t\t#define LOWP lowp\n\t\t\t\t\tprecision mediump float;\n\t\t\t\t#else\n\t\t\t\t\t#define LOWP\n\t\t\t\t#endif\n\t\t\t\tvarying LOWP vec4 v_color;\n\t\t\t\tvarying vec2 v_texCoords;\n\t\t\t\tuniform sampler2D u_texture;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tgl_FragColor = v_color * texture2D(u_texture, v_texCoords);\n\t\t\t\t}\n\t\t\t"
              );
            };
            e.newTwoColoredTextured = function (b) {
              return new e(
                b,
                "\n\t\t\t\tattribute vec4 " +
                  e.POSITION +
                  ";\n\t\t\t\tattribute vec4 " +
                  e.COLOR +
                  ";\n\t\t\t\tattribute vec4 " +
                  e.COLOR2 +
                  ";\n\t\t\t\tattribute vec2 " +
                  e.TEXCOORDS +
                  ";\n\t\t\t\tuniform mat4 " +
                  e.MVP_MATRIX +
                  ";\n\t\t\t\tvarying vec4 v_light;\n\t\t\t\tvarying vec4 v_dark;\n\t\t\t\tvarying vec2 v_texCoords;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tv_light = " +
                  e.COLOR +
                  ";\n\t\t\t\t\tv_dark = " +
                  e.COLOR2 +
                  ";\n\t\t\t\t\tv_texCoords = " +
                  e.TEXCOORDS +
                  ";\n\t\t\t\t\tgl_Position = " +
                  e.MVP_MATRIX +
                  " * " +
                  e.POSITION +
                  ";\n\t\t\t\t}\n\t\t\t",
                "\n\t\t\t\t#ifdef GL_ES\n\t\t\t\t\t#define LOWP lowp\n\t\t\t\t\tprecision mediump float;\n\t\t\t\t#else\n\t\t\t\t\t#define LOWP\n\t\t\t\t#endif\n\t\t\t\tvarying LOWP vec4 v_light;\n\t\t\t\tvarying LOWP vec4 v_dark;\n\t\t\t\tvarying vec2 v_texCoords;\n\t\t\t\tuniform sampler2D u_texture;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tvec4 texColor = texture2D(u_texture, v_texCoords);\n\t\t\t\t\tgl_FragColor.a = texColor.a * v_light.a;\n\t\t\t\t\tgl_FragColor.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n\t\t\t\t}\n\t\t\t"
              );
            };
            e.newColored = function (b) {
              return new e(
                b,
                "\n\t\t\t\tattribute vec4 " +
                  e.POSITION +
                  ";\n\t\t\t\tattribute vec4 " +
                  e.COLOR +
                  ";\n\t\t\t\tuniform mat4 " +
                  e.MVP_MATRIX +
                  ";\n\t\t\t\tvarying vec4 v_color;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tv_color = " +
                  e.COLOR +
                  ";\n\t\t\t\t\tgl_Position = " +
                  e.MVP_MATRIX +
                  " * " +
                  e.POSITION +
                  ";\n\t\t\t\t}\n\t\t\t",
                "\n\t\t\t\t#ifdef GL_ES\n\t\t\t\t\t#define LOWP lowp\n\t\t\t\t\tprecision mediump float;\n\t\t\t\t#else\n\t\t\t\t\t#define LOWP\n\t\t\t\t#endif\n\t\t\t\tvarying LOWP vec4 v_color;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tgl_FragColor = v_color;\n\t\t\t\t}\n\t\t\t"
              );
            };
            e.MVP_MATRIX = "u_projTrans";
            e.POSITION = "a_position";
            e.COLOR = "a_color";
            e.COLOR2 = "a_color2";
            e.TEXCOORDS = "a_texCoords";
            e.SAMPLER = "u_texture";
            return e;
          })();
          d.Shader = k;
        })(a.webgl || (a.webgl = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function () {
            function b(c, f) {
              void 0 === f && (f = 10920);
              this.isDrawing = !1;
              this.shapeType = e.Filled;
              this.color = new a.Color(1, 1, 1, 1);
              this.vertexIndex = 0;
              this.tmp = new a.Vector2();
              if (10920 < f)
                throw Error(
                  "Can't have more than 10920 triangles per batch: " + f
                );
              this.context =
                c instanceof d.ManagedWebGLRenderingContext
                  ? c
                  : new d.ManagedWebGLRenderingContext(c);
              this.mesh = new d.Mesh(
                c,
                [new d.Position2Attribute(), new d.ColorAttribute()],
                f,
                0
              );
              this.srcBlend = this.context.gl.SRC_ALPHA;
              this.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA;
            }
            b.prototype.begin = function (c) {
              if (this.isDrawing)
                throw Error("ShapeRenderer.begin() has already been called");
              this.shader = c;
              this.vertexIndex = 0;
              this.isDrawing = !0;
              c = this.context.gl;
              c.enable(c.BLEND);
              c.blendFunc(this.srcBlend, this.dstBlend);
            };
            b.prototype.setBlendMode = function (c, f) {
              var g = this.context.gl;
              this.srcBlend = c;
              this.dstBlend = f;
              this.isDrawing &&
                (this.flush(), g.blendFunc(this.srcBlend, this.dstBlend));
            };
            b.prototype.setColor = function (c) {
              this.color.setFromColor(c);
            };
            b.prototype.setColorWith = function (c, f, g, m) {
              this.color.set(c, f, g, m);
            };
            b.prototype.point = function (c, f, g) {
              void 0 === g && (g = null);
              this.check(e.Point, 1);
              null === g && (g = this.color);
              this.vertex(c, f, g);
            };
            b.prototype.line = function (c, f, g, m, n) {
              void 0 === n && (n = null);
              this.check(e.Line, 2);
              this.mesh.getVertices();
              this.vertexIndex;
              null === n && (n = this.color);
              this.vertex(c, f, n);
              this.vertex(g, m, n);
            };
            b.prototype.triangle = function (c, f, g, m, n, q, r, u, v, x) {
              void 0 === u && (u = null);
              void 0 === v && (v = null);
              void 0 === x && (x = null);
              this.check(c ? e.Filled : e.Line, 3);
              this.mesh.getVertices();
              this.vertexIndex;
              null === u && (u = this.color);
              null === v && (v = this.color);
              null === x && (x = this.color);
              c
                ? (this.vertex(f, g, u),
                  this.vertex(m, n, v),
                  this.vertex(q, r, x))
                : (this.vertex(f, g, u),
                  this.vertex(m, n, v),
                  this.vertex(m, n, u),
                  this.vertex(q, r, v),
                  this.vertex(q, r, u),
                  this.vertex(f, g, v));
            };
            b.prototype.quad = function (
              c,
              f,
              g,
              m,
              n,
              q,
              r,
              u,
              v,
              x,
              y,
              z,
              A
            ) {
              void 0 === x && (x = null);
              void 0 === y && (y = null);
              void 0 === z && (z = null);
              void 0 === A && (A = null);
              this.check(c ? e.Filled : e.Line, 3);
              this.mesh.getVertices();
              this.vertexIndex;
              null === x && (x = this.color);
              null === y && (y = this.color);
              null === z && (z = this.color);
              null === A && (A = this.color);
              c
                ? (this.vertex(f, g, x),
                  this.vertex(m, n, y),
                  this.vertex(q, r, z),
                  this.vertex(q, r, z))
                : (this.vertex(f, g, x),
                  this.vertex(m, n, y),
                  this.vertex(m, n, y),
                  this.vertex(q, r, z),
                  this.vertex(q, r, z),
                  this.vertex(u, v, A));
              this.vertex(u, v, A);
              this.vertex(f, g, x);
            };
            b.prototype.rect = function (c, f, g, m, n, q) {
              void 0 === q && (q = null);
              this.quad(c, f, g, f + m, g, f + m, g + n, f, g + n, q, q, q, q);
            };
            b.prototype.rectLine = function (c, f, g, m, n, q, r) {
              void 0 === r && (r = null);
              this.check(c ? e.Filled : e.Line, 8);
              null === r && (r = this.color);
              var u = this.tmp.set(n - g, f - m);
              u.normalize();
              q *= 0.5;
              var v = u.x * q;
              q *= u.y;
              c
                ? (this.vertex(f + v, g + q, r),
                  this.vertex(f - v, g - q, r),
                  this.vertex(m + v, n + q, r),
                  this.vertex(m - v, n - q, r),
                  this.vertex(m + v, n + q, r))
                : (this.vertex(f + v, g + q, r),
                  this.vertex(f - v, g - q, r),
                  this.vertex(m + v, n + q, r),
                  this.vertex(m - v, n - q, r),
                  this.vertex(m + v, n + q, r),
                  this.vertex(f + v, g + q, r),
                  this.vertex(m - v, n - q, r));
              this.vertex(f - v, g - q, r);
            };
            b.prototype.x = function (c, f, g) {
              this.line(c - g, f - g, c + g, f + g);
              this.line(c - g, f + g, c + g, f - g);
            };
            b.prototype.polygon = function (c, f, g, m) {
              void 0 === m && (m = null);
              if (3 > g)
                throw Error("Polygon must contain at least 3 vertices");
              this.check(e.Line, 2 * g);
              null === m && (m = this.color);
              this.mesh.getVertices();
              this.vertexIndex;
              f <<= 1;
              g <<= 1;
              var n = c[f],
                q = c[f + 1],
                r = f + g,
                u = f;
              for (f = f + g - 2; u < f; u += 2) {
                g = c[u];
                var v = c[u + 1];
                if (u + 2 >= r) {
                  var x = n;
                  var y = q;
                } else (x = c[u + 2]), (y = c[u + 3]);
                this.vertex(g, v, m);
                this.vertex(x, y, m);
              }
            };
            b.prototype.circle = function (c, f, g, m, n, q) {
              void 0 === n && (n = null);
              void 0 === q && (q = 0);
              0 === q && (q = Math.max(1, (6 * a.MathUtils.cbrt(m)) | 0));
              if (0 >= q) throw Error("segments must be > 0.");
              null === n && (n = this.color);
              var r = (2 * a.MathUtils.PI) / q,
                u = Math.cos(r);
              r = Math.sin(r);
              var v = m,
                x = 0;
              if (c) {
                this.check(e.Filled, 3 * q + 3);
                q--;
                for (c = 0; c < q; c++) {
                  this.vertex(f, g, n);
                  this.vertex(f + v, g + x, n);
                  var y = v;
                  v = u * v - r * x;
                  x = r * y + u * x;
                  this.vertex(f + v, g + x, n);
                }
                this.vertex(f, g, n);
              } else
                for (this.check(e.Line, 2 * q + 2), c = 0; c < q; c++)
                  this.vertex(f + v, g + x, n),
                    (y = v),
                    (v = u * v - r * x),
                    (x = r * y + u * x),
                    this.vertex(f + v, g + x, n);
              this.vertex(f + v, g + x, n);
              this.vertex(f + m, g + 0, n);
            };
            b.prototype.curve = function (c, f, g, m, n, q, r, u, v, x) {
              void 0 === x && (x = null);
              this.check(e.Line, 2 * v + 2);
              null === x && (x = this.color);
              var y = 1 / v,
                z = y * y,
                A = y * y * y,
                B = 3 * y,
                D = 3 * z;
              y = 6 * z;
              z = 6 * A;
              var E = c - 2 * g + n,
                C = f - 2 * m + q,
                F = 3 * (g - n) - c + r,
                G = 3 * (m - q) - f + u;
              q = c;
              n = f;
              c = (g - c) * B + E * D + F * A;
              f = (m - f) * B + C * D + G * A;
              m = E * y + F * z;
              A = C * y + G * z;
              y = F * z;
              for (z *= G; 0 < v--; )
                this.vertex(q, n, x),
                  (q += c),
                  (n += f),
                  (c += m),
                  (f += A),
                  (m += y),
                  (A += z),
                  this.vertex(q, n, x);
              this.vertex(q, n, x);
              this.vertex(r, u, x);
            };
            b.prototype.vertex = function (c, f, g) {
              var m = this.vertexIndex,
                n = this.mesh.getVertices();
              n[m++] = c;
              n[m++] = f;
              n[m++] = g.r;
              n[m++] = g.g;
              n[m++] = g.b;
              n[m++] = g.a;
              this.vertexIndex = m;
            };
            b.prototype.end = function () {
              if (!this.isDrawing)
                throw Error("ShapeRenderer.begin() has not been called");
              this.flush();
              this.context.gl.disable(this.context.gl.BLEND);
              this.isDrawing = !1;
            };
            b.prototype.flush = function () {
              0 != this.vertexIndex &&
                (this.mesh.setVerticesLength(this.vertexIndex),
                this.mesh.draw(this.shader, this.shapeType),
                (this.vertexIndex = 0));
            };
            b.prototype.check = function (c, f) {
              if (!this.isDrawing)
                throw Error("ShapeRenderer.begin() has not been called");
              this.shapeType == c
                ? this.mesh.maxVertices() - this.mesh.numVertices() < f &&
                  this.flush()
                : (this.flush(), (this.shapeType = c));
            };
            b.prototype.dispose = function () {
              this.mesh.dispose();
            };
            return b;
          })();
          d.ShapeRenderer = k;
          var e;
          (function (b) {
            b[(b.Point = 0)] = "Point";
            b[(b.Line = 1)] = "Line";
            b[(b.Filled = 4)] = "Filled";
          })((e = d.ShapeType || (d.ShapeType = {})));
        })(a.webgl || (a.webgl = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function () {
            function e(b) {
              this.boneLineColor = new a.Color(1, 0, 0, 1);
              this.boneOriginColor = new a.Color(0, 1, 0, 1);
              this.attachmentLineColor = new a.Color(0, 0, 1, 0.5);
              this.triangleLineColor = new a.Color(1, 0.64, 0, 0.5);
              this.pathColor = new a.Color().setFromString("FF7F00");
              this.clipColor = new a.Color(0.8, 0, 0, 2);
              this.aabbColor = new a.Color(0, 1, 0, 0.5);
              this.drawPaths =
                this.drawMeshTriangles =
                this.drawMeshHull =
                this.drawBoundingBoxes =
                this.drawRegionAttachments =
                this.drawBones =
                  !0;
              this.drawSkeletonXY = !1;
              this.drawClipping = !0;
              this.premultipliedAlpha = !1;
              this.scale = 1;
              this.boneWidth = 2;
              this.bounds = new a.SkeletonBounds();
              this.temp = [];
              this.vertices = a.Utils.newFloatArray(2048);
              this.context =
                b instanceof d.ManagedWebGLRenderingContext
                  ? b
                  : new d.ManagedWebGLRenderingContext(b);
            }
            e.prototype.draw = function (b, c, f) {
              void 0 === f && (f = null);
              var g = c.x,
                m = c.y,
                n = this.context.gl;
              b.setBlendMode(
                this.premultipliedAlpha ? n.ONE : n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA
              );
              var q = c.bones;
              if (this.drawBones) {
                b.setColor(this.boneLineColor);
                n = 0;
                for (var r = q.length; n < r; n++) {
                  var u = q[n];
                  if (!(f && -1 < f.indexOf(u.data.name)) && null != u.parent) {
                    var v = g + u.data.length * u.a + u.worldX,
                      x = m + u.data.length * u.c + u.worldY;
                    b.rectLine(
                      !0,
                      g + u.worldX,
                      m + u.worldY,
                      v,
                      x,
                      this.boneWidth * this.scale
                    );
                  }
                }
                this.drawSkeletonXY && b.x(g, m, 4 * this.scale);
              }
              if (this.drawRegionAttachments)
                for (
                  b.setColor(this.attachmentLineColor),
                    u = c.slots,
                    n = 0,
                    r = u.length;
                  n < r;
                  n++
                ) {
                  var y = u[n],
                    z = y.getAttachment();
                  if (z instanceof a.RegionAttachment) {
                    var A = this.vertices;
                    z.computeWorldVertices(y.bone, A, 0, 2);
                    b.line(A[0], A[1], A[2], A[3]);
                    b.line(A[2], A[3], A[4], A[5]);
                    b.line(A[4], A[5], A[6], A[7]);
                    b.line(A[6], A[7], A[0], A[1]);
                  }
                }
              if (this.drawMeshHull || this.drawMeshTriangles)
                for (u = c.slots, n = 0, r = u.length; n < r; n++)
                  if (
                    ((y = u[n]),
                    y.bone.active &&
                      ((z = y.getAttachment()), z instanceof a.MeshAttachment))
                  ) {
                    A = this.vertices;
                    z.computeWorldVertices(
                      y,
                      0,
                      z.worldVerticesLength,
                      A,
                      0,
                      2
                    );
                    var B = z.triangles,
                      D = z.hullLength;
                    if (this.drawMeshTriangles)
                      for (
                        b.setColor(this.triangleLineColor), y = 0, z = B.length;
                        y < z;
                        y += 3
                      ) {
                        v = 2 * B[y];
                        x = 2 * B[y + 1];
                        var E = 2 * B[y + 2];
                        b.triangle(
                          !1,
                          A[v],
                          A[v + 1],
                          A[x],
                          A[x + 1],
                          A[E],
                          A[E + 1]
                        );
                      }
                    if (this.drawMeshHull && 0 < D)
                      for (
                        b.setColor(this.attachmentLineColor),
                          D = 2 * (D >> 1),
                          B = A[D - 2],
                          E = A[D - 1],
                          y = 0,
                          z = D;
                        y < z;
                        y += 2
                      )
                        (v = A[y]),
                          (x = A[y + 1]),
                          b.line(v, x, B, E),
                          (B = v),
                          (E = x);
                  }
              if (this.drawBoundingBoxes)
                for (
                  n = this.bounds,
                    n.update(c, !0),
                    b.setColor(this.aabbColor),
                    b.rect(!1, n.minX, n.minY, n.getWidth(), n.getHeight()),
                    u = n.polygons,
                    z = n.boundingBoxes,
                    n = 0,
                    r = u.length;
                  n < r;
                  n++
                )
                  (y = u[n]), b.setColor(z[n].color), b.polygon(y, 0, y.length);
              if (this.drawPaths)
                for (u = c.slots, n = 0, r = u.length; n < r; n++)
                  if (
                    ((y = u[n]),
                    y.bone.active &&
                      ((z = y.getAttachment()), z instanceof a.PathAttachment))
                  ) {
                    D = z;
                    z = D.worldVerticesLength;
                    A = this.temp = a.Utils.setArraySize(this.temp, z, 0);
                    D.computeWorldVertices(y, 0, z, A, 0, 2);
                    v = this.pathColor;
                    x = A[2];
                    E = A[3];
                    if (D.closed) {
                      b.setColor(v);
                      var C = A[0],
                        F = A[1],
                        G = A[z - 2],
                        H = A[z - 1];
                      D = A[z - 4];
                      B = A[z - 3];
                      b.curve(x, E, C, F, G, H, D, B, 32);
                      b.setColor(e.LIGHT_GRAY);
                      b.line(x, E, C, F);
                      b.line(D, B, G, H);
                    }
                    z -= 4;
                    for (y = 4; y < z; y += 6)
                      (C = A[y]),
                        (F = A[y + 1]),
                        (G = A[y + 2]),
                        (H = A[y + 3]),
                        (D = A[y + 4]),
                        (B = A[y + 5]),
                        b.setColor(v),
                        b.curve(x, E, C, F, G, H, D, B, 32),
                        b.setColor(e.LIGHT_GRAY),
                        b.line(x, E, C, F),
                        b.line(D, B, G, H),
                        (x = D),
                        (E = B);
                  }
              if (this.drawBones)
                for (
                  b.setColor(this.boneOriginColor), n = 0, r = q.length;
                  n < r;
                  n++
                )
                  (u = q[n]),
                    (f && -1 < f.indexOf(u.data.name)) ||
                      b.circle(
                        !0,
                        g + u.worldX,
                        m + u.worldY,
                        3 * this.scale,
                        e.GREEN,
                        8
                      );
              if (this.drawClipping)
                for (
                  u = c.slots, b.setColor(this.clipColor), n = 0, r = u.length;
                  n < r;
                  n++
                )
                  if (
                    ((y = u[n]),
                    y.bone.active &&
                      ((z = y.getAttachment()),
                      z instanceof a.ClippingAttachment))
                  )
                    for (
                      c = z,
                        z = c.worldVerticesLength,
                        A = this.temp = a.Utils.setArraySize(this.temp, z, 0),
                        c.computeWorldVertices(y, 0, z, A, 0, 2),
                        c = 0,
                        f = A.length;
                      c < f;
                      c += 2
                    )
                      (v = A[c]),
                        (x = A[c + 1]),
                        (D = A[(c + 2) % A.length]),
                        (B = A[(c + 3) % A.length]),
                        b.line(v, x, D, B);
            };
            e.prototype.dispose = function () {};
            e.LIGHT_GRAY = new a.Color(192 / 255, 192 / 255, 192 / 255, 1);
            e.GREEN = new a.Color(0, 1, 0, 1);
            return e;
          })();
          d.SkeletonDebugRenderer = k;
        })(a.webgl || (a.webgl = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function () {
              return function (b, c, f) {
                this.vertices = b;
                this.numVertices = c;
                this.numFloats = f;
              };
            })(),
            e = (function () {
              function b(c, f) {
                void 0 === f && (f = !0);
                this.premultipliedAlpha = !1;
                this.vertexEffect = null;
                this.tempColor = new a.Color();
                this.tempColor2 = new a.Color();
                this.vertexSize = 8;
                this.twoColorTint = !1;
                this.renderable = new k(null, 0, 0);
                this.clipper = new a.SkeletonClipping();
                this.temp = new a.Vector2();
                this.temp2 = new a.Vector2();
                this.temp3 = new a.Color();
                this.temp4 = new a.Color();
                if ((this.twoColorTint = f)) this.vertexSize += 4;
                this.vertices = a.Utils.newFloatArray(1024 * this.vertexSize);
              }
              b.prototype.draw = function (c, f, g, m) {
                void 0 === g && (g = -1);
                void 0 === m && (m = -1);
                var n = this.clipper,
                  q = this.premultipliedAlpha,
                  r = this.twoColorTint,
                  u = null,
                  v = this.temp,
                  x = this.temp2,
                  y = this.temp3,
                  z = this.temp4,
                  A = this.renderable,
                  B = f.drawOrder;
                f = f.color;
                var D = r ? 12 : 8,
                  E = !1;
                -1 == g && (E = !0);
                for (var C = 0, F = B.length; C < F; C++) {
                  var G = n.isClipping() ? 2 : D,
                    H = B[C];
                  if (
                    H.bone.active &&
                    (0 <= g && g == H.data.index && (E = !0), E)
                  ) {
                    0 <= m && m == H.data.index && (E = !1);
                    var K = H.getAttachment();
                    if (K instanceof a.RegionAttachment) {
                      var I = K;
                      A.vertices = this.vertices;
                      A.numVertices = 4;
                      A.numFloats = G << 2;
                      I.computeWorldVertices(H.bone, A.vertices, 0, G);
                      K = b.QUAD_TRIANGLES;
                      var M = I.uvs;
                      G = I.region.renderObject.texture;
                      I = I.color;
                    } else if (K instanceof a.MeshAttachment)
                      (I = K),
                        (A.vertices = this.vertices),
                        (A.numVertices = I.worldVerticesLength >> 1),
                        (A.numFloats = A.numVertices * G),
                        A.numFloats > A.vertices.length &&
                          (A.vertices = this.vertices =
                            a.Utils.newFloatArray(A.numFloats)),
                        I.computeWorldVertices(
                          H,
                          0,
                          I.worldVerticesLength,
                          A.vertices,
                          0,
                          G
                        ),
                        (K = I.triangles),
                        (G = I.region.renderObject.texture),
                        (M = I.uvs),
                        (I = I.color);
                    else {
                      K instanceof a.ClippingAttachment
                        ? n.clipStart(H, K)
                        : n.clipEndWithSlot(H);
                      continue;
                    }
                    if (null != G) {
                      var N = H.color,
                        P = this.tempColor;
                      P.r = f.r * N.r * I.r;
                      P.g = f.g * N.g * I.g;
                      P.b = f.b * N.b * I.b;
                      P.a = f.a * N.a * I.a;
                      q && ((P.r *= P.a), (P.g *= P.a), (P.b *= P.a));
                      var J = this.tempColor2;
                      null == H.darkColor
                        ? J.set(0, 0, 0, 1)
                        : (q
                            ? ((J.r = H.darkColor.r * P.a),
                              (J.g = H.darkColor.g * P.a),
                              (J.b = H.darkColor.b * P.a))
                            : J.setFromColor(H.darkColor),
                          (J.a = q ? 1 : 0));
                      I = H.data.blendMode;
                      I != u &&
                        ((u = I),
                        c.setBlendMode(
                          d.WebGLBlendModeConverter.getSourceGLBlendMode(u, q),
                          d.WebGLBlendModeConverter.getDestGLBlendMode(u)
                        ));
                      if (n.isClipping()) {
                        n.clipTriangles(
                          A.vertices,
                          A.numFloats,
                          K,
                          K.length,
                          M,
                          P,
                          J,
                          r
                        );
                        K = new Float32Array(n.clippedVertices);
                        M = n.clippedTriangles;
                        if (null != this.vertexEffect) {
                          var L = this.vertexEffect;
                          I = K;
                          if (r)
                            for (N = 0, P = K.length; N < P; N += D)
                              (v.x = I[N]),
                                (v.y = I[N + 1]),
                                y.set(I[N + 2], I[N + 3], I[N + 4], I[N + 5]),
                                (x.x = I[N + 6]),
                                (x.y = I[N + 7]),
                                z.set(I[N + 8], I[N + 9], I[N + 10], I[N + 11]),
                                L.transform(v, x, y, z),
                                (I[N] = v.x),
                                (I[N + 1] = v.y),
                                (I[N + 2] = y.r),
                                (I[N + 3] = y.g),
                                (I[N + 4] = y.b),
                                (I[N + 5] = y.a),
                                (I[N + 6] = x.x),
                                (I[N + 7] = x.y),
                                (I[N + 8] = z.r),
                                (I[N + 9] = z.g),
                                (I[N + 10] = z.b),
                                (I[N + 11] = z.a);
                          else
                            for (N = 0, P = K.length; N < P; N += D)
                              (v.x = I[N]),
                                (v.y = I[N + 1]),
                                y.set(I[N + 2], I[N + 3], I[N + 4], I[N + 5]),
                                (x.x = I[N + 6]),
                                (x.y = I[N + 7]),
                                z.set(0, 0, 0, 0),
                                L.transform(v, x, y, z),
                                (I[N] = v.x),
                                (I[N + 1] = v.y),
                                (I[N + 2] = y.r),
                                (I[N + 3] = y.g),
                                (I[N + 4] = y.b),
                                (I[N + 5] = y.a),
                                (I[N + 6] = x.x),
                                (I[N + 7] = x.y);
                        }
                        c.draw(G, K, M);
                      } else {
                        I = A.vertices;
                        if (null != this.vertexEffect)
                          if (((L = this.vertexEffect), r)) {
                            Q = N = 0;
                            for (var O = A.numFloats; N < O; N += D, Q += 2)
                              (v.x = I[N]),
                                (v.y = I[N + 1]),
                                (x.x = M[Q]),
                                (x.y = M[Q + 1]),
                                y.setFromColor(P),
                                z.setFromColor(J),
                                L.transform(v, x, y, z),
                                (I[N] = v.x),
                                (I[N + 1] = v.y),
                                (I[N + 2] = y.r),
                                (I[N + 3] = y.g),
                                (I[N + 4] = y.b),
                                (I[N + 5] = y.a),
                                (I[N + 6] = x.x),
                                (I[N + 7] = x.y),
                                (I[N + 8] = z.r),
                                (I[N + 9] = z.g),
                                (I[N + 10] = z.b),
                                (I[N + 11] = z.a);
                          } else {
                            var Q = (N = 0);
                            for (J = A.numFloats; N < J; N += D, Q += 2)
                              (v.x = I[N]),
                                (v.y = I[N + 1]),
                                (x.x = M[Q]),
                                (x.y = M[Q + 1]),
                                y.setFromColor(P),
                                z.set(0, 0, 0, 0),
                                L.transform(v, x, y, z),
                                (I[N] = v.x),
                                (I[N + 1] = v.y),
                                (I[N + 2] = y.r),
                                (I[N + 3] = y.g),
                                (I[N + 4] = y.b),
                                (I[N + 5] = y.a),
                                (I[N + 6] = x.x),
                                (I[N + 7] = x.y);
                          }
                        else if (r)
                          for (
                            N = 2, Q = 0, L = A.numFloats;
                            N < L;
                            N += D, Q += 2
                          )
                            (I[N] = P.r),
                              (I[N + 1] = P.g),
                              (I[N + 2] = P.b),
                              (I[N + 3] = P.a),
                              (I[N + 4] = M[Q]),
                              (I[N + 5] = M[Q + 1]),
                              (I[N + 6] = J.r),
                              (I[N + 7] = J.g),
                              (I[N + 8] = J.b),
                              (I[N + 9] = J.a);
                        else
                          for (
                            N = 2, Q = 0, L = A.numFloats;
                            N < L;
                            N += D, Q += 2
                          )
                            (I[N] = P.r),
                              (I[N + 1] = P.g),
                              (I[N + 2] = P.b),
                              (I[N + 3] = P.a),
                              (I[N + 4] = M[Q]),
                              (I[N + 5] = M[Q + 1]);
                        M = A.vertices.subarray(0, A.numFloats);
                        c.draw(G, M, K);
                      }
                    }
                  }
                  n.clipEndWithSlot(H);
                }
                n.clipEnd();
              };
              b.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
              return b;
            })();
          d.SkeletonRenderer = e;
        })(a.webgl || (a.webgl = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function () {
            function e(b, c, f) {
              void 0 === b && (b = 0);
              void 0 === c && (c = 0);
              void 0 === f && (f = 0);
              this.z = this.y = this.x = 0;
              this.x = b;
              this.y = c;
              this.z = f;
            }
            e.prototype.setFrom = function (b) {
              this.x = b.x;
              this.y = b.y;
              this.z = b.z;
              return this;
            };
            e.prototype.set = function (b, c, f) {
              this.x = b;
              this.y = c;
              this.z = f;
              return this;
            };
            e.prototype.add = function (b) {
              this.x += b.x;
              this.y += b.y;
              this.z += b.z;
              return this;
            };
            e.prototype.sub = function (b) {
              this.x -= b.x;
              this.y -= b.y;
              this.z -= b.z;
              return this;
            };
            e.prototype.scale = function (b) {
              this.x *= b;
              this.y *= b;
              this.z *= b;
              return this;
            };
            e.prototype.normalize = function () {
              var b = this.length();
              if (0 == b) return this;
              b = 1 / b;
              this.x *= b;
              this.y *= b;
              this.z *= b;
              return this;
            };
            e.prototype.cross = function (b) {
              return this.set(
                this.y * b.z - this.z * b.y,
                this.z * b.x - this.x * b.z,
                this.x * b.y - this.y * b.x
              );
            };
            e.prototype.multiply = function (b) {
              b = b.values;
              return this.set(
                this.x * b[d.M00] +
                  this.y * b[d.M01] +
                  this.z * b[d.M02] +
                  b[d.M03],
                this.x * b[d.M10] +
                  this.y * b[d.M11] +
                  this.z * b[d.M12] +
                  b[d.M13],
                this.x * b[d.M20] +
                  this.y * b[d.M21] +
                  this.z * b[d.M22] +
                  b[d.M23]
              );
            };
            e.prototype.project = function (b) {
              b = b.values;
              var c =
                1 /
                (this.x * b[d.M30] +
                  this.y * b[d.M31] +
                  this.z * b[d.M32] +
                  b[d.M33]);
              return this.set(
                (this.x * b[d.M00] +
                  this.y * b[d.M01] +
                  this.z * b[d.M02] +
                  b[d.M03]) *
                  c,
                (this.x * b[d.M10] +
                  this.y * b[d.M11] +
                  this.z * b[d.M12] +
                  b[d.M13]) *
                  c,
                (this.x * b[d.M20] +
                  this.y * b[d.M21] +
                  this.z * b[d.M22] +
                  b[d.M23]) *
                  c
              );
            };
            e.prototype.dot = function (b) {
              return this.x * b.x + this.y * b.y + this.z * b.z;
            };
            e.prototype.length = function () {
              return Math.sqrt(
                this.x * this.x + this.y * this.y + this.z * this.z
              );
            };
            e.prototype.distance = function (b) {
              var c = b.x - this.x,
                f = b.y - this.y;
              b = b.z - this.z;
              return Math.sqrt(c * c + f * f + b * b);
            };
            return e;
          })();
          d.Vector3 = k;
        })(a.webgl || (a.webgl = {}));
      })(t || (t = {}));
      (function (a) {
        (function (d) {
          var k = (function () {
            function e(b, c) {
              void 0 === c &&
                (c = {
                  alpha: "true",
                });
              this.restorables = [];
              b instanceof HTMLCanvasElement || b instanceof EventTarget
                ? this.setupCanvas(b, c)
                : ((this.gl = b), (this.canvas = this.gl.canvas));
            }
            e.prototype.setupCanvas = function (b, c) {
              var f = this;
              this.gl = b.getContext("webgl2", c) || b.getContext("webgl", c);
              this.canvas = b;
              b.addEventListener("webglcontextlost", function (g) {
                g && g.preventDefault();
              });
              b.addEventListener("webglcontextrestored", function (g) {
                g = 0;
                for (var m = f.restorables.length; g < m; g++)
                  f.restorables[g].restore();
              });
            };
            e.prototype.addRestorable = function (b) {
              this.restorables.push(b);
            };
            e.prototype.removeRestorable = function (b) {
              b = this.restorables.indexOf(b);
              -1 < b && this.restorables.splice(b, 1);
            };
            return e;
          })();
          d.ManagedWebGLRenderingContext = k;
          k = (function () {
            function e() {}
            e.getDestGLBlendMode = function (b) {
              switch (b) {
                case a.BlendMode.Normal:
                  return e.ONE_MINUS_SRC_ALPHA;
                case a.BlendMode.Additive:
                  return e.ONE;
                case a.BlendMode.Multiply:
                  return e.ONE_MINUS_SRC_ALPHA;
                case a.BlendMode.Screen:
                  return e.ONE_MINUS_SRC_ALPHA;
                default:
                  throw Error("Unknown blend mode: " + b);
              }
            };
            e.getSourceGLBlendMode = function (b, c) {
              void 0 === c && (c = !1);
              switch (b) {
                case a.BlendMode.Normal:
                  return c ? e.ONE : e.SRC_ALPHA;
                case a.BlendMode.Additive:
                  return c ? e.ONE : e.SRC_ALPHA;
                case a.BlendMode.Multiply:
                  return e.DST_COLOR;
                case a.BlendMode.Screen:
                  return e.ONE;
                default:
                  throw Error("Unknown blend mode: " + b);
              }
            };
            e.ZERO = 0;
            e.ONE = 1;
            e.SRC_COLOR = 768;
            e.ONE_MINUS_SRC_COLOR = 769;
            e.SRC_ALPHA = 770;
            e.ONE_MINUS_SRC_ALPHA = 771;
            e.DST_ALPHA = 772;
            e.ONE_MINUS_DST_ALPHA = 773;
            e.DST_COLOR = 774;
            return e;
          })();
          d.WebGLBlendModeConverter = k;
        })(a.webgl || (a.webgl = {}));
      })(t || (t = {}));
      l.exports = t;
    }).call(window);
  },
  function (l, w, h) {
    w = h(0);
    var t = h(11),
      a = h(204),
      d = h(7),
      k = h(218),
      e = h(219),
      b = h(220);
    h = new w({
      Extends: e,
      initialize: function (c, f, g, m, n, q, r) {
        var u = [],
          v = c.cacheManager.custom.spine;
        if (d(f))
          for (
            r = f,
              f = t(r, "key"),
              q = new k(c, {
                key: f,
                url: t(r, "jsonURL"),
                extension: t(r, "jsonExtension", "json"),
                xhrSettings: t(r, "jsonXhrSettings"),
              }),
              m = t(r, "atlasURL"),
              n = t(r, "preMultipliedAlpha"),
              Array.isArray(m) || (m = [m]),
              g = 0;
            g < m.length;
            g++
          ) {
            var x = new b(c, {
              key: f + "!" + g,
              url: m[g],
              extension: t(r, "atlasExtension", "atlas"),
              xhrSettings: t(r, "atlasXhrSettings"),
            });
            x.cache = v;
            u.push(x);
          }
        else
          for (
            q = new k(c, f, g, q), Array.isArray(m) || (m = [m]), g = 0;
            g < m.length;
            g++
          )
            (x = new b(c, f + "!" + g, m[g], r)), (x.cache = v), u.push(x);
        u.unshift(q);
        e.call(this, c, "spine", f, u);
        this.config.preMultipliedAlpha = n;
      },
      onFileComplete: function (c) {
        if (
          -1 !== this.files.indexOf(c) &&
          (this.pending--, "text" === c.type)
        ) {
          for (var f = c.data.split("\n"), g = [], m = 0; m < f.length; m++) {
            var n = f[m];
            "" === n.trim() && m < f.length - 1 && ((n = f[m + 1]), g.push(n));
          }
          var q = this.config;
          f = this.loader;
          m = f.baseURL;
          n = f.path;
          var r = f.prefix,
            u = t(q, "baseURL", this.baseURL),
            v = t(q, "path", c.src.match(/^.*\//))[0],
            x = t(q, "prefix", this.prefix);
          c = t(q, "textureXhrSettings");
          f.setBaseURL(u);
          f.setPath(v);
          f.setPrefix(x);
          for (u = 0; u < g.length; u++)
            (q = g[u]),
              (q = new a(f, q, q, c)),
              f.keyExists(q) || (this.addToMultiFile(q), f.addFile(q));
          f.setBaseURL(m);
          f.setPath(n);
          f.setPrefix(r);
        }
      },
      addToCache: function () {
        if (this.isReadyToProcess()) {
          this.files[0].addToCache();
          for (
            var c,
              f = "",
              g = "",
              m = this.config.preMultipliedAlpha ? !0 : !1,
              n = this.loader.textureManager,
              q = 1;
            q < this.files.length;
            q++
          ) {
            var r = this.files[q];
            if ("text" === r.type)
              (f = r.key.replace(/![\d]$/, "")),
                (c = r.cache),
                (g = g.concat(r.data));
            else {
              var u = r.key.trim(),
                v = u.indexOf("!");
              u = u.substr(v + 1);
              n.exists(u) || n.addImage(u, r.data);
            }
            r.pendingDestroy();
          }
          c.add(f, {
            preMultipliedAlpha: m,
            data: g,
            prefix: this.prefix,
          });
          this.complete = !0;
        }
      },
    });
    l.exports = h;
  },
  function (l, w, h) {
    w = h(0);
    var t = h(15),
      a = h(21),
      d = h(22),
      k = h(11),
      e = h(7),
      b = new w({
        Extends: a,
        initialize: function r(f, g, m, n, q) {
          var u = "png";
          if (e(g)) {
            q = g;
            g = k(q, "key");
            m = k(q, "url");
            var v = k(q, "normalMap");
            n = k(q, "xhrSettings");
            u = k(q, "extension", u);
            q = k(q, "frameConfig");
          }
          Array.isArray(m) && ((v = m[1]), (m = m[0]));
          a.call(this, f, {
            type: "image",
            cache: f.textureManager,
            extension: u,
            responseType: "blob",
            key: g,
            url: m,
            xhrSettings: n,
            config: q,
          });
          v &&
            ((g = new r(f, this.key, v, n, q)),
            (g.type = "normalMap"),
            this.setLink(g),
            f.addFile(g));
        },
        onProcess: function () {
          this.state = t.FILE_PROCESSING;
          this.data = new Image();
          this.data.crossOrigin = this.crossOrigin;
          var f = this;
          this.data.onload = function () {
            a.revokeObjectURL(f.data);
            f.onProcessComplete();
          };
          this.data.onerror = function () {
            a.revokeObjectURL(f.data);
            f.onProcessError();
          };
          a.createObjectURL(this.data, this.xhrLoader.response, "image/png");
        },
        addToCache: function () {
          var f = this.linkFile;
          if (f && f.state === t.FILE_COMPLETE) {
            var g =
              "image" === this.type
                ? this.cache.addImage(this.key, this.data, f.data)
                : this.cache.addImage(f.key, f.data, this.data);
            this.pendingDestroy(g);
            f.pendingDestroy(g);
          } else
            f ||
              ((g = this.cache.addImage(this.key, this.data)),
              this.pendingDestroy(g));
        },
      });
    d.register("image", function (f, g, m) {
      if (Array.isArray(f))
        for (g = 0; g < f.length; g++) this.addFile(new b(this, f[g]));
      else this.addFile(new b(this, f, g, m));
      return this;
    });
    l.exports = b;
  },
  function (l, w, h) {
    l.exports = {
      ADD: h(206),
      COMPLETE: h(207),
      FILE_COMPLETE: h(208),
      FILE_KEY_COMPLETE: h(209),
      FILE_LOAD_ERROR: h(210),
      FILE_LOAD: h(211),
      FILE_PROGRESS: h(212),
      POST_PROCESS: h(213),
      PROGRESS: h(214),
      START: h(215),
    };
  },
  function (l, w) {
    l.exports = "addfile";
  },
  function (l, w) {
    l.exports = "complete";
  },
  function (l, w) {
    l.exports = "filecomplete";
  },
  function (l, w) {
    l.exports = "filecomplete-";
  },
  function (l, w) {
    l.exports = "loaderror";
  },
  function (l, w) {
    l.exports = "load";
  },
  function (l, w) {
    l.exports = "fileprogress";
  },
  function (l, w) {
    l.exports = "postprocess";
  },
  function (l, w) {
    l.exports = "progress";
  },
  function (l, w) {
    l.exports = "start";
  },
  function (l, w) {
    l.exports = function (h, t) {
      return h.url
        ? h.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/)
          ? h.url
          : t + h.url
        : !1;
    };
  },
  function (l, w, h) {
    var t = h(45);
    l.exports = function (a, d) {
      d = t(d, a.xhrSettings);
      var k = new XMLHttpRequest();
      k.open("GET", a.src, d.async, d.user, d.password);
      k.responseType = a.xhrSettings.responseType;
      k.timeout = d.timeout;
      if (d.headers)
        for (var e in d.headers) k.setRequestHeader(e, d.headers[e]);
      d.header && d.headerValue && k.setRequestHeader(d.header, d.headerValue);
      d.requestedWith &&
        k.setRequestHeader("X-Requested-With", d.requestedWith);
      d.overrideMimeType && k.overrideMimeType(d.overrideMimeType);
      d.withCredentials && (k.withCredentials = !0);
      k.onload = a.onLoad.bind(a, k);
      k.onerror = a.onError.bind(a, k);
      k.onprogress = a.onProgress.bind(a);
      k.send();
      return k;
    };
  },
  function (l, w, h) {
    w = h(0);
    var t = h(15),
      a = h(21),
      d = h(22),
      k = h(11),
      e = h(10),
      b = h(7),
      c = new w({
        Extends: a,
        initialize: function (f, g, m, n, q) {
          var r = "json";
          if (b(g)) {
            var u = g;
            g = k(u, "key");
            m = k(u, "url");
            n = k(u, "xhrSettings");
            r = k(u, "extension", r);
            q = k(u, "dataKey", q);
          }
          a.call(this, f, {
            type: "json",
            cache: f.cacheManager.json,
            extension: r,
            responseType: "text",
            key: g,
            url: m,
            xhrSettings: n,
            config: q,
          });
          b(m) &&
            ((this.data = q ? e(m, q) : m), (this.state = t.FILE_POPULATED));
        },
        onProcess: function () {
          if (this.state !== t.FILE_POPULATED) {
            this.state = t.FILE_PROCESSING;
            try {
              var f = JSON.parse(this.xhrLoader.responseText);
            } catch (m) {
              throw (
                (console.warn("Invalid JSON: " + this.key),
                this.onProcessError(),
                m)
              );
            }
            var g = this.config;
            this.data = "string" === typeof g ? e(f, g, f) : f;
          }
          this.onProcessComplete();
        },
      });
    d.register("json", function (f, g, m, n) {
      if (Array.isArray(f))
        for (g = 0; g < f.length; g++) this.addFile(new c(this, f[g]));
      else this.addFile(new c(this, f, g, n, m));
      return this;
    });
    l.exports = c;
  },
  function (l, w, h) {
    w = new (h(0))({
      initialize: function (t, a, d, k) {
        var e = [];
        k.forEach(function (b) {
          b && e.push(b);
        });
        this.loader = t;
        this.type = a;
        this.key = d;
        this.multiKeyIndex = t.multiKeyIndex++;
        this.files = e;
        this.complete = !1;
        this.pending = e.length;
        this.failed = 0;
        this.config = {};
        this.baseURL = t.baseURL;
        this.path = t.path;
        this.prefix = t.prefix;
        for (t = 0; t < e.length; t++) e[t].multiFile = this;
      },
      isReadyToProcess: function () {
        return 0 === this.pending && 0 === this.failed && !this.complete;
      },
      addToMultiFile: function (t) {
        this.files.push(t);
        t.multiFile = this;
        this.pending++;
        this.complete = !1;
        return this;
      },
      onFileComplete: function (t) {
        -1 !== this.files.indexOf(t) && this.pending--;
      },
      onFileFailed: function (t) {
        -1 !== this.files.indexOf(t) && this.failed++;
      },
    });
    l.exports = w;
  },
  function (l, w, h) {
    w = h(0);
    var t = h(15),
      a = h(21),
      d = h(22),
      k = h(11),
      e = h(7),
      b = new w({
        Extends: a,
        initialize: function (c, f, g, m) {
          var n = "text",
            q = "txt",
            r = c.cacheManager.text;
          if (e(f)) {
            var u = f;
            f = k(u, "key");
            g = k(u, "url");
            m = k(u, "xhrSettings");
            q = k(u, "extension", q);
            n = k(u, "type", n);
            r = k(u, "cache", r);
          }
          a.call(this, c, {
            type: n,
            cache: r,
            extension: q,
            responseType: "text",
            key: f,
            url: g,
            xhrSettings: m,
          });
        },
        onProcess: function () {
          this.state = t.FILE_PROCESSING;
          this.data = this.xhrLoader.responseText;
          this.onProcessComplete();
        },
      });
    d.register("text", function (c, f, g) {
      if (Array.isArray(c))
        for (f = 0; f < c.length; f++) this.addFile(new b(this, c[f]));
      else this.addFile(new b(this, c, f, g));
      return this;
    });
    l.exports = b;
  },
  function (l, w, h) {
    var t = h(28),
      a = h(3);
    w = h(0);
    var d = h(47),
      k = h(48),
      e = h(49),
      b = h(50),
      c = h(51),
      f = h(52),
      g = h(8),
      m = h(19),
      n = h(53),
      q = h(9),
      r = h(243);
    h = h(250);
    h = new w({
      Extends: n,
      Mixins: [d, k, e, b, c, f, h],
      initialize: function (u, v, x, y, z, A, B) {
        n.call(this, u, "Spine");
        this.plugin = v;
        this.bounds =
          this.root =
          this.stateData =
          this.state =
          this.skeletonData =
          this.skeleton =
            null;
        this.drawDebug = !1;
        this.timeScale = 1;
        this.displayOriginY = this.displayOriginX = 0;
        this.preMultipliedAlpha = !1;
        this.blendMode = -1;
        this.setPosition(x, y);
        z && this.setSkeleton(z, A, B);
      },
      willRender: function (u, v) {
        u =
          !this.skeleton ||
          !(
            15 !== this.renderFlags ||
            (0 !== this.cameraFilter && this.cameraFilter & u.id)
          );
        if (!v && !u && this.parentContainer) {
          v = this.plugin;
          var x = v.sceneRenderer;
          v.gl &&
            x.batcher.isDrawing &&
            (x.end(), v.renderer.pipelines.rebind());
        }
        return u;
      },
      setAlpha: function (u, v) {
        void 0 === u && (u = 1);
        if (v) {
          if ((v = this.findSlot(v))) v.color.a = a(u, 0, 1);
        } else this.alpha = u;
        return this;
      },
      alpha: {
        get: function () {
          return this.skeleton.color.a;
        },
        set: function (u) {
          u = a(u, 0, 1);
          this.skeleton && (this.skeleton.color.a = u);
          this.renderFlags =
            0 === u ? this.renderFlags & -3 : this.renderFlags | 2;
        },
      },
      red: {
        get: function () {
          return this.skeleton.color.r;
        },
        set: function (u) {
          u = a(u, 0, 1);
          this.skeleton && (this.skeleton.color.r = u);
        },
      },
      green: {
        get: function () {
          return this.skeleton.color.g;
        },
        set: function (u) {
          u = a(u, 0, 1);
          this.skeleton && (this.skeleton.color.g = u);
        },
      },
      blue: {
        get: function () {
          return this.skeleton.color.b;
        },
        set: function (u) {
          u = a(u, 0, 1);
          this.skeleton && (this.skeleton.color.b = u);
        },
      },
      setColor: function (u, v) {
        void 0 === u && (u = 16777215);
        var x = ((u >> 16) & 255) / 255,
          y = ((u >> 8) & 255) / 255,
          z = (u & 255) / 255;
        u = 16777215 < u ? (u >>> 24) / 255 : null;
        var A = this.skeleton;
        v && (v = this.findSlot(v)) && (A = v);
        A.color.r = x;
        A.color.g = y;
        A.color.b = z;
        null !== u && (A.color.a = u);
        return this;
      },
      setSkeletonFromJSON: function (u, v, x, y) {
        return this.setSkeleton(u, v, x, y);
      },
      setSkeleton: function (u, v, x, y) {
        this.state &&
          (this.state.clearListeners(),
          this.state.clearListenerNotifications());
        u = this.plugin.createSkeleton(u, y);
        this.skeletonData = u.skeletonData;
        this.preMultipliedAlpha = u.preMultipliedAlpha;
        y = u.skeleton;
        y.setSkin();
        y.setToSetupPose();
        this.skeleton = y;
        u = this.plugin.createAnimationState(y);
        this.state &&
          (this.state.clearListeners(),
          this.state.clearListenerNotifications());
        this.state = u.state;
        this.stateData = u.stateData;
        this.state.addListener({
          event: this.onEvent.bind(this),
          complete: this.onComplete.bind(this),
          start: this.onStart.bind(this),
          end: this.onEnd.bind(this),
          dispose: this.onDispose.bind(this),
          interrupted: this.onInterrupted.bind(this),
        });
        v && this.setAnimation(0, v, x);
        if ((this.root = this.getRootBone()))
          this.root.rotation = q(g(this.rotation)) + 90;
        this.state.apply(y);
        y.updateCache();
        return this.updateSize();
      },
      onComplete: function (u) {
        this.emit(r.COMPLETE, u);
      },
      onDispose: function (u) {
        this.emit(r.DISPOSE, u);
      },
      onEnd: function (u) {
        this.emit(r.END, u);
      },
      onEvent: function (u, v) {
        this.emit(r.EVENT, u, v);
      },
      onInterrupted: function (u) {
        this.emit(r.INTERRUPTED, u);
      },
      onStart: function (u) {
        this.emit(r.START, u);
      },
      refresh: function () {
        this.root && (this.root.rotation = q(g(this.rotation)) + 90);
        this.updateSize();
        this.skeleton.updateCache();
        return this;
      },
      setSize: function (u, v, x, y) {
        var z = this.skeleton;
        void 0 === u && (u = z.data.width);
        void 0 === v && (v = z.data.height);
        void 0 === x && (x = 0);
        void 0 === y && (y = 0);
        this.width = u;
        this.height = v;
        this.displayOriginX = z.x - x;
        this.displayOriginY = z.y - y;
        return this;
      },
      setOffset: function (u, v) {
        var x = this.skeleton;
        void 0 === u && (u = 0);
        void 0 === v && (v = 0);
        this.displayOriginX = x.x - u;
        this.displayOriginY = x.y - v;
        return this;
      },
      updateSize: function () {
        var u = this.skeleton,
          v = this.plugin.renderer.height,
          x = this.scaleX,
          y = this.scaleY;
        u.x = this.x;
        u.y = v - this.y;
        u.scaleX = 1;
        u.scaleY = 1;
        u.updateWorldTransform();
        var z = this.getBounds();
        this.width = z.size.x;
        this.height = z.size.y;
        this.displayOriginX = this.x - z.offset.x;
        this.displayOriginY = this.y - (v - (this.height + z.offset.y));
        u.scaleX = x;
        u.scaleY = y;
        u.updateWorldTransform();
        return this;
      },
      scaleX: {
        get: function () {
          return this._scaleX;
        },
        set: function (u) {
          this._scaleX = u;
          this.refresh();
        },
      },
      scaleY: {
        get: function () {
          return this._scaleY;
        },
        set: function (u) {
          this._scaleY = u;
          this.refresh();
        },
      },
      getBoneList: function () {
        var u = [],
          v = this.skeletonData;
        if (v) for (var x = 0; x < v.bones.length; x++) u.push(v.bones[x].name);
        return u;
      },
      getSkinList: function () {
        var u = [],
          v = this.skeletonData;
        if (v) for (var x = 0; x < v.skins.length; x++) u.push(v.skins[x].name);
        return u;
      },
      getSlotList: function () {
        for (var u = [], v = this.skeleton, x = 0; x < v.slots.length; x++)
          u.push(v.slots[x].data.name);
        return u;
      },
      getAnimationList: function () {
        var u = [],
          v = this.skeletonData;
        if (v)
          for (var x = 0; x < v.animations.length; x++)
            u.push(v.animations[x].name);
        return u;
      },
      getCurrentAnimation: function (u) {
        void 0 === u && (u = 0);
        if ((u = this.state.getCurrent(u))) return u.animation;
      },
      play: function (u, v, x) {
        this.setAnimation(0, u, v, x);
        return this;
      },
      setAnimation: function (u, v, x, y) {
        void 0 === x && (x = !1);
        void 0 === y && (y = !1);
        if (
          y &&
          this.state &&
          (y = this.state.getCurrent(u)) &&
          y.animation.name === v &&
          !y.isComplete()
        )
          return;
        if (this.findAnimation(v)) return this.state.setAnimation(u, v, x);
      },
      addAnimation: function (u, v, x, y) {
        void 0 === x && (x = !1);
        void 0 === y && (y = 0);
        return this.state.addAnimation(u, v, x, y);
      },
      setEmptyAnimation: function (u, v) {
        return this.state.setEmptyAnimation(u, v);
      },
      clearTrack: function (u) {
        this.state.clearTrack(u);
        return this;
      },
      clearTracks: function () {
        this.state.clearTracks();
        return this;
      },
      setSkinByName: function (u) {
        var v = this.skeleton;
        v.setSkinByName(u);
        v.setSlotsToSetupPose();
        this.state.apply(v);
        return this;
      },
      setSkin: function (u) {
        var v = this.skeleton;
        v.setSkin(u);
        v.setSlotsToSetupPose();
        this.state.apply(v);
        return this;
      },
      setMix: function (u, v, x) {
        this.stateData.setMix(u, v, x);
        return this;
      },
      getAttachment: function (u, v) {
        return this.skeleton.getAttachment(u, v);
      },
      getAttachmentByName: function (u, v) {
        return this.skeleton.getAttachmentByName(u, v);
      },
      setAttachment: function (u, v) {
        if (Array.isArray(u) && Array.isArray(v) && u.length === v.length)
          for (var x = 0; x < u.length; x++)
            this.skeleton.setAttachment(u[x], v[x]);
        else this.skeleton.setAttachment(u, v);
        return this;
      },
      setToSetupPose: function () {
        this.skeleton.setToSetupPose();
        return this;
      },
      setSlotsToSetupPose: function () {
        this.skeleton.setSlotsToSetupPose();
        return this;
      },
      setBonesToSetupPose: function () {
        this.skeleton.setBonesToSetupPose();
        return this;
      },
      getRootBone: function () {
        return this.skeleton.getRootBone();
      },
      angleBoneToXY: function (u, v, x, y, z, A) {
        void 0 === y && (y = 0);
        void 0 === z && (z = 0);
        void 0 === A && (A = 360);
        v = g(t(u.worldX, this.plugin.renderer.height - u.worldY, v, x) + m(y));
        u.rotation = a(q(v), z, A);
        return this;
      },
      findBone: function (u) {
        return this.skeleton.findBone(u);
      },
      findBoneIndex: function (u) {
        return this.skeleton.findBoneIndex(u);
      },
      findSlot: function (u) {
        return this.skeleton.findSlot(u);
      },
      findSlotIndex: function (u) {
        return this.skeleton.findSlotIndex(u);
      },
      findSkin: function (u) {
        return this.skeletonData.findSkin(u);
      },
      findEvent: function (u) {
        return this.skeletonData.findEvent(u);
      },
      findAnimation: function (u) {
        return this.skeletonData.findAnimation(u);
      },
      findIkConstraint: function (u) {
        return this.skeletonData.findIkConstraint(u);
      },
      findTransformConstraint: function (u) {
        return this.skeletonData.findTransformConstraint(u);
      },
      findPathConstraint: function (u) {
        return this.skeletonData.findPathConstraint(u);
      },
      findPathConstraintIndex: function (u) {
        return this.skeletonData.findPathConstraintIndex(u);
      },
      getBounds: function () {
        return this.plugin.getBounds(this.skeleton);
      },
      preUpdate: function (u, v) {
        u = this.skeleton;
        this.state.update((v / 1e3) * this.timeScale);
        this.state.apply(u);
      },
      preDestroy: function () {
        this.state &&
          (this.state.clearListeners(),
          this.state.clearListenerNotifications());
        this.stateData =
          this.state =
          this.skeletonData =
          this.skeleton =
          this.plugin =
            null;
      },
    });
    l.exports = h;
  },
  function (l, w, h) {
    w = h(0);
    var t = h(223);
    h = new w({
      initialize: function (a, d) {
        this.parent = a;
        this.events = d;
        d || (this.events = a.events ? a.events : a);
        this.list = {};
        this.values = {};
        this._frozen = !1;
        if (!a.hasOwnProperty("sys") && this.events)
          this.events.once(t.DESTROY, this.destroy, this);
      },
      get: function (a) {
        var d = this.list;
        if (Array.isArray(a)) {
          for (var k = [], e = 0; e < a.length; e++) k.push(d[a[e]]);
          return k;
        }
        return d[a];
      },
      getAll: function () {
        var a = {},
          d;
        for (d in this.list)
          this.list.hasOwnProperty(d) && (a[d] = this.list[d]);
        return a;
      },
      query: function (a) {
        var d = {},
          k;
        for (k in this.list)
          this.list.hasOwnProperty(k) && k.match(a) && (d[k] = this.list[k]);
        return d;
      },
      set: function (a, d) {
        if (this._frozen) return this;
        if ("string" === typeof a) return this.setValue(a, d);
        for (var k in a) this.setValue(k, a[k]);
        return this;
      },
      inc: function (a, d) {
        if (this._frozen) return this;
        void 0 === d && (d = 1);
        var k = this.get(a);
        void 0 === k && (k = 0);
        this.set(a, k + d);
        return this;
      },
      toggle: function (a) {
        if (this._frozen) return this;
        this.set(a, !this.get(a));
        return this;
      },
      setValue: function (a, d) {
        if (this._frozen) return this;
        if (this.has(a)) this.values[a] = d;
        else {
          var k = this,
            e = this.list,
            b = this.events,
            c = this.parent;
          Object.defineProperty(this.values, a, {
            enumerable: !0,
            configurable: !0,
            get: function () {
              return e[a];
            },
            set: function (f) {
              if (!k._frozen) {
                var g = e[a];
                e[a] = f;
                b.emit(t.CHANGE_DATA, c, a, f, g);
                b.emit(t.CHANGE_DATA_KEY + a, c, f, g);
              }
            },
          });
          e[a] = d;
          b.emit(t.SET_DATA, c, a, d);
        }
        return this;
      },
      each: function (a, d) {
        for (
          var k = [this.parent, null, void 0], e = 1;
          e < arguments.length;
          e++
        )
          k.push(arguments[e]);
        for (var b in this.list)
          (k[1] = b), (k[2] = this.list[b]), a.apply(d, k);
        return this;
      },
      merge: function (a, d) {
        void 0 === d && (d = !0);
        for (var k in a)
          a.hasOwnProperty(k) &&
            (d || (!d && !this.has(k))) &&
            this.setValue(k, a[k]);
        return this;
      },
      remove: function (a) {
        if (this._frozen) return this;
        if (Array.isArray(a))
          for (var d = 0; d < a.length; d++) this.removeValue(a[d]);
        else return this.removeValue(a);
        return this;
      },
      removeValue: function (a) {
        if (this.has(a)) {
          var d = this.list[a];
          delete this.list[a];
          delete this.values[a];
          this.events.emit(t.REMOVE_DATA, this.parent, a, d);
        }
        return this;
      },
      pop: function (a) {
        var d = void 0;
        !this._frozen &&
          this.has(a) &&
          ((d = this.list[a]),
          delete this.list[a],
          delete this.values[a],
          this.events.emit(t.REMOVE_DATA, this.parent, a, d));
        return d;
      },
      has: function (a) {
        return this.list.hasOwnProperty(a);
      },
      setFreeze: function (a) {
        this._frozen = a;
        return this;
      },
      reset: function () {
        for (var a in this.list) delete this.list[a], delete this.values[a];
        this._frozen = !1;
        return this;
      },
      destroy: function () {
        this.reset();
        this.events.off(t.CHANGE_DATA);
        this.events.off(t.SET_DATA);
        this.events.off(t.REMOVE_DATA);
        this.parent = null;
      },
      freeze: {
        get: function () {
          return this._frozen;
        },
        set: function (a) {
          this._frozen = a ? !0 : !1;
        },
      },
      count: {
        get: function () {
          var a = 0,
            d;
          for (d in this.list) void 0 !== this.list[d] && a++;
          return a;
        },
      },
    });
    l.exports = h;
  },
  function (l, w, h) {
    l.exports = {
      CHANGE_DATA: h(224),
      CHANGE_DATA_KEY: h(225),
      DESTROY: h(226),
      REMOVE_DATA: h(227),
      SET_DATA: h(228),
    };
  },
  function (l, w) {
    l.exports = "changedata";
  },
  function (l, w) {
    l.exports = "changedata-";
  },
  function (l, w) {
    l.exports = "destroy";
  },
  function (l, w) {
    l.exports = "removedata";
  },
  function (l, w) {
    l.exports = "setdata";
  },
  function (l, w, h) {
    function t() {}

    function a(f, g, m) {
      this.fn = f;
      this.context = g;
      this.once = m || !1;
    }

    function d(f, g, m, n, q) {
      if ("function" !== typeof m)
        throw new TypeError("The listener must be a function");
      m = new a(m, n || f, q);
      g = c ? c + g : g;
      f._events[g]
        ? f._events[g].fn
          ? (f._events[g] = [f._events[g], m])
          : f._events[g].push(m)
        : ((f._events[g] = m), f._eventsCount++);
      return f;
    }

    function k(f, g) {
      0 === --f._eventsCount ? (f._events = new t()) : delete f._events[g];
    }

    function e() {
      this._events = new t();
      this._eventsCount = 0;
    }
    var b = Object.prototype.hasOwnProperty,
      c = "~";
    Object.create &&
      ((t.prototype = Object.create(null)), new t().__proto__ || (c = !1));
    e.prototype.eventNames = function () {
      var f = [],
        g,
        m;
      if (0 === this._eventsCount) return f;
      for (m in (g = this._events)) b.call(g, m) && f.push(c ? m.slice(1) : m);
      return Object.getOwnPropertySymbols
        ? f.concat(Object.getOwnPropertySymbols(g))
        : f;
    };
    e.prototype.listeners = function (f) {
      f = this._events[c ? c + f : f];
      if (!f) return [];
      if (f.fn) return [f.fn];
      for (var g = 0, m = f.length, n = Array(m); g < m; g++) n[g] = f[g].fn;
      return n;
    };
    e.prototype.listenerCount = function (f) {
      return (f = this._events[c ? c + f : f]) ? (f.fn ? 1 : f.length) : 0;
    };
    e.prototype.emit = function (f, g, m, n, q, r) {
      var u = c ? c + f : f;
      if (!this._events[u]) return !1;
      u = this._events[u];
      var v = arguments.length,
        x;
      if (u.fn) {
        u.once && this.removeListener(f, u.fn, void 0, !0);
        switch (v) {
          case 1:
            return u.fn.call(u.context), !0;
          case 2:
            return u.fn.call(u.context, g), !0;
          case 3:
            return u.fn.call(u.context, g, m), !0;
          case 4:
            return u.fn.call(u.context, g, m, n), !0;
          case 5:
            return u.fn.call(u.context, g, m, n, q), !0;
          case 6:
            return u.fn.call(u.context, g, m, n, q, r), !0;
        }
        var y = 1;
        for (x = Array(v - 1); y < v; y++) x[y - 1] = arguments[y];
        u.fn.apply(u.context, x);
      } else {
        var z = u.length;
        for (y = 0; y < z; y++)
          switch (
            (u[y].once && this.removeListener(f, u[y].fn, void 0, !0), v)
          ) {
            case 1:
              u[y].fn.call(u[y].context);
              break;
            case 2:
              u[y].fn.call(u[y].context, g);
              break;
            case 3:
              u[y].fn.call(u[y].context, g, m);
              break;
            case 4:
              u[y].fn.call(u[y].context, g, m, n);
              break;
            default:
              if (!x) {
                var A = 1;
                for (x = Array(v - 1); A < v; A++) x[A - 1] = arguments[A];
              }
              u[y].fn.apply(u[y].context, x);
          }
      }
      return !0;
    };
    e.prototype.on = function (f, g, m) {
      return d(this, f, g, m, !1);
    };
    e.prototype.once = function (f, g, m) {
      return d(this, f, g, m, !0);
    };
    e.prototype.removeListener = function (f, g, m, n) {
      f = c ? c + f : f;
      if (!this._events[f]) return this;
      if (!g) return k(this, f), this;
      var q = this._events[f];
      if (q.fn)
        q.fn !== g || (n && !q.once) || (m && q.context !== m) || k(this, f);
      else {
        for (var r = 0, u = [], v = q.length; r < v; r++)
          (q[r].fn !== g || (n && !q[r].once) || (m && q[r].context !== m)) &&
            u.push(q[r]);
        u.length ? (this._events[f] = 1 === u.length ? u[0] : u) : k(this, f);
      }
      return this;
    };
    e.prototype.removeAllListeners = function (f) {
      f
        ? ((f = c ? c + f : f), this._events[f] && k(this, f))
        : ((this._events = new t()), (this._eventsCount = 0));
      return this;
    };
    e.prototype.off = e.prototype.removeListener;
    e.prototype.addListener = e.prototype.on;
    e.prefixed = c;
    e.EventEmitter = e;
    l.exports = e;
  },
  function (l, w) {
    l.exports = "addedtoscene";
  },
  function (l, w) {
    l.exports = "destroy";
  },
  function (l, w) {
    l.exports = "removedfromscene";
  },
  function (l, w) {
    l.exports = "complete";
  },
  function (l, w) {
    l.exports = "created";
  },
  function (l, w) {
    l.exports = "error";
  },
  function (l, w) {
    l.exports = "loop";
  },
  function (l, w) {
    l.exports = "play";
  },
  function (l, w) {
    l.exports = "seeked";
  },
  function (l, w) {
    l.exports = "seeking";
  },
  function (l, w) {
    l.exports = "stop";
  },
  function (l, w) {
    l.exports = "timeout";
  },
  function (l, w) {
    l.exports = "unlocked";
  },
  function (l, w, h) {
    l.exports = {
      COMPLETE: h(244),
      DISPOSE: h(245),
      END: h(246),
      EVENT: h(247),
      INTERRUPTED: h(248),
      START: h(249),
    };
  },
  function (l, w) {
    l.exports = "complete";
  },
  function (l, w) {
    l.exports = "dispose";
  },
  function (l, w) {
    l.exports = "end";
  },
  function (l, w) {
    l.exports = "event";
  },
  function (l, w) {
    l.exports = "interrupted";
  },
  function (l, w) {
    l.exports = "start";
  },
  function (l, w, h) {
    h(1);
    h(1);
    h(1);
    w = h(251);
    var t = h(252);
    h = h(253);
    l.exports = {
      renderWebGL: w,
      renderCanvas: h,
      renderDirect: t,
    };
  },
  function (l, w, h) {
    var t = h(3),
      a = h(8),
      d = h(56),
      k = h(9),
      e = h(6);
    l.exports = function (b, c, f, g, m) {
      var n = c.plugin,
        q = c.skeleton,
        r = n.sceneRenderer;
      b.newType && (b.pipelines.clear(), r.begin());
      var u = c.scrollFactorX,
        v = c.scrollFactorY,
        x = q.color.a;
      m &&
        ((c.scrollFactorX = m.scrollFactorX),
        (c.scrollFactorY = m.scrollFactorY),
        (q.color.a = t(x * m.alpha, 0, 1)));
      f.addToRenderList(c);
      f = d(c, f, g).calc;
      g = b.height;
      q.x = f.tx;
      q.y = g - f.ty;
      q.scaleX = f.scaleX;
      q.scaleY = f.scaleY;
      0 > c.scaleX
        ? ((q.scaleX *= -1),
          (c.root.rotation = e(k(f.rotationNormalized) - 180, 0, 360)))
        : (c.root.rotation = e(k(a(f.rotationNormalized)) + 90, 0, 360));
      0 > c.scaleY &&
        ((q.scaleY *= -1),
        (c.root.rotation =
          0 > c.scaleX
            ? c.root.rotation - 2 * k(f.rotationNormalized)
            : c.root.rotation + 2 * k(f.rotationNormalized)));
      q.updateWorldTransform();
      r.drawSkeleton(q, c.preMultipliedAlpha);
      m && ((c.scrollFactorX = u), (c.scrollFactorY = v), (q.color.a = x));
      if (n.drawDebug || c.drawDebug)
        (m = q.x),
          (n = q.y),
          (q.x = 0),
          (q.y = 0),
          r.drawSkeletonDebug(q, c.preMultipliedAlpha),
          (q.x = m),
          (q.y = n);
      b.nextTypeMatch || (r.end(), b.pipelines.rebind());
    };
  },
  function (l, w, h) {
    var t = h(3),
      a = h(8),
      d = h(56),
      k = h(9),
      e = h(6);
    l.exports = function (b, c, f, g, m) {
      var n = c.plugin,
        q = c.skeleton,
        r = n.sceneRenderer;
      b.pipelines.clear();
      r.begin();
      var u = c.scrollFactorX,
        v = c.scrollFactorY,
        x = q.color.a;
      m &&
        ((c.scrollFactorX = m.scrollFactorX),
        (c.scrollFactorY = m.scrollFactorY),
        (q.color.a = t(x * m.alpha, 0, 1)));
      f.addToRenderList(c);
      f = d(c, f, g).calc;
      g = b.height;
      q.x = f.tx;
      q.y = g - f.ty;
      q.scaleX = f.scaleX;
      q.scaleY = f.scaleY;
      0 > c.scaleX
        ? ((q.scaleX *= -1),
          (c.root.rotation = e(k(f.rotationNormalized) - 180, 0, 360)))
        : (c.root.rotation = e(k(a(f.rotationNormalized)) + 90, 0, 360));
      0 > c.scaleY &&
        ((q.scaleY *= -1),
        (c.root.rotation =
          0 > c.scaleX
            ? c.root.rotation - 2 * k(f.rotationNormalized)
            : c.root.rotation + 2 * k(f.rotationNormalized)));
      q.updateWorldTransform();
      r.drawSkeleton(q, c.preMultipliedAlpha);
      m && ((c.scrollFactorX = u), (c.scrollFactorY = v), (q.color.a = x));
      if (n.drawDebug || c.drawDebug)
        (m = q.x),
          (n = q.y),
          (q.x = 0),
          (q.y = 0),
          r.drawSkeletonDebug(q, c.preMultipliedAlpha),
          (q.x = m),
          (q.y = n);
      r.end();
      b.pipelines.rebind();
    };
  },
  function (l, w, h) {
    var t = h(8),
      a = h(9),
      d = h(6);
    l.exports = function (k, e, b, c) {
      var f = k.currentContext,
        g = e.plugin,
        m = e.skeleton,
        n = g.skeletonRenderer,
        q = k._tempMatrix1,
        r = k._tempMatrix2;
      k = k._tempMatrix3;
      b.addToRenderList(e);
      r.applyITRS(e.x, e.y, e.rotation, Math.abs(e.scaleX), Math.abs(e.scaleY));
      q.copyFrom(b.matrix);
      c
        ? (q.multiplyWithOffset(
            c,
            -b.scrollX * e.scrollFactorX,
            -b.scrollY * e.scrollFactorY
          ),
          (r.e = e.x),
          (r.f = e.y))
        : ((r.e -= b.scrollX * e.scrollFactorX),
          (r.f -= b.scrollY * e.scrollFactorY));
      q.multiply(r, k);
      m.x = k.tx;
      m.y = k.ty;
      m.scaleX = k.scaleX;
      m.scaleY = -1 * k.scaleY;
      0 > e.scaleX
        ? ((m.scaleX *= -1), (e.root.rotation = a(k.rotationNormalized)))
        : (e.root.rotation = d(a(t(k.rotationNormalized)) + 90, 0, 360));
      0 > e.scaleY &&
        ((m.scaleY *= -1),
        (e.root.rotation =
          0 > e.scaleX
            ? e.root.rotation - 2 * a(k.rotationNormalized)
            : e.root.rotation + 2 * a(k.rotationNormalized)));
      b.renderToTexture && ((m.y = k.ty), (m.scaleY *= -1));
      m.updateWorldTransform();
      n.ctx = f;
      n.debugRendering = g.drawDebug || e.drawDebug;
      f.save();
      n.draw(m);
      f.restore();
    };
  },
  function (l, w, h) {
    w = h(0);
    var t = h(255);
    h = h(347);
    h = new w({
      Extends: t,
      Mixins: [h],
      initialize: function (a, d, k, e, b) {
        t.call(this, a, k, e, b);
        this.type = "Spine";
        this.plugin = d;
      },
      preDestroy: function () {
        this.removeAll(!!this.exclusive);
        this.localTransform.destroy();
        this.tempTransformMatrix.destroy();
        this.list = [];
        this.plugin = this._displayList = null;
      },
    });
    l.exports = h;
  },
  function (l, w, h) {
    var t = h(256),
      a = h(17);
    w = h(0);
    var d = h(293),
      k = h(55),
      e = h(53),
      b = h(25),
      c = h(343),
      f = h(346),
      g = h(2);
    h = new w({
      Extends: e,
      Mixins: [
        d.AlphaSingle,
        d.BlendMode,
        d.ComputedSize,
        d.Depth,
        d.Mask,
        d.Pipeline,
        d.Transform,
        d.Visible,
        c,
      ],
      initialize: function (m, n, q, r) {
        e.call(this, m, "Container");
        this.list = [];
        this.exclusive = !0;
        this.maxSize = -1;
        this.position = 0;
        this.localTransform = new d.TransformMatrix();
        this.tempTransformMatrix = new d.TransformMatrix();
        this._sortKey = "";
        this._sysEvents = m.sys.events;
        this.scrollFactorY = this.scrollFactorX = 1;
        this.initPipeline();
        this.setPosition(n, q);
        this.clearAlpha();
        this.setBlendMode(a.SKIP_CHECK);
        r && this.add(r);
      },
      originX: {
        get: function () {
          return 0.5;
        },
      },
      originY: {
        get: function () {
          return 0.5;
        },
      },
      displayOriginX: {
        get: function () {
          return 0.5 * this.width;
        },
      },
      displayOriginY: {
        get: function () {
          return 0.5 * this.height;
        },
      },
      setExclusive: function (m) {
        void 0 === m && (m = !0);
        this.exclusive = m;
        return this;
      },
      getBounds: function (m) {
        void 0 === m && (m = new b());
        m.setTo(this.x, this.y, 0, 0);
        if (this.parentContainer) {
          var n = this.parentContainer
            .getBoundsTransformMatrix()
            .transformPoint(this.x, this.y);
          m.setTo(n.x, n.y, 0, 0);
        }
        if (0 < this.list.length) {
          n = this.list;
          var q = new b(),
            r = !1;
          m.setEmpty();
          for (var u = 0; u < n.length; u++) {
            var v = n[u];
            v.getBounds &&
              (v.getBounds(q),
              r
                ? f(q, m, m)
                : (m.setTo(q.x, q.y, q.width, q.height), (r = !0)));
          }
        }
        return m;
      },
      addHandler: function (m) {
        m.once(k.DESTROY, this.remove, this);
        this.exclusive &&
          (m.parentContainer && m.parentContainer.remove(m),
          m.removeFromDisplayList(),
          (m.parentContainer = this));
      },
      removeHandler: function (m) {
        m.off(k.DESTROY, this.remove);
        this.exclusive && ((m.parentContainer = null), m.addToDisplayList());
      },
      pointToContainer: function (m, n) {
        void 0 === n && (n = new g());
        this.parentContainer
          ? this.parentContainer.pointToContainer(m, n)
          : (n = new g(m.x, m.y));
        var q = this.tempTransformMatrix;
        q.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY);
        q.invert();
        q.transformPoint(m.x, m.y, n);
        return n;
      },
      getBoundsTransformMatrix: function () {
        return this.getWorldTransformMatrix(
          this.tempTransformMatrix,
          this.localTransform
        );
      },
      add: function (m) {
        t.Add(this.list, m, this.maxSize, this.addHandler, this);
        return this;
      },
      addAt: function (m, n) {
        t.AddAt(this.list, m, n, this.maxSize, this.addHandler, this);
        return this;
      },
      getAt: function (m) {
        return this.list[m];
      },
      getIndex: function (m) {
        return this.list.indexOf(m);
      },
      sort: function (m, n) {
        if (!m) return this;
        void 0 === n &&
          (n = function (q, r) {
            return q[m] - r[m];
          });
        t.StableSort(this.list, n);
        return this;
      },
      getByName: function (m) {
        return t.GetFirst(this.list, "name", m);
      },
      getRandom: function (m, n) {
        return t.GetRandom(this.list, m, n);
      },
      getFirst: function (m, n, q, r) {
        return t.GetFirst(this.list, m, n, q, r);
      },
      getAll: function (m, n, q, r) {
        return t.GetAll(this.list, m, n, q, r);
      },
      count: function (m, n, q, r) {
        return t.CountAllMatching(this.list, m, n, q, r);
      },
      swap: function (m, n) {
        t.Swap(this.list, m, n);
        return this;
      },
      moveTo: function (m, n) {
        t.MoveTo(this.list, m, n);
        return this;
      },
      remove: function (m, n) {
        m = t.Remove(this.list, m, this.removeHandler, this);
        if (n && m)
          for (Array.isArray(m) || (m = [m]), n = 0; n < m.length; n++)
            m[n].destroy();
        return this;
      },
      removeAt: function (m, n) {
        m = t.RemoveAt(this.list, m, this.removeHandler, this);
        n && m && m.destroy();
        return this;
      },
      removeBetween: function (m, n, q) {
        m = t.RemoveBetween(this.list, m, n, this.removeHandler, this);
        if (q) for (q = 0; q < m.length; q++) m[q].destroy();
        return this;
      },
      removeAll: function (m) {
        var n = t.RemoveBetween(
          this.list,
          0,
          this.list.length,
          this.removeHandler,
          this
        );
        if (m) for (m = 0; m < n.length; m++) n[m].destroy();
        return this;
      },
      bringToTop: function (m) {
        t.BringToTop(this.list, m);
        return this;
      },
      sendToBack: function (m) {
        t.SendToBack(this.list, m);
        return this;
      },
      moveUp: function (m) {
        t.MoveUp(this.list, m);
        return this;
      },
      moveDown: function (m) {
        t.MoveDown(this.list, m);
        return this;
      },
      reverse: function () {
        this.list.reverse();
        return this;
      },
      shuffle: function () {
        t.Shuffle(this.list);
        return this;
      },
      replace: function (m, n, q) {
        t.Replace(this.list, m, n) &&
          (this.addHandler(n), this.removeHandler(m), q && m.destroy());
        return this;
      },
      exists: function (m) {
        return -1 < this.list.indexOf(m);
      },
      setAll: function (m, n, q, r) {
        t.SetAll(this.list, m, n, q, r);
        return this;
      },
      each: function (m, n) {
        var q = [null],
          r,
          u = this.list.slice(),
          v = u.length;
        for (r = 2; r < arguments.length; r++) q.push(arguments[r]);
        for (r = 0; r < v; r++) (q[0] = u[r]), m.apply(n, q);
        return this;
      },
      iterate: function (m, n) {
        var q = [null],
          r;
        for (r = 2; r < arguments.length; r++) q.push(arguments[r]);
        for (r = 0; r < this.list.length; r++)
          (q[0] = this.list[r]), m.apply(n, q);
        return this;
      },
      setScrollFactor: function (m, n, q) {
        void 0 === n && (n = m);
        void 0 === q && (q = !1);
        this.scrollFactorX = m;
        this.scrollFactorY = n;
        q &&
          (t.SetAll(this.list, "scrollFactorX", m),
          t.SetAll(this.list, "scrollFactorY", n));
        return this;
      },
      length: {
        get: function () {
          return this.list.length;
        },
      },
      first: {
        get: function () {
          this.position = 0;
          return 0 < this.list.length ? this.list[0] : null;
        },
      },
      last: {
        get: function () {
          return 0 < this.list.length
            ? ((this.position = this.list.length - 1), this.list[this.position])
            : null;
        },
      },
      next: {
        get: function () {
          return this.position < this.list.length
            ? (this.position++, this.list[this.position])
            : null;
        },
      },
      previous: {
        get: function () {
          return 0 < this.position
            ? (this.position--, this.list[this.position])
            : null;
        },
      },
      preDestroy: function () {
        this.removeAll(!!this.exclusive);
        this.localTransform.destroy();
        this.tempTransformMatrix.destroy();
        this.list = [];
      },
    });
    l.exports = h;
  },
  function (l, w, h) {
    l.exports = {
      Matrix: h(257),
      Add: h(266),
      AddAt: h(267),
      BringToTop: h(268),
      CountAllMatching: h(269),
      Each: h(270),
      EachInRange: h(271),
      FindClosestInSorted: h(272),
      GetAll: h(273),
      GetFirst: h(274),
      GetRandom: h(275),
      MoveDown: h(276),
      MoveTo: h(277),
      MoveUp: h(278),
      NumberArray: h(279),
      NumberArrayStep: h(280),
      QuickSelect: h(281),
      Range: h(282),
      Remove: h(283),
      RemoveAt: h(284),
      RemoveBetween: h(285),
      RemoveRandomElement: h(286),
      Replace: h(287),
      RotateLeft: h(58),
      RotateRight: h(59),
      SafeRange: h(5),
      SendToBack: h(288),
      SetAll: h(289),
      Shuffle: h(60),
      SortByDigits: h(290),
      SpliceOne: h(12),
      StableSort: h(291),
      Swap: h(292),
    };
  },
  function (l, w, h) {
    l.exports = {
      CheckMatrix: h(24),
      MatrixToString: h(258),
      ReverseColumns: h(260),
      ReverseRows: h(261),
      Rotate180: h(262),
      RotateLeft: h(263),
      RotateMatrix: h(16),
      RotateRight: h(264),
      Translate: h(265),
      TransposeMatrix: h(57),
    };
  },
  function (l, w, h) {
    var t = h(259),
      a = h(24);
    l.exports = function (d) {
      var k = "";
      if (!a(d)) return k;
      for (var e = 0; e < d.length; e++) {
        for (var b = 0; b < d[e].length; b++) {
          var c = d[e][b].toString();
          k = "undefined" !== c ? k + t(c, 2) : k + "?";
          b < d[e].length - 1 && (k += " |");
        }
        if (e < d.length - 1) {
          k += "\n";
          for (b = 0; b < d[e].length; b++)
            (k += "---"), b < d[e].length - 1 && (k += "+");
          k += "\n";
        }
      }
      return k;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      void 0 === t && (t = 0);
      void 0 === a && (a = " ");
      void 0 === d && (d = 3);
      h = h.toString();
      if (t + 1 >= h.length)
        switch (d) {
          case 1:
            h = Array(t + 1 - h.length).join(a) + h;
            break;
          case 3:
            d = Math.ceil((t -= h.length) / 2);
            h = Array(t - d + 1).join(a) + h + Array(d + 1).join(a);
            break;
          default:
            h += Array(t + 1 - h.length).join(a);
        }
      return h;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return h.reverse();
    };
  },
  function (l, w) {
    l.exports = function (h) {
      for (var t = 0; t < h.length; t++) h[t].reverse();
      return h;
    };
  },
  function (l, w, h) {
    var t = h(16);
    l.exports = function (a) {
      return t(a, 180);
    };
  },
  function (l, w, h) {
    var t = h(16);
    l.exports = function (a) {
      return t(a, 90);
    };
  },
  function (l, w, h) {
    var t = h(16);
    l.exports = function (a) {
      return t(a, -90);
    };
  },
  function (l, w, h) {
    var t = h(58),
      a = h(59);
    l.exports = function (d, k, e) {
      void 0 === k && (k = 0);
      void 0 === e && (e = 0);
      0 !== e && (0 > e ? t(d, Math.abs(e)) : a(d, e));
      if (0 !== k)
        for (e = 0; e < d.length; e++) {
          var b = d[e];
          0 > k ? t(b, Math.abs(k)) : a(b, k);
        }
      return d;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d, k) {
      void 0 === k && (k = h);
      if (0 < a) {
        var e = a - h.length;
        if (0 >= e) return null;
      }
      if (!Array.isArray(t))
        return -1 === h.indexOf(t) ? (h.push(t), d && d.call(k, t), t) : null;
      for (var b = t.length - 1; 0 <= b; )
        -1 !== h.indexOf(t[b]) && t.splice(b, 1), b--;
      b = t.length;
      if (0 === b) return null;
      0 < a && b > e && (t.splice(e), (b = e));
      for (a = 0; a < b; a++) (e = t[a]), h.push(e), d && d.call(k, e);
      return t;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d, k, e) {
      void 0 === a && (a = 0);
      void 0 === e && (e = h);
      if (0 < d) {
        var b = d - h.length;
        if (0 >= b) return null;
      }
      if (!Array.isArray(t))
        return -1 === h.indexOf(t)
          ? (h.splice(a, 0, t), k && k.call(e, t), t)
          : null;
      for (var c = t.length - 1; 0 <= c; )
        -1 !== h.indexOf(t[c]) && t.pop(), c--;
      c = t.length;
      if (0 === c) return null;
      0 < d && c > b && (t.splice(b), (c = b));
      for (d = c - 1; 0 <= d; d--)
        (b = t[d]), h.splice(a, 0, b), k && k.call(e, b);
      return t;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      var a = h.indexOf(t);
      -1 !== a && a < h.length && (h.splice(a, 1), h.push(t));
      return t;
    };
  },
  function (l, w, h) {
    var t = h(5);
    l.exports = function (a, d, k, e, b) {
      void 0 === e && (e = 0);
      void 0 === b && (b = a.length);
      var c = 0;
      if (t(a, e, b)) for (; e < b; e++) a[e][d] === k && c++;
      return c;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      var d,
        k = [null];
      for (d = 3; d < arguments.length; d++) k.push(arguments[d]);
      for (d = 0; d < h.length; d++) (k[0] = h[d]), t.apply(a, k);
      return h;
    };
  },
  function (l, w, h) {
    var t = h(5);
    l.exports = function (a, d, k, e, b) {
      void 0 === e && (e = 0);
      void 0 === b && (b = a.length);
      if (t(a, e, b)) {
        var c,
          f = [null];
        for (c = 5; c < arguments.length; c++) f.push(arguments[c]);
        for (c = e; c < b; c++) (f[0] = a[c]), d.apply(k, f);
      }
      return a;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      if (!t.length) return NaN;
      if (1 === t.length) return t[0];
      var d = 1;
      if (a) {
        if (h < t[0][a]) return t[0];
        for (; t[d][a] < h; ) d++;
      } else for (; t[d] < h; ) d++;
      d > t.length && (d = t.length);
      if (a) {
        var k = t[d - 1][a];
        a = t[d][a];
        return a - h <= h - k ? t[d] : t[d - 1];
      }
      k = t[d - 1];
      a = t[d];
      return a - h <= h - k ? a : k;
    };
  },
  function (l, w, h) {
    var t = h(5);
    l.exports = function (a, d, k, e, b) {
      void 0 === e && (e = 0);
      void 0 === b && (b = a.length);
      var c = [];
      if (t(a, e, b))
        for (; e < b; e++) {
          var f = a[e];
          (!d ||
            (d && void 0 === k && f.hasOwnProperty(d)) ||
            (d && void 0 !== k && f[d] === k)) &&
            c.push(f);
        }
      return c;
    };
  },
  function (l, w, h) {
    var t = h(5);
    l.exports = function (a, d, k, e, b) {
      void 0 === e && (e = 0);
      void 0 === b && (b = a.length);
      if (t(a, e, b))
        for (; e < b; e++) {
          var c = a[e];
          if (
            !d ||
            (d && void 0 === k && c.hasOwnProperty(d)) ||
            (d && void 0 !== k && c[d] === k)
          )
            return c;
        }
      return null;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      void 0 === t && (t = 0);
      void 0 === a && (a = h.length);
      t += Math.floor(Math.random() * a);
      return void 0 === h[t] ? null : h[t];
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      var a = h.indexOf(t);
      if (0 < a) {
        var d = h[a - 1],
          k = h.indexOf(d);
        h[a] = d;
        h[k] = t;
      }
      return h;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      var d = h.indexOf(t);
      if (-1 === d || 0 > a || a >= h.length)
        throw Error("Supplied index out of bounds");
      d !== a && (h.splice(d, 1), h.splice(a, 0, t));
      return t;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      var a = h.indexOf(t);
      if (-1 !== a && a < h.length - 1) {
        var d = h[a + 1],
          k = h.indexOf(d);
        h[a] = d;
        h[k] = t;
      }
      return h;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      var k = [],
        e = !1;
      if (a || d) (e = !0), a || (a = ""), d || (d = "");
      if (t < h)
        for (; h >= t; h--) e ? k.push(a + h.toString() + d) : k.push(h);
      else for (; h <= t; h++) e ? k.push(a + h.toString() + d) : k.push(h);
      return k;
    };
  },
  function (l, w, h) {
    var t = h(40);
    l.exports = function (a, d, k) {
      void 0 === a && (a = 0);
      void 0 === d && (d = null);
      void 0 === k && (k = 1);
      null === d && ((d = a), (a = 0));
      var e = [];
      d = Math.max(t((d - a) / (k || 1)), 0);
      for (var b = 0; b < d; b++) e.push(a), (a += k);
      return e;
    };
  },
  function (l, w) {
    function h(d, k, e) {
      var b = d[k];
      d[k] = d[e];
      d[e] = b;
    }

    function t(d, k) {
      return d < k ? -1 : d > k ? 1 : 0;
    }
    var a = function (d, k, e, b, c) {
      void 0 === e && (e = 0);
      void 0 === b && (b = d.length - 1);
      for (void 0 === c && (c = t); b > e; ) {
        if (600 < b - e) {
          var f = b - e + 1,
            g = k - e + 1,
            m = Math.log(f),
            n = 0.5 * Math.exp((2 * m) / 3);
          m = 0.5 * Math.sqrt((m * n * (f - n)) / f) * (0 > g - f / 2 ? -1 : 1);
          a(
            d,
            k,
            Math.max(e, Math.floor(k - (g * n) / f + m)),
            Math.min(b, Math.floor(k + ((f - g) * n) / f + m)),
            c
          );
        }
        f = d[k];
        g = e;
        n = b;
        h(d, e, k);
        for (0 < c(d[b], f) && h(d, e, b); g < n; ) {
          h(d, g, n);
          g++;
          for (n--; 0 > c(d[g], f); ) g++;
          for (; 0 < c(d[n], f); ) n--;
        }
        0 === c(d[e], f) ? h(d, e, n) : (n++, h(d, n, b));
        n <= k && (e = n + 1);
        k <= n && (b = n - 1);
      }
    };
    l.exports = a;
  },
  function (l, w, h) {
    var t = h(10),
      a = h(60);
    l.exports = function (d, k, e) {
      var b = t(e, "max", 0),
        c = t(e, "qty", 1),
        f = t(e, "random", !1),
        g = t(e, "randomB", !1),
        m = t(e, "repeat", 0);
      e = t(e, "yoyo", !1);
      var n = [];
      g && a(k);
      -1 === m &&
        (0 === b
          ? (m = 0)
          : ((m = d.length * k.length * c),
            e && (m *= 2),
            (m = Math.ceil(b / m))));
      for (g = 0; g <= m; g++) {
        var q = d;
        for (var r = k, u = c, v = [], x = 0; x < q.length; x++)
          for (var y = 0; y < r.length; y++)
            for (var z = 0; z < u; z++)
              v.push({
                a: q[x],
                b: r[y],
              });
        q = v;
        f && a(q);
        n = n.concat(q);
        e && (q.reverse(), (n = n.concat(q)));
      }
      b && n.splice(b);
      return n;
    };
  },
  function (l, w, h) {
    var t = h(12);
    l.exports = function (a, d, k, e) {
      void 0 === e && (e = a);
      if (!Array.isArray(d)) {
        var b = a.indexOf(d);
        return -1 !== b ? (t(a, b), k && k.call(e, d), d) : null;
      }
      for (var c = d.length - 1, f = []; 0 <= c; ) {
        var g = d[c];
        b = a.indexOf(g);
        -1 !== b && (t(a, b), f.push(g), k && k.call(e, g));
        c--;
      }
      return f;
    };
  },
  function (l, w, h) {
    var t = h(12);
    l.exports = function (a, d, k, e) {
      void 0 === e && (e = a);
      if (0 > d || d > a.length - 1) throw Error("Index out of bounds");
      a = t(a, d);
      k && k.call(e, a);
      return a;
    };
  },
  function (l, w, h) {
    var t = h(5);
    l.exports = function (a, d, k, e, b) {
      void 0 === d && (d = 0);
      void 0 === k && (k = a.length);
      void 0 === b && (b = a);
      if (t(a, d, k)) {
        a = a.splice(d, k - d);
        if (e) for (d = 0; d < a.length; d++) e.call(b, a[d]);
        return a;
      }
      return [];
    };
  },
  function (l, w, h) {
    var t = h(12);
    l.exports = function (a, d, k) {
      void 0 === d && (d = 0);
      void 0 === k && (k = a.length);
      return t(a, d + Math.floor(Math.random() * k));
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      t = h.indexOf(t);
      var d = h.indexOf(a);
      return -1 !== t && -1 === d ? ((h[t] = a), !0) : !1;
    };
  },
  function (l, w) {
    l.exports = function (h, t) {
      var a = h.indexOf(t);
      -1 !== a && 0 < a && (h.splice(a, 1), h.unshift(t));
      return t;
    };
  },
  function (l, w, h) {
    var t = h(5);
    l.exports = function (a, d, k, e, b) {
      void 0 === e && (e = 0);
      void 0 === b && (b = a.length);
      if (t(a, e, b))
        for (; e < b; e++) {
          var c = a[e];
          c.hasOwnProperty(d) && (c[d] = k);
        }
      return a;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      var t = /\D/g;
      h.sort(function (a, d) {
        return parseInt(a.replace(t, ""), 10) - parseInt(d.replace(t, ""), 10);
      });
      return h;
    };
  },
  function (l, w) {
    function h(a, d) {
      return String(a).localeCompare(d);
    }

    function t(a, d, k, e) {
      var b = a.length,
        c = 0,
        f = 2 * k,
        g,
        m;
      for (g = 0; g < b; g += f) {
        var n = g + k;
        var q = n + k;
        n > b && (n = b);
        q > b && (q = b);
        var r = g;
        for (m = n; ; )
          if (r < n && m < q)
            0 >= d(a[r], a[m]) ? (e[c++] = a[r++]) : (e[c++] = a[m++]);
          else if (r < n) e[c++] = a[r++];
          else if (m < q) e[c++] = a[m++];
          else break;
      }
    }
    l.exports = function (a, d) {
      void 0 === d && (d = h);
      var k = a;
      var e = k.length;
      if (!(1 >= e))
        for (var b = Array(e), c = 1; c < e; c *= 2) {
          t(k, d, c, b);
          var f = k;
          k = b;
          b = f;
        }
      k !== a && t(k, null, a.length, a);
      return a;
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      if (t !== a) {
        var d = h.indexOf(t),
          k = h.indexOf(a);
        if (0 > d || 0 > k)
          throw Error("Supplied items must be elements of the same array");
        h[d] = a;
        h[k] = t;
        return h;
      }
    };
  },
  function (l, w, h) {
    l.exports = {
      Alpha: h(294),
      AlphaSingle: h(295),
      BlendMode: h(296),
      ComputedSize: h(47),
      Crop: h(297),
      Depth: h(48),
      Flip: h(49),
      GetBounds: h(298),
      Mask: h(307),
      Origin: h(332),
      PathFollower: h(333),
      Pipeline: h(336),
      ScrollFactor: h(50),
      Size: h(339),
      Texture: h(340),
      TextureCrop: h(341),
      Tint: h(342),
      ToJSON: h(54),
      Transform: h(51),
      TransformMatrix: h(23),
      Visible: h(52),
    };
  },
  function (l, w, h) {
    var t = h(3);
    l.exports = {
      _alpha: 1,
      _alphaTL: 1,
      _alphaTR: 1,
      _alphaBL: 1,
      _alphaBR: 1,
      clearAlpha: function () {
        return this.setAlpha(1);
      },
      setAlpha: function (a, d, k, e) {
        void 0 === a && (a = 1);
        void 0 === d
          ? (this.alpha = a)
          : ((this._alphaTL = t(a, 0, 1)),
            (this._alphaTR = t(d, 0, 1)),
            (this._alphaBL = t(k, 0, 1)),
            (this._alphaBR = t(e, 0, 1)));
        return this;
      },
      alpha: {
        get: function () {
          return this._alpha;
        },
        set: function (a) {
          this._alphaBR =
            this._alphaBL =
            this._alphaTR =
            this._alphaTL =
            this._alpha =
            a =
              t(a, 0, 1);
          this.renderFlags =
            0 === a ? this.renderFlags & -3 : this.renderFlags | 2;
        },
      },
      alphaTopLeft: {
        get: function () {
          return this._alphaTL;
        },
        set: function (a) {
          this._alphaTL = a = t(a, 0, 1);
          0 !== a && (this.renderFlags |= 2);
        },
      },
      alphaTopRight: {
        get: function () {
          return this._alphaTR;
        },
        set: function (a) {
          this._alphaTR = a = t(a, 0, 1);
          0 !== a && (this.renderFlags |= 2);
        },
      },
      alphaBottomLeft: {
        get: function () {
          return this._alphaBL;
        },
        set: function (a) {
          this._alphaBL = a = t(a, 0, 1);
          0 !== a && (this.renderFlags |= 2);
        },
      },
      alphaBottomRight: {
        get: function () {
          return this._alphaBR;
        },
        set: function (a) {
          this._alphaBR = a = t(a, 0, 1);
          0 !== a && (this.renderFlags |= 2);
        },
      },
    };
  },
  function (l, w, h) {
    var t = h(3);
    l.exports = {
      _alpha: 1,
      clearAlpha: function () {
        return this.setAlpha(1);
      },
      setAlpha: function (a) {
        void 0 === a && (a = 1);
        this.alpha = a;
        return this;
      },
      alpha: {
        get: function () {
          return this._alpha;
        },
        set: function (a) {
          this._alpha = a = t(a, 0, 1);
          this.renderFlags =
            0 === a ? this.renderFlags & -3 : this.renderFlags | 2;
        },
      },
    };
  },
  function (l, w, h) {
    var t = h(17);
    l.exports = {
      _blendMode: t.NORMAL,
      blendMode: {
        get: function () {
          return this._blendMode;
        },
        set: function (a) {
          "string" === typeof a && (a = t[a]);
          a |= 0;
          -1 <= a && (this._blendMode = a);
        },
      },
      setBlendMode: function (a) {
        this.blendMode = a;
        return this;
      },
    };
  },
  function (l, w) {
    l.exports = {
      texture: null,
      frame: null,
      isCropped: !1,
      setCrop: function (h, t, a, d) {
        void 0 === h
          ? (this.isCropped = !1)
          : this.frame &&
            ("number" === typeof h
              ? this.frame.setCropUVs(
                  this._crop,
                  h,
                  t,
                  a,
                  d,
                  this.flipX,
                  this.flipY
                )
              : this.frame.setCropUVs(
                  this._crop,
                  h.x,
                  h.y,
                  h.width,
                  h.height,
                  this.flipX,
                  this.flipY
                ),
            (this.isCropped = !0));
        return this;
      },
      resetCropObject: function () {
        return {
          u0: 0,
          v0: 0,
          u1: 0,
          v1: 0,
          width: 0,
          height: 0,
          x: 0,
          y: 0,
          flipX: !1,
          flipY: !1,
          cx: 0,
          cy: 0,
          cw: 0,
          ch: 0,
        };
      },
    };
  },
  function (l, w, h) {
    var t = h(25),
      a = h(39),
      d = h(2);
    l.exports = {
      prepareBoundsOutput: function (k, e) {
        void 0 === e && (e = !1);
        0 !== this.rotation && a(k, this.x, this.y, this.rotation);
        e &&
          this.parentContainer &&
          this.parentContainer
            .getBoundsTransformMatrix()
            .transformPoint(k.x, k.y, k);
        return k;
      },
      getCenter: function (k) {
        void 0 === k && (k = new d());
        k.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
        k.y =
          this.y - this.displayHeight * this.originY + this.displayHeight / 2;
        return k;
      },
      getTopLeft: function (k, e) {
        k || (k = new d());
        k.x = this.x - this.displayWidth * this.originX;
        k.y = this.y - this.displayHeight * this.originY;
        return this.prepareBoundsOutput(k, e);
      },
      getTopCenter: function (k, e) {
        k || (k = new d());
        k.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
        k.y = this.y - this.displayHeight * this.originY;
        return this.prepareBoundsOutput(k, e);
      },
      getTopRight: function (k, e) {
        k || (k = new d());
        k.x = this.x - this.displayWidth * this.originX + this.displayWidth;
        k.y = this.y - this.displayHeight * this.originY;
        return this.prepareBoundsOutput(k, e);
      },
      getLeftCenter: function (k, e) {
        k || (k = new d());
        k.x = this.x - this.displayWidth * this.originX;
        k.y =
          this.y - this.displayHeight * this.originY + this.displayHeight / 2;
        return this.prepareBoundsOutput(k, e);
      },
      getRightCenter: function (k, e) {
        k || (k = new d());
        k.x = this.x - this.displayWidth * this.originX + this.displayWidth;
        k.y =
          this.y - this.displayHeight * this.originY + this.displayHeight / 2;
        return this.prepareBoundsOutput(k, e);
      },
      getBottomLeft: function (k, e) {
        k || (k = new d());
        k.x = this.x - this.displayWidth * this.originX;
        k.y = this.y - this.displayHeight * this.originY + this.displayHeight;
        return this.prepareBoundsOutput(k, e);
      },
      getBottomCenter: function (k, e) {
        k || (k = new d());
        k.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
        k.y = this.y - this.displayHeight * this.originY + this.displayHeight;
        return this.prepareBoundsOutput(k, e);
      },
      getBottomRight: function (k, e) {
        k || (k = new d());
        k.x = this.x - this.displayWidth * this.originX + this.displayWidth;
        k.y = this.y - this.displayHeight * this.originY + this.displayHeight;
        return this.prepareBoundsOutput(k, e);
      },
      getBounds: function (k) {
        void 0 === k && (k = new t());
        if (this.parentContainer) {
          var e = this.parentContainer.getBoundsTransformMatrix();
          this.getTopLeft(k);
          e.transformPoint(k.x, k.y, k);
          var b = k.x;
          var c = k.y;
          this.getTopRight(k);
          e.transformPoint(k.x, k.y, k);
          var f = k.x;
          var g = k.y;
          this.getBottomLeft(k);
          e.transformPoint(k.x, k.y, k);
          var m = k.x;
          var n = k.y;
          this.getBottomRight(k);
          e.transformPoint(k.x, k.y, k);
        } else
          this.getTopLeft(k),
            (b = k.x),
            (c = k.y),
            this.getTopRight(k),
            (f = k.x),
            (g = k.y),
            this.getBottomLeft(k),
            (m = k.x),
            (n = k.y),
            this.getBottomRight(k);
        e = k.x;
        var q = k.y;
        k.x = Math.min(b, f, m, e);
        k.y = Math.min(c, g, n, q);
        k.width = Math.max(b, f, m, e) - k.x;
        k.height = Math.max(c, g, n, q) - k.y;
        return k;
      },
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      return 0 >= h.width || 0 >= h.height
        ? !1
        : h.x <= t && h.x + h.width >= t && h.y <= a && h.y + h.height >= a;
    };
  },
  function (l, w, h) {
    var t = h(61),
      a = h(62);
    l.exports = function (d, k, e, b) {
      void 0 === b && (b = []);
      !k && 0 < e && (k = a(d) / e);
      for (e = 0; e < k; e++) b.push(t(d, e / k));
      return b;
    };
  },
  function (l, w, h) {
    w = h(0);
    var t = h(302),
      a = h(303),
      d = h(26),
      k = h(305),
      e = h(2);
    h = new w({
      initialize: function (b, c, f, g) {
        void 0 === b && (b = 0);
        void 0 === c && (c = 0);
        void 0 === f && (f = 0);
        void 0 === g && (g = 0);
        this.type = d.LINE;
        this.x1 = b;
        this.y1 = c;
        this.x2 = f;
        this.y2 = g;
      },
      getPoint: function (b, c) {
        return t(this, b, c);
      },
      getPoints: function (b, c, f) {
        return a(this, b, c, f);
      },
      getRandomPoint: function (b) {
        return k(this, b);
      },
      setTo: function (b, c, f, g) {
        void 0 === b && (b = 0);
        void 0 === c && (c = 0);
        void 0 === f && (f = 0);
        void 0 === g && (g = 0);
        this.x1 = b;
        this.y1 = c;
        this.x2 = f;
        this.y2 = g;
        return this;
      },
      getPointA: function (b) {
        void 0 === b && (b = new e());
        b.set(this.x1, this.y1);
        return b;
      },
      getPointB: function (b) {
        void 0 === b && (b = new e());
        b.set(this.x2, this.y2);
        return b;
      },
      left: {
        get: function () {
          return Math.min(this.x1, this.x2);
        },
        set: function (b) {
          this.x1 <= this.x2 ? (this.x1 = b) : (this.x2 = b);
        },
      },
      right: {
        get: function () {
          return Math.max(this.x1, this.x2);
        },
        set: function (b) {
          this.x1 > this.x2 ? (this.x1 = b) : (this.x2 = b);
        },
      },
      top: {
        get: function () {
          return Math.min(this.y1, this.y2);
        },
        set: function (b) {
          this.y1 <= this.y2 ? (this.y1 = b) : (this.y2 = b);
        },
      },
      bottom: {
        get: function () {
          return Math.max(this.y1, this.y2);
        },
        set: function (b) {
          this.y1 > this.y2 ? (this.y1 = b) : (this.y2 = b);
        },
      },
    });
    l.exports = h;
  },
  function (l, w, h) {
    var t = h(13);
    l.exports = function (a, d, k) {
      void 0 === k && (k = new t());
      k.x = a.x1 + (a.x2 - a.x1) * d;
      k.y = a.y1 + (a.y2 - a.y1) * d;
      return k;
    };
  },
  function (l, w, h) {
    var t = h(304),
      a = h(13);
    l.exports = function (d, k, e, b) {
      void 0 === b && (b = []);
      !k && 0 < e && (k = t(d) / e);
      e = d.x1;
      var c = d.y1,
        f = d.x2;
      d = d.y2;
      for (var g = 0; g < k; g++) {
        var m = g / k;
        b.push(new a(e + (f - e) * m, c + (d - c) * m));
      }
      return b;
    };
  },
  function (l, w) {
    l.exports = function (h) {
      return Math.sqrt(
        (h.x2 - h.x1) * (h.x2 - h.x1) + (h.y2 - h.y1) * (h.y2 - h.y1)
      );
    };
  },
  function (l, w, h) {
    var t = h(13);
    l.exports = function (a, d) {
      void 0 === d && (d = new t());
      var k = Math.random();
      d.x = a.x1 + k * (a.x2 - a.x1);
      d.y = a.y1 + k * (a.y2 - a.y1);
      return d;
    };
  },
  function (l, w, h) {
    var t = h(13);
    l.exports = function (a, d) {
      void 0 === d && (d = new t());
      d.x = a.x + Math.random() * a.width;
      d.y = a.y + Math.random() * a.height;
      return d;
    };
  },
  function (l, w, h) {
    var t = h(308),
      a = h(331);
    l.exports = {
      mask: null,
      setMask: function (d) {
        this.mask = d;
        return this;
      },
      clearMask: function (d) {
        void 0 === d && (d = !1);
        d && this.mask && this.mask.destroy();
        this.mask = null;
        return this;
      },
      createBitmapMask: function (d) {
        void 0 === d && (this.texture || this.shader) && (d = this);
        return new t(this.scene, d);
      },
      createGeometryMask: function (d) {
        void 0 === d && "Graphics" === this.type && (d = this);
        return new a(this.scene, d);
      },
    };
  },
  function (l, w, h) {
    w = h(0);
    var t = h(309),
      a = h(326);
    h = new w({
      initialize: function (d, k) {
        var e = d.sys.renderer;
        this.renderer = e;
        this.bitmapMask = k;
        this.mainTexture = this.maskTexture = null;
        this.dirty = !0;
        this.maskFramebuffer = this.mainFramebuffer = null;
        this.isStencil = this.invertAlpha = !1;
        this.createMask();
        d.sys.game.events.on(t.CONTEXT_RESTORED, this.createMask, this);
        if (e) e.on(a.RESIZE, this.createMask, this);
      },
      createMask: function () {
        var d = this.renderer;
        if (d && d.gl) {
          this.mainTexture && this.clearMask();
          var k = d.width,
            e = d.height,
            b = d.gl,
            c =
              0 === (k & (k - 1)) && 0 === (e & (e - 1))
                ? b.REPEAT
                : b.CLAMP_TO_EDGE,
            f = b.LINEAR;
          this.mainTexture = d.createTexture2D(
            0,
            f,
            f,
            c,
            c,
            b.RGBA,
            null,
            k,
            e
          );
          this.maskTexture = d.createTexture2D(
            0,
            f,
            f,
            c,
            c,
            b.RGBA,
            null,
            k,
            e
          );
          this.mainFramebuffer = d.createFramebuffer(
            k,
            e,
            this.mainTexture,
            !0
          );
          this.maskFramebuffer = d.createFramebuffer(
            k,
            e,
            this.maskTexture,
            !0
          );
        }
      },
      clearMask: function () {
        var d = this.renderer;
        d &&
          d.gl &&
          this.mainTexture &&
          (d.deleteTexture(this.mainTexture),
          d.deleteTexture(this.maskTexture),
          d.deleteFramebuffer(this.mainFramebuffer),
          d.deleteFramebuffer(this.maskFramebuffer),
          (this.maskFramebuffer =
            this.mainFramebuffer =
            this.maskTexture =
            this.mainTexture =
              null));
      },
      setBitmap: function (d) {
        this.bitmapMask = d;
      },
      preRenderWebGL: function (d, k, e) {
        d.pipelines.BITMAPMASK_PIPELINE.beginMask(this, k, e);
      },
      postRenderWebGL: function (d, k) {
        d.pipelines.BITMAPMASK_PIPELINE.endMask(this, k);
      },
      preRenderCanvas: function () {},
      postRenderCanvas: function () {},
      destroy: function () {
        this.clearMask();
        this.renderer && this.renderer.off(a.RESIZE, this.createMask, this);
        this.renderer = this.prevFramebuffer = this.bitmapMask = null;
      },
    });
    l.exports = h;
  },
  function (l, w, h) {
    l.exports = {
      BLUR: h(310),
      BOOT: h(311),
      CONTEXT_LOST: h(312),
      CONTEXT_RESTORED: h(313),
      DESTROY: h(314),
      FOCUS: h(315),
      HIDDEN: h(316),
      PAUSE: h(317),
      POST_RENDER: h(318),
      POST_STEP: h(319),
      PRE_RENDER: h(320),
      PRE_STEP: h(321),
      READY: h(322),
      RESUME: h(323),
      STEP: h(324),
      VISIBLE: h(325),
    };
  },
  function (l, w) {
    l.exports = "blur";
  },
  function (l, w) {
    l.exports = "boot";
  },
  function (l, w) {
    l.exports = "contextlost";
  },
  function (l, w) {
    l.exports = "contextrestored";
  },
  function (l, w) {
    l.exports = "destroy";
  },
  function (l, w) {
    l.exports = "focus";
  },
  function (l, w) {
    l.exports = "hidden";
  },
  function (l, w) {
    l.exports = "pause";
  },
  function (l, w) {
    l.exports = "postrender";
  },
  function (l, w) {
    l.exports = "poststep";
  },
  function (l, w) {
    l.exports = "prerender";
  },
  function (l, w) {
    l.exports = "prestep";
  },
  function (l, w) {
    l.exports = "ready";
  },
  function (l, w) {
    l.exports = "resume";
  },
  function (l, w) {
    l.exports = "step";
  },
  function (l, w) {
    l.exports = "visible";
  },
  function (l, w, h) {
    l.exports = {
      POST_RENDER: h(327),
      PRE_RENDER: h(328),
      RENDER: h(329),
      RESIZE: h(330),
    };
  },
  function (l, w) {
    l.exports = "postrender";
  },
  function (l, w) {
    l.exports = "prerender";
  },
  function (l, w) {
    l.exports = "render";
  },
  function (l, w) {
    l.exports = "resize";
  },
  function (l, w, h) {
    w = new (h(0))({
      initialize: function (t, a) {
        this.geometryMask = a;
        this.invertAlpha = !1;
        this.isStencil = !0;
        this.level = 0;
      },
      setShape: function (t) {
        this.geometryMask = t;
        return this;
      },
      setInvertAlpha: function (t) {
        void 0 === t && (t = !0);
        this.invertAlpha = t;
        return this;
      },
      preRenderWebGL: function (t, a, d) {
        a = t.gl;
        t.flush();
        0 === t.maskStack.length &&
          (a.enable(a.STENCIL_TEST),
          a.clear(a.STENCIL_BUFFER_BIT),
          (t.maskCount = 0));
        t.currentCameraMask.mask !== this && (t.currentMask.mask = this);
        t.maskStack.push({
          mask: this,
          camera: d,
        });
        this.applyStencil(t, d, !0);
        t.maskCount++;
      },
      applyStencil: function (t, a, d) {
        var k = t.gl,
          e = this.geometryMask,
          b = t.maskCount;
        k.colorMask(!1, !1, !1, !1);
        d
          ? (k.stencilFunc(k.EQUAL, b, 255),
            k.stencilOp(k.KEEP, k.KEEP, k.INCR))
          : (k.stencilFunc(k.EQUAL, b + 1, 255),
            k.stencilOp(k.KEEP, k.KEEP, k.DECR));
        e.renderWebGL(t, e, a);
        t.flush();
        k.colorMask(!0, !0, !0, !0);
        k.stencilOp(k.KEEP, k.KEEP, k.KEEP);
        d
          ? this.invertAlpha
            ? k.stencilFunc(k.NOTEQUAL, b + 1, 255)
            : k.stencilFunc(k.EQUAL, b + 1, 255)
          : this.invertAlpha
          ? k.stencilFunc(k.NOTEQUAL, b, 255)
          : k.stencilFunc(k.EQUAL, b, 255);
      },
      postRenderWebGL: function (t) {
        var a = t.gl;
        t.maskStack.pop();
        t.maskCount--;
        t.flush();
        var d = t.currentMask;
        0 === t.maskStack.length
          ? ((d.mask = null), a.disable(a.STENCIL_TEST))
          : ((a = t.maskStack[t.maskStack.length - 1]),
            a.mask.applyStencil(t, a.camera, !1),
            t.currentCameraMask.mask !== a.mask
              ? ((d.mask = a.mask), (d.camera = a.camera))
              : (d.mask = null));
      },
      preRenderCanvas: function (t, a, d) {
        a = this.geometryMask;
        t.currentContext.save();
        a.renderCanvas(t, a, d, null, null, !0);
        t.currentContext.clip();
      },
      postRenderCanvas: function (t) {
        t.currentContext.restore();
      },
      destroy: function () {
        this.geometryMask = null;
      },
    });
    l.exports = w;
  },
  function (l, w) {
    l.exports = {
      _originComponent: !0,
      originX: 0.5,
      originY: 0.5,
      _displayOriginX: 0,
      _displayOriginY: 0,
      displayOriginX: {
        get: function () {
          return this._displayOriginX;
        },
        set: function (h) {
          this._displayOriginX = h;
          this.originX = h / this.width;
        },
      },
      displayOriginY: {
        get: function () {
          return this._displayOriginY;
        },
        set: function (h) {
          this._displayOriginY = h;
          this.originY = h / this.height;
        },
      },
      setOrigin: function (h, t) {
        void 0 === h && (h = 0.5);
        void 0 === t && (t = h);
        this.originX = h;
        this.originY = t;
        return this.updateDisplayOrigin();
      },
      setOriginFromFrame: function () {
        if (this.frame && this.frame.customPivot)
          (this.originX = this.frame.pivotX),
            (this.originY = this.frame.pivotY);
        else return this.setOrigin();
        return this.updateDisplayOrigin();
      },
      setDisplayOrigin: function (h, t) {
        void 0 === h && (h = 0);
        void 0 === t && (t = h);
        this.displayOriginX = h;
        this.displayOriginY = t;
        return this;
      },
      updateDisplayOrigin: function () {
        this._displayOriginX = this.originX * this.width;
        this._displayOriginY = this.originY * this.height;
        return this;
      },
    };
  },
  function (l, w, h) {
    var t = h(19),
      a = h(334),
      d = h(10),
      k = h(335),
      e = h(2);
    l.exports = {
      path: null,
      rotateToPath: !1,
      pathRotationOffset: 0,
      pathOffset: null,
      pathVector: null,
      pathDelta: null,
      pathTween: null,
      pathConfig: null,
      _prevDirection: k.PLAYING_FORWARD,
      setPath: function (b, c) {
        void 0 === c && (c = this.pathConfig);
        var f = this.pathTween;
        f && f.isPlaying() && f.stop();
        this.path = b;
        c && this.startFollow(c);
        return this;
      },
      setRotateToPath: function (b, c) {
        void 0 === c && (c = 0);
        this.rotateToPath = b;
        this.pathRotationOffset = c;
        return this;
      },
      isFollowing: function () {
        var b = this.pathTween;
        return b && b.isPlaying();
      },
      startFollow: function (b, c) {
        void 0 === b && (b = {});
        void 0 === c && (c = 0);
        var f = this.pathTween;
        f && f.isPlaying() && f.stop();
        "number" === typeof b &&
          (b = {
            duration: b,
          });
        b.from = d(b, "from", 0);
        b.to = d(b, "to", 1);
        f = a(b, "positionOnPath", !1);
        this.rotateToPath = a(b, "rotateToPath", !1);
        this.pathRotationOffset = d(b, "rotationOffset", 0);
        var g = d(b, "startAt", c);
        g &&
          (b.onStart = function (m) {
            m = m.data[0];
            m.progress = g;
            m.elapsed = m.duration * g;
            var n = m.ease(m.progress);
            m.current = m.start + (m.end - m.start) * n;
            m.target[m.key] = m.current;
          });
        this.pathOffset || (this.pathOffset = new e(this.x, this.y));
        this.pathVector || (this.pathVector = new e());
        this.pathDelta || (this.pathDelta = new e());
        this.pathDelta.reset();
        this.pathTween = this.scene.sys.tweens.addCounter(b);
        this.path.getStartPoint(this.pathOffset);
        f && ((this.x = this.pathOffset.x), (this.y = this.pathOffset.y));
        this.pathOffset.x = this.x - this.pathOffset.x;
        this.pathOffset.y = this.y - this.pathOffset.y;
        this._prevDirection = k.PLAYING_FORWARD;
        this.rotateToPath &&
          ((c = this.path.getPoint(0.1)),
          (this.rotation =
            Math.atan2(c.y - this.y, c.x - this.x) +
            t(this.pathRotationOffset)));
        this.pathConfig = b;
        return this;
      },
      pauseFollow: function () {
        var b = this.pathTween;
        b && b.isPlaying() && b.pause();
        return this;
      },
      resumeFollow: function () {
        var b = this.pathTween;
        b && b.isPaused() && b.resume();
        return this;
      },
      stopFollow: function () {
        var b = this.pathTween;
        b && b.isPlaying() && b.stop();
        return this;
      },
      pathUpdate: function () {
        var b = this.pathTween;
        if (b) {
          var c = b.data[0],
            f = this.pathDelta,
            g = this.pathVector;
          f.copy(g).negate();
          if (c.state === k.COMPLETE)
            this.path.getPoint(1, g),
              f.add(g),
              g.add(this.pathOffset),
              this.setPosition(g.x, g.y);
          else if (
            c.state === k.PLAYING_FORWARD ||
            c.state === k.PLAYING_BACKWARD
          )
            if (
              (this.path.getPoint(b.getValue(), g),
              f.add(g),
              g.add(this.pathOffset),
              (f = this.x),
              (b = this.y),
              this.setPosition(g.x, g.y),
              (g = this.x - f),
              (b = this.y - b),
              0 !== g || 0 !== b)
            )
              c.state !== this._prevDirection
                ? (this._prevDirection = c.state)
                : this.rotateToPath &&
                  (this.rotation =
                    Math.atan2(b, g) + t(this.pathRotationOffset));
        }
      },
    };
  },
  function (l, w) {
    l.exports = function (h, t, a) {
      return h ? (h.hasOwnProperty(t) ? h[t] : a) : a;
    };
  },
  function (l, w) {
    l.exports = {
      CREATED: 0,
      INIT: 1,
      DELAY: 2,
      OFFSET_DELAY: 3,
      PENDING_RENDER: 4,
      PLAYING_FORWARD: 5,
      PLAYING_BACKWARD: 6,
      HOLD_DELAY: 7,
      REPEAT_DELAY: 8,
      COMPLETE: 9,
      PENDING_ADD: 20,
      PAUSED: 21,
      LOOP_DELAY: 22,
      ACTIVE: 23,
      COMPLETE_DELAY: 24,
      PENDING_REMOVE: 25,
      REMOVED: 26,
    };
  },
  function (l, w, h) {
    var t = h(337),
      a = h(338),
      d = h(12);
    l.exports = {
      defaultPipeline: null,
      pipeline: null,
      hasPostPipeline: !1,
      postPipelines: null,
      pipelineData: null,
      initPipeline: function (k) {
        void 0 === k && (k = a.MULTI_PIPELINE);
        var e = this.scene.sys.renderer;
        if (!e) return !1;
        e = e.pipelines;
        this.postPipelines = [];
        this.pipelineData = {};
        return e && (k = e.get(k))
          ? ((this.pipeline = this.defaultPipeline = k), !0)
          : !1;
      },
      setPipeline: function (k, e, b) {
        var c = this.scene.sys.renderer;
        if (!c) return this;
        if ((c = c.pipelines)) {
          if ((k = c.get(k))) this.pipeline = k;
          e && (this.pipelineData = b ? t(e) : e);
        }
        return this;
      },
      setPostPipeline: function (k, e, b) {
        var c = this.scene.sys.renderer;
        if (!c) return this;
        if ((c = c.pipelines)) {
          Array.isArray(k) || (k = [k]);
          for (var f = 0; f < k.length; f++) {
            var g = c.getPostPipeline(k[f], this);
            g && this.postPipelines.push(g);
          }
          e && (this.pipelineData = b ? t(e) : e);
        }
        this.hasPostPipeline = 0 < this.postPipelines.length;
        return this;
      },
      setPipelineData: function (k, e) {
        var b = this.pipelineData;
        void 0 === e ? delete b[k] : (b[k] = e);
        return this;
      },
      getPostPipeline: function (k) {
        for (var e = this.postPipelines, b = [], c = 0; c < e.length; c++) {
          var f = e[c];
          (("string" === typeof k && f.name === k) || f instanceof k) &&
            b.push(f);
        }
        return 1 === b.length ? b[0] : b;
      },
      resetPipeline: function (k, e) {
        void 0 === k && (k = !1);
        void 0 === e && (e = !1);
        this.pipeline = this.defaultPipeline;
        k && ((this.postPipelines = []), (this.hasPostPipeline = !1));
        e && (this.pipelineData = {});
        return null !== this.pipeline;
      },
      resetPostPipeline: function (k) {
        void 0 === k && (k = !1);
        for (var e = this.postPipelines, b = 0; b < e.length; b++)
          e[b].destroy();
        this.postPipelines = [];
        this.hasPostPipeline = !1;
        k && (this.pipelineData = {});
      },
      removePostPipeline: function (k) {
        for (var e = this.postPipelines, b = e.length - 1; 0 <= b; b--) {
          var c = e[b];
          if (
            ("string" === typeof k && c.name === k) ||
            ("string" !== typeof k && c instanceof k)
          )
            c.destroy(), d(e, b);
        }
        this.hasPostPipeline = 0 < this.postPipelines.length;
        return this;
      },
      getPipelineName: function () {
        return this.pipeline.name;
      },
    };
  },
  function (l, w) {
    var h = function (t) {
      var a;
      if ("object" !== typeof t || null === t) return t;
      var d = Array.isArray(t) ? [] : {};
      for (a in t) {
        var k = t[a];
        d[a] = h(k);
      }
      return d;
    };
    l.exports = h;
  },
  function (l, w) {
    l.exports = {
      BITMAPMASK_PIPELINE: "BitmapMaskPipeline",
      LIGHT_PIPELINE: "Light2D",
      POINTLIGHT_PIPELINE: "PointLightPipeline",
      SINGLE_PIPELINE: "SinglePipeline",
      MULTI_PIPELINE: "MultiPipeline",
      ROPE_PIPELINE: "RopePipeline",
      GRAPHICS_PIPELINE: "GraphicsPipeline",
      POSTFX_PIPELINE: "PostFXPipeline",
      UTILITY_PIPELINE: "UtilityPipeline",
    };
  },
  function (l, w) {
    l.exports = {
      _sizeComponent: !0,
      width: 0,
      height: 0,
      displayWidth: {
        get: function () {
          return Math.abs(this.scaleX * this.frame.realWidth);
        },
        set: function (h) {
          this.scaleX = h / this.frame.realWidth;
        },
      },
      displayHeight: {
        get: function () {
          return Math.abs(this.scaleY * this.frame.realHeight);
        },
        set: function (h) {
          this.scaleY = h / this.frame.realHeight;
        },
      },
      setSizeToFrame: function (h) {
        void 0 === h && (h = this.frame);
        this.width = h.realWidth;
        this.height = h.realHeight;
        return this;
      },
      setSize: function (h, t) {
        this.width = h;
        this.height = t;
        return this;
      },
      setDisplaySize: function (h, t) {
        this.displayWidth = h;
        this.displayHeight = t;
        return this;
      },
    };
  },
  function (l, w) {
    l.exports = {
      texture: null,
      frame: null,
      isCropped: !1,
      setTexture: function (h, t) {
        this.texture = this.scene.sys.textures.get(h);
        return this.setFrame(t);
      },
      setFrame: function (h, t, a) {
        void 0 === t && (t = !0);
        void 0 === a && (a = !0);
        this.frame = this.texture.get(h);
        this.renderFlags =
          this.frame.cutWidth && this.frame.cutHeight
            ? this.renderFlags | 8
            : this.renderFlags & -9;
        this._sizeComponent && t && this.setSizeToFrame();
        this._originComponent &&
          a &&
          (this.frame.customPivot
            ? this.setOrigin(this.frame.pivotX, this.frame.pivotY)
            : this.updateDisplayOrigin());
        return this;
      },
    };
  },
  function (l, w) {
    l.exports = {
      texture: null,
      frame: null,
      isCropped: !1,
      setCrop: function (h, t, a, d) {
        void 0 === h
          ? (this.isCropped = !1)
          : this.frame &&
            ("number" === typeof h
              ? this.frame.setCropUVs(
                  this._crop,
                  h,
                  t,
                  a,
                  d,
                  this.flipX,
                  this.flipY
                )
              : this.frame.setCropUVs(
                  this._crop,
                  h.x,
                  h.y,
                  h.width,
                  h.height,
                  this.flipX,
                  this.flipY
                ),
            (this.isCropped = !0));
        return this;
      },
      setTexture: function (h, t) {
        this.texture = this.scene.sys.textures.get(h);
        return this.setFrame(t);
      },
      setFrame: function (h, t, a) {
        void 0 === t && (t = !0);
        void 0 === a && (a = !0);
        this.frame = this.texture.get(h);
        this.renderFlags =
          this.frame.cutWidth && this.frame.cutHeight
            ? this.renderFlags | 8
            : this.renderFlags & -9;
        this._sizeComponent && t && this.setSizeToFrame();
        this._originComponent &&
          a &&
          (this.frame.customPivot
            ? this.setOrigin(this.frame.pivotX, this.frame.pivotY)
            : this.updateDisplayOrigin());
        this.isCropped &&
          this.frame.updateCropUVs(this._crop, this.flipX, this.flipY);
        return this;
      },
      resetCropObject: function () {
        return {
          u0: 0,
          v0: 0,
          u1: 0,
          v1: 0,
          width: 0,
          height: 0,
          x: 0,
          y: 0,
          flipX: !1,
          flipY: !1,
          cx: 0,
          cy: 0,
          cw: 0,
          ch: 0,
        };
      },
    };
  },
  function (l, w) {
    l.exports = {
      tintTopLeft: 16777215,
      tintTopRight: 16777215,
      tintBottomLeft: 16777215,
      tintBottomRight: 16777215,
      tintFill: !1,
      clearTint: function () {
        this.setTint(16777215);
        return this;
      },
      setTint: function (h, t, a, d) {
        void 0 === h && (h = 16777215);
        void 0 === t && (d = a = t = h);
        this.tintTopLeft = h;
        this.tintTopRight = t;
        this.tintBottomLeft = a;
        this.tintBottomRight = d;
        this.tintFill = !1;
        return this;
      },
      setTintFill: function (h, t, a, d) {
        this.setTint(h, t, a, d);
        this.tintFill = !0;
        return this;
      },
      tint: {
        set: function (h) {
          this.setTint(h, h, h, h);
        },
      },
      isTinted: {
        get: function () {
          return (
            this.tintFill ||
            16777215 !== this.tintTopLeft ||
            16777215 !== this.tintTopRight ||
            16777215 !== this.tintBottomLeft ||
            16777215 !== this.tintBottomRight
          );
        },
      },
    };
  },
  function (l, w, h) {
    h(1);
    h(1);
    w = h(344);
    h = h(345);
    l.exports = {
      renderWebGL: w,
      renderCanvas: h,
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      var k = t.list,
        e = k.length;
      if (0 !== e) {
        a.addToRenderList(t);
        var b = t.localTransform;
        d
          ? (b.loadIdentity(),
            b.multiply(d),
            b.translate(t.x, t.y),
            b.rotate(t.rotation),
            b.scale(t.scaleX, t.scaleY))
          : b.applyITRS(t.x, t.y, t.rotation, t.scaleX, t.scaleY);
        h.pipelines.preBatch(t);
        (d = -1 !== t.blendMode) || h.setBlendMode(0);
        for (
          var c = t.alpha, f = t.scrollFactorX, g = t.scrollFactorY, m = 0;
          m < e;
          m++
        ) {
          var n = k[m];
          if (n.willRender(a)) {
            if (void 0 !== n.alphaTopLeft) {
              var q = n.alphaTopLeft;
              var r = n.alphaTopRight;
              var u = n.alphaBottomLeft;
              var v = n.alphaBottomRight;
            } else u = r = q = v = n.alpha;
            var x = n.scrollFactorX,
              y = n.scrollFactorY;
            d ||
              n.blendMode === h.currentBlendMode ||
              h.setBlendMode(n.blendMode);
            var z = n.mask;
            z && z.preRenderWebGL(h, n, a);
            var A = n.type;
            A !== h.currentType && ((h.newType = !0), (h.currentType = A));
            h.nextTypeMatch = m < e - 1 ? k[m + 1].type === h.currentType : !1;
            n.setScrollFactor(x * f, y * g);
            n.setAlpha(q * c, r * c, u * c, v * c);
            n.renderWebGL(h, n, a, b);
            n.setAlpha(q, r, u, v);
            n.setScrollFactor(x, y);
            z && z.postRenderWebGL(h, a);
            h.newType = !1;
          }
        }
        h.pipelines.postBatch(t);
      }
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      var k = t.list;
      if (0 !== k.length) {
        a.addToRenderList(t);
        var e = t.localTransform;
        d
          ? (e.loadIdentity(),
            e.multiply(d),
            e.translate(t.x, t.y),
            e.rotate(t.rotation),
            e.scale(t.scaleX, t.scaleY))
          : e.applyITRS(t.x, t.y, t.rotation, t.scaleX, t.scaleY);
        (d = -1 !== t.blendMode) || h.setBlendMode(0);
        var b = t._alpha,
          c = t.scrollFactorX,
          f = t.scrollFactorY;
        t.mask && t.mask.preRenderCanvas(h, null, a);
        for (var g = 0; g < k.length; g++) {
          var m = k[g];
          if (m.willRender(a)) {
            var n = m.alpha,
              q = m.scrollFactorX,
              r = m.scrollFactorY;
            d ||
              m.blendMode === h.currentBlendMode ||
              h.setBlendMode(m.blendMode);
            m.setScrollFactor(q * c, r * f);
            m.setAlpha(n * b);
            m.renderCanvas(h, m, a, e);
            m.setAlpha(n);
            m.setScrollFactor(q, r);
          }
        }
        t.mask && t.mask.postRenderCanvas(h);
      }
    };
  },
  function (l, w, h) {
    var t = h(25);
    l.exports = function (a, d, k) {
      void 0 === k && (k = new t());
      var e = Math.min(a.x, d.x),
        b = Math.min(a.y, d.y);
      return k.setTo(
        e,
        b,
        Math.max(a.right, d.right) - e,
        Math.max(a.bottom, d.bottom) - b
      );
    };
  },
  function (l, w, h) {
    h(1);
    h(1);
    w = h(348);
    h = h(349);
    l.exports = {
      renderWebGL: w,
      renderCanvas: h,
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      var k = t.plugin.sceneRenderer,
        e = t.list;
      if (0 === e.length)
        k.batcher.isDrawing && h.finalType && (k.end(), h.pipelines.rebind());
      else {
        a.addToRenderList(t);
        var b = t.localTransform;
        d
          ? (b.loadIdentity(),
            b.multiply(d),
            b.translate(t.x, t.y),
            b.rotate(t.rotation),
            b.scale(t.scaleX, t.scaleY))
          : b.applyITRS(t.x, t.y, t.rotation, t.scaleX, t.scaleY);
        h.newType && (h.pipelines.clear(), k.begin());
        d = h.nextTypeMatch;
        h.nextTypeMatch = !0;
        h.newType = !1;
        for (var c = 0; c < e.length; c++) {
          var f = e[c];
          if (f.willRender(a, t)) {
            var g = f.mask;
            g &&
              (k.end(),
              h.pipelines.rebind(),
              g.preRenderWebGL(h, f, a),
              h.pipelines.clear(),
              k.begin());
            f.renderWebGL(h, f, a, b, t);
            g &&
              (k.end(),
              h.pipelines.rebind(),
              g.postRenderWebGL(h, a),
              h.pipelines.clear(),
              k.begin());
          }
        }
        h.nextTypeMatch = d;
        d || (k.end(), h.pipelines.rebind());
      }
    };
  },
  function (l, w) {
    l.exports = function (h, t, a, d) {
      var k = t.list;
      if (0 !== k.length) {
        a.addToRenderList(t);
        var e = t.localTransform;
        d
          ? (e.loadIdentity(),
            e.multiply(d),
            e.translate(t.x, t.y),
            e.rotate(t.rotation),
            e.scale(t.scaleX, t.scaleY))
          : e.applyITRS(t.x, t.y, t.rotation, t.scaleX, t.scaleY);
        (d = -1 !== t.blendMode) || h.setBlendMode(0);
        var b = t._alpha,
          c = t.scrollFactorX,
          f = t.scrollFactorY;
        t.mask && t.mask.preRenderCanvas(h, null, a);
        for (var g = 0; g < k.length; g++) {
          var m = k[g];
          if (m.willRender(a)) {
            var n = m.alpha,
              q = m.scrollFactorX,
              r = m.scrollFactorY;
            d ||
              m.blendMode === h.currentBlendMode ||
              h.setBlendMode(m.blendMode);
            m.setScrollFactor(q * c, r * f);
            m.setAlpha(n * b);
            m.renderCanvas(h, m, a, e);
            m.setAlpha(n);
            m.setScrollFactor(q, r);
          }
        }
        t.mask && t.mask.postRenderCanvas(h);
      }
    };
  },
]);
class EngineInitVO {
  constructor() {
    this.data = {
      flagOverrides: {},
      gameName: null,
      gameVersion: "_v1",
      gameSubEngineConfig: null,
      preloaderInitialsAssetsNames: {
        manifestJson: null,
        font: null,
        logo: null,
      },
      initialAssetPackData: null,
      funcStartGame: null,
      funcRegisterComponents: null,
      funcDoGameRegisters: null,
      requiredScreenOrientation: "any",
    };
  }
}
const _Plugins = {
  scene: [
    {
      key: "spine",
      plugin: window.SpinePlugin,
      start: !0,
      sceneKey: "spine",
      mapping: "spine",
    },
    {
      key: "rexGestures",
      plugin: GesturesPlugin,
      start: !0,
      sceneKey: "rexGestures",
      mapping: "rexGestures",
    },
    {
      key: "rexBoard",
      plugin: BoardPlugin,
      mapping: "rexBoard",
    },
  ],
  global: [
    {
      key: "rexEaseMove",
      plugin: EaseMovePlugin,
      start: !0,
      sceneKey: "rexEaseMove",
      mapping: "rexEaseMove",
    },
    {
      key: "rexCsvScenario",
      plugin: CSVScenarioPlugin,
      start: !0,
      sceneKey: "rexCsvScenario",
      mapping: "rexCsvScenario",
    },
    {
      key: "rexMoveTo",
      plugin: MoveToPlugin,
      start: !0,
      sceneKey: "rexMoveTo",
      mapping: "rexMoveTo",
    },
    {
      key: "rexBullet",
      plugin: BulletPlugin,
      start: !0,
      sceneKey: "rexBullet",
      mapping: "rexBullet",
    },
    {
      key: "rexRotateTo",
      plugin: RotateToPlugin,
      start: !0,
    },
  ],
};
class BMEngine {
  static EnableEditor() {
    _PhaserEditorValues.enabled = !0;
  }
  static IsCanvas() {
    return (
      _PhaserEngineValues.phaserGameObject.renderer.type === Phaser$1.CANVAS
    );
  }
  static SetGameplayCameraOffset(l, w, h) {
    _EngineValues.camera.x = void 0 === l ? 0 : l;
    _EngineValues.camera.y = void 0 === w ? 0 : w;
    (void 0 === h ? 0 : h) && _InternalUpdateCamera();
  }
  static GetGameplayCameraOffset() {
    return _EngineValues.camera;
  }
  static SetCameraCenter(l, w) {
    _EngineValues.camera.centerX = void 0 === l ? !0 : l;
    _EngineValues.camera.centerY = void 0 === w ? !1 : w;
  }
  static SetPauseAllowedByStates(l) {
    _EngineValues.pauseAllowedByStates = l;
  }
  static TryPauseGame() {
    if (
      0 != _EngineValues.flags.allowPauseAlways ||
      (_EngineValues.pauseAllowedByStates &&
        _EngineValues.pauseAllowedAfterStartGame)
    ) {
      if (_EngineValues.hasBeenPaused) return !1;
      InternalPauseModel.PauseGameScenes();
      return !0;
    }
  }
  static TryUnpauseGame() {
    if (!_EngineValues.hasBeenPaused) return !1;
    InternalPauseModel.UnPauseGameScenes();
    return !0;
  }
  static UserMuteAudio() {
    _EngineValues.audio.wasMutedManually = !0;
    AudioModelInstance.MuteAudio();
    InternalSaveModel.SaveGameSettings();
  }
  static UserUnmuteAudio() {
    _EngineValues.audio.wasMutedManually = !1;
    AudioModelInstance.UnmuteAudio();
    InternalSaveModel.SaveGameSettings();
  }
  static PlayAudioFile(l, w, h) {
    h = void 0 === h ? null : h;
    if (_PhaserEngineValues.soundInstanceCache[l])
      w = _PhaserEngineValues.soundInstanceCache[l];
    else {
      if (!BMEngine.GetPhaserGame().cache.audio.exists(l)) return;
      _EngineValues.audioConfigCache[l] ||
        ((_EngineValues.audioConfigCache[l] = {
          volume: 1,
          loop: !1,
        }),
        h && merge(_EngineValues.audioConfigCache[l], h));
      w = _EngineValues.audioConfigCache[l];
      w = BMEngine.GetPhaserGame().sound.add(l, w);
    }
    w.play();
    _PhaserEngineValues.soundInstanceCache[l] = w;
  }
  static GetAudioState() {
    return _EngineValues.audio.audioState;
  }
  static GetDisplayDataCopy() {
    return merge({}, _EngineValues.display);
  }
  static GetPhaserGame() {
    return _PhaserEngineValues.phaserGameObject;
  }
  static GetGameplayScene() {
    console.assert(
      _PhaserEngineValues.phaserScenes.game.ref,
      _PhaserEngineValues.phaserScenes.game
    );
    return _PhaserEngineValues.phaserScenes.game.ref;
  }
  static GetAudioModelInstance() {
    return AudioModelInstance;
  }
  static GetGameplayCamera() {
    return BMEngine.GetGameplayScene().cameras.main;
  }
  static GetRightForGameplayScene() {
    const l = BMEngine.GetGameplayScene().cameras.main.worldView;
    return l.width + l.x;
  }
  static GetInterfaceScene() {
    console.assert(
      _PhaserEngineValues.phaserScenes.gameInterface.ref,
      _PhaserEngineValues.phaserScenes.gameInterface
    );
    return _PhaserEngineValues.phaserScenes.gameInterface.ref;
  }
  static GetEditorScene() {
    return _PhaserEngineValues.phaserScenes.pauseDisplayer.ref;
  }
  static GetFileFromCache(l, w) {
    return _PhaserEngineValues.phaserGameObject.cache[l].get(w);
  }
  static IsRotationDisplayed() {
    return _EngineValues.isRotationDisplayActive;
  }
  static GetOrMakeContainerLayer(l, w, h, t) {
    const a = l + "_" + w + h + "_" + t;
    if (!_PhaserEngineValues.phaserLayers[a]) {
      if ("gameplay" == l)
        (l = BMEngine.GetGameplayScene().make.container({}, !1)),
          BMEngine.GetGameplayScene().add.existing(l),
          l.setDepth(1e4 * t),
          (_PhaserEngineValues.phaserLayers[a] = {
            layer: l,
            anchorX: 1,
            anchorY: 1,
          });
      else {
        let d;
        "gui" == l
          ? ((d = BMEngine.GetInterfaceScene().make.container({}, !1)),
            BMEngine.GetInterfaceScene().add.existing(d))
          : "pause" == l &&
            ((d =
              _PhaserEngineValues.phaserScenes.pauseDisplayer.ref.make.container(
                {},
                !1
              )),
            _PhaserEngineValues.phaserScenes.pauseDisplayer.ref.add.existing(
              d
            ));
        d.setDepth(1e4 * t);
        _PhaserEngineValues.phaserLayers[a] = {
          layer: d,
          anchorX: w,
          anchorY: h,
        };
      }
      _InternalRepositionLayers();
    }
    return _PhaserEngineValues.phaserLayers[a].layer;
  }
  static GetSaveSlotReference(l) {
    return InternalSaveModel.LoadGameData(l);
  }
  static SaveGame() {
    InternalSaveModel.SaveCurrentSlot();
  }
}
const _EngineValues = {
    refGameSave: {},
    refGameState: null,
    audioConfigCache: {},
    audio: {
      wasMutedManually: !1,
      wasMutedAutomatically: !1,
      audioState: 1,
    },
    pausedFromRotation: !1,
    isRotationDisplayActive: !1,
    hasBeenPaused: !1,
    pauseAllowedAfterStartGame: !1,
    pauseAllowedByStates: !1,
    flags: {
      disableSaveUserPrefs: 0,
      disableSaveGameData: 0,
      disableFakeMusicPreload: 0,
      cordovaListenersEnabled: 0,
      disableAutoPause: 0,
      allowPauseAlways: 0,
    },
    camera: {
      x: 0,
      y: 0,
      centerX: !0,
      centerY: !1,
    },
    display: {
      designWidth: 1,
      designHeight: 1,
      responsiveWidth: 1,
      responsiveHeight: 1,
      dpi: 1,
      lastWidth: 1,
      lastHeight: 1,
    },
    currentOrientation: "any",
    requiredOrientation: "any",
    gameManifestJSON: null,
    initVO: null,
  },
  _PhaserEditorValues = {
    enabled: !1,
  },
  _PhaserEngineValues = {
    gameSubEngineConfig: {},
    phaserGameObject: null,
    phaserLayers: {},
    soundInstanceCache: {},
    phaserScenes: {
      preloader: {
        ref: null,
        def: null,
        loadedPreloaderInitials: !1,
        loadedGameAssets: !1,
        assetsRealLoadPercentage: 0,
        assetsRealLoadDone: !1,
        funcRefUpdatePreloaderFont: null,
        funcRefCompletePreload: null,
        extraMaxRequiredTime: 5e3,
        extraCurRequiredTime: 0,
      },
      resizeHandler: {
        ref: null,
        def: null,
      },
      pauseDisplayer: {
        ref: null,
        def: null,
      },
      rotateDisplayer: {
        ref: null,
        def: null,
        layer: null,
        bg: null,
        rotateHelper: null,
      },
      controlPauseGameLoop: {
        ref: null,
        def: null,
      },
      game: {
        ref: null,
        def: null,
      },
      gameInterface: {
        ref: null,
        def: null,
      },
    },
  };

function UsePhaserSubEngine(l) {
  merge(_EngineValues.flags, l.data.flagOverrides);
  const w = merge(
    _PhaserEngineValues.gameSubEngineConfig,
    l.data.gameSubEngineConfig
  );
  _PhaserEditorValues.enabled && (w.backgroundColor = "0x000000");
  _EngineValues.requiredOrientation = l.data.requiredScreenOrientation;
  _EngineValues.initVO = l;
  l.data.funcDoGameRegisters();
  const h = l.data.preloaderInitialsAssetsNames,
    t = l.data.initialAssetPackData,
    a = l.data.funcStartGame;
  l = !1;
  GetOs().android && GetBrowser().firefox && (w.type = Phaser$1.CANVAS);
  !GetOs().desktop && GetOs().iOS && (l = !0);
  GetOs().desktop && GetOs().macOS && (l = !0);
  w.fps = {
    forceSetTimeOut: !1,
    target: 60,
  };
  l &&
    ((w.type = Phaser$1.CANVAS),
    (w.fps = {
      forceSetTimeOut: !0,
      target: 60,
    }),
    (w.roundPixels = !1));
  w.type = GameBranding.GetSingleton().onGetRendererTypeOverride(w.type);
  const d = function () {
    if (GetOs().desktop)
      (_EngineValues.display.designWidth = w.scale.width),
        (_EngineValues.display.designHeight = w.scale.height);
    else {
      var b = w.scale.height / w.scale.width;
      b =
        InternalScreenModel.GetRealScreenHeight() /
        InternalScreenModel.GetRealScreenWidth() /
        b;
      b = Clamp$1(b, 1, 2);
      _EngineValues.display.dpi = b;
      _EngineValues.display.designWidth =
        w.scale.width * _EngineValues.display.dpi;
      _EngineValues.display.designHeight =
        w.scale.height * _EngineValues.display.dpi;
    }
  };
  d();
  w.plugins = _Plugins;
  const k = new Phaser$1.Game(w);
  _PhaserEngineValues.phaserGameObject = k;
  k.events.addListener(Phaser$1.Core.Events.BLUR, function () {
    !_EngineValues.flags.disableAutoPause &&
      GameCommandsRegistry.hasKey("PauseGame") &&
      (AudioModelInstance.TryToAutomaticallyMuteIfNotMutedManually(),
      GameCommandsRegistry.runCommand("PauseGame"));
  });
  k.events.addListener(Phaser$1.Core.Events.FOCUS, function () {
    _EngineValues.pausedFromRotation ||
      AudioModelInstance.TryAutomaticallyUnmuteIfWasMutedAlsoAutomatically();
  });
  document.addEventListener(
    "visibilitychange",
    function () {
      document.hidden
        ? !_EngineValues.flags.disableAutoPause &&
          GameCommandsRegistry.hasKey("PauseGame") &&
          (GameCommandsRegistry.runCommand("PauseGame"),
          AudioModelInstance.TryToAutomaticallyMuteIfNotMutedManually())
        : _EngineValues.pausedFromRotation ||
          AudioModelInstance.TryAutomaticallyUnmuteIfWasMutedAlsoAutomatically();
    },
    !1
  );
  document.addEventListener(
    "pause",
    function () {
      document.hidden &&
        !_EngineValues.flags.disableAutoPause &&
        GameCommandsRegistry.hasKey("PauseGame") &&
        (GameCommandsRegistry.runCommand("PauseGame"),
        AudioModelInstance.TryToAutomaticallyMuteIfNotMutedManually());
    },
    !1
  );
  window.document.addEventListener(
    "resume",
    function () {
      _EngineValues.pausedFromRotation ||
        AudioModelInstance.TryAutomaticallyUnmuteIfWasMutedAlsoAutomatically();
    },
    !1
  );
  const e = () => {
    d();
    var b =
      InternalScreenModel.GetRealScreenWidth() /
      InternalScreenModel.GetRealScreenHeight();
    _EngineValues.display.responsiveWidth =
      (_EngineValues.display.designHeight / _EngineValues.display.designWidth) *
      _EngineValues.display.designWidth *
      b;
    _EngineValues.display.responsiveHeight = _EngineValues.display.designHeight;
    10 > _EngineValues.display.responsiveWidth &&
      (_EngineValues.display.responsiveWidth = 10);
    10 > _EngineValues.display.responsiveHeight &&
      (_EngineValues.display.responsiveWidth = 10);
    15e3 < _EngineValues.display.responsiveWidth &&
      (_EngineValues.display.responsiveWidth = 15e3);
    15e3 < _EngineValues.display.responsiveHeight &&
      (_EngineValues.display.responsiveWidth = 15e3);
    k.scale.setGameSize(
      _EngineValues.display.responsiveWidth,
      _EngineValues.display.responsiveHeight
    );
    if (_PhaserEditorValues.enabled) {
      b = [
        BMEngine.GetGameplayScene().cameras,
        BMEngine.GetInterfaceScene().cameras,
      ];
      for (const c in b) {
        const f = _EngineValues.display.responsiveWidth;
        b[c].main.setViewport(
          f / 4,
          0,
          f / 2,
          _EngineValues.display.responsiveHeight
        );
      }
    }
    _InternalRepositionLayers();
  };
  _PhaserEngineValues.phaserScenes.resizeHandler.def = {
    create: function () {
      e();
      window.addEventListener("resize", function () {
        e();
      });
    },
    update: function () {
      if (
        InternalScreenModel.GetRealScreenWidth() !=
          _EngineValues.display.lastWidth ||
        InternalScreenModel.GetRealScreenHeight() !=
          _EngineValues.display.lastHeight
      )
        (_EngineValues.display.lastWidth =
          InternalScreenModel.GetRealScreenWidth()),
          (_EngineValues.display.lastHeight =
            InternalScreenModel.GetRealScreenHeight()),
          e();
    },
  };
  _PhaserEngineValues.phaserScenes.preloader.def = {
    preload: function () {
      const b = this,
        c = new AssetPackLoader();
      c.fillRequestDataFrom(t);
      c.supplyLoadFunctionDictionary(b, () => {
        const f = this.make.container({}, !0),
          g = this.make.image(
            {
              x: 0,
              y: 0,
              key: h.logo,
              add: !0,
            },
            !1
          ),
          m = this.make.bitmapText(
            {
              x: 0,
              y: 125,
              font: h.font,
              text: "0",
              size: !1,
              add: !0,
              align: 1,
            },
            !1
          );
        f.add(g);
        f.add(m);
        const n = () => {
          f.x = _EngineValues.display.responsiveWidth / 2;
          f.y = _EngineValues.display.responsiveHeight / 2;
        };
        n();
        window.addEventListener("resize", n);
        _PhaserEngineValues.phaserScenes.preloader.funcRefCompletePreload =
          () => {
            _PhaserEngineValues.phaserScenes.preloader.funcRefCompletePreload =
              null;
            _PhaserEngineValues.phaserScenes.preloader.funcRefCompletePreload_callback();
          };
        _PhaserEngineValues.phaserScenes.preloader.funcRefCompletePreload_callback =
          () => {
            g.destroy();
            m.destroy();
            f.destroy();
            window.removeEventListener("resize", n);
            b.game.scene.stop("PreloaderScene");
            const r = () => {
              w.optionalLoadDelayValidator
                ? (w.optionalValidatorBreak &&
                    (--w.optionalValidatorBreak.val,
                    0 >= w.optionalValidatorBreak.val &&
                      ((w.optionalValidatorBreak = null),
                      (w.optionalLoadDelayValidator = null))),
                  w.optionalLoadDelayValidator() &&
                    (w.optionalLoadDelayValidator = null),
                  EndOfLoopRoutine.QueueDelayedFunction(GetGUID(), 10, () => {
                    r();
                  }))
                : (InternalSaveModel.LoadGameSettings(),
                  -1 == _EngineValues.audio.audioState &&
                    BMEngine.UserMuteAudio(),
                  a(),
                  (_EngineValues.pauseAllowedAfterStartGame = !0));
            };
            r();
          };
        _PhaserEngineValues.phaserScenes.preloader.funcRefUpdatePreloaderFont =
          () => {
            let r = Math.ceil(
              100 *
                _PhaserEngineValues.phaserScenes.preloader
                  .assetsRealLoadPercentage
            );
            if (!_EngineValues.flags.disableFakeMusicPreload) {
              let u =
                _PhaserEngineValues.phaserScenes.preloader
                  .extraCurRequiredTime /
                _PhaserEngineValues.phaserScenes.preloader.extraMaxRequiredTime;
              u = Math.ceil(25 * u);
              r = Math.ceil(0.75 * r + u);
            }
            m.text = "" + r + "%";
            m.x = -(m.width / 2);
          };
        _EngineValues.gameManifestJSON = BMEngine.GetFileFromCache(
          "json",
          h.manifestJson
        );
        const q = new AssetPackLoader();
        q.fillRequestDataFrom(_EngineValues.gameManifestJSON.assets);
        q.supplyLoadFunctionDictionary(b, () => {
          _PhaserEngineValues.phaserScenes.preloader.assetsRealLoadPercentage = 1;
          _PhaserEngineValues.phaserScenes.preloader.assetsRealLoadDone = !0;
        });
        b.load.on("progress", (r) => {
          _PhaserEngineValues.phaserScenes.preloader
            .funcRefUpdatePreloaderFont &&
            ((_PhaserEngineValues.phaserScenes.preloader.assetsRealLoadPercentage =
              r),
            _PhaserEngineValues.phaserScenes.preloader.funcRefUpdatePreloaderFont());
        });
        q.load();
        b.load.start();
      });
      c.load();
    },
    create: function () {
      adinplay_init();
    },
    update: function (b, c) {
      if (
        _PhaserEngineValues.phaserScenes.preloader.funcRefCompletePreload &&
        _PhaserEngineValues.phaserScenes.preloader.funcRefUpdatePreloaderFont
      ) {
        _PhaserEngineValues.phaserScenes.preloader.assetsRealLoadDone &&
          (_PhaserEngineValues.phaserScenes.preloader.assetsRealLoadPercentage = 1);
        b = !1;
        if (1 == _EngineValues.flags.disableFakeMusicPreload) b = !0;
        else if (
          0.75 <=
          _PhaserEngineValues.phaserScenes.preloader.assetsRealLoadPercentage
        ) {
          let f = 1;
          _PhaserEngineValues.phaserScenes.preloader.assetsRealLoadDone &&
            (f = 5);
          _PhaserEngineValues.phaserScenes.preloader.extraCurRequiredTime +=
            c * f;
          _PhaserEngineValues.phaserScenes.preloader.extraCurRequiredTime >=
            _PhaserEngineValues.phaserScenes.preloader.extraMaxRequiredTime &&
            ((_PhaserEngineValues.phaserScenes.preloader.extraCurRequiredTime =
              _PhaserEngineValues.phaserScenes.preloader.extraMaxRequiredTime),
            (b = !0));
        }
        _PhaserEngineValues.phaserScenes.preloader.funcRefUpdatePreloaderFont();
        _PhaserEngineValues.phaserScenes.preloader.assetsRealLoadDone &&
          b &&
          _PhaserEngineValues.phaserScenes.preloader.funcRefCompletePreload();
      }
    },
  };
  _PhaserEngineValues.phaserScenes.rotateDisplayer.def = {
    create: function () {
      _PhaserEngineValues.phaserScenes.rotateDisplayer.ref = this;
      _PhaserEngineValues.phaserScenes.rotateDisplayer.layer =
        this.make.container({}, !0);
    },
    update: function () {
      _PhaserEngineValues.phaserScenes.rotateDisplayer.bg &&
        _PhaserEngineValues.phaserScenes.rotateDisplayer.def.updateRotateSize();
    },
    showRotate: function () {
      _PhaserEngineValues.phaserScenes.rotateDisplayer.bg ||
        ((_PhaserEngineValues.phaserScenes.rotateDisplayer.bg =
          _PhaserEngineValues.phaserScenes.rotateDisplayer.ref.make.image(
            {
              x: 0,
              y: 0,
              key: "RotateBG",
              add: !1,
            },
            !1
          )),
        (_PhaserEngineValues.phaserScenes.rotateDisplayer.rotateHelper =
          _PhaserEngineValues.phaserScenes.rotateDisplayer.ref.make.image(
            {
              x: 0,
              y: 0,
              key: "NeedPortrait",
              add: !1,
            },
            !1
          )),
        _PhaserEngineValues.phaserScenes.rotateDisplayer.def.updateRotateSize(),
        _PhaserEngineValues.phaserScenes.rotateDisplayer.layer.add(
          _PhaserEngineValues.phaserScenes.rotateDisplayer.bg
        ),
        _PhaserEngineValues.phaserScenes.rotateDisplayer.layer.add(
          _PhaserEngineValues.phaserScenes.rotateDisplayer.rotateHelper
        ));
    },
    hideRotate: function () {
      _PhaserEngineValues.phaserScenes.rotateDisplayer.bg &&
        _PhaserEngineValues.phaserScenes.rotateDisplayer.bg.destroy();
      _PhaserEngineValues.phaserScenes.rotateDisplayer.bg = null;
      _PhaserEngineValues.phaserScenes.rotateDisplayer.rotateHelper &&
        _PhaserEngineValues.phaserScenes.rotateDisplayer.rotateHelper.destroy();
      _PhaserEngineValues.phaserScenes.rotateDisplayer.rotateHelper = null;
    },
    updateRotateSize() {
      _PhaserEngineValues.phaserScenes.rotateDisplayer.bg.setDisplaySize(
        4096,
        4096
      );
      _PhaserEngineValues.phaserScenes.rotateDisplayer.layer.x =
        _EngineValues.display.responsiveWidth / 2;
      _PhaserEngineValues.phaserScenes.rotateDisplayer.layer.y =
        _EngineValues.display.responsiveHeight / 2;
    },
  };
  _PhaserEngineValues.phaserScenes.pauseDisplayer.def = {
    create: function () {
      _PhaserEngineValues.phaserScenes.pauseDisplayer.ref = this;
    },
    update: function () {},
  };
  _PhaserEngineValues.phaserScenes.controlPauseGameLoop.def = {
    create: function () {},
    update: function () {
      if (
        "any" != _EngineValues.requiredOrientation &&
        _PhaserEngineValues.phaserScenes.preloader.assetsRealLoadDone
      ) {
        var b =
          InternalScreenModel.GetRealScreenWidth() >
          InternalScreenModel.GetRealScreenHeight()
            ? "landscape"
            : "portrait";
        _EngineValues.currentOrientation != b &&
          ((_EngineValues.currentOrientation = b),
          _EngineValues.requiredOrientation == _EngineValues.currentOrientation
            ? ((_EngineValues.isRotationDisplayActive = !1),
              _PhaserEngineValues.phaserScenes.rotateDisplayer.def.hideRotate(),
              AudioModelInstance.TryAutomaticallyUnmuteIfWasMutedAlsoAutomatically(),
              _EngineValues.pausedFromRotation &&
                (_EngineValues.pausedFromRotation = !1))
            : ((_EngineValues.isRotationDisplayActive = !0),
              _PhaserEngineValues.phaserScenes.rotateDisplayer.def.showRotate(),
              AudioModelInstance.TryToAutomaticallyMuteIfNotMutedManually(),
              _EngineValues.hasBeenPaused ||
                (GameCommandsRegistry.runCommand("PauseGame"),
                (_EngineValues.pausedFromRotation = !0))));
      }
    },
  };
  _PhaserEngineValues.phaserScenes.gameInterface.def = {
    create: function () {
      _PhaserEngineValues.phaserScenes.gameInterface.ref = this;
    },
    update: function () {},
  };
  _PhaserEngineValues.phaserScenes.game.def = {
    create: function () {
      _PhaserEngineValues.phaserScenes.game.ref = this;
      RoutinesManager.InitRoutines();
    },
    update: function (b, c) {
      _EngineValues.isRotationDisplayActive ||
        (_InternalUpdateCamera(),
        RoutinesManager.UpdateRoutines(b, c),
        GameBranding.GetSingleton().updateTime(c));
    },
  };
  k.scene.add(
    "PreloaderScene",
    _PhaserEngineValues.phaserScenes.preloader.def,
    !0
  );
  k.scene.add("GameScene", _PhaserEngineValues.phaserScenes.game.def, !0);
  k.scene.add(
    "GameInterface",
    _PhaserEngineValues.phaserScenes.gameInterface.def,
    !0
  );
  k.scene.add(
    "RotateDeviceSceneDisplayer",
    _PhaserEngineValues.phaserScenes.rotateDisplayer.def,
    !0
  );
  k.scene.add(
    "ControlPauseGameLoop",
    _PhaserEngineValues.phaserScenes.controlPauseGameLoop.def,
    !0
  );
  k.scene.add(
    "PauseSceneDisplayer",
    _PhaserEngineValues.phaserScenes.pauseDisplayer.def,
    !0
  );
  k.scene.add(
    "ResizeHandlerScene",
    _PhaserEngineValues.phaserScenes.resizeHandler.def,
    !0
  );
}
class InternalSaveModel {
  static GetSaveSlotKey() {
    return (
      _EngineValues.initVO.data.gameName +
      "_slot_" +
      _EngineValues.initVO.data.gameVersion +
      "_major_3"
    );
  }
  static SaveCurrentSlot() {
    1 != _EngineValues.flags.disableSaveGameData &&
      GameBranding.GetSingleton().adaptLocalStorageSetItem(
        InternalSaveModel.GetSaveSlotKey(),
        _EngineValues.refGameSave
      );
  }
  static SaveGameSettings() {
    1 != _EngineValues.flags.disableSaveUserPrefs &&
      GameBranding.GetSingleton().adaptLocalStorageSetItem(
        InternalSaveModel.GetSaveSlotKey(),
        _EngineValues.refGameSave
      );
  }
  static LoadGameSettings() {
    if (1 != _EngineValues.flags.disableSaveUserPrefs) {
      var l = GameBranding.GetSingleton().adaptLocalStorageGetItem(
          InternalSaveModel.GetSaveSlotKey()
        ),
        w = {
          version: 1,
          audio: {
            audioState: _EngineValues.audio.audioState,
          },
          gameState: null,
        };
      null == l
        ? ((_EngineValues.refGameSave = w), this.SaveGameSettings())
        : ((_EngineValues.refGameSave = w),
          merge(_EngineValues.refGameSave, l));
      _EngineValues.audio = _EngineValues.refGameSave.audio;
    }
  }
  static LoadGameData(l) {
    if (1 == _EngineValues.flags.disableSaveGameData)
      return (_EngineValues.refGameState = l);
    null == _EngineValues.refGameSave.gameState &&
      ((_EngineValues.refGameSave.gameState = {}),
      merge(_EngineValues.refGameSave.gameState, l));
    _EngineValues.refGameState = _EngineValues.refGameSave.gameState;
    return _EngineValues.refGameState;
  }
}
class InternalAudioModel {
  MuteAudio(l) {
    if (void 0 === l || l) _EngineValues.audio.audioState = -1;
    BMEngine.GetGameplayScene().sound.setMute(!0);
  }
  UnmuteAudio(l) {
    if (void 0 === l || l) _EngineValues.audio.audioState = 1;
    BMEngine.GetGameplayScene().sound.setMute(!1);
  }
  TryAutomaticallyUnmuteIfWasMutedAlsoAutomatically() {
    !_EngineValues.audio.wasMutedManually &&
      _EngineValues.audio.wasMutedAutomatically &&
      ((_EngineValues.audio.wasMutedAutomatically = !1),
      AudioModelInstance.UnmuteAudio(!1));
  }
  TryToAutomaticallyMuteIfNotMutedManually() {
    _EngineValues.audio.wasMutedManually ||
      _EngineValues.audio.wasMutedAutomatically ||
      ((_EngineValues.audio.wasMutedAutomatically = !0),
      AudioModelInstance.MuteAudio(!1));
  }
}
const AudioModelInstance = new InternalAudioModel();
class InternalPauseModel {
  static PauseGameScenes() {
    _EngineValues.hasBeenPaused ||
      ((_EngineValues.hasBeenPaused = !0),
      _PhaserEngineValues.phaserScenes.game.ref &&
        _PhaserEngineValues.phaserScenes.game.ref.sys.pause(),
      _PhaserEngineValues.phaserScenes.gameInterface.ref &&
        _PhaserEngineValues.phaserScenes.gameInterface.ref.sys.pause());
  }
  static UnPauseGameScenes() {
    _EngineValues.hasBeenPaused &&
      ((_EngineValues.hasBeenPaused = !1),
      _PhaserEngineValues.phaserScenes.game.ref &&
        _PhaserEngineValues.phaserScenes.game.ref.sys.resume(),
      _PhaserEngineValues.phaserScenes.gameInterface.ref &&
        _PhaserEngineValues.phaserScenes.gameInterface.ref.sys.resume());
  }
}
class InternalScreenModel {
  static GetRealScreenSize() {
    var l = window.innerWidth;
    let w = window.innerHeight;
    document.documentElement &&
      "clientWidth" in document.documentElement &&
      ((l = document.documentElement.clientWidth),
      (w = document.documentElement.clientHeight));
    let h = {
      bottom: 0,
      top: 0,
    };
    GetOs().iOS &&
      (document.documentElement &&
      "getBoundingClientRect" in document.documentElement
        ? (h = document.documentElement.getBoundingClientRect())
        : "getBoundingClientRect" in document.body &&
          (h = document.body.getBoundingClientRect()),
      h && ((l = h.right - h.left), (w = h.bottom - h.top)));
    l = {
      w: l,
      h: w,
    };
    l.h = window.innerHeight;
    return l;
  }
  static GetRealScreenHeight() {
    return InternalScreenModel.GetRealScreenSize().h;
  }
  static GetRealScreenWidth() {
    return InternalScreenModel.GetRealScreenSize().w;
  }
}

function _InternalUpdateCamera() {
  BMEngine.GetGameplayScene().cameras.main.scrollX =
    -BMEngine.GetGameplayScene().cameras.main.width / 2 +
    _EngineValues.camera.x;
  _EngineValues.camera.centerY
    ? (BMEngine.GetGameplayScene().cameras.main.scrollY =
        -BMEngine.GetGameplayScene().cameras.main.height / 2 +
        _EngineValues.camera.y)
    : (BMEngine.GetGameplayScene().cameras.main.scrollY =
        _EngineValues.camera.y);
}

function _InternalRepositionLayers() {
  for (const l in _PhaserEngineValues.phaserLayers) {
    const w = _PhaserEngineValues.phaserLayers[l],
      h = w.layer.scene.cameras.main.width,
      t = w.layer.scene.cameras.main.height;
    2 == w.anchorX && (w.layer.x = h / 2);
    3 == w.anchorX && (w.layer.x = h);
    2 == w.anchorY && (w.layer.y = t / 2);
    3 == w.anchorY && (w.layer.y = t);
  }
}
class TransformComponent extends Component {
  constructor(l) {
    super(null);
    this.refTarget = {
      x: l.x,
      y: l.y,
      angle: l.angle,
    };
    const w = JSON.parse(JSON.stringify(this.constructor.properties));
    Object.assign(this, w, l);
  }
  static CalculateDeltaBetween(l, w) {
    l = TransformComponent.At(l);
    w = TransformComponent.At(w);
    const h = {
      x: 0,
      y: 0,
    };
    l &&
      w &&
      ((h.x = w.refTarget.x - l.refTarget.x),
      (h.y = w.refTarget.y - l.refTarget.y));
    return h;
  }
  static At(l) {
    return l.transform;
  }
  setPosition(l, w) {
    null != l && (this.refTarget.x = l);
    null != w && (this.refTarget.y = w);
  }
  getTarget() {
    return this.refTarget;
  }
  static get properties() {
    return {};
  }
  static AddToEntity(l, w, h, t) {
    l.add(TransformComponent, {
      x: void 0 === w ? 0 : w,
      y: void 0 === h ? 0 : h,
      angle: void 0 === t ? 0 : t,
    });
  }
}
const _RepositionEntityByDeltaAction = class {
  static RegisterPackedAsGameCommand() {
    GameCommandsRegistry.register(
      this.Name,
      new GameCommand((l) => {
        _RepositionEntityByDeltaAction.Take(l.entity, l.deltaX, l.deltaY);
      })
    );
  }
  static Take(l, w, h) {
    w = void 0 === w ? null : w;
    h = void 0 === h ? null : h;
    null == w && (w = 0);
    null == h && (h = 0);
    l = TransformComponent.At(l);
    l.refTarget.x += w;
    l.refTarget.y += h;
  }
};
let RepositionEntityByDeltaAction = _RepositionEntityByDeltaAction;
__publicField(
  RepositionEntityByDeltaAction,
  "Name",
  "RepositionEntityByDeltaAction"
);

function isNil(l) {
  return void 0 === l || null === l;
}

function coerceToBoolean(l) {
  var w = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : !1;
  return isNil(l) ? w : !!l;
}

function isString(l) {
  return "string" === typeof l;
}

function coerceToString(l) {
  var w = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "";
  return isNil(l) ? w : isString(l) ? l : String(l);
}

function capitalize(l, w) {
  l = coerceToString(l);
  w = coerceToBoolean(w);
  if ("" === l) return "";
  w && (l = l.toLowerCase());
  return l.substr(0, 1).toUpperCase() + l.substr(1);
}

function lowerCase(l) {
  return coerceToString(l, "").toLowerCase();
}
var digit = "\\d",
  whitespace = "\\s\\uFEFF\\xA0",
  highSurrogate = "\\uD800-\\uDBFF",
  lowSurrogate = "\\uDC00-\\uDFFF",
  diacriticalMark =
    "\\u0300-\\u036F\\u1AB0-\\u1AFF\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F",
  base =
    "\\0-\\u02FF\\u0370-\\u1AAF\\u1B00-\\u1DBF\\u1E00-\\u20CF\\u2100-\\uD7FF\\uE000-\\uFE1F\\uFE30-\\uFFFF",
  REGEXP_COMBINING_MARKS = new RegExp(
    "([" +
      base +
      "]|[" +
      highSurrogate +
      "][" +
      lowSurrogate +
      "]|[" +
      highSurrogate +
      "](?![" +
      lowSurrogate +
      "])|(?:[^" +
      highSurrogate +
      "]|^)[" +
      lowSurrogate +
      "])([" +
      diacriticalMark +
      "]+)",
    "g"
  ),
  REGEXP_SURROGATE_PAIRS = new RegExp(
    "([" + highSurrogate + "])([" + lowSurrogate + "])",
    "g"
  ),
  REGEXP_UNICODE_CHARACTER = new RegExp(
    "((?:[" +
      base +
      "]|[" +
      highSurrogate +
      "][" +
      lowSurrogate +
      "]|[" +
      highSurrogate +
      "](?![" +
      lowSurrogate +
      "])|(?:[^" +
      highSurrogate +
      "]|^)[" +
      lowSurrogate +
      "])(?:[" +
      diacriticalMark +
      "]+))|([" +
      highSurrogate +
      "][" +
      lowSurrogate +
      "])|([\\n\\r\\u2028\\u2029])|(.)",
    "g"
  ),
  REGEXP_WHITESPACE = new RegExp("[" + whitespace + "]"),
  REGEXP_TRIM_LEFT = new RegExp("^[" + whitespace + "]+"),
  REGEXP_TRIM_RIGHT = new RegExp("[" + whitespace + "]+$"),
  REGEXP_DIGIT = new RegExp("^" + digit + "+$"),
  REGEXP_SPECIAL_CHARACTERS = /[-[\]{}()*+!<=:?./\\^$|#,]/g,
  REGEXP_NON_LATIN = /[^A-Za-z0-9]/g,
  REGEXP_HTML_SPECIAL_CHARACTERS = /[<>&"'`]/g,
  REGEXP_CONVERSION_SPECIFICATION =
    /(%{1,2})(?:(\d+)\$)?(\+)?([ 0]|'.{1})?(-)?(\d+)?(?:\.(\d+))?([bcdiouxXeEfgGs])?/g,
  REGEXP_TRAILING_ZEROS = /\.?0+$/g,
  REGEXP_FLAGS = /[gimuy]*$/,
  REGEXP_TAG_LIST = /<([A-Za-z0-9]+)>/g,
  generalPunctuationBlock = "\\u2000-\\u206F",
  nonCharacter = "\\x00-\\x2F\\x3A-\\x40\\x5B-\\x60\\x7b-\\xBF\\xD7\\xF7",
  dingbatBlock = "\\u2700-\\u27BF",
  lowerCaseLetter =
    "a-z\\xB5\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F",
  upperCaseLetter =
    "\\x41-\\x5a\\xc0-\\xd6\\xd8-\\xde\\u0100\\u0102\\u0104\\u0106\\u0108\\u010a\\u010c\\u010e\\u0110\\u0112\\u0114\\u0116\\u0118\\u011a\\u011c\\u011e\\u0120\\u0122\\u0124\\u0126\\u0128\\u012a\\u012c\\u012e\\u0130\\u0132\\u0134\\u0136\\u0139\\u013b\\u013d\\u013f\\u0141\\u0143\\u0145\\u0147\\u014a\\u014c\\u014e\\u0150\\u0152\\u0154\\u0156\\u0158\\u015a\\u015c\\u015e\\u0160\\u0162\\u0164\\u0166\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017b\\u017d\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018b\\u018e-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019c\\u019d\\u019f\\u01a0\\u01a2\\u01a4\\u01a6\\u01a7\\u01a9\\u01ac\\u01ae\\u01af\\u01b1-\\u01b3\\u01b5\\u01b7\\u01b8\\u01bc\\u01c4\\u01c5\\u01c7\\u01c8\\u01ca\\u01cb\\u01cd\\u01cf\\u01d1\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u01de\\u01e0\\u01e2\\u01e4\\u01e6\\u01e8\\u01ea\\u01ec\\u01ee\\u01f1\\u01f2\\u01f4\\u01f6-\\u01f8\\u01fa\\u01fc\\u01fe\\u0200\\u0202\\u0204\\u0206\\u0208\\u020a\\u020c\\u020e\\u0210\\u0212\\u0214\\u0216\\u0218\\u021a\\u021c\\u021e\\u0220\\u0222\\u0224\\u0226\\u0228\\u022a\\u022c\\u022e\\u0230\\u0232\\u023a\\u023b\\u023d\\u023e\\u0241\\u0243-\\u0246\\u0248\\u024a\\u024c\\u024e",
  REGEXP_WORD = new RegExp(
    "(?:[" +
      upperCaseLetter +
      "][" +
      diacriticalMark +
      "]*)?(?:[" +
      lowerCaseLetter +
      "][" +
      diacriticalMark +
      "]*)+|(?:[" +
      upperCaseLetter +
      "][" +
      diacriticalMark +
      "]*)+(?![" +
      lowerCaseLetter +
      "])|[" +
      digit +
      "]+|[" +
      dingbatBlock +
      "]|[^" +
      nonCharacter +
      generalPunctuationBlock +
      whitespace +
      "]+",
    "g"
  ),
  REGEXP_LATIN_WORD =
    /[A-Z\xC0-\xD6\xD8-\xDE]?[a-z\xDF-\xF6\xF8-\xFF]+|[A-Z\xC0-\xD6\xD8-\xDE]+(?![a-z\xDF-\xF6\xF8-\xFF])|\d+/g,
  REGEXP_ALPHA = new RegExp(
    "^(?:[" +
      lowerCaseLetter +
      upperCaseLetter +
      "][" +
      diacriticalMark +
      "]*)+$"
  ),
  REGEXP_ALPHA_DIGIT = new RegExp(
    "^((?:[" +
      lowerCaseLetter +
      upperCaseLetter +
      "][" +
      diacriticalMark +
      "]*)|[" +
      digit +
      "])+$"
  ),
  REGEXP_EXTENDED_ASCII = /^[\x01-\xFF]*$/;

function nilDefault(l, w) {
  return null == l ? w : l;
}

function toString(l) {
  return isNil(l) ? null : isString(l) ? l : String(l);
}

function words(l, w, h) {
  l = coerceToString(l);
  isNil(w)
    ? (w = REGEXP_EXTENDED_ASCII.test(l) ? REGEXP_LATIN_WORD : REGEXP_WORD)
    : w instanceof RegExp ||
      ((h = toString(nilDefault(h, ""))), (w = new RegExp(toString(w), h)));
  return nilDefault(l.match(w), []);
}

function wordToCamel(l, w) {
  return 0 === w ? lowerCase(l) : capitalize(l, !0);
}

function camelCase(l) {
  l = coerceToString(l);
  return "" === l ? "" : words(l).map(wordToCamel).join("");
}

function decapitalize(l) {
  l = coerceToString(l);
  return "" === l ? "" : l.substr(0, 1).toLowerCase() + l.substr(1);
}

function kebabCase(l) {
  l = coerceToString(l);
  return "" === l ? "" : words(l).map(lowerCase).join("-");
}

function snakeCase(l) {
  l = coerceToString(l);
  return "" === l ? "" : words(l).map(lowerCase).join("_");
}

function upperCase(l) {
  return coerceToString(l).toUpperCase();
}

function swapCase(l) {
  return coerceToString(l).split("").reduce(swapAndConcat, "");
}

function swapAndConcat(l, w) {
  var h = w.toLowerCase(),
    t = w.toUpperCase();
  return l + (w === h ? t : h);
}

function titleCase(l, w) {
  var h = coerceToString(l),
    t = Array.isArray(w) ? w : [];
  l = REGEXP_EXTENDED_ASCII.test(h) ? REGEXP_LATIN_WORD : REGEXP_WORD;
  return h.replace(l, function (a, d) {
    return 0 < d && 0 <= t.indexOf(h[d - 1])
      ? a.toLowerCase()
      : capitalize(a, !0);
  });
}

function clipNumber(l, w, h) {
  return l <= w ? w : l >= h ? h : l;
}
var MAX_SAFE_INTEGER = 9007199254740991;

function toInteger(l) {
  return Infinity === l
    ? MAX_SAFE_INTEGER
    : -Infinity === l
    ? -MAX_SAFE_INTEGER
    : ~~l;
}

function truncate(l, w, h) {
  l = coerceToString(l);
  var t = isNil(w) ? l.length : clipNumber(toInteger(w), 0, MAX_SAFE_INTEGER);
  h = coerceToString(h, "...");
  return t >= l.length ? l : l.substr(0, w - h.length) + h;
}

function charAt(l, w) {
  return coerceToString(l).charAt(w);
}
var HIGH_SURROGATE_START = 55296,
  HIGH_SURROGATE_END = 56319,
  LOW_SURROGATE_START = 56320,
  LOW_SURROGATE_END = 57343;

function isHighSurrogate(l) {
  return l >= HIGH_SURROGATE_START && l <= HIGH_SURROGATE_END;
}

function isLowSurrogate(l) {
  return l >= LOW_SURROGATE_START && l <= LOW_SURROGATE_END;
}

function getAstralNumberFromSurrogatePair(l, w) {
  return 1024 * (l - HIGH_SURROGATE_START) + w - LOW_SURROGATE_START + 65536;
}

function coerceToNumber(l) {
  var w = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
  return isNil(l) ? w : "number" === typeof l ? l : Number(l);
}

function nanDefault(l, w) {
  return l !== l ? w : l;
}

function codePointAt(l, w) {
  l = coerceToString(l);
  var h = l.length,
    t = coerceToNumber(w);
  t = nanDefault(t, 0);
  if (!(0 > t || t >= h))
    return (
      (w = l.charCodeAt(t)),
      isHighSurrogate(w) &&
      h > t + 1 &&
      ((l = l.charCodeAt(t + 1)), isLowSurrogate(l))
        ? getAstralNumberFromSurrogatePair(w, l)
        : w
    );
}

function first(l, w) {
  l = coerceToString(l);
  w = isNil(w) ? 1 : clipNumber(toInteger(w), 0, MAX_SAFE_INTEGER);
  return l.length <= w ? l : l.substr(0, w);
}

function graphemeAt(l, w) {
  l = coerceToString(l);
  w = coerceToNumber(w);
  var h,
    t = 0;
  for (
    w = nanDefault(w, 0);
    null !== (h = REGEXP_UNICODE_CHARACTER.exec(l));

  ) {
    if (t === w) return (REGEXP_UNICODE_CHARACTER.lastIndex = 0), h[0];
    t++;
  }
  return "";
}

function last(l, w) {
  l = coerceToString(l);
  w = isNil(w) ? 1 : clipNumber(toInteger(w), 0, MAX_SAFE_INTEGER);
  return l.length <= w ? l : l.substr(l.length - w, w);
}

function prune(l, w, h) {
  l = coerceToString(l);
  var t = isNil(w) ? l.length : clipNumber(toInteger(w), 0, MAX_SAFE_INTEGER),
    a = coerceToString(h, "...");
  if (t >= l.length) return l;
  w = REGEXP_EXTENDED_ASCII.test(l) ? REGEXP_LATIN_WORD : REGEXP_WORD;
  var d = 0;
  l.replace(w, function (k, e) {
    k = e + k.length;
    k <= t - a.length && (d = k);
  });
  return l.substr(0, d) + a;
}

function slice(l, w, h) {
  return coerceToString(l).slice(w, h);
}

function substr(l, w, h) {
  return coerceToString(l).substr(w, h);
}

function substring(l, w, h) {
  return coerceToString(l).substring(w, h);
}

function count(l) {
  return coerceToString(l).length;
}

function countGrapheme(l) {
  return coerceToString(l)
    .replace(REGEXP_COMBINING_MARKS, "*")
    .replace(REGEXP_SURROGATE_PAIRS, "*").length;
}

function countSubstrings(l, w) {
  l = coerceToString(l);
  w = coerceToString(w);
  var h = w.length,
    t = 0,
    a = 0;
  if ("" === l || "" === w) return t;
  do (a = l.indexOf(w, a)), -1 !== a && (t++, (a += h));
  while (-1 !== a);
  return t;
}
var reduce = Array.prototype.reduce;

function countWhere(l, w, h) {
  var t = coerceToString(l);
  if ("" === t || "function" !== typeof w) return 0;
  var a = w.bind(h);
  return reduce.call(
    t,
    function (d, k, e) {
      return a(k, e, t) ? d + 1 : d;
    },
    0
  );
}

function countWords(l, w, h) {
  return words(l, w, h).length;
}

function ReplacementIndex() {
  this.index = 0;
}
ReplacementIndex.prototype.increment = function () {
  this.index++;
};
ReplacementIndex.prototype.incrementOnEmptyPosition = function (l) {
  isNil(l) && this.increment();
};
ReplacementIndex.prototype.getIndexByPosition = function (l) {
  return isNil(l) ? this.index : l - 1;
};
var TYPE_INTEGER = "i",
  TYPE_INTEGER_BINARY = "b",
  TYPE_INTEGER_ASCII_CHARACTER = "c",
  TYPE_INTEGER_DECIMAL = "d",
  TYPE_INTEGER_OCTAL = "o",
  TYPE_INTEGER_UNSIGNED_DECIMAL = "u",
  TYPE_INTEGER_HEXADECIMAL = "x",
  TYPE_INTEGER_HEXADECIMAL_UPPERCASE = "X",
  TYPE_FLOAT_SCIENTIFIC = "e",
  TYPE_FLOAT_SCIENTIFIC_UPPERCASE = "E",
  TYPE_FLOAT = "f",
  TYPE_FLOAT_SHORT = "g",
  TYPE_FLOAT_SHORT_UPPERCASE = "G",
  TYPE_STRING = "s",
  LITERAL_SINGLE_QUOTE = "'",
  LITERAL_PLUS = "+",
  LITERAL_MINUS = "-",
  LITERAL_PERCENT_SPECIFIER = "%%",
  RADIX_BINARY = 2,
  RADIX_OCTAL = 8,
  RADIX_HEXADECIMAL = 16;

function repeat(l, w) {
  l = coerceToString(l);
  w = isNil(w) ? 1 : clipNumber(toInteger(w), 0, MAX_SAFE_INTEGER);
  for (var h = ""; w; ) w & 1 && (h += l), 1 < w && (l += l), (w >>= 1);
  return h;
}

function buildPadding(l, w) {
  var h = toInteger(w / l.length);
  return repeat(l, h + (w % l.length)).substr(0, w);
}

function padLeft(l, w, h) {
  l = coerceToString(l);
  w = isNil(w) ? 0 : clipNumber(toInteger(w), 0, MAX_SAFE_INTEGER);
  h = coerceToString(h, " ");
  return w <= l.length ? l : buildPadding(h, w - l.length) + l;
}

function padRight(l, w, h) {
  l = coerceToString(l);
  w = isNil(w) ? 0 : clipNumber(toInteger(w), 0, MAX_SAFE_INTEGER);
  h = coerceToString(h, " ");
  return w <= l.length ? l : l + buildPadding(h, w - l.length);
}

function alignAndPad(l, w) {
  var h = w.width;
  return isNil(h) || l.length >= h
    ? l
    : (w.alignmentSpecifier === LITERAL_MINUS ? padRight : padLeft)(
        l,
        h,
        w.getPaddingCharacter()
      );
}

function addSignToFormattedNumber(l, w, h) {
  h.signSpecifier === LITERAL_PLUS && 0 <= l && (w = LITERAL_PLUS + w);
  return w;
}

function float(l, w) {
  l = parseFloat(l);
  var h = void 0;
  isNaN(l) && (l = 0);
  var t = coerceToNumber(w.precision, 6);
  switch (w.typeSpecifier) {
    case TYPE_FLOAT:
      h = l.toFixed(t);
      break;
    case TYPE_FLOAT_SCIENTIFIC:
      h = l.toExponential(t);
      break;
    case TYPE_FLOAT_SCIENTIFIC_UPPERCASE:
      h = l.toExponential(t).toUpperCase();
      break;
    case TYPE_FLOAT_SHORT:
    case TYPE_FLOAT_SHORT_UPPERCASE:
      h = formatFloatAsShort(l, t, w);
  }
  h = addSignToFormattedNumber(l, h, w);
  return coerceToString(h);
}

function formatFloatAsShort(l, w, h) {
  if (0 === l) return "0";
  l = l.toPrecision(0 === w ? 1 : w).replace(REGEXP_TRAILING_ZEROS, "");
  h.typeSpecifier === TYPE_FLOAT_SHORT_UPPERCASE && (l = l.toUpperCase());
  return l;
}

function integerBase(l, w) {
  l = parseInt(l);
  isNaN(l) && (l = 0);
  l >>>= 0;
  switch (w.typeSpecifier) {
    case TYPE_INTEGER_ASCII_CHARACTER:
      l = String.fromCharCode(l);
      break;
    case TYPE_INTEGER_BINARY:
      l = l.toString(RADIX_BINARY);
      break;
    case TYPE_INTEGER_OCTAL:
      l = l.toString(RADIX_OCTAL);
      break;
    case TYPE_INTEGER_HEXADECIMAL:
      l = l.toString(RADIX_HEXADECIMAL);
      break;
    case TYPE_INTEGER_HEXADECIMAL_UPPERCASE:
      l = l.toString(RADIX_HEXADECIMAL).toUpperCase();
  }
  return coerceToString(l);
}

function integerDecimal(l, w) {
  l = parseInt(l);
  isNaN(l) && (l = 0);
  return addSignToFormattedNumber(l, toString(l), w);
}

function stringFormat(l, w) {
  w = w.precision;
  !isNil(w) && l.length > w && (l = truncate(l, w, ""));
  return l;
}

function compute(l, w) {
  var h = void 0;
  switch (w.typeSpecifier) {
    case TYPE_STRING:
      h = stringFormat;
      break;
    case TYPE_INTEGER_DECIMAL:
    case TYPE_INTEGER:
      h = integerDecimal;
      break;
    case TYPE_INTEGER_ASCII_CHARACTER:
    case TYPE_INTEGER_BINARY:
    case TYPE_INTEGER_OCTAL:
    case TYPE_INTEGER_HEXADECIMAL:
    case TYPE_INTEGER_HEXADECIMAL_UPPERCASE:
    case TYPE_INTEGER_UNSIGNED_DECIMAL:
      h = integerBase;
      break;
    case TYPE_FLOAT:
    case TYPE_FLOAT_SCIENTIFIC:
    case TYPE_FLOAT_SCIENTIFIC_UPPERCASE:
    case TYPE_FLOAT_SHORT:
    case TYPE_FLOAT_SHORT_UPPERCASE:
      h = float;
  }
  l = h(l, w);
  return alignAndPad(l, w);
}

function ConversionSpecification(l) {
  this.percent = l.percent;
  this.signSpecifier = l.signSpecifier;
  this.paddingSpecifier = l.paddingSpecifier;
  this.alignmentSpecifier = l.alignmentSpecifier;
  this.width = l.width;
  this.precision = l.precision;
  this.typeSpecifier = l.typeSpecifier;
}
ConversionSpecification.prototype.isPercentLiteral = function () {
  return LITERAL_PERCENT_SPECIFIER === this.percent;
};
ConversionSpecification.prototype.getPaddingCharacter = function () {
  var l = nilDefault(this.paddingSpecifier, " ");
  2 === l.length && l[0] === LITERAL_SINGLE_QUOTE && (l = l[1]);
  return l;
};

function validate(l, w, h) {
  if (isNil(h.typeSpecifier)) throw Error("sprintf(): Unknown type specifier");
  if (l > w - 1) throw Error("sprintf(): Too few arguments");
  if (0 > l)
    throw Error("sprintf(): Argument number must be greater than zero");
}

function match(l, w, h, t, a, d, k, e, b, c, f) {
  t = new ConversionSpecification({
    percent: t,
    signSpecifier: d,
    paddingSpecifier: k,
    alignmentSpecifier: e,
    width: coerceToNumber(b, null),
    precision: coerceToNumber(c, null),
    typeSpecifier: f,
  });
  if (t.isPercentLiteral()) return h.slice(1);
  h = l.getIndexByPosition(a);
  l.incrementOnEmptyPosition(a);
  validate(h, w.length, t);
  return compute(w[h], t);
}

function sprintf(l) {
  var w = coerceToString(l);
  if ("" === w) return w;
  for (
    var h = arguments.length, t = Array(1 < h ? h - 1 : 0), a = 1;
    a < h;
    a++
  )
    t[a - 1] = arguments[a];
  h = match.bind(void 0, new ReplacementIndex(), t);
  return w.replace(REGEXP_CONVERSION_SPECIFICATION, h);
}

function _toConsumableArray(l) {
  if (Array.isArray(l)) {
    for (var w = 0, h = Array(l.length); w < l.length; w++) h[w] = l[w];
    return h;
  }
  return Array.from(l);
}

function vprintf(l, w) {
  return sprintf.apply(
    void 0,
    [l].concat(_toConsumableArray(nilDefault(w, [])))
  );
}
var escapeCharactersMap = {
  "<": "&lt;",
  ">": "&gt;",
  "&": "&amp;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;",
};

function replaceSpecialCharacter(l) {
  return escapeCharactersMap[l];
}

function escapeHtml(l) {
  return coerceToString(l).replace(
    REGEXP_HTML_SPECIAL_CHARACTERS,
    replaceSpecialCharacter
  );
}

function escapeRegExp(l) {
  return coerceToString(l).replace(REGEXP_SPECIAL_CHARACTERS, "\\$&");
}
var unescapeCharactersMap = {
    "<": /(&lt;)|(&#x0*3c;)|(&#0*60;)/gi,
    ">": /(&gt;)|(&#x0*3e;)|(&#0*62;)/gi,
    "&": /(&amp;)|(&#x0*26;)|(&#0*38;)/gi,
    '"': /(&quot;)|(&#x0*22;)|(&#0*34;)/gi,
    "'": /(&#x0*27;)|(&#0*39;)/gi,
    "`": /(&#x0*60;)|(&#0*96;)/gi,
  },
  characters = Object.keys(unescapeCharactersMap);

function reduceUnescapedString(l, w) {
  return l.replace(unescapeCharactersMap[w], w);
}

function unescapeHtml(l) {
  l = coerceToString(l);
  return characters.reduce(reduceUnescapedString, l);
}

function indexOf(l, w, h) {
  return coerceToString(l).indexOf(w, h);
}

function lastIndexOf(l, w, h) {
  return coerceToString(l).lastIndexOf(w, h);
}

function search(l, w, h) {
  l = coerceToString(l);
  h = isNil(h) ? 0 : clipNumber(toInteger(h), 0, l.length);
  w = l.substr(h).search(w);
  -1 === w || isNaN(h) || (w += h);
  return w;
}

function insert(l, w, h) {
  l = coerceToString(l);
  w = coerceToString(w);
  h = coerceToNumber(h);
  return 0 > h || h > l.length || "" === w ? l : l.slice(0, h) + w + l.slice(h);
}
var diacritics = {
    3: "\u039e\u03be",
    8: "\u0398\u03b8",
    A: "A\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u0100\u0102\u0104\u01cd\u01de\u01e0\u01fa\u0200\u0202\u0226\u023a\u1e00\u1ea0\u1ea2\u1ea4\u1ea6\u1ea8\u1eaa\u1eac\u1eae\u1eb0\u1eb2\u1eb4\u1eb6\u24b6\u2c6f\uff21\u0386\u0391\u0410",
    B: "B\u0181\u0182\u0243\u1e02\u1e04\u1e06\u24b7\uff22\u0392\u0411",
    C: "C\u00c7\u0106\u0108\u010a\u010c\u0187\u023b\u1e08\u24b8\ua73e\uff23\u0426",
    D: "D\u010e\u0110\u0189\u018a\u018b\u1e0a\u1e0c\u1e0e\u1e10\u1e12\u24b9\ua779\uff24\u00d0\u0394\u0414",
    E: "E\u00c8\u00c9\u00ca\u00cb\u0112\u0114\u0116\u0118\u011a\u018e\u0190\u0204\u0206\u0228\u1e14\u1e16\u1e18\u1e1a\u1e1c\u1eb8\u1eba\u1ebc\u1ebe\u1ec0\u1ec2\u1ec4\u1ec6\u24ba\uff25\u0388\u0395\u0415\u042d",
    F: "F\u0191\u1e1e\u24bb\ua77b\uff26\u03a6\u0424",
    G: "G\u011c\u011e\u0120\u0122\u0193\u01e4\u01e6\u01f4\u1e20\u24bc\ua77d\ua77e\ua7a0\uff27\u0393\u0413\u0490",
    H: "H\u0124\u0126\u021e\u1e22\u1e24\u1e26\u1e28\u1e2a\u24bd\u2c67\u2c75\ua78d\uff28\u0389\u0397\u0425",
    I: "I\u00cc\u00cd\u00ce\u00cf\u0128\u012a\u012c\u012e\u0130\u0197\u01cf\u0208\u020a\u1e2c\u1e2e\u1ec8\u1eca\u24be\uff29\u038a\u0399\u03aa\u0406\u0418",
    J: "J\u0134\u0248\u24bf\uff2a\u0419",
    K: "K\u0136\u0198\u01e8\u1e30\u1e32\u1e34\u24c0\u2c69\ua740\ua742\ua744\ua7a2\uff2b\u039a\u041a",
    L: "L\u0139\u013b\u013d\u013f\u0141\u023d\u1e36\u1e38\u1e3a\u1e3c\u24c1\u2c60\u2c62\ua746\ua748\ua780\uff2c\u039b\u041b",
    M: "M\u019c\u1e3e\u1e40\u1e42\u24c2\u2c6e\uff2d\u039c\u041c",
    N: "N\u00d1\u0143\u0145\u0147\u019d\u01f8\u0220\u1e44\u1e46\u1e48\u1e4a\u24c3\ua790\ua7a4\uff2e\u039d\u041d",
    O: "O\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u014c\u014e\u0150\u0186\u019f\u01a0\u01d1\u01ea\u01ec\u01fe\u020c\u020e\u022a\u022c\u022e\u0230\u1e4c\u1e4e\u1e50\u1e52\u1ecc\u1ece\u1ed0\u1ed2\u1ed4\u1ed6\u1ed8\u1eda\u1edc\u1ede\u1ee0\u1ee2\u24c4\ua74a\ua74c\uff2f\u038c\u039f\u041e",
    P: "P\u01a4\u1e54\u1e56\u24c5\u2c63\ua750\ua752\ua754\uff30\u03a0\u041f",
    Q: "Q\u024a\u24c6\ua756\ua758\uff31",
    R: "R\u0154\u0156\u0158\u0210\u0212\u024c\u1e58\u1e5a\u1e5c\u1e5e\u24c7\u2c64\ua75a\ua782\ua7a6\uff32\u03a1\u0420",
    S: "S\u015a\u015c\u015e\u0160\u0218\u1e60\u1e62\u1e64\u1e66\u1e68\u1e9e\u24c8\u2c7e\ua784\ua7a8\uff33\u03a3\u0421",
    T: "T\u0162\u0164\u0166\u01ac\u01ae\u021a\u023e\u1e6a\u1e6c\u1e6e\u1e70\u24c9\ua786\uff34\u03a4\u0422",
    U: "U\u00d9\u00da\u00db\u00dc\u0168\u016a\u016c\u016e\u0170\u0172\u01af\u01d3\u01d5\u01d7\u01d9\u01db\u0214\u0216\u0244\u1e72\u1e74\u1e76\u1e78\u1e7a\u1ee4\u1ee6\u1ee8\u1eea\u1eec\u1eee\u1ef0\u24ca\uff35\u0423\u042a",
    V: "V\u01b2\u0245\u1e7c\u1e7e\u24cb\ua75e\uff36\u0412",
    W: "W\u0174\u1e80\u1e82\u1e84\u1e86\u1e88\u24cc\u2c72\uff37\u038f\u03a9",
    X: "X\u1e8a\u1e8c\u24cd\uff38\u03a7",
    Y: "Y\u00dd\u0176\u0178\u01b3\u0232\u024e\u1e8e\u1ef2\u1ef4\u1ef6\u1ef8\u1efe\u24ce\uff39\u038e\u03a5\u03ab\u042b",
    Z: "Z\u0179\u017b\u017d\u01b5\u0224\u1e90\u1e92\u1e94\u24cf\u2c6b\u2c7f\ua762\uff3a\u0396\u0417",
    a: "a\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u0101\u0103\u0105\u01ce\u01df\u01e1\u01fb\u0201\u0203\u0227\u0250\u1e01\u1e9a\u1ea1\u1ea3\u1ea5\u1ea7\u1ea9\u1eab\u1ead\u1eaf\u1eb1\u1eb3\u1eb5\u1eb7\u24d0\u2c65\uff41\u03ac\u03b1\u0430",
    b: "b\u0180\u0183\u0253\u1e03\u1e05\u1e07\u24d1\uff42\u03b2\u0431",
    c: "c\u00e7\u0107\u0109\u010b\u010d\u0188\u023c\u1e09\u2184\u24d2\ua73f\uff43\u0446",
    d: "d\u010f\u0111\u018c\u0256\u0257\u1e0b\u1e0d\u1e0f\u1e11\u1e13\u24d3\ua77a\uff44\u00f0\u03b4\u0434",
    e: "e\u00e8\u00e9\u00ea\u00eb\u0113\u0115\u0117\u0119\u011b\u01dd\u0205\u0207\u0229\u0247\u025b\u1e15\u1e17\u1e19\u1e1b\u1e1d\u1eb9\u1ebb\u1ebd\u1ebf\u1ec1\u1ec3\u1ec5\u1ec7\u24d4\uff45\u03ad\u03b5\u0435\u044d",
    f: "f\u0192\u1e1f\u24d5\ua77c\uff46\u03c6\u0444",
    g: "g\u011d\u011f\u0121\u0123\u01e5\u01e7\u01f5\u0260\u1d79\u1e21\u24d6\ua77f\ua7a1\uff47\u03b3\u0433\u0491",
    h: "h\u0125\u0127\u021f\u0265\u1e23\u1e25\u1e27\u1e29\u1e2b\u1e96\u24d7\u2c68\u2c76\uff48\u03ae\u03b7\u0445",
    i: "i\u00ec\u00ed\u00ee\u00ef\u0129\u012b\u012d\u012f\u0131\u01d0\u0209\u020b\u0268\u1e2d\u1e2f\u1ec9\u1ecb\u24d8\uff49\u0390\u03af\u03b9\u03ca\u0438\u0456",
    j: "j\u0135\u01f0\u0249\u24d9\uff4a\u0439",
    k: "k\u0137\u0199\u01e9\u1e31\u1e33\u1e35\u24da\u2c6a\ua741\ua743\ua745\ua7a3\uff4b\u03ba\u043a",
    l: "l\u013a\u013c\u013e\u0140\u0142\u017f\u019a\u026b\u1e37\u1e39\u1e3b\u1e3d\u24db\u2c61\ua747\ua749\ua781\uff4c\u03bb\u043b",
    m: "m\u026f\u0271\u1e3f\u1e41\u1e43\u24dc\uff4d\u03bc\u043c",
    n: "n\u00f1\u0144\u0146\u0148\u0149\u019e\u01f9\u0272\u1e45\u1e47\u1e49\u1e4b\u24dd\ua791\ua7a5\uff4e\u03bd\u043d",
    o: "o\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u014d\u014f\u0151\u01a1\u01d2\u01eb\u01ed\u01ff\u020d\u020f\u022b\u022d\u022f\u0231\u0254\u0275\u1e4d\u1e4f\u1e51\u1e53\u1ecd\u1ecf\u1ed1\u1ed3\u1ed5\u1ed7\u1ed9\u1edb\u1edd\u1edf\u1ee1\u1ee3\u24de\ua74b\ua74d\uff4f\u03bf\u03cc\u043e",
    p: "p\u01a5\u1d7d\u1e55\u1e57\u24df\ua751\ua753\ua755\uff50\u03c0\u043f",
    q: "q\u024b\u24e0\ua757\ua759\uff51",
    r: "r\u0155\u0157\u0159\u0211\u0213\u024d\u027d\u1e59\u1e5b\u1e5d\u1e5f\u24e1\ua75b\ua783\ua7a7\uff52\u03c1\u0440",
    s: "s\u00df\u015b\u015d\u015f\u0161\u0219\u023f\u1e61\u1e63\u1e65\u1e67\u1e69\u1e9b\u24e2\ua785\ua7a9\uff53\u03c2\u03c3\u0441",
    t: "t\u0163\u0165\u0167\u01ad\u021b\u0288\u1e6b\u1e6d\u1e6f\u1e71\u1e97\u24e3\u2c66\ua787\uff54\u03c4\u0442",
    u: "u\u00f9\u00fa\u00fb\u00fc\u0169\u016b\u016d\u016f\u0171\u0173\u01b0\u01d4\u01d6\u01d8\u01da\u01dc\u0215\u0217\u0289\u1e73\u1e75\u1e77\u1e79\u1e7b\u1ee5\u1ee7\u1ee9\u1eeb\u1eed\u1eef\u1ef1\u24e4\uff55\u0443\u044a",
    v: "v\u028b\u028c\u1e7d\u1e7f\u24e5\ua75f\uff56\u0432",
    w: "w\u0175\u1e81\u1e83\u1e85\u1e87\u1e89\u1e98\u24e6\u2c73\uff57\u03c9\u03ce",
    x: "x\u1e8b\u1e8d\u24e7\uff58\u03c7",
    y: "y\u00fd\u00ff\u0177\u01b4\u0233\u024f\u1e8f\u1e99\u1ef3\u1ef5\u1ef7\u1ef9\u1eff\u24e8\uff59\u03b0\u03c5\u03cb\u03cd\u044b",
    z: "z\u017a\u017c\u017e\u01b6\u0225\u0240\u1e91\u1e93\u1e95\u24e9\u2c6c\ua763\uff5a\u03b6\u0437",
    OE: "\u008c\u0152",
    oe: "\u009c\u0153",
    AE: "\u00c6\u01e2\u01fc",
    ae: "\u00e6\u01e3\u01fd",
    hv: "\u0195",
    OI: "\u01a2",
    oi: "\u01a3",
    DZ: "\u01c4\u01f1",
    Dz: "\u01c5\u01f2",
    dz: "\u01c6\u01f3",
    LJ: "\u01c7",
    Lj: "\u01c8",
    lj: "\u01c9",
    NJ: "\u01ca",
    Nj: "\u01cb",
    nj: "\u01cc",
    OU: "\u0222",
    ou: "\u0223",
    TZ: "\ua728",
    tz: "\ua729",
    AA: "\ua732",
    aa: "\ua733",
    AO: "\ua734",
    ao: "\ua735",
    AU: "\ua736",
    au: "\ua737",
    AV: "\ua738\ua73a",
    av: "\ua739\ua73b",
    AY: "\ua73c",
    ay: "\ua73d",
    OO: "\ua74e",
    oo: "\ua74f",
    VY: "\ua760",
    vy: "\ua761",
    TH: "\u00de",
    th: "\u00fe",
    PS: "\u03a8",
    ps: "\u03c8",
    Yo: "\u0401",
    Ye: "\u0404",
    Yi: "\u0407",
    Zh: "\u0416",
    Ch: "\u0427",
    Sh: "\u0428\u0429",
    "": "\u042c\u044c",
    Yu: "\u042e",
    Ya: "\u042f",
    zh: "\u0436",
    ch: "\u0447",
    sh: "\u0448\u0449",
    yu: "\u044e",
    ya: "\u044f",
    yo: "\u0451",
    ye: "\u0454",
    yi: "\u0457",
  },
  diacriticsMap = null;

function getDiacriticsMap() {
  if (null !== diacriticsMap) return diacriticsMap;
  diacriticsMap = {};
  Object.keys(diacritics).forEach(function (l) {
    for (var w = diacritics[l], h = 0; h < w.length; h++)
      diacriticsMap[w[h]] = l;
  });
  return diacriticsMap;
}

function getLatinCharacter(l) {
  var w = getDiacriticsMap()[l];
  return w ? w : l;
}

function removeCombiningMarks(l, w) {
  return w;
}

function latinise(l) {
  l = coerceToString(l);
  return "" === l
    ? ""
    : l
        .replace(REGEXP_NON_LATIN, getLatinCharacter)
        .replace(REGEXP_COMBINING_MARKS, removeCombiningMarks);
}

function pad(l, w, h) {
  l = coerceToString(l);
  w = isNil(w) ? 0 : clipNumber(toInteger(w), 0, MAX_SAFE_INTEGER);
  h = coerceToString(h, " ");
  if (w <= l.length) return l;
  var t = w - l.length;
  w = toInteger(t / 2);
  t %= 2;
  return buildPadding(h, w) + l + buildPadding(h, w + t);
}

function replace(l, w, h) {
  return coerceToString(l).replace(w, h);
}

function getRegExpFlags(l) {
  return l.toString().match(REGEXP_FLAGS)[0];
}

function includes(l, w, h) {
  l = coerceToString(l);
  w = toString(w);
  if (null === w) return !1;
  if ("" === w) return !0;
  h = isNil(h) ? 0 : clipNumber(toInteger(h), 0, l.length);
  return -1 !== l.indexOf(w, h);
}

function appendFlagToRegExp(l, w) {
  var h = getRegExpFlags(l);
  return includes(h, w) ? l : new RegExp(l.source, h + w);
}

function replaceAll(l, w, h) {
  l = coerceToString(l);
  var t = w;
  w instanceof RegExp
    ? w.global || (t = appendFlagToRegExp(w, "g"))
    : (t = new RegExp(escapeRegExp(w), "g"));
  return l.replace(t, h);
}

function reverse(l) {
  return coerceToString(l).split("").reverse().join("");
}

function reverseGrapheme(l) {
  l = coerceToString(l);
  l = l
    .replace(REGEXP_COMBINING_MARKS, function (t, a, d) {
      return reverseGrapheme(d) + a;
    })
    .replace(REGEXP_SURROGATE_PAIRS, "$2$1");
  for (var w = "", h = l.length; h--; ) w += l.charAt(h);
  return w;
}

function slugify(l) {
  l = coerceToString(l);
  if ("" === l) return "";
  l = latinise(l).replace(REGEXP_NON_LATIN, "-");
  return kebabCase(l);
}

function splice(l, w, h, t) {
  l = coerceToString(l);
  t = coerceToString(t);
  w = coerceToNumber(w);
  0 > w
    ? ((w = l.length + w), 0 > w && (w = 0))
    : w > l.length && (w = l.length);
  h = coerceToNumber(h, l.length - w);
  0 > h && (h = 0);
  return l.slice(0, w) + t + l.slice(w + h);
}
var _slicedToArray = (function () {
  return function (l, w) {
    if (Array.isArray(l)) return l;
    if (Symbol.iterator in Object(l)) {
      var h = [],
        t = !0,
        a = !1,
        d = void 0;
      try {
        for (
          var k = l[Symbol.iterator](), e;
          !(t = (e = k.next()).done) && (h.push(e.value), !w || h.length !== w);
          t = !0
        );
      } catch (b) {
        (a = !0), (d = b);
      } finally {
        try {
          if (!t && k["return"]) k["return"]();
        } finally {
          if (a) throw d;
        }
      }
      return h;
    }
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  };
})();

function tr(l, w, h) {
  l = coerceToString(l);
  isString(w) && isString(h)
    ? ((w = w.split("")), (h = h.split("")))
    : ((w = extractKeysAndValues(nilDefault(w, {}))),
      (h = _slicedToArray(w, 2)),
      (w = h[0]),
      (h = h[1]));
  var t = w.length;
  if (0 === t) return l;
  for (var a = "", d = h.length, k = 0; k < l.length; k++) {
    for (var e = !1, b = void 0, c = 0; c < t && c < d; c++) {
      var f = w[c];
      if (l.substr(k, f.length) === f) {
        e = !0;
        b = h[c];
        k = k + f.length - 1;
        break;
      }
    }
    a += e ? b : l[k];
  }
  return a;
}

function extractKeysAndValues(l) {
  var w = Object.keys(l),
    h = w.sort(sortStringByLength).map(function (t) {
      return l[t];
    });
  return [w, h];
}

function sortStringByLength(l, w) {
  return l.length === w.length ? 0 : l.length < w.length ? 1 : -1;
}
var reduce$1 = Array.prototype.reduce;

function trimLeft(l, w) {
  l = coerceToString(l);
  if ("" === w || "" === l) return l;
  var h = toString(w);
  if (isNil(h)) return l.replace(REGEXP_TRIM_LEFT, "");
  var t = !0;
  return reduce$1.call(
    l,
    function (a, d) {
      if (t && includes(h, d)) return a;
      t = !1;
      return a + d;
    },
    ""
  );
}
var reduceRight = Array.prototype.reduceRight;

function trimRight(l, w) {
  l = coerceToString(l);
  if ("" === w || "" === l) return l;
  var h = toString(w);
  if (isNil(h)) return l.replace(REGEXP_TRIM_RIGHT, "");
  var t = !0;
  return reduceRight.call(
    l,
    function (a, d) {
      if (t && includes(h, d)) return a;
      t = !1;
      return d + a;
    },
    ""
  );
}

function trim(l, w) {
  l = coerceToString(l);
  if ("" === w || "" === l) return l;
  w = toString(w);
  return isNil(w) ? l.trim() : trimRight(trimLeft(l, w), w);
}
var OPTION_WIDTH = "width",
  OPTION_NEW_LINE = "newLine",
  OPTION_INDENT = "indent",
  OPTION_CUT = "cut";

function wordWrap(l) {
  var w = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
    h = coerceToString(l),
    t = determineOptions(w);
  w = t.width;
  var a = t.newLine,
    d = t.indent;
  t = t.cut;
  if ("" === h || 0 >= w) return d;
  for (var k = h.length, e = h.substring.bind(h), b = 0, c = ""; k - b > w; )
    if (" " === h[b]) b++;
    else {
      var f = h.lastIndexOf(" ", w + b);
      f >= b
        ? ((c += d + e(b, f) + a), (b = f + 1))
        : t
        ? ((c += d + e(b, w + b) + a), (b += w))
        : ((f = h.indexOf(" ", w + b)),
          0 <= f
            ? ((c += d + e(b, f) + a), (b = f + 1))
            : ((c += d + e(b)), (b = k)));
    }
  b < k && (c += d + e(b));
  return c;
}

function determineOptions(l) {
  return {
    width: coerceToNumber(l[OPTION_WIDTH], 75),
    newLine: coerceToString(l[OPTION_NEW_LINE], "\n"),
    indent: coerceToString(l[OPTION_INDENT], ""),
    cut: coerceToBoolean(l[OPTION_CUT], !1),
  };
}

function endsWith(l, w, h) {
  if (isNil(w)) return !1;
  l = coerceToString(l);
  w = coerceToString(w);
  if ("" === w) return !0;
  h = isNil(h) ? l.length : clipNumber(toInteger(h), 0, l.length);
  h -= w.length;
  w = l.indexOf(w, h);
  return -1 !== w && w === h;
}

function isAlpha(l) {
  l = coerceToString(l);
  return REGEXP_ALPHA.test(l);
}

function isAlphaDigit(l) {
  l = coerceToString(l);
  return REGEXP_ALPHA_DIGIT.test(l);
}

function isBlank(l) {
  return 0 === coerceToString(l).trim().length;
}

function isDigit(l) {
  l = coerceToString(l);
  return REGEXP_DIGIT.test(l);
}

function isEmpty(l) {
  return 0 === coerceToString(l).length;
}

function isLowerCase(l) {
  l = coerceToString(l);
  return isAlpha(l) && l.toLowerCase() === l;
}

function isNumeric(l) {
  l = "object" !== typeof l || isNil(l) ? l : Number(l);
  return (
    ("number" === typeof l || "string" === typeof l) &&
    !isNaN(l - parseFloat(l))
  );
}

function isUpperCase(l) {
  l = coerceToString(l);
  return isAlpha(l) && l.toUpperCase() === l;
}

function matches(l, w, h) {
  l = coerceToString(l);
  h = coerceToString(h);
  if (!(w instanceof RegExp)) {
    w = toString(w);
    if (null === w) return !1;
    w = new RegExp(w, h);
  }
  return w.test(l);
}

function startsWith(l, w, h) {
  l = coerceToString(l);
  w = toString(w);
  if (null === w) return !1;
  if ("" === w) return !0;
  h = isNil(h) ? 0 : clipNumber(toInteger(h), 0, l.length);
  return l.substr(h, w.length) === w;
}

function chars(l) {
  return coerceToString(l).split("");
}

function codePoints(l) {
  l = coerceToString(l);
  for (var w = l.length, h = [], t = 0, a; t < w; )
    (a = codePointAt(l, t)), h.push(a), (t += 65535 < a ? 2 : 1);
  return h;
}

function graphemes(l) {
  l = coerceToString(l);
  return nilDefault(l.match(REGEXP_UNICODE_CHARACTER), []);
}

function split(l, w, h) {
  return coerceToString(l).split(w, h);
}
var BYRE_ORDER_MARK = "\ufeff";

function trim$1(l) {
  l = coerceToString(l);
  return "" === l ? "" : l[0] === BYRE_ORDER_MARK ? l.substring(1) : l;
}

function hasSubstringAtIndex(l, w, h) {
  var t = 0;
  if (3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1)
    t = -w.length + 1;
  return l.substr(h + t, w.length).toLowerCase() === w;
}

function parseTagList(l) {
  for (var w = [], h; null !== (h = REGEXP_TAG_LIST.exec(l)); ) w.push(h[1]);
  return w;
}
var STATE_START_TAG = 0,
  STATE_NON_WHITESPACE = 1,
  STATE_DONE = 2;

function parseTagName(l) {
  for (var w = STATE_START_TAG, h = "", t = 0; w !== STATE_DONE; ) {
    var a = l[t++].toLowerCase();
    switch (a) {
      case "<":
        break;
      case ">":
        w = STATE_DONE;
        break;
      default:
        REGEXP_WHITESPACE.test(a)
          ? w === STATE_NON_WHITESPACE && (w = STATE_DONE)
          : (w === STATE_START_TAG && (w = STATE_NON_WHITESPACE),
            "/" !== a && (h += a));
    }
  }
  return h;
}
var STATE_OUTPUT = 0,
  STATE_HTML = 1,
  STATE_EXCLAMATION = 2,
  STATE_COMMENT = 3;

function trim$2(l, w, h) {
  l = coerceToString(l);
  if ("" === l) return "";
  Array.isArray(w) ||
    ((w = coerceToString(w)), (w = "" === w ? [] : parseTagList(w)));
  h = coerceToString(h);
  for (
    var t = l.length,
      a = 0 < w.length,
      d = hasSubstringAtIndex.bind(null, l),
      k = STATE_OUTPUT,
      e = 0,
      b = "",
      c = "",
      f = null,
      g = 0;
    g < t;
    g++
  ) {
    var m = l[g],
      n = !1;
    switch (m) {
      case "<":
        if (f) break;
        if (d("< ", g, !1)) {
          n = !0;
          break;
        }
        if (k === STATE_OUTPUT) {
          n = !0;
          k = STATE_HTML;
          break;
        }
        if (k === STATE_HTML) {
          e++;
          break;
        }
        n = !0;
        break;
      case "!":
        if (k === STATE_HTML && d("<!", g)) {
          k = STATE_EXCLAMATION;
          break;
        }
        n = !0;
        break;
      case "-":
        if (k === STATE_EXCLAMATION && d("!--", g)) {
          k = STATE_COMMENT;
          break;
        }
        n = !0;
        break;
      case '"':
      case "'":
        k === STATE_HTML && (f === m ? (f = null) : f || (f = m));
        n = !0;
        break;
      case "E":
      case "e":
        if (k === STATE_EXCLAMATION && d("doctype", g)) {
          k = STATE_HTML;
          break;
        }
        n = !0;
        break;
      case ">":
        if (0 < e) {
          e--;
          break;
        }
        if (f) break;
        if (k === STATE_HTML) {
          f = null;
          k = STATE_OUTPUT;
          if (a) {
            c += ">";
            var q = parseTagName(c);
            b = -1 !== w.indexOf(q.toLowerCase()) ? b + c : b + h;
            c = "";
          } else b += h;
          break;
        }
        if (
          k === STATE_EXCLAMATION ||
          (k === STATE_COMMENT && d("--\x3e", g))
        ) {
          f = null;
          k = STATE_OUTPUT;
          c = "";
          break;
        }
        n = !0;
        break;
      default:
        n = !0;
    }
    if (n)
      switch (k) {
        case STATE_OUTPUT:
          b += m;
          break;
        case STATE_HTML:
          a && (c += m);
      }
  }
  return b;
}
var globalObject$1 = null;

function getGlobalObject() {
  return null !== globalObject$1
    ? globalObject$1
    : (globalObject$1 =
        "object" === typeof global && global.Object === Object
          ? global
          : "object" === typeof self && self.Object === Object
          ? self
          : new Function("return this")());
}
var globalObject = getGlobalObject(),
  previousV = globalObject.v;

function noConflict() {
  this === globalObject.v && (globalObject.v = previousV);
  return this;
}
var version = "1.4.0",
  functions = {
    camelCase,
    capitalize,
    decapitalize,
    kebabCase,
    lowerCase,
    snakeCase,
    swapCase,
    titleCase,
    upperCase,
    count,
    countGraphemes: countGrapheme,
    countSubstrings,
    countWhere,
    countWords,
    escapeHtml,
    escapeRegExp,
    unescapeHtml,
    sprintf,
    vprintf,
    indexOf,
    lastIndexOf,
    search,
    charAt,
    codePointAt,
    first,
    graphemeAt,
    last,
    prune,
    slice,
    substr,
    substring,
    truncate,
    insert,
    latinise,
    pad,
    padLeft,
    padRight,
    repeat,
    replace,
    replaceAll,
    reverse,
    reverseGrapheme,
    slugify,
    splice,
    tr,
    trim,
    trimLeft,
    trimRight,
    wordWrap,
    endsWith,
    includes,
    isAlpha,
    isAlphaDigit,
    isBlank,
    isDigit,
    isEmpty,
    isLowerCase,
    isNumeric,
    isString,
    isUpperCase,
    matches,
    startsWith,
    chars,
    codePoints,
    graphemes,
    split,
    words,
    stripBom: trim$1,
    stripTags: trim$2,
    noConflict,
    version,
  };

function ChainWrapper(l, w) {
  this._wrappedValue = l;
  this._explicitChain = w;
}
ChainWrapper.prototype.value = function () {
  return this._wrappedValue;
};
ChainWrapper.prototype.valueOf = function () {
  return this.value();
};
ChainWrapper.prototype.toJSON = function () {
  return this.value();
};
ChainWrapper.prototype.toString = function () {
  return String(this.value());
};
ChainWrapper.prototype.chain = function () {
  return new ChainWrapper(this._wrappedValue, !0);
};
ChainWrapper.prototype.thru = function (l) {
  return "function" === typeof l
    ? new ChainWrapper(l(this._wrappedValue), this._explicitChain)
    : this;
};
ChainWrapper.prototype._explicitChain = !0;

function makeFunctionChainable(l) {
  return function () {
    for (var w = arguments.length, h = Array(w), t = 0; t < w; t++)
      h[t] = arguments[t];
    w = l.apply(void 0, [this._wrappedValue].concat(h));
    return this._explicitChain || "string" === typeof w
      ? new ChainWrapper(w, this._explicitChain)
      : w;
  };
}
Object.keys(functions).forEach(function (l) {
  ChainWrapper.prototype[l] = makeFunctionChainable(functions[l]);
});

function chain(l) {
  return new ChainWrapper(l, !0);
}
var _extends =
  Object.assign ||
  function (l) {
    for (var w = 1; w < arguments.length; w++) {
      var h = arguments[w],
        t;
      for (t in h) Object.prototype.hasOwnProperty.call(h, t) && (l[t] = h[t]);
    }
    return l;
  };

function Voca(l) {
  return new ChainWrapper(l, !1);
}
_extends(Voca, functions, {
  chain,
});
const TWEEN_END_STATE = 26,
  TYPES = {
    SPRITE: "sprite",
    IMAGE: "image",
    SPINE: "spine",
    TEXT: "text",
    ZONE: "zone",
    PARTICLE: "particle",
  };
class OperateOnVisual {
  static GetDisplayedAsAny(l) {
    return VisualComponent.At(l).refDisplayed;
  }
  static GetDisplayed(l) {
    return VisualComponent.At(l).refDisplayed;
  }
  static GetDisplayedAsImage(l) {
    return VisualComponent.At(l).refDisplayed;
  }
  static GetDisplayedAsBitmapText(l) {
    return VisualComponent.At(l).refDisplayed;
  }
  static GetBottomY(l) {
    return OperateOnVisual.GetDisplayed(l).y + OperateOnVisual.GetHeight(l) / 2;
  }
  static GetHeight(l) {
    return OperateOnVisual.GetDisplayedAsImage(l).displayHeight;
  }
  static GetWidth(l) {
    return OperateOnVisual.GetDisplayedAsImage(l).displayWidth;
  }
  static IsImgOrSprite(l) {
    return VisualComponent.At(l).type == TYPES.IMAGE ||
      VisualComponent.At(l).type == TYPES.SPRITE
      ? !0
      : !1;
  }
  static IsSpine(l) {
    return VisualComponent.At(l).type == TYPES.SPINE ? !0 : !1;
  }
  static SpineListAttachmentsBySlots(l, w) {
    w = void 0 === w ? !1 : w;
    var h = OperateOnVisual.GetDisplayedAsAny(l);
    l = {};
    let t = h.skeletonData.defaultSkin.attachments;
    h = h.getSlotList();
    for (let d = 0; d < h.length; d++) {
      let k = h[d];
      var a = t[d];
      for (let e in a) (a = l[k]), a || ((a = []), (l[k] = a)), a.push(e);
    }
    if (w) return l;
  }
  static RandomizeAnimationTime(l) {
    l = OperateOnVisual.GetDisplayedAsAny(l).state.tracks[0];
    l.trackTime = Phaser.Math.FloatBetween(0, l.animationEnd);
  }
  static SpineSetAttachment(l, w, h) {
    OperateOnVisual.GetDisplayedAsAny(l).setAttachment(w, h);
  }
  static SetScale(l, w, h) {
    w = void 0 === w ? 1 : w;
    h = void 0 === h ? 1 : h;
    1 != w &&
      ((OperateOnVisual.GetDisplayedAsImage(l).scaleX = w),
      1 != h && (OperateOnVisual.GetDisplayedAsImage(l).scaleY = w));
    1 != h && (OperateOnVisual.GetDisplayedAsImage(l).scaleY = h);
  }
  static SetTextWithZeroPad(l, w, h) {
    w = Voca.padLeft(w, h, "0");
    OperateOnVisual.GetDisplayedAsBitmapText(l).setText(w);
  }
  static SetText(l, w) {
    OperateOnVisual.GetDisplayedAsBitmapText(l).setText(w);
  }
  static SortParentByProperty(l, w) {
    OperateOnVisual.GetDisplayedAsImage(l).parentContainer.sort(w);
  }
  static ReparentLayer(l, w, h) {
    h = void 0 === h ? {} : h;
    let t = VisualComponent.At(l);
    merge(t, h);
    t.layerName = w;
    PostProcessLayerName(t);
    var a = OperateOnVisual.GetDisplayedAsImage(l);
    w = BMEngine.GetOrMakeContainerLayer(
      t.layerData.layer,
      t.layerData.anchorX,
      t.layerData.anchorY,
      t.layerDepth
    );
    h = a.parentContainer;
    let d = a.x;
    a = a.y;
    d -= h.scene.cameras.main.scrollX;
    a -= h.scene.cameras.main.scrollY;
    d += w.scene.cameras.main.scrollX;
    a += w.scene.cameras.main.scrollY;
    d += h.x;
    a += h.y;
    d -= w.x;
    a -= w.y;
    OperateOnVisual.GetDisplayedAsImage(l).x = d;
    OperateOnVisual.GetDisplayedAsImage(l).y = a;
    w.add(t.refDisplayed);
  }
  static GetBounds(l) {
    const w = VisualComponent.At(l);
    return OperateOnVisual.IsSpine(l)
      ? ((l = OperateOnVisual.GetDisplayedAsAny(l).getBounds()),
        w._boundCache.setTo(l.offset.x, l.offset.y, l.size.x, l.size.y),
        w._boundCache)
      : OperateOnVisual.GetDisplayedAsImage(l).getBounds(w._boundCache);
  }
  static GetParticles(l) {
    return VisualComponent.At(l).refDisplayed;
  }
}

function PostProcessLayerName(l) {
  if (0 < Voca.countSubstrings(l.layerName, "_")) {
    const w = Voca.split(l.layerName, "_");
    l.layerData.layer = w[0];
    l.layerData.anchorX = parseInt(Voca.charAt(w[1], 0));
    l.layerData.anchorY = parseInt(Voca.charAt(w[1], 1));
  } else
    (l.layerData.layer = l.layerName),
      (l.layerData.anchorX = 1),
      (l.layerData.anchorY = 1);
}
class VisualComponent extends Component {
  constructor(l) {
    super(null);
    this._boundCache = new Phaser.Geom.Rectangle(0, 0, 1, 1);
    this.texture = this.type = null;
    this.animations = {};
    this.curAnimationCfg = this.curAnimation = null;
    this.curAnimationFinishCount = 0;
    this.emitterConfig = null;
    this.layerName = "gameplay";
    this.layerDepth = this.selfDepth = 0;
    this.scale = 1;
    this.layerData = {
      layer: "gameplay",
      x: 1,
      y: 1,
    };
    this.tweens = {
      position: null,
      scale: null,
      alpha: null,
    };
    this.refDisplayed = null;
    const w = JSON.parse(JSON.stringify(this.constructor.properties));
    Object.assign(this, w, l);
  }
  static At(l) {
    return l.visual;
  }
  onAttached(l) {
    super.onAttached(l);
    PostProcessLayerName(this);
    let w = BMEngine.GetOrMakeContainerLayer(
      this.layerData.layer,
      this.layerData.anchorX,
      this.layerData.anchorY,
      this.layerDepth
    );
    var h = w.scene;
    if (this.type == TYPES.IMAGE)
      var t = BMEngine.GetPhaserGame().textures.exists(this.texture)
        ? h.make.image(
            {
              x: 0,
              y: 0,
              key: this.texture,
              add: !0,
            },
            !1
          )
        : h.make.image(
            {
              x: 0,
              y: 0,
              key: "megaset",
              frame: this.texture,
              add: !0,
            },
            !1
          );
    else
      this.type == TYPES.SPINE
        ? (null == this.animations &&
            ((this.animations = {
              Idle: {
                loop: !0,
              },
            }),
            (this.curAnimation = "Idle")),
          (t = h.make.spine(
            {
              x: 0,
              y: 0,
              key: this.texture,
              animationName: this.curAnimation,
              loop: this.animations[this.curAnimation].loop,
              add: !1,
            },
            !1
          )),
          t.state.addListener({
            complete: (a) => {
              a.animation.name;
              this.curAnimationCfg &&
                (0 == this.curAnimationCfg.loop &&
                  0 >= this.curAnimationFinishCount &&
                  this.curAnimationFinishCount++,
                this.curAnimationCfg.onAnimationLoopedCmd &&
                  ((this.curAnimationCfg.onAnimationLoopedCmd.entity =
                    this.entity),
                  GameCommandsRegistry.runCommandObj(
                    this.curAnimationCfg.onAnimationLoopedCmd
                  )));
            },
          }))
        : this.type == TYPES.TEXT
        ? ((t = this.text),
          null == t && (this.text = t = "000000"),
          (t = h.make.bitmapText(
            {
              x: 0,
              y: 0,
              font: this.texture,
              text: t,
              add: !0,
            },
            !1
          )),
          t.setOrigin(0.5, 0.5))
        : this.type == TYPES.ZONE
        ? (null == this.width && (this.width = 100),
          null == this.height && (this.height = 100),
          (t = h.make.zone({
            x: 0,
            y: 0,
            width: this.width,
            height: this.height,
            add: !0,
          })))
        : this.type == TYPES.PARTICLE &&
          ((t = this.emitterConfig),
          (h = h.add.particles(this.texture)),
          h.createEmitter(t),
          (t = h));
    t.setScale(this.scale);
    this.refDisplayed = t;
    w.add(t);
    t.selfEntity = l;
    0 != this.selfDepth &&
      (t.setDepth(this.selfDepth),
      OperateOnVisual.SortParentByProperty(this.entity, "depth"));
  }
  bringToTop() {
    OperateOnVisual.GetDisplayedAsImage(this.entity).parentContainer.bringToTop(
      OperateOnVisual.GetDisplayedAsImage(this.entity)
    );
  }
  setTexture(l) {
    if (OperateOnVisual.IsImgOrSprite(this.entity)) {
      const w = OperateOnVisual.GetDisplayedAsImage(this.entity);
      BMEngine.GetPhaserGame().textures.exists(l)
        ? w.setTexture(l)
        : w.setTexture("megaset", l);
    }
  }
  setAnimation(l, w) {
    w = void 0 === w ? null : w;
    if (OperateOnVisual.IsImgOrSprite(this.entity))
      (this.curAnimation = l),
        this.setTexture(this.animations[this.curAnimation].texture);
    else if (OperateOnVisual.IsSpine(this.entity)) {
      var h = !1;
      this.curAnimation == l && (h = !0);
      this.animations[l] &&
        0 == this.animations[l].loop &&
        1 <= this.curAnimationFinishCount &&
        (h = !1);
      h ||
        ((this.curAnimation = l),
        (this.curAnimationFinishCount = 0),
        (h = {}),
        this.animations[l] && merge(h, this.animations[l]),
        w && merge(h, w),
        null == h.loop && (h.loop = !0),
        (this.curAnimationCfg = h),
        this.refDisplayed.setAnimation(0, l, h.loop));
    } else console.warn("IMPLEMENT HERE!");
  }
  getAnimationName() {
    return this.curAnimation;
  }
  getDisplayedAsImage() {
    return this.refDisplayed;
  }
  getDisplayedAsZone() {
    return this.refDisplayed;
  }
  getEmitter() {
    return this.refDisplayed.emitters.list[0];
  }
  isDisplayedOnScreen(l) {
    var w = this.getDisplayedAsImage();
    l = OperateOnVisual.GetBounds(this.entity);
    w = w.scene.cameras.main.worldView;
    let h;
    0 == OperateOnVisual.IsSpine(this.entity)
      ? ((h = !0),
        l.y + l.height < w.y && (h = !1),
        l.y > w.bottom && (h = !1),
        l.x + l.width < w.x && (h = !1),
        l.x > w.width && (h = !1))
      : ((h = !0),
        (l.x = this.refDisplayed.x),
        (l.y = this.refDisplayed.y),
        l.y + l.height < w.y && (h = !1),
        l.y - l.height > w.y + w.height && (h = !1),
        l.x + l.width < w.x && (h = !1),
        l.x - l.width > w.right && (h = !1));
    return h;
  }
  setFlipX(l) {
    const w = this.getDisplayedAsImage();
    OperateOnVisual.IsSpine(this.entity)
      ? l
        ? 0 <= w.scaleX && (w.scaleX *= -1)
        : 0 >= w.scaleX && (w.scaleX *= -1)
      : w.setFlipX(l);
  }
  setFlipY(l) {
    const w = this.getDisplayedAsImage();
    OperateOnVisual.IsSpine(this.entity)
      ? l
        ? 0 <= w.scaleY && (w.scaleY *= -1)
        : 0 >= w.scaleY && (w.scaleY *= -1)
      : w.setFlipY(l);
  }
  disposePositionTween() {
    this.tweens.position &&
      (this.tweens.position.stop(0),
      this.tweens.position.remove(),
      (this.tweens.position = null));
  }
  disposeAllTweens() {
    this.disposePositionTween();
    this.tweens.scale &&
      (this.tweens.scale.stop(0),
      this.tweens.scale.remove(),
      (this.tweens.scale = null));
    this.tweens.alpha &&
      (this.tweens.alpha.stop(0),
      this.tweens.alpha.remove(),
      (this.tweens.alpha = null));
  }
  fastTrackPosition(l) {
    l = this.tweens;
    if (l.position) {
      let w = l.position;
      if (w.state != TWEEN_END_STATE) {
        w.stop();
        w.remove();
        for (let h = 0; h < w.data.length; h++) {
          let t = w.data[h];
          t.target[t.key] = t.end;
        }
      }
      l.position = null;
    }
  }
  tweenPosition(l) {
    const w = this.tweens;
    w.position &&
      (w.position.state != TWEEN_END_STATE && w.position.stop(),
      w.position.remove(),
      (w.position = null));
    l.targets = OperateOnVisual.GetDisplayedAsImage(this.entity);
    w.position = OperateOnVisual.GetDisplayedAsImage(
      this.entity
    ).scene.tweens.add(l);
  }
  isTweeningPosition() {
    const l = this.tweens;
    return l.position ? (l.position.state != TWEEN_END_STATE ? !0 : !1) : !1;
  }
  isTweeningScale() {
    const l = this.tweens;
    return l.scale ? (l.scale.state != TWEEN_END_STATE ? !0 : !1) : !1;
  }
  tweenScale(l, w) {
    w = void 0 === w ? null : w;
    const h = this.tweens;
    h.scale &&
      (h.scale.state != TWEEN_END_STATE && h.scale.stop(),
      h.scale.remove(),
      (h.scale = null));
    l.targets = OperateOnVisual.GetDisplayedAsImage(this.entity);
    null == w
      ? (h.scale = OperateOnVisual.GetDisplayedAsImage(
          this.entity
        ).scene.tweens.add(l))
      : OperateOnVisual.GetDisplayedAsImage(this.entity).scene.tweens.add(l);
  }
  tweenAlpha(l) {
    const w = this.tweens;
    w.alpha &&
      (w.alpha.state != TWEEN_END_STATE && w.alpha.stop(),
      w.alpha.remove(),
      (w.alpha = null));
    l.targets = OperateOnVisual.GetDisplayedAsImage(this.entity);
    w.alpha = OperateOnVisual.GetDisplayedAsImage(this.entity).scene.tweens.add(
      l
    );
  }
  getSpineSlotsList(l) {
    l = void 0 === l ? !1 : l;
    const w = this.refDisplayed.getSlotList();
    if (l) return w;
  }
  getSpineAnimationList(l) {
    l = void 0 === l ? !1 : l;
    const w = [],
      h = OperateOnVisual.GetDisplayedAsAny(this.entity);
    for (var t = 0; t < h.stateData.skeletonData.animations.length; t++)
      w.push(h.stateData.skeletonData.animations[t].name);
    if (l) return w;
  }
  spineRandomizeSlotsAttachments(l) {
    OperateOnVisual.GetDisplayedAsAny(this.entity);
    for (let h = 0; h < l.length; h++) {
      let t = l[h];
      var w = OperateOnVisual.SpineListAttachmentsBySlots(this.entity, !1)[t];
      w = Phaser.Utils.Array.GetRandom(w);
      OperateOnVisual.SpineSetAttachment(this.entity, t, w);
    }
  }
  onDestroyed(l) {
    this.refDisplayed &&
      (this.disposeAllTweens(),
      (this.refDisplayed.selfEntity = null),
      this.refDisplayed.destroy(),
      (this.refDisplayed = null));
  }
  static get properties() {
    return {};
  }
}
class VisualTemplates {
  static DefaultImage(l, w) {
    w = void 0 === w ? null : w;
    l = {
      type: TYPES.IMAGE,
      texture: void 0 === l ? "_NONE" : l,
    };
    w && merge(l, w);
    return l;
  }
  static DefaultSpine(l, w) {
    w = void 0 === w ? null : w;
    l = {
      type: TYPES.SPINE,
      texture: void 0 === l ? "_NONE" : l,
    };
    w && merge(l, w);
    return l;
  }
  static DefaultText(l, w) {
    w = void 0 === w ? null : w;
    l = {
      type: TYPES.TEXT,
      texture: void 0 === l ? "_NONE" : l,
    };
    w && merge(l, w);
    return l;
  }
  static DefaultParticle(l, w) {
    w = void 0 === w ? null : w;
    l = {
      type: TYPES.PARTICLE,
      texture: void 0 === l ? "_NONE" : l,
    };
    w && merge(l, w);
    return l;
  }
  static DefaultZone(l) {
    l = void 0 === l ? null : l;
    let w = {
      type: TYPES.ZONE,
    };
    l && merge(w, l);
    return w;
  }
}
const _RepositionEntityBySizeAction = class {
  static RegisterPackedAsGameCommand() {
    GameCommandsRegistry.register(
      this.Name,
      new GameCommand((l) => {
        _RepositionEntityBySizeAction.Take(l.entity, l.multX, l.multY);
      })
    );
  }
  static Take(l, w, h) {
    w = void 0 === w ? null : w;
    h = void 0 === h ? null : h;
    null == w && (w = 0);
    null == h && (h = 0);
    const t = TransformComponent.At(l);
    l = OperateOnVisual.GetDisplayed(l);
    t.refTarget.x += l.displayWidth * w;
    t.refTarget.y += l.displayHeight * h;
  }
};
let RepositionEntityBySizeAction = _RepositionEntityBySizeAction;
__publicField(RepositionEntityBySizeAction, "Name", "RepositionEntityToAction");
const _SetEntityAnimationAction = class {
  static RegisterPackedAsGameCommand() {
    GameCommandsRegistry.register(
      this.Name,
      new GameCommand((l) => {
        _SetEntityAnimationAction.Take(l.entity, l.animationName, l);
      })
    );
  }
  static Take(l, w, h) {
    VisualComponent.At(l).setAnimation(w, h);
  }
};
let SetEntityAnimationAction = _SetEntityAnimationAction;
__publicField(SetEntityAnimationAction, "Name", "SetEntityAnimationAction");
class ToggleComponent extends Component {
  constructor(l) {
    super(null);
    this.states = this.curStateName = null;
    const w = JSON.parse(JSON.stringify(this.constructor.properties));
    Object.assign(this, w, l);
  }
  synchAnimationToState() {
    SetEntityAnimationAction.Take(this.entity, this.curStateName);
  }
  setToggleStateAsNext() {
    this.curStateName = this.states[this.curStateName].nextState;
    this.synchAnimationToState();
  }
  runCommandsAtCurrentState() {
    GameCommandsRegistry.runCommandObj(
      merge(
        {
          entity: this.entity,
        },
        this.states[this.curStateName].command
      )
    );
  }
  setToggleState(l) {
    this.curStateName = l;
    this.synchAnimationToState();
  }
  static At(l) {
    console.assert(null != l, l);
    console.assert(null != l.toggle, l);
    return l.toggle;
  }
  static get properties() {
    return {};
  }
  static AddWithToggleStatesDictionary(l, w, h) {
    l.add(ToggleComponent, {
      curStateName: w,
      states: h,
    });
  }
}
class InternalDataClass$7 {
  constructor() {
    this.groups = {};
    this.colliders = {};
  }
}
const InternalData$9 = new InternalDataClass$7(),
  _PhysicsModel = class {
    static GetGroup(l) {
      return InternalData$9.groups[l]
        ? InternalData$9.groups[l]
        : (console.warn("NO GROUP: ", l), null);
    }
    static PhysicsAddCollider(l, w, h, t) {
      if (!InternalData$9.colliders[l]) {
        var a = _PhysicsModel.GetGroup(w),
          d = _PhysicsModel.GetGroup(h);
        a = BMEngine.GetGameplayScene().physics.add.collider(a, d, t, null);
        InternalData$9.colliders[l] = {
          group1: w,
          group2: h,
          callbackFn: t,
          collider: a,
        };
      }
    }
    static PhysicsAddOverlap(l, w, h, t) {
      if (!InternalData$9.colliders[l]) {
        var a = _PhysicsModel.GetGroup(w),
          d = _PhysicsModel.GetGroup(h);
        a = BMEngine.GetGameplayScene().physics.add.overlap(a, d, t, null);
        InternalData$9.colliders[l] = {
          group1: w,
          group2: h,
          callbackFn: t,
          collider: a,
        };
      }
    }
    static OverlapGroupsByNames(l, w, h, t, a) {
      console.assert(h);
      l = _PhysicsModel.GetGroup(l);
      w = _PhysicsModel.GetGroup(w);
      l &&
        w &&
        BMEngine.GetGameplayScene().physics.world.overlap(l, w, h, t, a);
    }
    static OverlapObjects(l, w, h, t, a) {
      return BMEngine.GetGameplayScene().physics.world.overlap(l, w, h, t, a);
    }
  };
let PhysicsModel = _PhysicsModel;
__publicField(PhysicsModel, "AddGroup", function (l, w) {
  if (!InternalData$9.groups[l])
    return (
      (InternalData$9.groups[l] = (void 0 === w ? 0 : w)
        ? BMEngine.GetGameplayScene().physics.add.staticGroup()
        : BMEngine.GetGameplayScene().physics.add.group()),
      InternalData$9.groups[l]
    );
});
const InternalData$8 = new DataHolder();
class LogicLoopRoutine {
  static Init() {}
  static OnRegister() {}
  static Register() {
    RoutinesManager.RegisterRoutine(LogicLoopRoutine);
  }
  static GetName() {
    return "LogicLoopRoutine";
  }
  static Update(l) {
    const w = InternalData$8.getKeyList();
    for (let h = 0; h < w.length; h++) InternalData$8.getData(w[h]).f(l);
  }
  static SetUpdateFunc(l, w) {
    InternalData$8.register(
      l,
      {
        f: w,
      },
      !0
    );
  }
  static CleanFunction(l) {
    InternalData$8.register(
      l,
      {
        f: () => {},
      },
      !0
    );
  }
}

function DeltaScaled(l) {
  return l / 1e3;
}
class GameSession {
  constructor() {
    this.initialized = this.seenTutorial = !1;
  }
}
class GameSubsession {
  constructor() {
    this.latestScore = this.score = 0;
  }
}
class PandaJumpGameLevelData {
  constructor() {
    this.levelLoopStarted = this.levelLoopEnded = !1;
    this.activeLevelTime = 0;
    this.highestPlatformY = 9999999999;
    this.difficulty = 1;
    this.totalSpawnedPlatform = this.toNextSpring = 0;
    this.touchedFirst = !1;
  }
}
class PandaJumpGlobals {
  constructor() {
    this.session = new GameSession();
    this.subsession = new GameSubsession();
    this.currentLevelData = new PandaJumpGameLevelData();
  }
  ResetLevelData() {
    this.currentLevelData = new PandaJumpGameLevelData();
  }
  ResetSubsession() {
    this.subsession = new GameSubsession();
  }
}
const PandaJumpGlobalsInstance = new PandaJumpGlobals();
class OperateOnPhysics {
  static GetBodyAsDynamic(l) {
    return l.physics.body;
  }
  static GetBodyAsStatic(l) {
    return l.physics.body;
  }
  static PutIntoPhysicsGroups(l) {
    const w = PhysicsComponent.At(l);
    for (let h = 0; h < w.groupsList.length; h++) {
      let t = w.groupsList[h];
      const a = PhysicsModel.GetGroup(t);
      a || console.warn("NO GROUP: ", t);
      a.add(l.physics.body.gameObject);
    }
  }
  static DisableBody(l) {
    l.physics.body.stop();
    l.physics.body.enable = !1;
    l.physics.body.gameObject.active = !1;
  }
}
class PhysicsComponent extends Component {
  constructor(l) {
    super(null);
    this.isCircle = this.isStatic = !1;
    this.groupsList = [];
    this.circleRadius = this.offsetY = this.offsetX = 0;
    this.bullet = this.body = this.bulletData = null;
    const w = JSON.parse(JSON.stringify(this.constructor.properties));
    Object.assign(this, w, l);
  }
  getBodyAsDynamic() {
    return this.body;
  }
  setSizeScaled(l) {
    var w = this.getBodyAsDynamic().sourceWidth * l;
    l *= this.getBodyAsDynamic().sourceHeight;
    this.getBodyAsDynamic().setSize(w, l, !0);
  }
  resizeTo(l, w, h, t) {
    h = void 0 === h ? null : h;
    t = void 0 === t ? null : t;
    this.isCircle
      ? console.warn("IMPLEMENT!")
      : (this.body.setSize(l, w),
        null != h && (this.offsetX = h),
        null != t && (this.offsetY = t),
        this.body.setOffset(this.offsetX, this.offsetY));
  }
  resizeDeltaOwnSize(l, w, h, t) {
    this.isCircle
      ? console.warn("IMPLEMENT!")
      : this.resizeTo(this.body.width + l, this.body.height + w, h, t);
  }
  static get properties() {
    return {};
  }
  static At(l) {
    return l.physics;
  }
  static AddToEntity(l, w) {
    l.add(PhysicsComponent, w);
  }
  static AddToEntityWithBulletBehaviour(l, w) {
    let h = {
      bulletData: {
        speed: 100,
        rotateToTarget: !0,
        enable: !0,
      },
    };
    merge(h, w);
    l.has(PhysicsComponent) || PhysicsComponent.AddToEntity(l, h);
  }
  static BootBody(l) {
    const w = PhysicsComponent.At(l);
    if (w.isCircle) {
      var h = w.body.halfWidth - w.circleRadius;
      let t = w.body.halfWidth - w.circleRadius;
      w.body.setCircle(w.circleRadius);
      w.body.setOffset(h + w.offsetX, t + w.offsetY);
    } else
      w.body.setSize(w.body.width, w.body.height),
        w.body.setOffset(w.offsetX, w.offsetY);
    w.bulletData &&
      ((h = BMEngine.GetGameplayScene().plugins.get("rexBullet")),
      (w.bullet = h.add(w.body.gameObject, w.bulletData)));
    OperateOnPhysics.PutIntoPhysicsGroups(l);
  }
}
const BuildCommand = (l, w) =>
  merge(
    {
      key: l,
    },
    w
  );

function CmdTweenScaleTo(l, w, h) {
  h = void 0 === h ? null : h;
  if (l && !l.isDestroyed) {
    var t = {
      scale: 1,
      duration: 1e3,
      delay: 0,
      ease: "Cubic.InOut",
    };
    merge(t, w);
    VisualComponent.At(l).tweenScale(t, h);
  }
}
const _ButtonInteractionAction = class {
  static RegisterPackedAsGameCommand() {
    GameCommandsRegistry.register(
      this.Name,
      new GameCommand((l) => {
        _ButtonInteractionAction.Take(l.entity, l.reason);
      })
    );
  }
  static Take(l, w) {
    "over" == w
      ? CmdTweenScaleTo(l, {
          scale: 1.1,
          duration: 100,
        })
      : "out" == w
      ? CmdTweenScaleTo(l, {
          scale: 1,
          duration: 100,
        })
      : "up" == w
      ? (BMEngine.PlayAudioFile("tap"),
        CmdTweenScaleTo(l, {
          scale: 1,
          duration: 100,
        }))
      : "down" == w &&
        CmdTweenScaleTo(l, {
          scale: 0.9,
          duration: 100,
        });
  }
};
let ButtonInteractionAction = _ButtonInteractionAction;
__publicField(ButtonInteractionAction, "Name", "ButtonInteractionAction");
const _BasicInteractionAction = class {
  static RegisterPackedAsGameCommand() {
    GameCommandsRegistry.register(
      this.Name,
      new GameCommand((l) => {
        _BasicInteractionAction.Take(l.entity, l.reason);
      })
    );
  }
  static Take(l, w) {
    "over" == w
      ? CmdTweenScaleTo(l, {
          scale: 1.1,
          duration: 100,
        })
      : "out" == w
      ? CmdTweenScaleTo(l, {
          scale: 1,
          duration: 100,
        })
      : "up" == w
      ? CmdTweenScaleTo(l, {
          scale: 1,
          duration: 100,
        })
      : "down" == w &&
        CmdTweenScaleTo(l, {
          scale: 0.9,
          duration: 100,
        });
  }
};
let BasicInteractionAction = _BasicInteractionAction;
__publicField(BasicInteractionAction, "Name", "BasicInteractionAction");
class Interactive extends Component {
  constructor(l) {
    super(null);
    this.pressed = this.canSwipe = this.canDrag = this.isDisabled = !1;
    this.dict = {};
    this.swipeCfg = this.onSwipeCmdName = null;
    this.runtime = {
      rexSwipe: null,
    };
    this.refHitArea = null;
    const w = JSON.parse(JSON.stringify(this.constructor.properties));
    Object.assign(this, w, l);
  }
  setEnabled(l) {
    this.isDisabled = !l;
  }
  resizeInputAreaAsRectangle(l, w, h, t) {
    h = void 0 === h ? null : h;
    t = void 0 === t ? null : t;
    this.refHitArea.setSize(l, w);
    null != h && (this.refHitArea.x = h);
    null != t && (this.refHitArea.y = t);
  }
  debugInput() {
    const l = VisualComponent.At(this.entity).getDisplayedAsImage();
    l.scene.input.enableDebug(l);
  }
  static At(l) {
    return l.interactive;
  }
  static AddPlain(l, w, h, t, a, d) {
    if (l.has(Interactive)) console.warn("CANT ADD COMPONENT SECOND TIME");
    else {
      var k = {};
      h && (k.up = BuildCommand(h));
      w && (k.down = BuildCommand(w));
      t && (k.over = BuildCommand(t));
      a && (k.move = BuildCommand(a));
      d && (k.always = BuildCommand(d));
      l.add(Interactive, GetInitialData(k));
    }
  }
  static AddWithCmdOnUpAndBtnInteraction(l, w, h) {
    h = void 0 === h ? null : h;
    if (l.has(Interactive)) console.warn("CANT ADD COMPONENT SECOND TIME");
    else {
      var t = {};
      null == h && (h = ButtonInteractionAction.Name);
      h && (t.always = BuildCommand(h));
      t.up = BuildCommand(w);
      l.add(Interactive, GetInitialData(t));
    }
  }
  static AddWithDrag(l, w, h, t) {
    w = void 0 === w ? null : w;
    h = void 0 === h ? null : h;
    t = void 0 === t ? null : t;
    if (l.has(Interactive)) console.warn("CANT ADD COMPONENT SECOND TIME");
    else {
      var a = {};
      null == t && (t = ButtonInteractionAction.Name);
      t && (a.always = BuildCommand(t));
      w && (a.down = BuildCommand(w));
      h && (a.up = BuildCommand(h));
      l.add(
        Interactive,
        GetInitialData(a, {
          canDrag: !0,
        })
      );
    }
  }
  static AddWithSwipe(l, w, h, t) {
    h = void 0 === h ? {} : h;
    t = void 0 === t ? null : t;
    if (l.has(Interactive)) console.warn("CANT ADD COMPONENT SECOND TIME");
    else {
      var a = {};
      null == t && (t = BasicInteractionAction.Name);
      t && (a.always = BuildCommand(t));
      l.add(
        Interactive,
        GetInitialData(a, {
          canSwipe: !0,
          onSwipeCmdName: w,
          swipeCfg: h,
        })
      );
    }
  }
  static get properties() {
    return {};
  }
}

function GetInitialData(l, w) {
  w = void 0 === w ? null : w;
  l = {
    dict: l,
  };
  w && merge(l, w);
  return l;
}
const _DisposeEntityAction = class {
  static RegisterPackedAsGameCommand() {
    GameCommandsRegistry.register(
      this.Name,
      new GameCommand((l) => {
        _DisposeEntityAction.Take(l.entity);
      })
    );
  }
  static Take(l) {
    EndOfLoopRoutine.QueueActorToDisposeBuffer(l);
  }
};
let DisposeEntityAction = _DisposeEntityAction;
__publicField(DisposeEntityAction, "Name", "DisposeEntityAction");
class CommonGamePrefabs {
  constructor() {
    this.EmptyObject = (l) => GeoticManager.CreateEntity(l);
    this.GuiImageObject = (l, w, h, t) => {
      h = void 0 === h ? "gui_22" : h;
      t = void 0 === t ? null : t;
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage(w, {
          layerName: h,
        })
      );
      "bottom" == t
        ? CommandsComponent.AddWithData(l, {
            postmake: BuildCommand("TweenPositionFromBottom"),
            exit: BuildCommand("TweenPositionToBottom"),
          })
        : "top" == t
        ? CommandsComponent.AddWithData(l, {
            postmake: BuildCommand("TweenPositionFromTop"),
            exit: BuildCommand("TweenPositionToTop"),
          })
        : null != t &&
          (t.postmake &&
            CommandsComponent.AddWithData(l, {
              postmake: BuildCommand(t.postmake),
            }),
          t.exit &&
            CommandsComponent.AddWithData(l, {
              exit: BuildCommand(t.exit),
            }));
      return l;
    };
    this.GuiSpineObject = (l, w, h, t, a, d, k) => {
      h = void 0 === h ? "Idle" : h;
      t = void 0 === t ? 0 : t;
      a = void 0 === a ? 0 : a;
      d = void 0 === d ? "gui_22" : d;
      k =
        void 0 === k
          ? {
              layerDepth: 0,
            }
          : k;
      console.assert(null != l);
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l, t, a);
      h = {
        curAnimation: h,
        animations: {
          [h]: {
            loop: !0,
          },
        },
        layerName: d,
      };
      merge(h, k);
      w = VisualTemplates.DefaultSpine(w, h);
      l.add(VisualComponent, w);
      return l;
    };
    this.GuiButtonObject = (l, w, h, t, a) => {
      t = void 0 === t ? "gui_22" : t;
      a = void 0 === a ? null : a;
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage(w, {
          layerName: t,
        })
      );
      "bottom" == a &&
        CommandsComponent.AddWithData(l, {
          postmake: BuildCommand("TweenPositionFromBottom"),
          exit: BuildCommand("TweenPositionToBottom"),
        });
      Interactive.AddWithCmdOnUpAndBtnInteraction(l, h);
      return l;
    };
    this.GuiFont = (l, w, h) => {
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultText(w, {
          layerName: h,
        })
      );
      return l;
    };
    this.GameplayImageObject = (l, w, h, t, a) => {
      h = void 0 === h ? 0 : h;
      t = void 0 === t ? 0 : t;
      a = void 0 === a ? {} : a;
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l, h, t);
      l.add(VisualComponent, VisualTemplates.DefaultImage(w, a));
      return l;
    };
    this.GameplayZoneObject = (l, w, h, t) => {
      w = void 0 === w ? 0 : w;
      h = void 0 === h ? 0 : h;
      t = void 0 === t ? {} : t;
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l, w, h);
      l.add(VisualComponent, VisualTemplates.DefaultZone(t));
      return l;
    };
    this.GameplaySpineObject = (l, w, h, t, a, d) => {
      h = void 0 === h ? "Idle" : h;
      t = void 0 === t ? 0 : t;
      a = void 0 === a ? 0 : a;
      d =
        void 0 === d
          ? {
              layerDepth: 0,
            }
          : d;
      console.assert(null != l);
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l, t, a);
      h = {
        curAnimation: h,
        animations: {
          [h]: {
            loop: !0,
          },
        },
      };
      merge(h, d);
      l.add(VisualComponent, VisualTemplates.DefaultSpine(w, h));
      return l;
    };
    this.GameplaySpineObjectDieAfterAnim = (l, w, h, t, a, d) => {
      h = void 0 === h ? "Idle" : h;
      t = void 0 === t ? 0 : t;
      a = void 0 === a ? 0 : a;
      d =
        void 0 === d
          ? {
              layerDepth: 0,
            }
          : d;
      let k = {
        curAnimation: h,
        layerDepth: 0,
        animations: {
          [h]: {
            loop: !1,
            onAnimationLoopedCmd: BuildCommand(DisposeEntityAction.Name, {}),
          },
        },
      };
      merge(k, d);
      return this.GameplaySpineObject(l, w, h, t, a, k);
    };
    this.GameplayTextObject = (l, w, h, t, a) => {
      h = void 0 === h ? 0 : h;
      t = void 0 === t ? 0 : t;
      a = void 0 === a ? null : a;
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l, h, t);
      l.add(VisualComponent, VisualTemplates.DefaultText(w, a));
      return l;
    };
    this.GameplayParticleObject = (l, w, h, t, a) => {
      h = void 0 === h ? 0 : h;
      t = void 0 === t ? 0 : t;
      a = void 0 === a ? {} : a;
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l, h, t);
      l.add(VisualComponent, VisualTemplates.DefaultParticle(w, a));
      return l;
    };
  }
}
const _RunEntityToggleLogic = class {
  static RegisterPackedAsGameCommand() {
    GameCommandsRegistry.register(
      this.Name,
      new GameCommand((l) => {
        _RunEntityToggleLogic.Take(l.entity);
      })
    );
  }
  static Take(l) {
    l = ToggleComponent.At(l);
    l.runCommandsAtCurrentState();
    l.setToggleStateAsNext();
  }
};
let RunEntityToggleLogic = _RunEntityToggleLogic;
__publicField(RunEntityToggleLogic, "Name", "RunEntityToggleLogic");
const _GlobalMuteAudioAction = class {
  static RegisterPackedAsGameCommand() {
    GameCommandsRegistry.register(
      this.Name,
      new GameCommand((l) => {
        _GlobalMuteAudioAction.Take();
      })
    );
  }
  static Take() {
    BMEngine.UserMuteAudio();
  }
};
let GlobalMuteAudioAction = _GlobalMuteAudioAction;
__publicField(GlobalMuteAudioAction, "Name", "GlobalMuteAudioAction");
const _GlobalUnmuteAudioAction = class {
  static RegisterPackedAsGameCommand() {
    GameCommandsRegistry.register(
      this.Name,
      new GameCommand((l) => {
        _GlobalUnmuteAudioAction.Take();
      })
    );
  }
  static Take() {
    BMEngine.UserUnmuteAudio();
  }
};
let GlobalUnmuteAudioAction = _GlobalUnmuteAudioAction;
__publicField(GlobalUnmuteAudioAction, "Name", "GlobalUnmuteAudioAction");
class CasualGameSharedPrefabs extends CommonGamePrefabs {
  constructor() {
    super();
    this.Background = (l) => {
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(VisualComponent, VisualTemplates.DefaultImage("BG"));
      return l;
    };
    this.CoverTitle = (l) => {
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage("GameTitle", {
          layerName: "gui_22",
        })
      );
      CommandsComponent.AddWithData(l, {
        postmake: BuildCommand("TweenCoverTitle"),
        exit: BuildCommand("TweenPositionToTop"),
      });
      return l;
    };
    this.CoverLogo = (l, w) => {
      l = this.GuiImageObject(l, "BM_Logo", w);
      let h = "TweenPositionFromTop",
        t = "TweenPositionToTop";
      "gui_33" == w &&
        ((h = "TweenPositionFromBottom"), (t = "TweenPositionToBottom"));
      CommandsComponent.AddWithData(l, {
        postmake: BuildCommand(h, {
          delay: 200,
        }),
        exit: BuildCommand(t),
      });
      return l;
    };
    this.ScorePanel = (l, w) => {
      l = this.GuiImageObject(l, "ScorePanel", w);
      CommandsComponent.AddWithData(l, {
        postmake: BuildCommand("TweenPositionFromTop", {
          delay: 100,
        }),
        exit: BuildCommand("TweenPositionToTop"),
      });
      return l;
    };
    this.CoverScoreFont = (l) => {
      l = GeoticManager.CreateEntity(l);
      BagsComponent.At(l).setAlias("AliasCoverScoreText");
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultText("scorefont", {
          layerName: "gui_11",
        })
      );
      return l;
    };
    this.CoverHighscoreIcon = (l) => {
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage("HighscoreIcon", {
          layerName: "gui_11",
        })
      );
      return l;
    };
    this.CoverPlayBtn = (l) => {
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage("Btn_Play", {
          layerName: "gui_22",
        })
      );
      CommandsComponent.AddWithData(l, {
        postmake: BuildCommand("TweenPositionFromBottom", {
          duration: 800,
          delay: 300,
        }),
        exit: BuildCommand("TweenPositionToBottom"),
      });
      Interactive.AddWithCmdOnUpAndBtnInteraction(l, "RequestGameplay");
      return l;
    };
    this.GameOverRestartIcon = (l) => {
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage("TryAgain", {
          layerName: "gui_22",
        })
      );
      CommandsComponent.AddWithData(l, {
        postmake: BuildCommand("TweenPositionFromTop", {
          delay: 100,
        }),
        exit: BuildCommand("TweenPositionToTop"),
      });
      return l;
    };
    this.GameOverPlayBtn = (l) => {
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage("Btn_Play", {
          layerName: "gui_22",
        })
      );
      CommandsComponent.AddWithData(l, {
        postmake: BuildCommand("TweenPositionFromBottom"),
        exit: BuildCommand("TweenPositionToBottom"),
      });
      Interactive.AddWithCmdOnUpAndBtnInteraction(
        l,
        "RequestCoverFromGameOver"
      );
      return l;
    };
    this.GameOverHighscoreIcon = (l) => {
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage("HighscoreIcon", {
          layerName: "gui_11",
        })
      );
      CommandsComponent.AddWithData(l, {
        postmake: BuildCommand("TweenPositionFromTop"),
        exit: BuildCommand("TweenPositionToTop"),
      });
      return l;
    };
    this.FadeCurtain = (l) => {
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage("ZaslonkaFade", {
          layerName: "pause_22",
          scale: 32,
        })
      );
      CommandsComponent.AddWithData(l, {
        exit: BuildCommand("TweenAlphaTo", {
          alpha: 0,
          duration: 400,
        }),
      });
      return l;
    };
    this.PauseBackground = (l) => {
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage("PauseCurtain", {
          layerName: "pause_22",
          scale: 32,
        })
      );
      return l;
    };
    this.PauseIcon = (l) => {
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage("PauseIcon", {
          layerName: "pause_22",
        })
      );
      return l;
    };
    this.PauseButtonCallUnpause = (l) => {
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage("Btn_Play", {
          layerName: "pause_22",
        })
      );
      Interactive.AddWithCmdOnUpAndBtnInteraction(l, "UnpauseGame");
      return l;
    };
    this.BtnAudioToggle = (l) => {
      l = GeoticManager.CreateEntity(l);
      BagsComponent.At(l).setAlias("SettingsToggleBtnAudio");
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage("Btn_SoundOn", {
          layerName: "gui_31",
          animations: {
            active: {
              texture: "Btn_SoundOn",
            },
            inactive: {
              texture: "Btn_SoundOff",
            },
          },
        })
      );
      CommandsComponent.AddWithData(l, {
        postmake: BuildCommand("TweenPositionFromTop"),
        exit: BuildCommand("TweenPositionToTop"),
      });
      Interactive.AddWithCmdOnUpAndBtnInteraction(l, RunEntityToggleLogic.Name);
      ToggleComponent.AddWithToggleStatesDictionary(l, "active", {
        active: {
          nextState: "inactive",
          command: BuildCommand(GlobalMuteAudioAction.Name),
        },
        inactive: {
          nextState: "active",
          command: BuildCommand(GlobalUnmuteAudioAction.Name),
        },
      });
      return l;
    };
    this.TutorialHowToPlayHand = (l, w) => {
      w = void 0 === w ? null : w;
      l = GeoticManager.CreateEntity(l);
      BagsComponent.At(l).setAlias("TutorialHowToPlayHand");
      TransformComponent.AddToEntity(l);
      const h = {
        selfDepth: 50,
        layerDepth: 25,
        curAnimation: "SwipeRight",
        animations: {
          Hold: {
            loop: !0,
          },
          SwipeRight: {
            loop: !0,
          },
        },
      };
      w && merge(h, w);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultSpine("HTP_MinimalHand", h)
      );
      return l;
    };
    this.GameplayBtnPause = (l) => {
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage("Btn_Pause", {
          layerName: "gui_31",
        })
      );
      CommandsComponent.AddWithData(l, {
        postmake: BuildCommand("TweenPositionFromRight"),
        exit: BuildCommand("TweenPositionToRight"),
      });
      Interactive.AddWithCmdOnUpAndBtnInteraction(l, "PauseGame");
      return l;
    };
    this.GameplayScoreFont = (l) => {
      l = GeoticManager.CreateEntity(l);
      BagsComponent.At(l).setAlias("GameplayScoreText");
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultText("scorefont", {
          layerName: "gui_11",
        })
      );
      return l;
    };
    this.GameplayScoreIcon = (l) => {
      l = GeoticManager.CreateEntity(l);
      TransformComponent.AddToEntity(l);
      l.add(
        VisualComponent,
        VisualTemplates.DefaultImage("ScoreIcon", {
          layerName: "gui_11",
        })
      );
      return l;
    };
  }
}
class CasualGameStates {
  constructor() {
    this.Always = new GameState("Always");
    this.GameplayLoop = new GameState("GameplayLoop");
    this.GameplayLevel = new GameState("GameplayLevel");
    this.GameplayGui = new GameState("GameplayGui");
    this.Cover = new GameState("Cover");
    this.GameOver = new GameState("GameOver");
    this.Fade = new GameState("Fade");
    this.AudioController = new GameState("AudioController");
    this.Pause = new GameState("Pause");
    this.CommandRequestCover = GameCommandsRegistry.register(
      "RequestCover",
      new GameCommand(() => {
        BMEngine.SetPauseAllowedByStates(!1);
        this.Always.continue();
        this.GameplayLoop.quit();
        this.GameplayGui.quit();
        this.GameplayLevel.enterFresh();
        this.GameOver.quit();
        this.Cover.enterFresh();
        this.AudioController.continue();
      })
    );
    this.CommandRequestCoverFromGameOver = GameCommandsRegistry.register(
      "RequestCoverFromGameOver",
      new GameCommand(() => {
        BMEngine.SetPauseAllowedByStates(!1);
        this.Always.continue();
        this.GameplayLevel.exit();
        this.GameplayGui.exit();
        this.GameplayLoop.exit();
        this.GameOver.exit();
        this.AudioController.continue();
        this.Fade.enterFresh();
        EndOfLoopRoutine.QueueDelayedFunction(null, 550, () => {
          this.Cover.enterFresh();
          this.GameplayLevel.enterFresh();
          this.Fade.exit();
        });
      })
    );
    this.CommandRequestGameplay = GameCommandsRegistry.register(
      "RequestGameplay",
      new GameCommand(() => {
        onGameStart(() => {
          BMEngine.SetPauseAllowedByStates(!0);
          this.Always.continue();
          this.Cover.exit();
          this.GameOver.quit();
          this.GameplayLevel.continue();
          this.GameplayGui.enterFresh();
          this.GameplayLoop.enterFresh();
          this.AudioController.continue();
        });
      })
    );
    this.CommandRequestGameOver = GameCommandsRegistry.register(
      "RequestGameOver",
      new GameCommand(() => {
        BMEngine.SetPauseAllowedByStates(!0);
        this.Always.continue();
        this.GameplayLevel.continue();
        this.GameplayGui.continue();
        this.GameplayLoop.exit();
        this.Cover.quit();
        this.GameOver.enterFresh();
        this.AudioController.continue();
      })
    );
    this.CommandRestartLevelLogic = GameCommandsRegistry.register(
      "RestartLevelLogic",
      new GameCommand(() => {
        BMEngine.SetPauseAllowedByStates(!0);
        this.Always.continue();
        this.Cover.exit();
        this.GameOver.quit();
        this.GameplayLevel.exit();
        this.GameplayGui.continue();
        this.GameplayLoop.exit();
        this.AudioController.continue();
        EndOfLoopRoutine.QueueDelayedFunction(null, 100, () => {
          onGameStart(() => {
            this.GameplayLevel.enterFresh();
            this.GameplayGui.continue();
            this.GameplayLoop.enterFresh();
          });
        });
      })
    );
    this.CommandPauseGame = GameCommandsRegistry.register(
      "PauseGame",
      new GameCommand((l) => {
        BMEngine.TryPauseGame() && this.Pause.continue();
      })
    );
    this.CommandUnpauseGame = GameCommandsRegistry.register(
      "UnpauseGame",
      new GameCommand((l) => {
        BMEngine.TryUnpauseGame() && (this.Pause.exit(), this.Pause.quit());
      })
    );
  }
}
const PandaJumpStatesInstance = new CasualGameStates();
class PandaJumpPrefabs extends CasualGameSharedPrefabs {
  constructor() {
    super();
  }
  DecayedHalfPlatforms(l, w) {
    const h = PandaJumpStatesInstance.GameplayLevel.name,
      t = this.GameplayImageObject(h, "OneTimePlatform_PartLeft", l - 28, w, {
        layerDepth: 11,
      });
    BagsComponent.AddBagList(t, ["CHECK_OFFSCREEN_DIE"]);
    PhysicsComponent.AddToEntity(t, {});
    PhysicsComponent.At(t).getBodyAsDynamic().setGravity(0, 700);
    PhysicsComponent.At(t).getBodyAsDynamic().setVelocity(-70, 200);
    PhysicsComponent.At(t).getBodyAsDynamic().setAngularVelocity(25);
    l = this.GameplayImageObject(h, "OneTimePlatform_PartRight", l + 28, w, {
      layerDepth: 11,
    });
    BagsComponent.AddBagList(l, ["CHECK_OFFSCREEN_DIE"]);
    PhysicsComponent.AddToEntity(l, {});
    PhysicsComponent.At(l).getBodyAsDynamic().setGravity(0, 700);
    PhysicsComponent.At(l).getBodyAsDynamic().setVelocity(70, 200);
    PhysicsComponent.At(l).getBodyAsDynamic().setAngularVelocity(-25);
  }
}
const PandaJumpPrefabsInstance = new PandaJumpPrefabs();

function CmdTweenAlphaTo(l, w) {
  var h;
  let t = {
    duration: 1e3,
    delay: 0,
    ease: "Cubic.InOut",
  };
  null != (h = w.alpha) ? h : (w.alpha = 1);
  merge(t, w);
  VisualComponent.At(l).tweenAlpha(t);
}
class InternalDataClass$6 {
  constructor() {
    this.query;
  }
}
const InternalData$7 = new InternalDataClass$6();
class ReactivePinOthersQuery {
  static RegisterQuery() {
    InternalData$7.query = GeoticManager.GetWorld().createQuery({
      all: [PinOthers, TransformComponent],
    });
    InternalData$7.query.onEntityAdded((l) => {});
    InternalData$7.query.onEntityRemoved((l) => {});
  }
  static GetReference() {
    return InternalData$7.query;
  }
}
class InternalDataClass$5 {
  constructor() {
    __publicField(this, "active", !0);
    __publicField(this, "queryPinOthers", null);
  }
}
const InternalData$6 = new InternalDataClass$5();
class SynchPinsRoutine {
  static Register() {
    RoutinesManager.RegisterRoutine(SynchPinsRoutine);
  }
  static OnRegister() {}
  static Init() {
    InternalData$6.queryPinOthers = ReactivePinOthersQuery.GetReference();
  }
  static GetName() {
    return "SynchPinsRoutine";
  }
  static UpdateEntity(l) {
    let w = PinOthers.At(l).pinnedEntitiesList;
    for (let t = 0; t < w.length; t++) {
      var h = w[t].ref;
      let a = w[t].relation;
      if (!h.isDestroyed) {
        h = TransformComponent.At(h);
        const d = TransformComponent.At(l);
        h.refTarget.x = d.refTarget.x + a.x;
        h.refTarget.y = d.refTarget.y + a.y;
      }
    }
  }
  static Update(l) {
    l = InternalData$6.queryPinOthers._cache;
    for (let w = 0; w < l.length; w++) SynchPinsRoutine.UpdateEntity(l[w]);
  }
}
class PinOthers extends Component {
  constructor(l) {
    super(null);
    this.pinnedEntitiesList = [];
    this.killPinnedOnDestroy = !1;
    const w = JSON.parse(JSON.stringify(this.constructor.properties));
    Object.assign(this, w, l);
  }
  addPin(l, w) {
    var h, t;
    null != (h = w.x) ? h : (w.x = 0);
    null != (t = w.y) ? t : (w.y = 0);
    this.pinnedEntitiesList.push({
      ref: l,
      relation: w,
    });
    SynchPinsRoutine.UpdateEntity(this.entity);
  }
  onDestroyed() {
    super.onDestroyed();
    if (this.killPinnedOnDestroy)
      for (let l = 0; l < this.pinnedEntitiesList.length; l++)
        DisposeEntityAction.Take(this.pinnedEntitiesList[l].ref);
  }
  unpinAll() {
    this.pinnedEntitiesList = [];
  }
  static AddWithPin(l, w, h, t) {
    t = void 0 === t ? !0 : t;
    l.has(PinOthers) || l.add(PinOthers);
    l = PinOthers.At(l);
    l.addPin(w, h);
    l.killPinnedOnDestroy = t;
  }
  static At(l) {
    return l.pinOthers;
  }
  static get properties() {
    return {};
  }
}
const _RepositionEntityToAction = class {
  static RegisterPackedAsGameCommand() {
    GameCommandsRegistry.register(
      this.Name,
      new GameCommand((l) => {
        _RepositionEntityToAction.Take(l.entity, l.x, l.y);
      })
    );
  }
  static Take(l, w, h) {
    w = void 0 === w ? null : w;
    h = void 0 === h ? null : h;
    TransformComponent.At(l).setPosition(w, h);
  }
};
let RepositionEntityToAction = _RepositionEntityToAction;
__publicField(RepositionEntityToAction, "Name", "RepositionEntityToAction");
class CasualGamePremadeOverrides {
  constructor() {
    this.cover = {
      delta: {
        x: 0,
        y: 0,
      },
    };
    this.coverBtnPlay = {
      delta: {
        x: 0,
        y: 0,
      },
    };
    this.scorePanel = {
      layer: "gui_11",
      x: 0,
      y: 0,
    };
    this.coverLogo = {
      layer: "gui_31",
    };
    this.gameplayScoreIcon = {
      x: -145,
      y: 0,
    };
    this.coverScoreIcon = {
      x: -145,
      y: 3,
    };
  }
}
class CasualGamePremades {
  constructor() {
    this.overrides = new CasualGamePremadeOverrides();
  }
  Always(l, w) {
    console.warn("PLEASE DON'T CALL ALWAYS ON CASUAL PREMADES");
  }
  GameplayLevel(l, w) {}
  GameplayLoop(l, w) {
    l = l.GameplayBtnPause(w.name);
    RepositionEntityBySizeAction.Take(l, -0.5, 0.5);
    RepositionEntityByDeltaAction.Take(l, 0, 80);
    CommandsComponent.At(l).runCommandAtTriggerKey("postmake");
  }
  AudioController(l, w) {
    l = l.BtnAudioToggle(w.name);
    RepositionEntityBySizeAction.Take(l, -0.5, 0.5);
    RepositionEntityByDeltaAction.Take(l, 0, 7);
    CommandsComponent.At(l).runCommandAtTriggerKey("postmake");
  }
  GameOver(l, w) {
    const h = l.GameOverRestartIcon(w.name);
    RepositionEntityBySizeAction.Take(h, 0, -0.5);
    RepositionEntityByDeltaAction.Take(h, 0, -30);
    CommandsComponent.At(h).runCommandAtTriggerKey("postmake");
    l = l.GameOverPlayBtn(w.name);
    RepositionEntityBySizeAction.Take(l, 0, 0.5);
    RepositionEntityByDeltaAction.Take(l, 0, 30);
    CommandsComponent.At(l).runCommandAtTriggerKey("postmake");
  }
  Fade(l, w) {
    l = l.FadeCurtain(w.name);
    CommandsComponent.At(l).runCommandAtTriggerKey("postmake");
    VisualComponent.At(l).getDisplayedAsImage().alpha = 0;
    CmdTweenAlphaTo(l, {
      alpha: 1,
      duration: 450,
    });
  }
  Pause(l, w) {
    l.PauseBackground(w.name);
    const h = l.PauseIcon(w.name);
    RepositionEntityBySizeAction.Take(h, 0, -0.5);
    RepositionEntityByDeltaAction.Take(h, 0, -40);
    l = l.PauseButtonCallUnpause(w.name);
    RepositionEntityBySizeAction.Take(l, 0, 0.5);
    RepositionEntityByDeltaAction.Take(l, 0, 40);
    CommandsComponent.At(l).runCommandAtTriggerKey("postmake");
  }
  GameplayGui(l, w) {
    merge(this.overrides, GameBranding.GetSingleton().getPremadeOverrides());
    const h = l.ScorePanel(w.name, this.overrides.scorePanel.layer);
    RepositionEntityToAction.Take(
      h,
      this.overrides.scorePanel.x,
      this.overrides.scorePanel.y
    );
    "gui_11" == this.overrides.scorePanel.layer &&
      RepositionEntityBySizeAction.Take(h, 0.5, 0.5);
    "gui_21" == this.overrides.scorePanel.layer &&
      RepositionEntityBySizeAction.Take(h, 0, 0.5);
    CommandsComponent.At(h).runCommandAtTriggerKey("postmake");
    const t = l.GameplayScoreFont(w.name);
    OperateOnVisual.ReparentLayer(t, this.overrides.scorePanel.layer);
    PinOthers.AddWithPin(h, t, {
      x: 25,
      y: 2,
    });
    l = l.GameplayScoreIcon(w.name);
    OperateOnVisual.ReparentLayer(l, this.overrides.scorePanel.layer);
    BagsComponent.At(l).setAlias("AliasGameplayGuiScoreIcon");
    PinOthers.AddWithPin(h, l, {
      x: this.overrides.gameplayScoreIcon.x,
      y: this.overrides.gameplayScoreIcon.y,
    });
  }
  Cover(l, w) {
    merge(this.overrides, GameBranding.GetSingleton().getPremadeOverrides());
    var h = l.CoverTitle(w.name);
    RepositionEntityBySizeAction.Take(h, 0, -0.5);
    RepositionEntityByDeltaAction.Take(
      h,
      this.overrides.cover.delta.x,
      this.overrides.cover.delta.y
    );
    CommandsComponent.At(h).runCommandAtTriggerKey("postmake");
    h = l.CoverLogo(w.name, this.overrides.coverLogo.layer);
    "gui_31" == this.overrides.coverLogo.layer
      ? (RepositionEntityBySizeAction.Take(h, -0.5, 0.5),
        RepositionEntityByDeltaAction.Take(h, -85, 8))
      : (RepositionEntityBySizeAction.Take(h, -0.5, -0.5),
        RepositionEntityByDeltaAction.Take(h, -10, -10));
    CommandsComponent.At(h).runCommandAtTriggerKey("postmake");
    h = l.ScorePanel(w.name, this.overrides.scorePanel.layer);
    RepositionEntityToAction.Take(
      h,
      this.overrides.scorePanel.x,
      this.overrides.scorePanel.y
    );
    BagsComponent.At(h).setAlias("AliasCoverScorePanel");
    "gui_11" == this.overrides.scorePanel.layer &&
      RepositionEntityBySizeAction.Take(h, 0.5, 0.5);
    "gui_21" == this.overrides.scorePanel.layer &&
      RepositionEntityBySizeAction.Take(h, 0, 0.5);
    CommandsComponent.At(h).runCommandAtTriggerKey("postmake");
    var t = l.CoverScoreFont(w.name);
    OperateOnVisual.ReparentLayer(t, this.overrides.scorePanel.layer);
    PinOthers.AddWithPin(h, t, {
      x: 25,
      y: 2,
    });
    t = l.CoverHighscoreIcon(w.name);
    BagsComponent.At(t).setAlias("AliasCoverScoreIcon");
    OperateOnVisual.ReparentLayer(t, this.overrides.scorePanel.layer);
    PinOthers.AddWithPin(h, t, {
      x: this.overrides.coverScoreIcon.x,
      y: this.overrides.coverScoreIcon.y,
    });
    l = l.CoverPlayBtn(w.name);
    RepositionEntityBySizeAction.Take(l, 0, 0.5);
    RepositionEntityByDeltaAction.Take(
      l,
      this.overrides.coverBtnPlay.delta.x,
      150 + this.overrides.coverBtnPlay.delta.y
    );
    CommandsComponent.At(l).runCommandAtTriggerKey("postmake");
  }
}
class GameSpecificPremades extends CasualGamePremades {
  constructor() {
    super();
    this.overrides.cover.delta.y = -100;
    this.overrides.coverBtnPlay.delta.y = -120;
  }
  Always(l, w) {
    l = l.Background(w);
    VisualComponent.At(l).getDisplayedAsImage().setScale(8, 8);
  }
  GameplayLoop(l, w) {
    super.GameplayLoop(l, w);
  }
}
const PandaJumpPremadesInstance = new GameSpecificPremades();
class FollowPointerMovementComponent extends Component {
  constructor(l) {
    super(null);
    this.processAxisY =
      this.processAxisX =
      this.processPointerConstantly =
      this.enabled =
        !0;
    this.boundsAxisY = this.boundsAxisX = null;
    this.offsetY = this.offsetX = 0;
    this.speed = null;
    const w = JSON.parse(JSON.stringify(this.constructor.properties));
    Object.assign(this, w, l);
  }
  static GetName() {
    return "followPointerMovement";
  }
  static get properties() {
    return {};
  }
  static At(l) {
    return l.followPointerMovement;
  }
  static AddToEntity(l, w) {
    l.add(FollowPointerMovementComponent, w);
  }
}
const PREFABS$1 = PandaJumpPrefabsInstance,
  STATES_MODEL = PandaJumpStatesInstance;

function GetTextureRegularPlatform() {
  return Phaser.Utils.Array.GetRandom([
    "Platform_Regular_01",
    "Platform_Regular_02",
    "Platform_Regular_03",
    "Platform_Regular_04",
  ]);
}

function GetTextureOneTimePlatform() {
  return Phaser.Utils.Array.GetRandom([
    "Platform_OneTime_01",
    "Platform_OneTime_02",
    "Platform_OneTime_03",
    "Platform_OneTime_04",
  ]);
}

function GetTextureCloud() {
  return Phaser.Utils.Array.GetRandom(
    "Cloud_01 Cloud_02 Cloud_03 Cloud_04 Cloud_05 Cloud_06 Cloud_07".split(" ")
  );
}

function _SpawnSpring(l, w) {
  l = PandaJumpPrefabsInstance.GameplayImageObject(
    PandaJumpStatesInstance.GameplayLevel.name,
    "Spring",
    l,
    w - 35,
    {
      layerDepth: 8,
    }
  );
  PhysicsComponent.AddToEntity(l, {
    groupsList: ["SPRING"],
  });
  BagsComponent.AddBagList(l, ["CHECK_OFFSCREEN_DIE"]);
  return l;
}

function _SpawnPlatform(l, w, h, t, a, d) {
  const k = PandaJumpStatesInstance.GameplayLevel.name,
    e = PandaJumpPrefabsInstance.GameplayImageObject(
      k,
      GetTextureRegularPlatform(),
      l,
      w,
      {
        layerDepth: 10,
      }
    );
  PhysicsComponent.AddToEntity(e, {
    groupsList: ["PLATFORM"],
  });
  BagsComponent.AddBagList(e, ["CHECK_OFFSCREEN_DIE"]);
  w < PandaJumpGlobalsInstance.currentLevelData.highestPlatformY &&
    (PandaJumpGlobalsInstance.currentLevelData.highestPlatformY = w);
  h &&
    ((h = _SpawnSpring(l, w)),
    (PandaJumpGlobalsInstance.currentLevelData.highestPlatformY -= 30),
    PinOthers.AddWithPin(e, h, TransformComponent.CalculateDeltaBetween(e, h)));
  a &&
    ((a = _SpawnWatermelon(l, w)),
    PinOthers.AddWithPin(e, a, TransformComponent.CalculateDeltaBetween(e, a)));
  d &&
    ((d = _SpawnBrick(l, w)),
    PinOthers.AddWithPin(e, d, TransformComponent.CalculateDeltaBetween(e, d)));
  t &&
    ((t = PandaJumpPrefabsInstance.GameplaySpineObject(
      k,
      "Wiatraczek",
      "spin",
      l - 55,
      w,
      {
        layerDepth: 15,
        loop: !0,
      }
    )),
    PinOthers.AddWithPin(e, t, TransformComponent.CalculateDeltaBetween(e, t)),
    (DataComponent.At(e).refWiatrak_1 = t),
    (l = PandaJumpPrefabsInstance.GameplaySpineObject(
      k,
      "Wiatraczek",
      "spin",
      l + 55,
      w,
      {
        layerDepth: 15,
        loop: !0,
      }
    )),
    PinOthers.AddWithPin(e, l, TransformComponent.CalculateDeltaBetween(e, l)),
    (DataComponent.At(e).refWiatrak_2 = l),
    BagsComponent.AddBagList(e, ["MOVING_PLATFORM"]),
    DataComponent.AddToEntityWithProperties(e, {
      direction: Phaser.Utils.Array.GetRandom([-1, 1]),
    }));
  return e;
}

function _SpawnDecayedPlatform(l, w) {
  l = PandaJumpPrefabsInstance.GameplayImageObject(
    PandaJumpStatesInstance.GameplayLevel.name,
    GetTextureOneTimePlatform(),
    l,
    w,
    {
      layerDepth: 10,
    }
  );
  PhysicsComponent.AddToEntity(l, {
    groupsList: ["PLATFORM_DECAYED"],
  });
  BagsComponent.AddBagList(l, ["CHECK_OFFSCREEN_DIE"]);
  w < PandaJumpGlobalsInstance.currentLevelData.highestPlatformY &&
    (PandaJumpGlobalsInstance.currentLevelData.highestPlatformY = w);
}

function _SpawnSkyPasek(l, w) {
  l = PandaJumpPrefabsInstance.GameplayImageObject(
    PandaJumpStatesInstance.GameplayLevel.name,
    "PasekNieba",
    l,
    w,
    {
      layerDepth: 5,
    }
  );
  BagsComponent.AddBagList(l, ["SKY_CHECK_OFFSCREEN_REPOSITION"]);
  VisualComponent.At(l).getDisplayedAsImage().setScale(4, 1);
}

function _SpawnCloud(l, w) {
  l = PandaJumpPrefabsInstance.GameplayImageObject(
    PandaJumpStatesInstance.GameplayLevel.name,
    GetTextureCloud(),
    l,
    w,
    {
      layerDepth: 7,
    }
  );
  BagsComponent.AddBagList(l, ["CLOUD_CHECK_OFFSCREEN_REPOSITION"]);
  return l;
}

function _SpawnWatermelon(l, w) {
  l = PandaJumpPrefabsInstance.GameplayImageObject(
    PandaJumpStatesInstance.GameplayLevel.name,
    "Watermelon",
    l,
    w - 45,
    {
      layerDepth: 20,
    }
  );
  PhysicsComponent.AddToEntity(l, {
    groupsList: ["PICKABLE"],
  });
  BagsComponent.AddBagList(l, ["CHECK_OFFSCREEN_DIE"]);
  VisualComponent.At(l).tweenScale({
    scale: 0.8,
    duration: Phaser.Math.Between(350, 450),
    delay: 0,
    ease: "Linear",
    repeat: -1,
    yoyo: !0,
  });
  return l;
}

function _SpawnBrick(l, w) {
  l = PandaJumpPrefabsInstance.GameplayImageObject(
    PandaJumpStatesInstance.GameplayLevel.name,
    "Murek",
    l,
    w + 20,
    {
      layerDepth: 9,
    }
  );
  BagsComponent.AddBagList(l, ["BRICKS"]);
  PhysicsComponent.AddToEntity(l, {
    groupsList: ["BRICK"],
  });
  BagsComponent.AddBagList(l, ["CHECK_OFFSCREEN_DIE"]);
  return l;
}

function LevelStartGeneration() {
  var l = PandaJumpStatesInstance.GameplayLevel.name;
  //for (var w = 0; 10 > w; w++) _SpawnSkyPasek(0, 256 * w);
  for (w = 1500; -1500 < w; ) {
    var h = _SpawnCloud(Phaser.Math.Between(-300, 300), w);
    h = VisualComponent.At(h);
    50 > Phaser.Math.Between(0, 100) &&
      _SpawnCloud(
        Phaser.Math.Between(400, 600),
        w + Phaser.Math.Between(-50, 50)
      );
    w -= h.getDisplayedAsImage().displayHeight + Phaser.Math.Between(100, 300);
  }
  w = [
    {
      x: 0 + Phaser.Math.Between(-10, 10),
      y: 900,
    },
    {
      x: -200 + Phaser.Math.Between(-10, 10),
      y: 550 + Phaser.Math.Between(0, 50),
    },
    {
      x: 200 + Phaser.Math.Between(-10, 10),
      y: 550 + Phaser.Math.Between(0, 50),
    },
    {
      x: -140 + Phaser.Math.Between(-10, 10),
      y: 900 + Phaser.Math.Between(25, 50),
    },
    {
      x: -280 + Phaser.Math.Between(-10, 10),
      y: 900 + Phaser.Math.Between(25, 50),
    },
    {
      x: -420 + Phaser.Math.Between(-10, 10),
      y: 900 + Phaser.Math.Between(25, 50),
    },
    {
      x: -560 + Phaser.Math.Between(-10, 10),
      y: 900 + Phaser.Math.Between(25, 50),
    },
    {
      x: 140 + Phaser.Math.Between(-10, 10),
      y: 900 + Phaser.Math.Between(25, 50),
    },
    {
      x: 280 + Phaser.Math.Between(-10, 10),
      y: 900 + Phaser.Math.Between(25, 50),
    },
    {
      x: 420 + Phaser.Math.Between(-10, 10),
      y: 900 + Phaser.Math.Between(25, 50),
    },
    {
      x: 560 + Phaser.Math.Between(-10, 10),
      y: 900 + Phaser.Math.Between(25, 50),
    },
  ];
  for (h = 0; h < w.length; h++) {
    const t = _SpawnPlatform(w[h].x, w[h].y);
    0 == h && (DataComponent.At(t).isFirst = !0);
  }
  w = "Panda";
  0 == BMEngine.IsCanvas() && (w = "Panda_Mesh");
  l = PandaJumpPrefabsInstance.GameplaySpineObject(l, w, "down", 0, 900, {
    layerDepth: 20,
    loop: !0,
  });
  BagsComponent.At(l).setAlias("player");
  DataComponent.AddToEntityWithProperties(l, {
    velocityY: -150,
    jumpDelay: 0,
  });
  VisualComponent.At(l);
  OperateOnVisual.GetDisplayedAsAny(l).setMix("up", "down", 0.15);
  OperateOnVisual.GetDisplayedAsAny(l).setMix("down", "up", 0.15);
  PhysicsComponent.AddToEntity(l, {
    groupsList: ["PLAYER"],
  });
  PhysicsComponent.At(l).resizeDeltaOwnSize(-70, -85, 40, 40);
  FollowPointerMovementComponent.AddToEntity(l, {
    enabled: !1,
    processAxisY: !1,
    boundsAxisX: {
      min: -600,
      max: 600,
    },
    speed: 600,
  });
}

function _GetIsDecayedPlatform() {
  const l = PandaJumpGlobalsInstance.currentLevelData.difficulty;
  return Phaser.Math.Between(0, 100) < 30 + 10 * l ? !0 : !1;
}

function UpdateDifficulty() {
  const l = PandaJumpGlobalsInstance.currentLevelData.difficulty,
    w = PandaJumpGlobalsInstance.currentLevelData.totalSpawnedPlatform;
  1 == l &&
    50 < w &&
    (PandaJumpGlobalsInstance.currentLevelData.difficulty = 2);
  1 == l &&
    150 < w &&
    (PandaJumpGlobalsInstance.currentLevelData.difficulty = 3);
  1 == l &&
    500 < w &&
    (PandaJumpGlobalsInstance.currentLevelData.difficulty = 4);
}

function UpdateMapGeneration(l) {
  var w = EntityKeeper.GetEntityByAlias("player");
  if (w) {
    VisualComponent.At(w);
    l = DataComponent.At(w);
    var h = TransformComponent.At(w);
    UpdateDifficulty();
    w = PandaJumpGlobalsInstance.currentLevelData.difficulty;
    if (
      1e3 >
      h.refTarget.y - PandaJumpGlobalsInstance.currentLevelData.highestPlatformY
    ) {
      h = [];
      var t = Phaser.Math.Between(-240, -60);
      h.push({
        x: Phaser.Math.Between(-300, 300),
        y: t + Phaser.Math.Between(0, 50),
        isDecayed: !1,
      });
      Phaser.Math.Between(0, 100) < 80 - 10 * w &&
        100 > Phaser.Math.Between(0, 100) &&
        h.push({
          x: Phaser.Math.Between(-300, 300),
          y: t + -80 + Phaser.Math.Between(0, 5),
          isDecayed: _GetIsDecayedPlatform(),
        });
      Phaser.Math.Between(0, 100) < 80 - 10 * w &&
        100 > Phaser.Math.Between(0, 100) &&
        h.push({
          x: Phaser.Math.Between(-300, 300),
          y: t + -160 + Phaser.Math.Between(0, 5),
          isDecayed: _GetIsDecayedPlatform(),
        });
      Phaser.Math.Between(0, 100) < 80 - 10 * w &&
        100 > Phaser.Math.Between(0, 100) &&
        h.push({
          x: Phaser.Math.Between(-300, 300),
          y: t + -240 + Phaser.Math.Between(0, 5),
          isDecayed: _GetIsDecayedPlatform(),
        });
      100 > Phaser.Math.Between(0, 100) &&
        h.push({
          x: Phaser.Math.Between(-300, 300),
          y: t - 320 + Phaser.Math.Between(0, 10),
          isDecayed: !1,
        });
      t = PandaJumpGlobalsInstance.currentLevelData.highestPlatformY;
      let a = !1,
        d = !1,
        k = !1,
        e = !1;
      for (let b = 0; b < h.length; b++) {
        const c = h[b];
        let f = !1;
        Phaser.Math.Between(0, 100) < 30 - 5 * w && (f = !0);
        --PandaJumpGlobalsInstance.currentLevelData.toNextSpring;
        0 < PandaJumpGlobalsInstance.currentLevelData.toNextSpring &&
          (a = f = !1);
        let g = !1;
        50 > Phaser.Math.Between(0, 100) && (g = !0);
        let m = !1;
        Phaser.Math.Between(0, 100) < 15 * w && (m = !0);
        let n = !1;
        Phaser.Math.Between(0, 100) < 25 * w && (n = !0);
        d && (m = !0);
        a && (f = !0);
        k && (g = !0);
        e && (n = !0);
        e = k = a = d = !1;
        0 < l.flyTime && (n = !1);
        let q = c.isDecayed;
        q &&
          (f && (a = !0), m && (d = !0), g && (k = !0), (m = f = !1), (q = !0));
        f && (g = !1);
        PandaJumpGlobalsInstance.currentLevelData.totalSpawnedPlatform += 1;
        q
          ? _SpawnDecayedPlatform(c.x, t + c.y)
          : _SpawnPlatform(c.x, t + c.y, f, m, g, n);
      }
    }
  }
}
class InternalModel$1 {
  constructor() {
    this.LevelStartGeneration = LevelStartGeneration;
    this.UpdateMapGeneration = UpdateMapGeneration;
  }
}
const PandaJumpLevelGenerationScripts = new InternalModel$1();
class PandaJumpStatesController {
  EnterGameplayLevel() {
    BMEngine.SetGameplayCameraOffset(0, 0, !0);
    PandaJumpLevelGenerationScripts.LevelStartGeneration();
  }
  EnterGameplayLoop() {
    const l = EntityKeeper.GetEntityByAlias("player");
    l && (FollowPointerMovementComponent.At(l).enabled = !0);
  }
}
const PandaJumpStatesControllerInstance = new PandaJumpStatesController();

function CmdTweenPositionTo(l, w, h) {
  var t, a;
  (void 0 === h || h) && VisualComponent.At(l).fastTrackPosition();
  h = {
    duration: 1e3,
    delay: 0,
    ease: "Cubic.InOut",
  };
  null != (t = w.x) ? t : (w.x = OperateOnVisual.GetDisplayed(l).x);
  null != (a = w.y) ? a : (w.y = OperateOnVisual.GetDisplayed(l).y);
  merge(h, w);
  VisualComponent.At(l).tweenPosition(h);
}
let SaveSlotReference = {
  version: "1",
  highscore: 0,
};
const LOOP_COUNT_GAMEPLAY_TIME = "LOOP_COUNT_GAMEPLAY_TIME",
  GLOBALS = PandaJumpGlobalsInstance,
  PREMADES = PandaJumpPremadesInstance,
  STATES = PandaJumpStatesInstance,
  PREFABS = PandaJumpPrefabsInstance,
  STATES_CONTROLLER = PandaJumpStatesControllerInstance;
class InternalMainScript {
  Init() {
    PhysicsModel.AddGroup("PLAYER");
    PhysicsModel.AddGroup("PLATFORM");
    PhysicsModel.AddGroup("SPRING");
    PhysicsModel.AddGroup("PLATFORM_DECAYED");
    PhysicsModel.AddGroup("PICKABLE");
    PhysicsModel.AddGroup("BRICK");
    (() => {
      PandaJumpStatesInstance.AudioController.onEnter = () => {
        PandaJumpPremadesInstance.AudioController(
          PandaJumpPrefabsInstance,
          PandaJumpStatesInstance.AudioController
        );
        if (-1 == BMEngine.GetAudioState()) {
          const l = EntityKeeper.GetEntityByAlias("SettingsToggleBtnAudio");
          ToggleComponent.At(l).setToggleState("inactive");
        }
      };
      PandaJumpStatesInstance.Pause.onEnter = () => {
        PandaJumpPremadesInstance.Pause(
          PandaJumpPrefabsInstance,
          PandaJumpStatesInstance.Pause
        );
      };
      PandaJumpStatesInstance.Fade.onEnter = () => {
        PandaJumpPremadesInstance.Fade(
          PandaJumpPrefabsInstance,
          PandaJumpStatesInstance.Fade
        );
      };
      PandaJumpStatesInstance.Always.onEnter = () => {
        PandaJumpPremadesInstance.Always(
          PandaJumpPrefabsInstance,
          PandaJumpStatesInstance.Always
        );
      };
      PandaJumpStatesInstance.GameplayGui.onEnter = () => {
        PandaJumpPremadesInstance.GameplayGui(
          PandaJumpPrefabsInstance,
          PandaJumpStatesInstance.GameplayGui
        );
        this.AddToScore(0);
      };
      PandaJumpStatesInstance.GameplayLoop.onEnter = () => {
        PandaJumpPremadesInstance.GameplayLoop(
          PandaJumpPrefabsInstance,
          PandaJumpStatesInstance.GameplayLoop
        );
        this.StateEnterGameplayLoop();
      };
      PandaJumpStatesInstance.GameplayLoop.onExit = () => {};
      PandaJumpStatesInstance.GameplayLevel.onEnter = () => {
        PandaJumpPremadesInstance.GameplayLevel(
          PandaJumpPrefabsInstance,
          PandaJumpStatesInstance.GameplayLevel
        );
        GameBranding.GetSingleton().hasToResetScoreEachLevel() &&
          ((PandaJumpGlobalsInstance.subsession.score = 0),
          (PandaJumpGlobalsInstance.subsession.latestScore = 0));
        this.AddToScore(0);
        this.StateEnterGameplayLevel();
      };
      PandaJumpStatesInstance.Cover.onEnter = () => {
        PandaJumpPremadesInstance.Cover(
          PandaJumpPrefabsInstance,
          PandaJumpStatesInstance.Cover
        );
        PandaJumpGlobalsInstance.ResetSubsession();
        null != SaveSlotReference &&
          OperateOnVisual.SetTextWithZeroPad(
            EntityKeeper.GetEntityByAlias("AliasCoverScoreText"),
            SaveSlotReference.highscore,
            6
          );
      };

      PandaJumpStatesInstance.GameOver.onEnter = () => {
        PandaJumpPremadesInstance.GameOver(
          PandaJumpPrefabsInstance,
          PandaJumpStatesInstance.GameOver
        );

        if (this.TrySaveNewHighscore()) {
          const l = PandaJumpPrefabsInstance.GameOverHighscoreIcon(
            PandaJumpStatesInstance.GameOver
          );
          RepositionEntityBySizeAction.Take(l, 0.5, 0.5);
          RepositionEntityByDeltaAction.Take(l, 10, 80);
          CommandsComponent.At(l).runCommandAtTriggerKey("postmake");

          // Mengambil data skor dan mengirimkannya ke server
          var uid = parse("uid");
          var msgid = parse("msgid");
          var chatid = parse("chatid");
          var iid = parse("iid");
          var score = PandaJumpGlobalsInstance.subsession.score;

          if (uid && msgid && chatid) {
            $.get(
              "/setscore/uid/" +
                uid +
                "/chat/" +
                chatid +
                "/msg/" +
                msgid +
                "/score/" +
                score
            );
          } else if (uid && iid) {
            $.get("/setscore/uid/" + uid + "/iid/" + iid + "/score/" + score);
          }
        }
      };
    })();
  }

  AddToScore(l) {
    PandaJumpGlobalsInstance.subsession.score += l;
    PandaJumpGlobalsInstance.subsession.latestScore =
      PandaJumpGlobalsInstance.subsession.score;
    GameBranding.GetSingleton().onUpdateScore(
      PandaJumpGlobalsInstance.subsession.latestScore
    );
    EntityKeeper.GetEntityByAlias("GameplayScoreText") &&
      OperateOnVisual.SetTextWithZeroPad(
        EntityKeeper.GetEntityByAlias("GameplayScoreText"),
        PandaJumpGlobalsInstance.subsession.score,
        6
      );
  }

  ShowTutorialHand(l, w, h) {
    l = void 0 === l ? "ActuallyHold" : l;
    w = void 0 === w ? 0 : w;
    h = void 0 === h ? 300 : h;
    const t = PandaJumpPrefabsInstance.TutorialHowToPlayHand(
      PandaJumpStatesInstance.GameplayLevel
    );
    VisualComponent.At(t).getSpineAnimationList(!1);
    GetOs().desktop
      ? VisualComponent.At(t).setAnimation("Mouse", {
          loop: !1,
        })
      : VisualComponent.At(t).setAnimation(l, {
          loop: !1,
        });
    TransformComponent.At(t).setPosition(w, h);
    return t;
  }
  TrySaveNewHighscore() {
    return SaveSlotReference.highscore <
      PandaJumpGlobalsInstance.subsession.score
      ? ((SaveSlotReference.highscore =
          PandaJumpGlobalsInstance.subsession.score),
        BMEngine.SaveGame(),
        !0)
      : !1;
  }
  TryKillTutorial() {
    let l = EntityKeeper.GetEntityByAlias("TutorialHowToPlayHand");
    l && EndOfLoopRoutine.QueueActorToDisposeBuffer(l);
  }
  RequestLevelWon() {
    PandaJumpGlobalsInstance.session.seenTutorial = !0;
    PandaJumpGlobalsInstance.currentLevelData.levelLoopEnded ||
      ((PandaJumpGlobalsInstance.currentLevelData.levelLoopEnded = !0),
      this.TrySaveNewHighscore(),
      EndOfLoopRoutine.QueueDelayedFunction(null, 750, () => {
        GameBranding.GetSingleton().showAd(() => {});
        PandaJumpStatesInstance.CommandRestartLevelLogic.run({
          levelResult: "won",
        });
      }),
      LogicLoopRoutine.CleanFunction(LOOP_COUNT_GAMEPLAY_TIME));
  }
  RequestLevelLost() {
    PandaJumpGlobalsInstance.session.seenTutorial = !0;
    PandaJumpGlobalsInstance.currentLevelData.levelLoopEnded ||
      ((PandaJumpGlobalsInstance.currentLevelData.levelLoopEnded = !0),
      this.TryKillTutorial(),
      PandaJumpStatesInstance.CommandRequestGameOver.run(),
      GameBranding.GetSingleton().showAd(() => {}),
      LogicLoopRoutine.CleanFunction(LOOP_COUNT_GAMEPLAY_TIME));
  }
  StateEnterGameplayLevel() {
    PandaJumpGlobalsInstance.ResetLevelData();
    PandaJumpStatesControllerInstance.EnterGameplayLevel();
  }
  StateEnterGameplayLoop() {
    PandaJumpGlobalsInstance.currentLevelData.levelLoopStarted = !0;
    if (0 == PandaJumpGlobalsInstance.session.seenTutorial) {
      const h = this.ShowTutorialHand("ActuallyHold", -100, 600);
      PandaJumpGlobalsInstance.session.seenTutorial = !0;
      var l = {
          x: 300,
          y: TransformComponent.At(h).refTarget.y,
          onComplete: null,
        },
        w = {
          x: -300,
          y: TransformComponent.At(h).refTarget.y,
          onComplete: null,
        };
      l.onComplete = () => {
        h.isDestroyed || CmdTweenPositionTo(h, w, !1);
      };
      w.onComplete = () => {
        h.isDestroyed || CmdTweenPositionTo(h, l, !1);
      };
      CmdTweenPositionTo(h, l, !1);
    }
    LogicLoopRoutine.SetUpdateFunc(LOOP_COUNT_GAMEPLAY_TIME, (h) => {
      0 != PandaJumpGlobalsInstance.currentLevelData.levelLoopStarted &&
        1 != PandaJumpGlobalsInstance.currentLevelData.levelLoopEnded &&
        ((h = DeltaScaled(h)),
        (PandaJumpGlobalsInstance.currentLevelData.activeLevelTime += h));
    });
    PandaJumpStatesControllerInstance.EnterGameplayLoop();
  }
}
const PandaJumpMainScriptInstance = new InternalMainScript();

function PandaJumpStartNormal() {
  SaveSlotReference = BMEngine.GetSaveSlotReference(SaveSlotReference);
  PandaJumpMainScriptInstance.Init();
  PandaJumpGlobalsInstance.session.initialized = !0;
  EndOfLoopRoutine.QueueDelayedFunction(null, 0, () =>
    PandaJumpStatesInstance.CommandRequestCover.run()
  );
  BMEngine.PlayAudioFile("GameMusic", null, {
    loop: !0,
    volume: 0.28,
  });
}
class InternalDataClass$4 {
  constructor() {
    this.query;
  }
}
const InternalData$5 = new InternalDataClass$4();
class ReactiveInteractiveAndVisualQuery {
  static RegisterQuery() {
    InternalData$5.query = GeoticManager.GetWorld().createQuery({
      all: [Interactive, VisualComponent],
    });
    InternalData$5.query.onEntityAdded((l) => {
      const w = VisualComponent.At(l);
      l = Interactive.At(l);
      w.getDisplayedAsImage().setInteractive();
      l.refHitArea = w.refDisplayed.input.hitArea;
    });
    InternalData$5.query.onEntityRemoved((l) => {});
  }
  static GetReference() {
    return InternalData$5.query;
  }
}
const KEY_CHAR_SPACE = " ",
  KEY_CHAR_RIGHT = "right",
  KEY_CHAR_LEFT = "left",
  KEY_CHAR_UP = "up",
  KEY_CHAR_DOWN = "down";
class Data {
  constructor() {
    this.trackedTaps = {};
    this.trackedInputs = [
      {
        input: null,
        obj: null,
      },
      {
        input: null,
        obj: null,
      },
      {
        input: null,
        obj: null,
      },
      {
        input: null,
        obj: null,
      },
      {
        input: null,
        obj: null,
      },
      {
        input: null,
        obj: null,
      },
      {
        input: null,
        obj: null,
      },
      {
        input: null,
        obj: null,
      },
      {
        input: null,
        obj: null,
      },
      {
        input: null,
        obj: null,
      },
      {
        input: null,
        obj: null,
      },
    ];
    this.keys = {};
    this.sinceButtonPress = 1e4;
    this.swipeCallback = this.swipe = null;
    this.keyCallbacks = {};
  }
}
const InternalData$4 = new Data();
class InputRoutine {
  static Register() {
    RoutinesManager.RegisterRoutine(InputRoutine);
  }
  static OnRegister() {
    ReactiveInteractiveAndVisualQuery.GetReference().onEntityAdded((l) => {
      _AddActorInteractivity(l);
    });
    ReactiveInteractiveAndVisualQuery.GetReference().onEntityRemoved((l) => {
      _RemoveButtonTracking(l);
      OperateOnVisual.GetDisplayedAsImage(l).removeInteractive();
    });
  }
  static Init() {
    const l = BMEngine.GetGameplayScene();
    l.input.addPointer(10);
    InternalData$4.trackedInputs[0].input = l.input.mousePointer;
    InternalData$4.trackedInputs[1].input = l.input.pointer1;
    InternalData$4.trackedInputs[2].input = l.input.pointer2;
    InternalData$4.trackedInputs[3].input = l.input.pointer3;
    InternalData$4.trackedInputs[4].input = l.input.pointer4;
    InternalData$4.trackedInputs[5].input = l.input.pointer5;
    InternalData$4.trackedInputs[6].input = l.input.pointer6;
    InternalData$4.trackedInputs[7].input = l.input.pointer7;
    InternalData$4.trackedInputs[8].input = l.input.pointer8;
    InternalData$4.trackedInputs[9].input = l.input.pointer9;
    InternalData$4.trackedInputs[10].input = l.input.pointer10;
    InternalData$4.keys.w = l.input.keyboard.addKey("w");
    InternalData$4.keys.s = l.input.keyboard.addKey("s");
    InternalData$4.keys.a = l.input.keyboard.addKey("a");
    InternalData$4.keys.d = l.input.keyboard.addKey("d");
    InternalData$4.keys[KEY_CHAR_SPACE] = l.input.keyboard.addKey(
      Phaser.Input.Keyboard.KeyCodes.SPACE
    );
    InternalData$4.keys["/"] = l.input.keyboard.addKey("/");
    InternalData$4.keys[KEY_CHAR_RIGHT] = l.input.keyboard.addKey("right");
    InternalData$4.keys[KEY_CHAR_LEFT] = l.input.keyboard.addKey("left");
    InternalData$4.keys[KEY_CHAR_UP] = l.input.keyboard.addKey("up");
    InternalData$4.keys[KEY_CHAR_DOWN] = l.input.keyboard.addKey("down");
    l.input.keyboard.on("keydown", function (w) {
      if (InternalData$4.keyCallbacks[w.key])
        InternalData$4.keyCallbacks[w.key](w);
    });
    InternalData$4.swipe = l.rexGestures.add.swipe({
      threshold: 35,
      velocityThreshold: 10,
      workaroundEnabled: 1,
      workaroundMaxTime: 1e9,
    });
    InternalData$4.swipe.on("swipe", (w) => {
      InternalData$4.swipeCallback && InternalData$4.swipeCallback(w);
    });
  }
  static GetName() {
    return "InputRoutine";
  }
  static Update(l) {
    BMEngine.GetGameplayScene();
    for (let w = 0; w < InternalData$4.trackedInputs.length; w++) {
      let h = InternalData$4.trackedInputs[w].input;
      if (
        InternalData$4.trackedInputs[w].obj &&
        Interactive.At(InternalData$4.trackedInputs[w].obj).canDrag
      ) {
        const t = OperateOnVisual.GetDisplayedAsImage(
          InternalData$4.trackedInputs[w].obj
        );
        RepositionEntityToAction.Take(
          InternalData$4.trackedInputs[w].obj,
          h.x + t.scene.cameras.main.scrollX,
          h.y + t.scene.cameras.main.scrollY
        );
      }
      h &&
        !h.isDown &&
        InternalData$4.trackedInputs[w].obj &&
        _RemoveButtonTracking(InternalData$4.trackedInputs[w].obj);
    }
    InputRoutine.GetPointerIfNotPressingButton()
      ? ((InternalData$4.sinceButtonPress += l),
        1e4 <= InternalData$4.sinceButtonPress &&
          (InternalData$4.sinceButtonPress = 1e4))
      : (InternalData$4.sinceButtonPress = 0);
  }
  static GetSinceButtonPress() {
    return InternalData$4.sinceButtonPress;
  }
  static SetSwipeCallback(l) {
    InternalData$4.swipeCallback = l;
  }
  static AddKeyDown(l, w) {
    if (Array.isArray(l))
      for (let h = 0; h < l.length; h++) InternalData$4.keyCallbacks[l[h]] = w;
    else InternalData$4.keyCallbacks[l] = w;
  }
  static HasTrackedButton() {
    for (let l = 0; l < InternalData$4.trackedInputs.length; l++)
      if (null != InternalData$4.trackedInputs[l].obj) return !0;
    return !1;
  }
  static GetPointerIfNotPressingButton() {
    return 0 == InputRoutine.HasTrackedButton()
      ? BMEngine.GetGameplayScene().input.activePointer
      : null;
  }
  static GetPointer() {
    return BMEngine.GetGameplayScene().input.activePointer;
  }
  static IsKeyFromListDown(l) {
    for (let w = 0; w < l.length; w++)
      if (InternalData$4.keys[l[w]].isDown) return !0;
    return !1;
  }
}

function _AddActorInteractivity(l) {
  const w = OperateOnVisual.GetDisplayedAsImage(l),
    h = Interactive.At(l);
  if (h.canSwipe) {
    const t = BMEngine.GetGameplayScene();
    let a = {
      threshold: 35,
      velocityThreshold: 10,
      workaroundEnabled: 1,
      workaroundMaxTime: 1e3,
    };
    merge(a, h.swipeCfg);
    t.rexGestures.add.swipe(w, a).on("swipe", (d, k, e) => {
      e = Interactive.At(k.selfEntity);
      GameCommandsRegistry.runCommand(e.onSwipeCmdName, {
        entity: k.selfEntity,
        swipe: d,
      });
    });
  }
  w.on("pointerup", function (t, a, d, k) {
    !BMEngine.IsRotationDisplayed() &&
      h.pressed &&
      GlobalGameStateManager.getData(
        DataComponent.At(l).gameStateName
      ).isRunning() &&
      (_RemoveButtonTracking(l),
      _PerformInteraction(l, "always", "up"),
      h.isDisabled || _PerformInteraction(l, "up", "up"));
  });
  w.on("pointerdown", function (t, a, d, k) {
    BMEngine.IsRotationDisplayed() ||
      !GlobalGameStateManager.getData(
        DataComponent.At(l).gameStateName
      ).isRunning() ||
      h.isDisabled ||
      (_PerformInteraction(l, "always", "down"),
      _PerformInteraction(l, "down", "down"),
      (h.pressed = !0),
      _AddButtonTracking(l, t.id));
  });
  w.on("pointerover", function (t, a, d, k) {
    BMEngine.IsRotationDisplayed() ||
      !GlobalGameStateManager.getData(
        DataComponent.At(l).gameStateName
      ).isRunning() ||
      h.isDisabled ||
      h.pressed ||
      (_PerformInteraction(l, "always", "over"),
      _PerformInteraction(l, "over", "over"));
  });
  w.on("pointermove", function (t, a, d, k) {
    !BMEngine.IsRotationDisplayed() &&
      GlobalGameStateManager.getData(
        DataComponent.At(l).gameStateName
      ).isRunning() &&
      !h.isDisabled &&
      h.pressed &&
      (_PerformInteraction(l, "always", "move"),
      _PerformInteraction(l, "move", "move"));
  });
  w.on("pointerout", function (t, a, d, k) {
    BMEngine.IsRotationDisplayed() ||
      !GlobalGameStateManager.getData(
        DataComponent.At(l).gameStateName
      ).isRunning() ||
      h.pressed ||
      (_PerformInteraction(l, "always", "out"),
      _PerformInteraction(l, "out", "out"));
  });
}

function _PerformInteraction(l, w, h) {
  const t = Interactive.At(l);
  t.dict[w] &&
    t.dict[w].key &&
    ((w = t.dict[w]),
    (l = merge(
      {
        entity: l,
        reason: h,
      },
      w
    )),
    GameCommandsRegistry.runCommand(w.key, l));
}

function _AddButtonTracking(l, w) {
  InternalData$4.trackedInputs[w].obj
    ? console.warn("ALREADY TRACKING BUTTON AT ID: ", w)
    : (InternalData$4.trackedInputs[w].obj = l);
}

function _RemoveButtonTracking(l) {
  const w = Interactive.At(l);
  w.pressed &&
    (_PerformInteraction(l, "always", "out"), _NullifyTrackedButton(l));
  w.pressed = !1;
}

function _NullifyTrackedButton(l) {
  for (let w = 0; w < InternalData$4.trackedInputs.length; w++)
    if (InternalData$4.trackedInputs[w].obj == l) {
      InternalData$4.trackedInputs[w].obj = null;
      break;
    }
}
class InternalDataClass$3 {
  constructor() {
    this.query;
  }
}
const InternalData$3 = new InternalDataClass$3();
class ReactiveFollowPointerMovementAndVisualQuery {
  static RegisterQuery() {
    InternalData$3.query = GeoticManager.GetWorld().createQuery({
      all: [VisualComponent, FollowPointerMovementComponent],
    });
    InternalData$3.query.onEntityAdded((l) => {});
    InternalData$3.query.onEntityRemoved((l) => {});
  }
  static GetReference() {
    return InternalData$3.query;
  }
}
class FollowPointerMovementRoutine {
  static OnRegister() {}
  static Register() {
    RoutinesManager.RegisterRoutine(FollowPointerMovementRoutine);
  }
  static Init() {}
  static GetName() {
    return "FollowPointerMovementRoutine";
  }
  static Update(l) {
    const w = ReactiveFollowPointerMovementAndVisualQuery.GetReference()._cache;
    for (let k = 0; k < w.length; k++) {
      const e = w[k];
      var h = FollowPointerMovementComponent.At(e);
      if (0 == h.enabled) break;
      const b = TransformComponent.At(e);
      var t = VisualComponent.At(e).getDisplayedAsImage(),
        a = 0,
        d = 0;
      const c = InputRoutine.GetPointerIfNotPressingButton();
      if (c && c.active) {
        let f = !1;
        c.isDown && (f = !0);
        h.processPointerConstantly && (f = !0);
        f &&
          ((d = c.y + h.offsetY + t.scene.cameras.main.scrollY),
          (a = c.x + h.offsetX + t.scene.cameras.main.scrollX));
      }
      if (0 != a || 0 != d)
        h.boundsAxisX && (a = Clamp$1(a, h.boundsAxisX.min, h.boundsAxisX.max)),
          h.boundsAxisY &&
            (d = Clamp$1(d, h.boundsAxisY.min, h.boundsAxisY.max)),
          h.processAxisX || (a = null),
          h.processAxisY || (d = null),
          !InputRoutine.HasTrackedButton() &&
            15 <= InputRoutine.GetSinceButtonPress() &&
            (null != h.speed &&
              (null != a &&
                ((t = h.speed * DeltaScaled(l)),
                a < b.refTarget.x
                  ? ((t *= -1),
                    (a = Clamp$1(b.refTarget.x + t, a, b.refTarget.x)))
                  : (a = Clamp$1(b.refTarget.x + t, b.refTarget.x, a))),
              null != d &&
                ((h = h.speed * DeltaScaled(l)),
                d < b.refTarget.y
                  ? ((h *= -1),
                    (d = Clamp$1(b.refTarget.y + h, d, b.refTarget.y)))
                  : (d = Clamp$1(b.refTarget.y + h, b.refTarget.y, d)))),
            RepositionEntityToAction.Take(e, a, d));
    }
  }
}

function CmdTweenVisualByDeltaFrom(l, w) {
  VisualComponent.At(l).fastTrackPosition(l);
  let h = {
    x: 0,
    y: 0,
    duration: 1e3,
    delay: 0,
    ease: "Cubic.InOut",
  };
  merge(h, w);
  w = OperateOnVisual.GetDisplayed(l);
  const t = h.x,
    a = h.y;
  h.x = w.x;
  h.y = w.y;
  w.x += t;
  w.y += a;
  VisualComponent.At(l).tweenPosition(h);
}

function CmdTweenVisualByDeltaTo(l, w) {
  VisualComponent.At(l).fastTrackPosition();
  w = merge(
    {
      x: 0,
      y: 0,
      duration: 1e3,
      delay: 0,
      ease: "Cubic.InOut",
    },
    w
  );
  const h = OperateOnVisual.GetDisplayed(l);
  w.x = h.x + w.x;
  w.y = h.y + w.y;
  VisualComponent.At(l).tweenPosition(w);
}

function DoCasualGameRegisters(l) {
  GameCommandsRegistry.register(
    "TweenCoverTitle",
    new GameCommand((w) => {
      const h = w.entity;
      CmdTweenVisualByDeltaFrom(h, {
        y: -800,
        duration: 1e3,
        onComplete: () => {
          CmdTweenVisualByDeltaTo(h, {
            y: -25,
            duration: 1800,
            yoyo: !0,
            repeat: -1,
            ease: "Quadratic.In",
          });
        },
      });
    })
  );
  GameCommandsRegistry.register(
    "TweenPositionFromTop",
    new GameCommand((w) => {
      CmdTweenVisualByDeltaFrom(
        w.entity,
        merge(
          {
            y: -700,
            duration: 700,
          },
          w
        )
      );
    })
  );
  GameCommandsRegistry.register(
    "TweenPositionToTop",
    new GameCommand((w) => {
      CmdTweenVisualByDeltaTo(
        w.entity,
        merge(
          {
            y: -700,
            duration: 450,
          },
          w
        )
      );
    })
  );
  GameCommandsRegistry.register(
    "TweenPositionFromBottom",
    new GameCommand((w) => {
      CmdTweenVisualByDeltaFrom(
        w.entity,
        merge(
          {
            y: 700,
            duration: 450,
          },
          w
        )
      );
    })
  );
  GameCommandsRegistry.register(
    "TweenPositionToBottom",
    new GameCommand((w) => {
      CmdTweenVisualByDeltaTo(
        w.entity,
        merge(
          {
            y: 700,
            duration: 700,
          },
          w
        )
      );
    })
  );
  GameCommandsRegistry.register(
    "TweenScaleToZero",
    new GameCommand((w) => {
      CmdTweenScaleTo(
        w.entity,
        merge(
          {
            scale: 0,
            duration: 700,
          },
          w
        )
      );
    })
  );
  GameCommandsRegistry.register(
    "TweenPositionFromRight",
    new GameCommand((w) => {
      CmdTweenVisualByDeltaFrom(
        w.entity,
        merge(
          {
            x: 700,
            duration: 450,
          },
          w
        )
      );
    })
  );
  GameCommandsRegistry.register(
    "TweenPositionToRight",
    new GameCommand((w) => {
      CmdTweenVisualByDeltaTo(
        w.entity,
        merge(
          {
            x: 700,
            duration: 700,
          },
          w
        )
      );
    })
  );
  GameCommandsRegistry.register(
    "TweenAlphaTo",
    new GameCommand((w) => {
      CmdTweenAlphaTo(
        w.entity,
        merge(
          {
            alpha: 1,
            duration: 500,
          },
          w
        )
      );
    })
  );
}
const _NoInteractionAction = class {
  static RegisterPackedAsGameCommand() {
    GameCommandsRegistry.register(
      this.Name,
      new GameCommand((l) => {
        _NoInteractionAction.Take(l.entity, l.reason);
      })
    );
  }
  static Take(l, w) {}
};
let NoInteractionAction = _NoInteractionAction;
__publicField(NoInteractionAction, "Name", "NoInteractionAction");
class RepositionEntityToEntityAction {
  static RegisterPackedAsGameCommand() {
    GameCommandsRegistry.register(this.Name, new GameCommand((l) => {}));
  }
  static Take(l, w, h) {
    h =
      void 0 === h
        ? {
            x: 0,
            y: 0,
          }
        : h;
    l = TransformComponent.At(l);
    w = TransformComponent.At(w);
    l.refTarget.x = w.refTarget.x + h.x;
    l.refTarget.y = w.refTarget.y + h.y;
  }
}
__publicField(
  RepositionEntityToEntityAction,
  "Name",
  "RepositionEntityToEntityAction"
);
class InternalDataClass$2 {
  constructor() {
    this.query;
  }
}
const InternalData$2 = new InternalDataClass$2();
class ReactivePhysicsAndVisualQuery {
  static RegisterQuery() {
    InternalData$2.query = GeoticManager.GetWorld().createQuery({
      all: [VisualComponent, PhysicsComponent],
    });
    InternalData$2.query.onEntityAdded((l) => {
      const w = PhysicsComponent.At(l),
        h = VisualComponent.At(l).getDisplayedAsImage();
      h.body
        ? console.warn("IMPLEMENT! ReactivePhysicsAndVisualQuery:onEntityAdded")
        : ((w.body = h.scene.physics.add.existing(h, w.isStatic).body),
          PhysicsComponent.BootBody(l));
    });
    InternalData$2.query.onEntityRemoved((l) => {});
  }
  static GetReference() {
    return InternalData$2.query;
  }
}
class InternalDataClass$1 {
  constructor() {
    this.query;
  }
}
const InternalData$1 = new InternalDataClass$1();
class ReactiveTransformAndVisualQuery {
  static RegisterQuery() {
    InternalData$1.query = GeoticManager.GetWorld().createQuery({
      all: [VisualComponent, TransformComponent],
    });
    InternalData$1.query.onEntityAdded((l) => {
      const w = TransformComponent.At(l);
      OperateOnVisual.GetDisplayed(l).x = w.refTarget.x;
      OperateOnVisual.GetDisplayed(l).y = w.refTarget.y;
      OperateOnVisual.GetDisplayed(l).angle = w.refTarget.angle;
      w.refTarget = OperateOnVisual.GetDisplayed(l);
    });
    InternalData$1.query.onEntityRemoved((l) => {});
  }
  static GetReference() {
    return InternalData$1.query;
  }
}
class ParticleTrailFollowerComponent extends Component {
  constructor(l) {
    super(null);
    this.targetGuid = null;
    this.offsetY = this.offsetX = this.angleMaxOffset = this.angleMinOffset = 0;
    const w = JSON.parse(JSON.stringify(this.constructor.properties));
    Object.assign(this, w, l);
  }
  static GetName() {
    return "particleTrailFollower";
  }
  static At(l) {
    return l.particleTrailFollower;
  }
  static get properties() {
    return {};
  }
  static AddToEntity(l, w, h) {
    h = void 0 === h ? {} : h;
    w = {
      targetGuid: w,
    };
    merge(w, h);
    l.add(ParticleTrailFollowerComponent, w);
  }
}
class InternalDataClass {
  constructor() {
    this.query;
  }
}
const InternalData = new InternalDataClass();
class ReactiveParticleTrailAndTransformAndVisualQuery {
  static RegisterQuery() {
    InternalData.query = GeoticManager.GetWorld().createQuery({
      all: [
        TransformComponent,
        VisualComponent,
        ParticleTrailFollowerComponent,
      ],
    });
  }
  static GetReference() {
    console.assert(InternalData.query);
    return InternalData.query;
  }
}

function DoCommonGameRegisters(l) {
  l.registerComponent(DataComponent, "data");
  l.registerComponent(TransformComponent, "transform");
  l.registerComponent(VisualComponent, "visual");
  l.registerComponent(CommandsComponent, "commands");
  l.registerComponent(BagsComponent, "bags");
  l.registerComponent(PinOthers, "pinOthers");
  l.registerComponent(Interactive, "interactive");
  l.registerComponent(ToggleComponent, "toggle");
  l.registerComponent(PhysicsComponent, "physics");
  l.registerComponent(
    ParticleTrailFollowerComponent,
    ParticleTrailFollowerComponent.GetName()
  );
  ReactiveTransformAndVisualQuery.RegisterQuery();
  ReactiveInteractiveAndVisualQuery.RegisterQuery();
  ReactivePinOthersQuery.RegisterQuery();
  ReactivePhysicsAndVisualQuery.RegisterQuery();
  ReactiveParticleTrailAndTransformAndVisualQuery.RegisterQuery();
  DisposeEntityAction.RegisterPackedAsGameCommand();
  RepositionEntityToEntityAction.RegisterPackedAsGameCommand();
  SetEntityAnimationAction.RegisterPackedAsGameCommand();
  RepositionEntityBySizeAction.RegisterPackedAsGameCommand();
  RepositionEntityByDeltaAction.RegisterPackedAsGameCommand();
  ButtonInteractionAction.RegisterPackedAsGameCommand();
  BasicInteractionAction.RegisterPackedAsGameCommand();
  NoInteractionAction.RegisterPackedAsGameCommand();
  RunEntityToggleLogic.RegisterPackedAsGameCommand();
  GlobalMuteAudioAction.RegisterPackedAsGameCommand();
  GlobalUnmuteAudioAction.RegisterPackedAsGameCommand();
}
class ScriptLoopRoutine {
  Init() {}
  OnRegister() {}
  static Register(l, w, h) {
    w = void 0 === w ? [] : w;
    RoutinesManager.RegisterRoutine(new ScriptLoopRoutine(l, w, h));
  }
  constructor(l, w, h) {
    w = void 0 === w ? [] : w;
    null == h && (h = GetGUID());
    this.name = h;
    this.func = l;
    this.guards = w;
  }
  GetName() {
    return this.name;
  }
  Update(l) {
    for (let w = 0; w < this.guards.length; w++)
      if ((0, this.guards[w])()) return;
    this.func(l);
  }
}

function _OnCollisionOverlapPlayerVsPickable(l, w) {
  l.selfEntity;
  l = w.selfEntity;
  w = DataComponent.At(l);
  1 != w.picked &&
    ((w.picked = !0),
    DisposeEntityAction.Take(l),
    PandaJumpMainScriptInstance.AddToScore(10),
    BMEngine.PlayAudioFile("03_watermelon_03"));
}

function _OnCollisionOverlapVsBrick(l, w) {
  l = l.selfEntity;
  var h = w.selfEntity;
  w = DataComponent.At(h);
  h = TransformComponent.At(h);
  const t = DataComponent.At(l),
    a = VisualComponent.At(l).getAnimationName();
  l = TransformComponent.At(l);
  t.cantDie ||
    0 == w.hit ||
    ((w.hit = !0),
    "up" != a ||
      l.refTarget.y < h.refTarget.y ||
      (PandaJumpPrefabsInstance.GameplaySpineObjectDieAfterAnim(
        PandaJumpStatesInstance.GameplayLevel,
        "Dust",
        "dust",
        h.refTarget.x,
        h.refTarget.y,
        {
          layerDepth: 25,
        }
      ),
      (t.velocityY = 500),
      (t.jumpDelay = 0.1),
      BMEngine.PlayAudioFile(
        "brickhit",
        {
          volume: 4,
        },
        {
          volume: 4,
        }
      )));
}

function _OnCollisionOverlapPlayerVsPlatform(l, w) {
  l = l.selfEntity;
  const h = w.selfEntity;
  DataComponent.At(h).isFirst ||
    (PandaJumpGlobalsInstance.currentLevelData.touchedFirst = !0);
  w = DataComponent.At(l);
  l = VisualComponent.At(l).getAnimationName();
  0 > w.velocityY ||
    "up" == l ||
    (void 0 != w.jumpDelay && 0 < w.jumpDelay) ||
    ((w.velocityY =
      0 == PandaJumpGlobalsInstance.currentLevelData.levelLoopStarted
        ? -500
        : -1100),
    (l = TransformComponent.At(h)),
    PandaJumpPrefabsInstance.GameplaySpineObjectDieAfterAnim(
      PandaJumpStatesInstance.GameplayLevel,
      "Dust",
      "dust",
      l.refTarget.x,
      l.refTarget.y,
      {
        layerDepth: 25,
      }
    ),
    0 >= w.flyTime && (w.cantDie = !1),
    BMEngine.PlayAudioFile(
      Phaser.Utils.Array.GetRandom(["01_bounce_01_01", "01_bounce_01_02"])
    ));
}

function _OnCollisionOverlapPlayerVsSpring(l, w) {
  l = l.selfEntity;
  w.selfEntity;
  w = DataComponent.At(l);
  l = VisualComponent.At(l).getAnimationName();
  if (!(0 > w.velocityY) && "up" != l)
    for (
      w.velocityY = -2200,
        w.flyTime = 100,
        w.cantDie = !0,
        PandaJumpGlobalsInstance.currentLevelData.toNextSpring =
          20 + 10 * PandaJumpGlobalsInstance.currentLevelData.difficulty,
        BMEngine.PlayAudioFile("02_jump_spring_01"),
        w = EntityKeeper.GetBagActorsReferenceList("BRICKS"),
        l = 0;
      l < w.length;
      l++
    ) {
      const h = w[l];
      0 == VisualComponent.At(h).isDisplayedOnScreen() &&
        DisposeEntityAction.Take(h);
    }
}

function _OnCollisionOverlapPlayerVsDecayedPlatform(l, w) {
  l = l.selfEntity;
  w = w.selfEntity;
  var h = DataComponent.At(l);
  l = VisualComponent.At(l).getAnimationName();
  0 > h.velocityY ||
    "up" == l ||
    ((l = DataComponent.At(w)),
    (h = TransformComponent.At(w)),
    l.hasCollided ||
      ((l.hasCollided = !0),
      PandaJumpPrefabsInstance.DecayedHalfPlatforms(
        h.refTarget.x,
        h.refTarget.y
      )),
    DisposeEntityAction.Take(w),
    BMEngine.PlayAudioFile(
      Phaser.Utils.Array.GetRandom([
        "04_platform_crack_01",
        "04_platform_crack_02",
        "04_platform_crack_03",
      ])
    ));
}

function CollisionOverlapPlayerVsPlatform(l) {
  PhysicsModel.OverlapGroupsByNames(
    "PLAYER",
    "PLATFORM",
    _OnCollisionOverlapPlayerVsPlatform
  );
}

function CollisionOverlapPlayerVsSpring(l) {
  PhysicsModel.OverlapGroupsByNames(
    "PLAYER",
    "SPRING",
    _OnCollisionOverlapPlayerVsSpring
  );
}

function CollisionOverlapPlayerVsDecayedPlatform(l) {
  PhysicsModel.OverlapGroupsByNames(
    "PLAYER",
    "PLATFORM_DECAYED",
    _OnCollisionOverlapPlayerVsDecayedPlatform
  );
}

function CollisionOverlapPlayerVsPickable(l) {
  PhysicsModel.OverlapGroupsByNames(
    "PLAYER",
    "PICKABLE",
    _OnCollisionOverlapPlayerVsPickable
  );
}

function CollisionOverlapVsBrick(l) {
  PhysicsModel.OverlapGroupsByNames(
    "PLAYER",
    "BRICK",
    _OnCollisionOverlapVsBrick
  );
}

function UpdatePlayerVelocity(l) {
  const w = EntityKeeper.GetEntityByAlias("player");
  if (w) {
    var h = DataComponent.At(w);
    h.jumpDelay -= DeltaScaled(l);
    0 < h.flyTime
      ? ((h.flyTime -= DeltaScaled(l)),
        (h.velocityY += 800 * DeltaScaled(l)),
        -500 <= h.velocityY && (h.flyTime = 0))
      : ((h.velocityY += 1500 * DeltaScaled(l)),
        1500 <= h.velocityY && (h.velocityY = 1500));
    TransformComponent.At(w).refTarget.y += h.velocityY * DeltaScaled(l);
  }
}

function UpdatePlayerAnimationState() {
  var l = EntityKeeper.GetEntityByAlias("player");
  if (l) {
    var w = VisualComponent.At(l);
    l = DataComponent.At(l);
    var h = w.getAnimationName();
    0 > l.velocityY
      ? "down" == h &&
        w.setAnimation("up", {
          loop: !0,
        })
      : "up" == h &&
        w.setAnimation("down", {
          loop: !0,
        });
  }
}

function UpdateCameraOffset(l) {
  var w = EntityKeeper.GetEntityByAlias("player");
  if (w) {
    var h = DataComponent.At(w),
      t = TransformComponent.At(w);
    w = 700;
    0 == PandaJumpGlobalsInstance.currentLevelData.touchedFirst && (w = -5e4);
    var a = BMEngine.GetGameplayCameraOffset().y;
    t.refTarget.y - a < w &&
      ((t = t.refTarget.y - a),
      (t = w - t),
      0 < h.flyTime && (t *= 3),
      (a -= t * DeltaScaled(l) * 2),
      BMEngine.SetGameplayCameraOffset(0, a));
  }
}

function OffscreenDieCheck() {
  var l = EntityKeeper.GetEntityByAlias("player");
  if (l) {
    l = TransformComponent.At(l);
    var w = EntityKeeper.GetBagActorsReferenceList("CHECK_OFFSCREEN_DIE");
    for (let h = 0; h < w.length; h++) {
      const t = w[h],
        a = TransformComponent.At(t);
      VisualComponent.At(t).isDisplayedOnScreen() ||
        (300 < a.refTarget.y - l.refTarget.y && DisposeEntityAction.Take(t));
    }
  }
}

function PlayerOffscreenDieCheck() {
  const l = EntityKeeper.GetEntityByAlias("player");
  l &&
    (TransformComponent.At(l),
    VisualComponent.At(l).isDisplayedOnScreen(!0) ||
      PandaJumpMainScriptInstance.RequestLevelLost());
}

function UpdateMovingPlatforms(l) {
  const w = EntityKeeper.GetBagActorsReferenceList("MOVING_PLATFORM");
  for (let k = 0; k < w.length; k++) {
    var h = w[k];
    const e = DataComponent.At(h),
      b = TransformComponent.At(h);
    VisualComponent.At(h);
    var t = e.refWiatrak_1,
      a = e.refWiatrak_2,
      d = e.direction;
    -1 == d
      ? ((h = -300),
        t &&
          ((t = VisualComponent.At(t)),
          (a = VisualComponent.At(a)),
          "spin_left" != t.getAnimationName() &&
            (t.setAnimation("spin_left", {
              loop: !0,
            }),
            a.setAnimation("spin_left", {
              loop: !0,
            }))))
      : ((h = 300),
        t &&
          ((t = VisualComponent.At(t)),
          (a = VisualComponent.At(a)),
          "spin_right" != t.getAnimationName() &&
            (t.setAnimation("spin_right", {
              loop: !0,
            }),
            a.setAnimation("spin_right", {
              loop: !0,
            }))));
    a = 200 * DeltaScaled(l);
    -1 == d
      ? ((a *= -1),
        (d = Clamp$1(b.refTarget.x + a, h, b.refTarget.x)),
        d <= h && (e.direction = 1))
      : ((d = Clamp$1(b.refTarget.x + a, b.refTarget.x, h)),
        d >= h && (e.direction = -1));
    b.refTarget.x = d;
  }
}

function OffscreenRepositionSky() {
  var l = EntityKeeper.GetEntityByAlias("player");
  if (l) {
    l = TransformComponent.At(l);
    var w = EntityKeeper.GetBagActorsReferenceList(
      "SKY_CHECK_OFFSCREEN_REPOSITION"
    );
    for (let h = 0; h < w.length; h++) {
      const t = w[h],
        a = TransformComponent.At(t);
      VisualComponent.At(t).isDisplayedOnScreen() ||
        (a.refTarget.y > l.refTarget.y &&
          RepositionEntityBySizeAction.Take(t, null, 2 * -w.length));
    }
  }
}

function OffscreenRepositionCloud() {
  var l = EntityKeeper.GetEntityByAlias("player");
  if (l) {
    l = TransformComponent.At(l);
    var w = EntityKeeper.GetBagActorsReferenceList(
      "CLOUD_CHECK_OFFSCREEN_REPOSITION"
    );
    for (let h = 0; h < w.length; h++) {
      const t = w[h],
        a = TransformComponent.At(t);
      VisualComponent.At(t).isDisplayedOnScreen() ||
        (a.refTarget.y > l.refTarget.y &&
          RepositionEntityByDeltaAction.Take(t, null, -3e3));
    }
  }
}
class InternalModel {
  constructor() {
    this.UpdatePlayerVelocity = UpdatePlayerVelocity;
    this.CollisionOverlapPlayerVsPlatform = CollisionOverlapPlayerVsPlatform;
    this.UpdatePlayerAnimationState = UpdatePlayerAnimationState;
    this.UpdateCameraOffset = UpdateCameraOffset;
    this.OffscreenDieCheck = OffscreenDieCheck;
    this.PlayerOffscreenDieCheck = PlayerOffscreenDieCheck;
    this.OffscreenRepositionSky = OffscreenRepositionSky;
    this.OffscreenRepositionCloud = OffscreenRepositionCloud;
    this.CollisionOverlapPlayerVsSpring = CollisionOverlapPlayerVsSpring;
    this.CollisionOverlapPlayerVsDecayedPlatform =
      CollisionOverlapPlayerVsDecayedPlatform;
    this.CollisionOverlapPlayerVsPickable = CollisionOverlapPlayerVsPickable;
    this.UpdateMovingPlatforms = UpdateMovingPlatforms;
    this.CollisionOverlapVsBrick = CollisionOverlapVsBrick;
  }
}
const PandaJumpGameplayScripts = new InternalModel();

function PandaJumpGameCentralRegistry() {
  const l = PandaJumpGameplayScripts,
    w = PandaJumpLevelGenerationScripts;
  var h = new Engine();
  GeoticManager.SetEngine(h);
  var t = h.createWorld();
  GeoticManager.SetWorld(t);
  DoCommonGameRegisters(h);
  DoCasualGameRegisters();
  h.registerComponent(
    FollowPointerMovementComponent,
    FollowPointerMovementComponent.GetName()
  );
  ReactiveFollowPointerMovementAndVisualQuery.RegisterQuery();
  h = () =>
    1 == PandaJumpGlobalsInstance.currentLevelData.levelLoopEnded ? !0 : !1;
  t = () =>
    0 == PandaJumpGlobalsInstance.currentLevelData.levelLoopStarted ? !0 : !1;
  const a = () => (0 == PandaJumpGlobalsInstance.session.initialized ? !0 : !1);
  InputRoutine.Register();
  LogicLoopRoutine.Register();
  ScriptLoopRoutine.Register(l.UpdatePlayerVelocity);
  FollowPointerMovementRoutine.Register();
  ScriptLoopRoutine.Register(l.CollisionOverlapVsBrick, [h, a]);
  ScriptLoopRoutine.Register(l.CollisionOverlapPlayerVsSpring, [h, a]);
  ScriptLoopRoutine.Register(l.CollisionOverlapPlayerVsDecayedPlatform, [h, a]);
  ScriptLoopRoutine.Register(l.CollisionOverlapPlayerVsPickable, [h, a]);
  ScriptLoopRoutine.Register(l.CollisionOverlapPlayerVsPlatform, [h, a]);
  ScriptLoopRoutine.Register(l.UpdateMovingPlatforms, [a]);
  ScriptLoopRoutine.Register(l.UpdatePlayerAnimationState);
  ScriptLoopRoutine.Register(l.UpdateCameraOffset, [t]);
  ScriptLoopRoutine.Register(w.UpdateMapGeneration);
  ScriptLoopRoutine.Register(l.OffscreenDieCheck, []);
  ScriptLoopRoutine.Register(l.OffscreenRepositionSky);
  ScriptLoopRoutine.Register(l.OffscreenRepositionCloud);
  ScriptLoopRoutine.Register(l.PlayerOffscreenDieCheck, [t]);
  SynchPinsRoutine.Register();
  EndOfLoopRoutine.Register();
}
const MANIFEST_NAME = "PandaJumpManifest",
  COLOUR = "#c0adff",
  GAME_NAME = "PandaJump",
  GAME_TITLE = "Panda Jump",
  PHYSICS_DEBUG = !1,
  FUNC_DO_GAME_REGISTERS = PandaJumpGameCentralRegistry,
  FUNC_START_GAME = PandaJumpStartNormal;

function InitPandaJumpGame(l, w) {
  l = void 0 === l ? {} : l;
  w = void 0 === w ? {} : w;
  const h = new EngineInitVO();
  h.data.flagOverrides = l;
  h.data.gameName = GAME_NAME;
  h.data.gameSubEngineConfig = merge(
    {
      dom: {
        createContainer: !0,
      },
      title: GAME_TITLE,
      type: Phaser.AUTO,
      parent: "game",
      backgroundColor: COLOUR,
      scale: {
        width: 640,
        height: 1050,
        min: {
          width: 135,
          height: 240,
        },
        max: {
          width: 4320,
          height: 7680,
        },
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
      },
      physics: {
        default: "arcade",
        arcade: {
          debug: PHYSICS_DEBUG,
        },
      },
    },
    w
  );
  h.data.requiredScreenOrientation = "portrait";
  GetOs().desktop && (h.data.requiredScreenOrientation = "any");
  h.data.preloaderInitialsAssetsNames = {
    manifestJson: MANIFEST_NAME,
    //logo: "PreloaderLogo",
    font: "PreloaderFontObelix_63",
  };
  h.data.initialAssetPackData = AssetPackLoader.GetRequestAsJsonFromArray([
    {
      path: "json",
      type: "json",
      files: [MANIFEST_NAME],
    },
    {
      path: "preloader",
      type: "png",
      files: ["PreloaderLogo", "EmptyPNG"],
    },
    {
      path: "preloader",
      type: "font",
      files: ["PreloaderFontObelix_63"],
    },
  ]);
  h.data.funcDoGameRegisters = PandaJumpGameCentralRegistry;
  h.data.funcStartGame = PandaJumpStartNormal;
  UsePhaserSubEngine(h);
}
class EventTargetPolyfill {
  constructor() {
    this.listeners = {};
  }
  addEventListener(l, w) {
    l in this.listeners || (this.listeners[l] = []);
    this.listeners[l].push(w);
  }
  removeEventListener(l, w) {
    if (l in this.listeners) {
      l = this.listeners[l];
      for (let h = 0, t = l.length; h < t; h++)
        if (l[h] === w) {
          l.splice(h, 1);
          break;
        }
    }
  }
  dispatchEvent(l) {
    if (!(l.type in this.listeners)) return !0;
    const w = this.listeners[l.type].slice();
    for (let h = 0, t = w.length; h < t; h++) w[h].call(this, l);
    return !l.defaultPrevented;
  }
}
const ____FPatchFixEventTargetForIE = function () {
    window.EventTarget || (window.EventTarget = EventTargetPolyfill);
  },
  ____FPatchFixObjectAssign = function () {
    "function" !== typeof Object.assign &&
      Object.defineProperty(Object, "assign", {
        value: function (l, w) {
          if (null === l || void 0 === l)
            throw new TypeError("Cannot convert undefined or null to object");
          for (var h = Object(l), t = 1; t < arguments.length; t++) {
            var a = arguments[t];
            if (null !== a && void 0 !== a)
              for (var d in a)
                Object.prototype.hasOwnProperty.call(a, d) && (h[d] = a[d]);
          }
          return h;
        },
        writable: !0,
        configurable: !0,
      });
  },
  ____FPatchFixObjectEntries = function () {
    Object.entries ||
      (Object.entries = function (l) {
        for (var w = Object.keys(l), h = w.length, t = Array(h); h--; )
          t[h] = [w[h], l[w[h]]];
        return t;
      });
  },
  ____PolyfixObjectValues = function () {
    Object.values ||
      (Object.values = function (l) {
        return Object.keys(l).map(function (w) {
          return l[w];
        });
      });
  },
  ____PolyfixFunctionName = function () {
    function l() {
      if (this === Function || this === Function.prototype.constructor)
        var d = "Function";
      else
        this !== Function.prototype && (d = (d = ("" + this).match(w)) && d[1]);
      return d || "";
    }
    var w = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^\(\s\/]*)\s*/,
      h = !("name" in Function.prototype && "name" in function () {}),
      t =
        "function" === typeof Object.defineProperty &&
        (function () {
          try {
            Object.defineProperty(Function.prototype, "_xyz", {
              get: function () {
                return "blah";
              },
              configurable: !0,
            });
            var d = "blah" === Function.prototype._xyz;
            delete Function.prototype._xyz;
          } catch (k) {
            d = !1;
          }
          return d;
        })(),
      a =
        "function" === typeof Object.prototype.__defineGetter__ &&
        (function () {
          try {
            Function.prototype.__defineGetter__("_abc", function () {
              return "foo";
            });
            var d = "foo" === Function.prototype._abc;
            delete Function.prototype._abc;
          } catch (k) {
            d = !1;
          }
          return d;
        })();
    Function.prototype._name = l;
    h &&
      (t
        ? Object.defineProperty(Function.prototype, "name", {
            get: function () {
              var d = l.call(this);
              this !== Function.prototype &&
                Object.defineProperty(this, "name", {
                  value: d,
                  configurable: !0,
                });
              return d;
            },
            configurable: !0,
          })
        : a &&
          Function.prototype.__defineGetter__("name", function () {
            var d = l.call(this);
            this !== Function.prototype &&
              this.__defineGetter__("name", function () {
                return d;
              });
            return d;
          }));
  };
____FPatchFixObjectAssign();
____FPatchFixEventTargetForIE();
____FPatchFixObjectEntries();
____PolyfixObjectValues();
____PolyfixFunctionName();
GameBranding.SetSingleton(new BrandingInlogic());
InitPandaJumpGame(GameBranding.GetSingleton().getFlags(), {});
var GameData = function () {};
GameData.BuildTitle = "Panda Jump";
GameData.BuildVersion = "1.0.0";
GameData.BuildString = "05.10.2023";
GameData.Copyright = "";
console.info(
  "%c %c   " +
    GameData.Copyright +
    " | " +
    GameData.BuildTitle +
    " v" +
    GameData.BuildVersion +
    " | " +
    GameData.BuildString +
    "  %c ",
  "background:#353AFB",
  "background:#000080;color:#fff",
  "background:#353AFB"
);

function onGameStart(l) {
  adinplay_onAdStarted = function () {
    l();
  }.bind(this);
  adinplay_onAdFinished = function () {};
  adinplay_playVideoAd();
}

function onGameOver() {}
var partnerName = "adinplay";
window.partnerName = partnerName;
var ADS_ENABLED = !1;
ADS_ENABLED = !0;
var ADS_DELAY = 12e4,
  ADS_DEC = 2e4,
  ADS_MINTIME = 9e4,
  ADS_TIME_DEC_ENABLED = !0,
  ADS_ON_FIRST_PLAY = !0,
  ADS_MOBILE_WIDTH = 480,
  ADS_MOBILE_HEIGHT = 800,
  ads_time = 0,
  adplayer,
  adinplay_onAdStarted = function () {},
  adinplay_onAdFinished = function () {};

function adinplay_init() {
  if (ADS_ENABLED && "undefined" !== typeof aiptag) {
    var l = "inlogic",
      w = getJsonFromUrl();
    w.hasOwnProperty("partner_id") && (l = w.partner_id);
    aiptag = aiptag || {};
    aiptag.cmd = aiptag.cmd || [];
    aiptag.cmd.display = aiptag.cmd.display || [];
    aiptag.cmd.player = aiptag.cmd.player || [];
    aiptag.subid = l;
    aiptag.consented = !0;
    ads_time = 0;
    ADS_ON_FIRST_PLAY && (ads_time = -ADS_DELAY);
    aiptag.cmp = {
      show: !0,
      position: "centered",
      button: !0,
      buttonText: "Privacy settings",
      buttonPosition: "bottom-left",
    };
    aiptag.cmd.player.push(function () {
      var h = _PhaserEngineValues.phaserGameObject.scale.width,
        t = _PhaserEngineValues.phaserGameObject.scale.height;
      _PhaserEngineValues.phaserGameObject.device.os.desktop ||
        ((h = ADS_MOBILE_WIDTH), (t = ADS_MOBILE_HEIGHT));
      adplayer = new aipPlayer({
        AD_WIDTH: h,
        AD_HEIGHT: t,
        AD_FULLSCREEN: 1,
        AD_CENTERPLAYER: 0,
        AD_FADING: 0,
        AD_DISPLAY: "default",
        LOADING_TEXT: "loading advertisement",
        PREROLL_ELEM: function () {
          return document.getElementById("ads");
        },
        AIP_COMPLETE: function () {
          adinplay_resumeMusic();
          adinplay_enableInput();
          adinplay_onAdStarted();
          !0 === ADS_TIME_DEC_ENABLED &&
            ADS_DELAY > ADS_MINTIME &&
            (ADS_DELAY -= ADS_DEC);
        },
        AIP_REMOVE: function () {
          adinplay_onAdFinished();
        },
        AIP_REWARDEDCOMPLETE: function (a) {
          adinplay_resumeMusic();
          adinplay_enableInput();
          adinplay_rew_callbacks[1].call(adinplay_rew_callbacks[2]);
        },
        AIP_REWARDEDGRANTED: function () {
          adinplay_resumeMusic();
          adinplay_enableInput();
          adinplay_rew_callbacks[0].call(adinplay_rew_callbacks[2]);
        },
      });
    });
  }
}

function adinplay_playVideoAd() {
  ADS_ENABLED
    ? "undefined" === typeof aiptag
      ? (adinplay_init(), adinplay_enableInput(), adinplay_onAdStarted())
      : "undefined" === typeof adplayer
      ? (adinplay_init(), adinplay_enableInput(), adinplay_onAdStarted())
      : Date.now() - ads_time < ADS_DELAY
      ? (adinplay_enableInput(), adinplay_onAdStarted())
      : ((ads_time = Date.now()),
        adinplay_disableInput(),
        adinplay_pauseMusic(),
        aiptag.cmd.player.push(function () {
          adplayer.startPreRoll();
        }))
    : (adinplay_enableInput(), adinplay_onAdStarted());
}
var adinplay_rew_callbacks = [];

function adinplay_playRewardedVideo(l, w, h) {
  adinplay_rew_callbacks[0] = l;
  adinplay_rew_callbacks[1] = w;
  adinplay_rew_callbacks[2] = h;
  ADS_ENABLED
    ? "undefined" === typeof aiptag
      ? (adinplay_init(), adinplay_enableInput(), w.call(h))
      : "undefined" === typeof adplayer
      ? (adinplay_init(), adinplay_enableInput(), w.call(h))
      : (adinplay_disableInput(),
        adinplay_pauseMusic(),
        aiptag.cmd.player.push(function () {
          adplayer.startRewardedAd({
            preload: !1,
            showLoading: !0,
          });
        }))
    : (adinplay_enableInput(), w.call(h));
}

function adinplay_rewardedPreload() {
  ADS_ENABLED &&
    ("undefined" === typeof aiptag
      ? adinplay_init()
      : "undefined" === typeof adplayer
      ? adinplay_init()
      : (!0 !== aipAPItag.rewardedSlotEventListener &&
          ((aipAPItag.rewardedSlotEventListener = !0),
          aiptag.events.addEventListener(
            "rewardedSlotReady",
            function (l) {},
            !1
          )),
        aiptag.cmd.player.push(function () {
          adplayer.startRewardedAd({
            preload: !0,
            showLoading: !1,
          });
        })));
}

function adinplay_disableInput() {
  _PhaserEngineValues.phaserGameObject.input.enabled = !1;
}

function adinplay_enableInput() {
  _PhaserEngineValues.phaserGameObject.input.enabled = !0;
}

function adinplay_pauseMusic() {
  _PhaserEngineValues.phaserGameObject.sound.volume = 0;
}

function adinplay_resumeMusic() {
  _PhaserEngineValues.phaserGameObject.sound.volume = 1;
}

function getJsonFromUrl() {
  for (
    var l = {}, w = location.search.substr(1).split("&"), h = 0;
    h < w.length;
    h++
  ) {
    var t = w[h].indexOf("=");
    t = [w[h].substring(0, t), w[h].substring(t + 1)];
    l[t[0]] = decodeURIComponent(t[1]);
  }
  return l;
}
